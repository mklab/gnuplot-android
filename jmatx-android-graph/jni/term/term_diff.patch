diff -rupN C:\gnuplot-4.4.0\term/.svn/all-wcprops C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/all-wcprops
--- C:\gnuplot-4.4.0\term/.svn/all-wcprops	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/all-wcprops	2012-05-21 16:37:07.259228300 -0700
@@ -0,0 +1,515 @@
+K 25
+svn:wc:ra_dav:version-url
+V 31
+/svn/!svn/ver/39/trunk/jni/term
+END
+aed.trm
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/39/trunk/jni/term/aed.trm
+END
+fg.trm
+K 25
+svn:wc:ra_dav:version-url
+V 38
+/svn/!svn/ver/39/trunk/jni/term/fg.trm
+END
+kyo.trm
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/39/trunk/jni/term/kyo.trm
+END
+be.trm
+K 25
+svn:wc:ra_dav:version-url
+V 38
+/svn/!svn/ver/39/trunk/jni/term/be.trm
+END
+gpic.trm
+K 25
+svn:wc:ra_dav:version-url
+V 40
+/svn/!svn/ver/39/trunk/jni/term/gpic.trm
+END
+pstricks.trm
+K 25
+svn:wc:ra_dav:version-url
+V 44
+/svn/!svn/ver/39/trunk/jni/term/pstricks.trm
+END
+Makefile.in
+K 25
+svn:wc:ra_dav:version-url
+V 43
+/svn/!svn/ver/39/trunk/jni/term/Makefile.in
+END
+cairo.trm
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/39/trunk/jni/term/cairo.trm
+END
+Makefile
+K 25
+svn:wc:ra_dav:version-url
+V 40
+/svn/!svn/ver/39/trunk/jni/term/Makefile
+END
+mif.trm
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/39/trunk/jni/term/mif.trm
+END
+hp26.trm
+K 25
+svn:wc:ra_dav:version-url
+V 40
+/svn/!svn/ver/39/trunk/jni/term/hp26.trm
+END
+sun.trm
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/39/trunk/jni/term/sun.trm
+END
+Makefile.am
+K 25
+svn:wc:ra_dav:version-url
+V 43
+/svn/!svn/ver/39/trunk/jni/term/Makefile.am
+END
+apollo.trm
+K 25
+svn:wc:ra_dav:version-url
+V 42
+/svn/!svn/ver/39/trunk/jni/term/apollo.trm
+END
+mac.trm
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/39/trunk/jni/term/mac.trm
+END
+hp2648.trm
+K 25
+svn:wc:ra_dav:version-url
+V 42
+/svn/!svn/ver/39/trunk/jni/term/hp2648.trm
+END
+tgif.trm
+K 25
+svn:wc:ra_dav:version-url
+V 40
+/svn/!svn/ver/39/trunk/jni/term/tgif.trm
+END
+dxf.trm
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/39/trunk/jni/term/dxf.trm
+END
+vws.trm
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/39/trunk/jni/term/vws.trm
+END
+debug.trm
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/39/trunk/jni/term/debug.trm
+END
+metafont.trm
+K 25
+svn:wc:ra_dav:version-url
+V 44
+/svn/!svn/ver/39/trunk/jni/term/metafont.trm
+END
+amiga.trm
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/39/trunk/jni/term/amiga.trm
+END
+qms.trm
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/39/trunk/jni/term/qms.trm
+END
+canvas.trm
+K 25
+svn:wc:ra_dav:version-url
+V 42
+/svn/!svn/ver/39/trunk/jni/term/canvas.trm
+END
+post.h
+K 25
+svn:wc:ra_dav:version-url
+V 38
+/svn/!svn/ver/39/trunk/jni/term/post.h
+END
+excl.trm
+K 25
+svn:wc:ra_dav:version-url
+V 40
+/svn/!svn/ver/39/trunk/jni/term/excl.trm
+END
+win.trm
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/39/trunk/jni/term/win.trm
+END
+gd.trm
+K 25
+svn:wc:ra_dav:version-url
+V 38
+/svn/!svn/ver/39/trunk/jni/term/gd.trm
+END
+driver.h
+K 25
+svn:wc:ra_dav:version-url
+V 40
+/svn/!svn/ver/39/trunk/jni/term/driver.h
+END
+svg.trm
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/39/trunk/jni/term/svg.trm
+END
+dxy.trm
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/39/trunk/jni/term/dxy.trm
+END
+dumb.trm
+K 25
+svn:wc:ra_dav:version-url
+V 40
+/svn/!svn/ver/39/trunk/jni/term/dumb.trm
+END
+unixplot.trm
+K 25
+svn:wc:ra_dav:version-url
+V 44
+/svn/!svn/ver/39/trunk/jni/term/unixplot.trm
+END
+eepic.trm
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/39/trunk/jni/term/eepic.trm
+END
+texdraw.trm
+K 25
+svn:wc:ra_dav:version-url
+V 43
+/svn/!svn/ver/39/trunk/jni/term/texdraw.trm
+END
+README
+K 25
+svn:wc:ra_dav:version-url
+V 38
+/svn/!svn/ver/39/trunk/jni/term/README
+END
+hpgl.trm
+K 25
+svn:wc:ra_dav:version-url
+V 40
+/svn/!svn/ver/39/trunk/jni/term/hpgl.trm
+END
+pslatex.trm
+K 25
+svn:wc:ra_dav:version-url
+V 43
+/svn/!svn/ver/39/trunk/jni/term/pslatex.trm
+END
+android.trm
+K 25
+svn:wc:ra_dav:version-url
+V 43
+/svn/!svn/ver/42/trunk/jni/term/android.trm
+END
+pdf.trm
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/39/trunk/jni/term/pdf.trm
+END
+imagen.trm
+K 25
+svn:wc:ra_dav:version-url
+V 42
+/svn/!svn/ver/39/trunk/jni/term/imagen.trm
+END
+next.trm
+K 25
+svn:wc:ra_dav:version-url
+V 40
+/svn/!svn/ver/39/trunk/jni/term/next.trm
+END
+pc.trm
+K 25
+svn:wc:ra_dav:version-url
+V 38
+/svn/!svn/ver/39/trunk/jni/term/pc.trm
+END
+linux.trm
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/39/trunk/jni/term/linux.trm
+END
+lua.trm
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/39/trunk/jni/term/lua.trm
+END
+t410x.trm
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/39/trunk/jni/term/t410x.trm
+END
+unixpc.trm
+K 25
+svn:wc:ra_dav:version-url
+V 42
+/svn/!svn/ver/39/trunk/jni/term/unixpc.trm
+END
+pm.trm
+K 25
+svn:wc:ra_dav:version-url
+V 38
+/svn/!svn/ver/39/trunk/jni/term/pm.trm
+END
+emxvga.trm
+K 25
+svn:wc:ra_dav:version-url
+V 42
+/svn/!svn/ver/39/trunk/jni/term/emxvga.trm
+END
+Makefile.am.in
+K 25
+svn:wc:ra_dav:version-url
+V 46
+/svn/!svn/ver/39/trunk/jni/term/Makefile.am.in
+END
+hppj.trm
+K 25
+svn:wc:ra_dav:version-url
+V 40
+/svn/!svn/ver/39/trunk/jni/term/hppj.trm
+END
+djsvga.trm
+K 25
+svn:wc:ra_dav:version-url
+V 42
+/svn/!svn/ver/39/trunk/jni/term/djsvga.trm
+END
+fig.trm
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/39/trunk/jni/term/fig.trm
+END
+cgi.trm
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/39/trunk/jni/term/cgi.trm
+END
+epson.trm
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/39/trunk/jni/term/epson.trm
+END
+cgm.trm
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/39/trunk/jni/term/cgm.trm
+END
+ggi.trm
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/39/trunk/jni/term/ggi.trm
+END
+xlib.trm
+K 25
+svn:wc:ra_dav:version-url
+V 40
+/svn/!svn/ver/39/trunk/jni/term/xlib.trm
+END
+tkcanvas.trm
+K 25
+svn:wc:ra_dav:version-url
+V 44
+/svn/!svn/ver/39/trunk/jni/term/tkcanvas.trm
+END
+latex.trm
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/39/trunk/jni/term/latex.trm
+END
+impcodes.h
+K 25
+svn:wc:ra_dav:version-url
+V 42
+/svn/!svn/ver/39/trunk/jni/term/impcodes.h
+END
+hp500c.trm
+K 25
+svn:wc:ra_dav:version-url
+V 42
+/svn/!svn/ver/39/trunk/jni/term/hp500c.trm
+END
+openstep.trm
+K 25
+svn:wc:ra_dav:version-url
+V 44
+/svn/!svn/ver/39/trunk/jni/term/openstep.trm
+END
+tpic.trm
+K 25
+svn:wc:ra_dav:version-url
+V 40
+/svn/!svn/ver/39/trunk/jni/term/tpic.trm
+END
+mgr.trm
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/39/trunk/jni/term/mgr.trm
+END
+x11.trm
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/39/trunk/jni/term/x11.trm
+END
+tek.trm
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/39/trunk/jni/term/tek.trm
+END
+rgip.trm
+K 25
+svn:wc:ra_dav:version-url
+V 40
+/svn/!svn/ver/39/trunk/jni/term/rgip.trm
+END
+gnugraph.trm
+K 25
+svn:wc:ra_dav:version-url
+V 44
+/svn/!svn/ver/39/trunk/jni/term/gnugraph.trm
+END
+post.trm
+K 25
+svn:wc:ra_dav:version-url
+V 40
+/svn/!svn/ver/39/trunk/jni/term/post.trm
+END
+metapost.trm
+K 25
+svn:wc:ra_dav:version-url
+V 44
+/svn/!svn/ver/39/trunk/jni/term/metapost.trm
+END
+hpljii.trm
+K 25
+svn:wc:ra_dav:version-url
+V 42
+/svn/!svn/ver/39/trunk/jni/term/hpljii.trm
+END
+ai.trm
+K 25
+svn:wc:ra_dav:version-url
+V 38
+/svn/!svn/ver/39/trunk/jni/term/ai.trm
+END
+aquaterm.trm
+K 25
+svn:wc:ra_dav:version-url
+V 44
+/svn/!svn/ver/39/trunk/jni/term/aquaterm.trm
+END
+estimate.trm
+K 25
+svn:wc:ra_dav:version-url
+V 44
+/svn/!svn/ver/39/trunk/jni/term/estimate.trm
+END
+gpr.trm
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/39/trunk/jni/term/gpr.trm
+END
+corel.trm
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/39/trunk/jni/term/corel.trm
+END
+wxt.trm
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/39/trunk/jni/term/wxt.trm
+END
+vgagl.trm
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/39/trunk/jni/term/vgagl.trm
+END
+grass.trm
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/39/trunk/jni/term/grass.trm
+END
+object.h
+K 25
+svn:wc:ra_dav:version-url
+V 40
+/svn/!svn/ver/39/trunk/jni/term/object.h
+END
+v384.trm
+K 25
+svn:wc:ra_dav:version-url
+V 40
+/svn/!svn/ver/39/trunk/jni/term/v384.trm
+END
+pbm.trm
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/39/trunk/jni/term/pbm.trm
+END
+emf.trm
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/39/trunk/jni/term/emf.trm
+END
+regis.trm
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/39/trunk/jni/term/regis.trm
+END
diff -rupN C:\gnuplot-4.4.0\term/.svn/entries C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/entries
--- C:\gnuplot-4.4.0\term/.svn/entries	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/entries	2012-05-21 16:37:07.273733700 -0700
@@ -0,0 +1,2934 @@
+10
+
+dir
+39
+https://addiplot.googlecode.com/svn/trunk/jni/term
+https://addiplot.googlecode.com/svn
+
+
+
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+svn:special svn:externals svn:needs-lock
+
+
+
+
+
+
+
+
+
+
+
+776c9c97-d481-0677-478a-dd5044256a82
+
+
+
+
+
+
+0
+
+Makefile
+file
+
+
+
+
+2012-01-03T23:32:39.263000Z
+b129ecf970e42866f9cfd832aa1f1242
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+16942
+
+Makefile.am
+file
+
+
+
+
+2012-01-03T23:32:39.231000Z
+9785a9206b37314e414e3b189a2fb491
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+2495
+
+Makefile.am.in
+file
+
+
+
+
+2012-01-03T23:32:38.939000Z
+5d834759266ee9d5c19ae7e929fb5fc8
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+1223
+
+Makefile.in
+file
+
+
+
+
+2012-01-03T23:32:38.806000Z
+213ea069e14a4a4c83f8d603e9833998
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+16181
+
+PostScript
+dir
+
+README
+file
+
+
+
+
+2012-01-03T23:32:38.825000Z
+330a350c1a822e02119e06b847902dfc
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+28423
+
+aed.trm
+file
+
+
+
+
+2012-01-03T23:32:39.018000Z
+11536e0f858ad78fd097ab38f68309a5
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+5789
+
+ai.trm
+file
+
+
+
+
+2012-01-03T23:32:38.981000Z
+5a8d4223c3e5a37ace6c4a62c256ddc8
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+13753
+
+amiga.trm
+file
+
+
+
+
+2012-01-03T23:32:38.697000Z
+a04a656e2d1847a57c524fff1236cf86
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+20994
+
+android.trm
+file
+42
+
+
+
+2012-05-21T06:06:14.698000Z
+0dcb71675e777f89274f893e6ac8e288
+2012-05-21T23:37:19.002687Z
+42
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+5375
+
+apollo.trm
+file
+
+
+
+
+2012-01-03T23:32:38.207000Z
+5921ec1ba30fa7161a3195efc7b37158
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+19540
+
+aquaterm.trm
+file
+
+
+
+
+2012-01-03T23:32:38.972000Z
+a2ba405749ce47b88df8e81b4dd437f7
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+29488
+
+be.trm
+file
+
+
+
+
+2012-01-03T23:32:38.912000Z
+5a4a10c186e7bf801008707ffbf35cbd
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+22217
+
+cairo.trm
+file
+
+
+
+
+2012-01-03T23:32:39.036000Z
+c0bce9240135024cf6b04dde52da036a
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+38347
+
+canvas.trm
+file
+
+
+
+
+2012-01-03T23:32:38.234000Z
+51dc44fceb45556a87c5e692e528943b
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+36848
+
+cgi.trm
+file
+
+
+
+
+2012-01-03T23:32:39.070000Z
+2dca8604b22b786cc88e2bd766483b1f
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+8428
+
+cgm.trm
+file
+
+
+
+
+2012-01-03T23:32:38.612000Z
+50ebb8419ecfe10110280c59177e29bc
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+63901
+
+corel.trm
+file
+
+
+
+
+2012-01-03T23:32:38.225000Z
+bf92a00defa52ce3cad3d5566f877a0e
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+10925
+
+debug.trm
+file
+
+
+
+
+2012-01-03T23:32:38.306000Z
+2be0c5f87c4f9f67cacfd9ae8860bb7d
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+8172
+
+djsvga.trm
+file
+
+
+
+
+2012-01-03T23:32:39.199000Z
+100bb3fca205359b697c8455eb3a141e
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+14470
+
+driver.h
+file
+
+
+
+
+2012-01-03T23:32:38.643000Z
+c762e4eda8f2e97f067c013dd846b8d6
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+2976
+
+dumb.trm
+file
+
+
+
+
+2012-01-03T23:32:38.600000Z
+754cba0b9b18b49a79b0e33929248051
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+15132
+
+dxf.trm
+file
+
+
+
+
+2012-01-03T23:32:38.263000Z
+de34538653824e1bd908109723391563
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+12795
+
+dxy.trm
+file
+
+
+
+
+2012-01-03T23:32:38.815000Z
+93b64e7af959124bc5d2d0b06e7580a5
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+5021
+
+eepic.trm
+file
+
+
+
+
+2012-01-03T23:32:38.885000Z
+6626554f8d001d6232b2e6ab89a4dbc9
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+19325
+
+emf.trm
+file
+
+
+
+
+2012-01-03T23:32:39.209000Z
+1dc4cbed12af955c87e5cba9618f17ce
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+52802
+
+emxvga.trm
+file
+
+
+
+
+2012-01-03T23:32:39.224000Z
+27cfbbf12f03a4f2e5e8e74a271da60f
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+16503
+
+epson.trm
+file
+
+
+
+
+2012-01-03T23:32:37.964000Z
+f4e7e5bf3132cd7f98b368a3dab62597
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+31397
+
+estimate.trm
+file
+
+
+
+
+2012-01-03T23:32:39.110000Z
+e9749f43afbc095cdd3cb904fec62226
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+4853
+
+excl.trm
+file
+
+
+
+
+2012-01-03T23:32:37.931000Z
+8cc52176204f2bd59317ffe452828344
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+8986
+
+fg.trm
+file
+
+
+
+
+2012-01-03T23:32:38.704000Z
+b1f37487cd6910eedc745418ae9a04e4
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+11319
+
+fig.trm
+file
+
+
+
+
+2012-01-03T23:32:39.173000Z
+07bf8a41a88ff0175278223541554f85
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+60752
+
+gd.trm
+file
+
+
+
+
+2012-01-03T23:32:39.080000Z
+cff857967453b19941f24a65e000ca98
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+83237
+
+ggi.trm
+file
+
+
+
+
+2012-01-03T23:32:39.090000Z
+d007dd9e90ee5d27bb757db8a1bc6e0d
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+37555
+
+gnugraph.trm
+file
+
+
+
+
+2012-01-03T23:32:38.673000Z
+4af9c0b45083d444766c657dfa913b53
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+13150
+
+gpic.trm
+file
+
+
+
+
+2012-01-03T23:32:38.292000Z
+91bad9f13ccf44696362bbab54fb7f05
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+9314
+
+gpr.trm
+file
+
+
+
+
+2012-01-03T23:32:39.026000Z
+c1f460c97c3be2b9f81e26c8ff846350
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+13809
+
+grass.trm
+file
+
+
+
+
+2012-01-03T23:32:39.008000Z
+fe0d6f999f99de3c5026d84d44dc39b4
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+18076
+
+hp26.trm
+file
+
+
+
+
+2012-01-03T23:32:38.328000Z
+e654ef2df7e1cceec37eace954736f48
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+20296
+
+hp2648.trm
+file
+
+
+
+
+2012-01-03T23:32:37.981000Z
+022ac244118dc067a094f070792928d3
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+5050
+
+hp500c.trm
+file
+
+
+
+
+2012-01-03T23:32:38.656000Z
+ad95943b9c576f0a7d169fae57d2ea95
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+13506
+
+hpgl.trm
+file
+
+
+
+
+2012-01-03T23:32:39.000000Z
+d6ed143ab885b3500236010afa4b19ab
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+79985
+
+hpljii.trm
+file
+
+
+
+
+2012-01-03T23:32:38.864000Z
+65d965ce5ba84f981afc31358c570776
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+11684
+
+hppj.trm
+file
+
+
+
+
+2012-01-03T23:32:38.279000Z
+7d19ca58cab4ec2aa5abcd7f0683c112
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+7879
+
+imagen.trm
+file
+
+
+
+
+2012-01-03T23:32:38.592000Z
+d4a055b84b68e2d91a93a23ef3cbda8d
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+23242
+
+impcodes.h
+file
+
+
+
+
+2012-01-03T23:32:38.338000Z
+f5647f7cac26afa367ddf8914607e027
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+1365
+
+js
+dir
+
+kyo.trm
+file
+
+
+
+
+2012-01-03T23:32:39.044000Z
+51a01aa2ed49cf6134298e9f6539770a
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+6379
+
+latex.trm
+file
+
+
+
+
+2012-01-03T23:32:38.846000Z
+27aa07b6653505d141cf62ca1c7e2436
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+30641
+
+linux.trm
+file
+
+
+
+
+2012-01-03T23:32:38.025000Z
+8dca68ad948fd826fe4e95e603d407bc
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+9281
+
+lua
+dir
+
+lua.trm
+file
+
+
+
+
+2012-01-03T23:32:38.922000Z
+2dc60618ff733451716dd9017ebc366f
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+34156
+
+mac.trm
+file
+
+
+
+
+2012-01-03T23:32:38.561000Z
+63f3581b5d2bab7b0c35443bf728d234
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+7422
+
+metafont.trm
+file
+
+
+
+
+2012-01-03T23:32:38.637000Z
+d86d68d7b30a07b310a45b0b5b27ee0a
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+20571
+
+metapost.trm
+file
+
+
+
+
+2012-01-03T23:32:39.135000Z
+94f6686ebf6a8d55349e51a79f8f8d8e
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+36607
+
+mgr.trm
+file
+
+
+
+
+2012-01-03T23:32:38.272000Z
+6a312ed82551081ac9e59e451338ed9c
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+6079
+
+mif.trm
+file
+
+
+
+
+2012-01-03T23:32:39.253000Z
+bae76c16fbc80c3bd3876d950bba087e
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+28627
+
+next.trm
+file
+
+
+
+
+2012-01-03T23:32:37.846000Z
+dac2dde313208a1f47f32bc05d113ab2
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+45645
+
+object.h
+file
+
+
+
+
+2012-01-03T23:32:38.242000Z
+69cbe49b0b5b97b9d4700cd9f868d683
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+11773
+
+openstep.trm
+file
+
+
+
+
+2012-01-03T23:32:39.062000Z
+e2af8d208e27ad40783fb13355b94a81
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+42711
+
+pbm.trm
+file
+
+
+
+
+2012-01-03T23:32:39.164000Z
+c36641226e5f7fa844b20aaab8134336
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+12835
+
+pc.trm
+file
+
+
+
+
+2012-01-03T23:32:38.947000Z
+e8dc2ee66f7edfacb9d36b2b03838cfa
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+14113
+
+pdf.trm
+file
+
+
+
+
+2012-01-03T23:32:39.053000Z
+590e71aa11c4fa3fbb694d2aeb925809
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+51988
+
+pm.trm
+file
+
+
+
+
+2012-01-03T23:32:38.184000Z
+5b6715ea79c132d2a97ff006d8cfd000
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+34262
+
+post.h
+file
+
+
+
+
+2012-01-03T23:32:38.727000Z
+0bddcefa3d99c722ffb050355261f7e6
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+2836
+
+post.trm
+file
+
+
+
+
+2012-01-03T23:32:39.103000Z
+51cef45d17e02955b300a8f8349c8442
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+143240
+
+pslatex.trm
+file
+
+
+
+
+2012-01-03T23:32:37.918000Z
+3b04551e31e5fbe6b95aee2b709bd651
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+34907
+
+pstricks.trm
+file
+
+
+
+
+2012-01-03T23:32:37.892000Z
+7af6cf9cb4c10a444d88b5e78032289d
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+19451
+
+qms.trm
+file
+
+
+
+
+2012-01-03T23:32:38.717000Z
+e3f727b101807e47e950a54f8ee718c7
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+6532
+
+regis.trm
+file
+
+
+
+
+2012-01-03T23:32:38.875000Z
+81bb2d10d4979f45f7d05b57b343119e
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+7229
+
+rgip.trm
+file
+
+
+
+
+2012-01-03T23:32:38.901000Z
+b8b2127582a9de6ca919fd8d809e7978
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+16418
+
+sun.trm
+file
+
+
+
+
+2012-01-03T23:32:38.962000Z
+0e4e3ade23ec1d4b7a4fc6c31161b47c
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+9271
+
+svg.trm
+file
+
+
+
+
+2012-01-03T23:32:38.837000Z
+fab7762d596919aba4152c458726973f
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+49431
+
+t410x.trm
+file
+
+
+
+
+2012-01-03T23:32:38.892000Z
+56ab8d5dbbc02ead0ecc6340797fba06
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+8233
+
+tek.trm
+file
+
+
+
+
+2012-01-03T23:32:39.127000Z
+615b674c506d63fed99f78356917f952
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+20495
+
+texdraw.trm
+file
+
+
+
+
+2012-01-03T23:32:39.150000Z
+dc42bfe5e4dc3d64f63ae993fb8d5733
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+11061
+
+tgif.trm
+file
+
+
+
+
+2012-01-03T23:32:38.253000Z
+22d47d376f88037f27c2de6464c323a4
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+59065
+
+tkcanvas.trm
+file
+
+
+
+
+2012-01-03T23:32:39.183000Z
+d0774557739b8ccc65ca667a29995502
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+21382
+
+tpic.trm
+file
+
+
+
+
+2012-01-03T23:32:37.877000Z
+3b616a36861744e34dd4d3075f14f497
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+27006
+
+unixpc.trm
+file
+
+
+
+
+2012-01-03T23:32:38.215000Z
+991ab12b97ef98af908b32d8dec16ee5
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+15354
+
+unixplot.trm
+file
+
+
+
+
+2012-01-03T23:32:39.143000Z
+953948940c68b458ac42c057a7a7b9f9
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+4910
+
+v384.trm
+file
+
+
+
+
+2012-01-03T23:32:39.118000Z
+324ef656db26eed90da47ef20e4d738a
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+5136
+
+vgagl.trm
+file
+
+
+
+
+2012-01-03T23:32:38.004000Z
+fc6c88a9d0bb245a08a1a31029e5c4da
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+46789
+
+vws.trm
+file
+
+
+
+
+2012-01-03T23:32:38.955000Z
+8b78d4511a895a26862b1c2e4169f7a9
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+15416
+
+win.trm
+file
+
+
+
+
+2012-01-03T23:32:38.932000Z
+7b477a2ef2cf28e082271801f4930ccd
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+36795
+
+wxt.trm
+file
+
+
+
+
+2012-01-03T23:32:38.688000Z
+9009c133ef64a2b4df6d1e4ed2a97429
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+17420
+
+x11.trm
+file
+
+
+
+
+2012-01-03T23:32:38.550000Z
+b8a17e6ccd45aeecff1766bbe4feaeb2
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+82964
+
+xlib.trm
+file
+
+
+
+
+2012-01-03T23:32:38.571000Z
+d8b487a5af97ea34e15e66f2bccdd7ff
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+2644
+
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/Makefile.am.in.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/Makefile.am.in.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/Makefile.am.in.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/Makefile.am.in.svn-base	2012-01-03 17:07:19.208792300 -0800
@@ -0,0 +1,36 @@
+## Process this file with automake to produce Makefile.in -*-Makefile-*-
+AUTOMAKE_OPTIONS = foreign 1.2h
+
+EXTRA_DIST = README Makefile.am.in driver.h impcodes.h \
+object.h post.h $(CORETERM) PostScript lua js
+
+postscriptdir = $(pkgdatadir)/$(VERSION_MAJOR)/PostScript
+
+luadir = $(pkgdatadir)/$(VERSION_MAJOR)/lua
+jsdir = $(pkgdatadir)/$(VERSION_MAJOR)/js
+
+# List of terminal drivers, and list of postscript installation files
+# must be created prior to running automake
+##trm-files-begin
+##trm-files-end
+
+Makefile.am: Makefile.am.in
+	rm -f $@ $@t
+	sed -n '1,/^##trm-files-begin/p' Makefile.am.in > $@t
+	echo CORETERM = *.trm | fmt | (tr '\012' @; echo) \
+	  |sed 's/@$$/%/;s/@/ \\@/g' | tr @% '\012 ' \
+	  >> $@t
+	echo '#' >> $@t
+	echo postscript_DATA = PostScript/*.ps PostScript/*.txt | fmt \
+	  | (tr '\012' @; echo) |sed 's/@$$/%/;s/@/ \\@/g' \
+	  | tr @% '\012 ' >> $@t
+	echo js_DATA = js/*.js js/*.png js/*.css js/README | fmt \
+	  | (tr '\012' @; echo) |sed 's/@$$/%/;s/@/ \\@/g' \
+	  | tr @% '\012 ' >> $@t
+	echo lua_DATA = lua/gnuplot-tikz.lua | fmt \
+	  | (tr '\012' @; echo) |sed 's/@$$/%/;s/@/ \\@/g' \
+	  | tr @% '\012 ' >> $@t
+	sed -n '/^##trm-files-end/,$$p' Makefile.am.in >> $@t
+	chmod a-w $@t
+	mv $@t $@
+
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/Makefile.am.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/Makefile.am.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/Makefile.am.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/Makefile.am.svn-base	2012-01-03 17:07:19.002256700 -0800
@@ -0,0 +1,57 @@
+## Process this file with automake to produce Makefile.in -*-Makefile-*-
+AUTOMAKE_OPTIONS = foreign 1.2h
+
+EXTRA_DIST = README Makefile.am.in driver.h impcodes.h \
+object.h post.h $(CORETERM) PostScript lua js
+
+postscriptdir = $(pkgdatadir)/$(VERSION_MAJOR)/PostScript
+
+luadir = $(pkgdatadir)/$(VERSION_MAJOR)/lua
+jsdir = $(pkgdatadir)/$(VERSION_MAJOR)/js
+
+# List of terminal drivers, and list of postscript installation files
+# must be created prior to running automake
+##trm-files-begin
+CORETERM = aed.trm ai.trm amiga.trm apollo.trm aquaterm.trm be.trm \
+cairo.trm canvas.trm cgi.trm cgm.trm corel.trm debug.trm djsvga.trm \
+dumb.trm dxf.trm dxy.trm eepic.trm emf.trm emxvga.trm epson.trm \
+estimate.trm excl.trm fg.trm fig.trm gd.trm ggi.trm gnugraph.trm \
+gpic.trm gpr.trm grass.trm hp2648.trm hp26.trm hp500c.trm hpgl.trm \
+hpljii.trm hppj.trm imagen.trm kyo.trm latex.trm linux.trm lua.trm \
+mac.trm metafont.trm metapost.trm mgr.trm mif.trm next.trm openstep.trm \
+pbm.trm pc.trm pdf.trm pm.trm post.trm pslatex.trm pstricks.trm qms.trm \
+regis.trm rgip.trm sun.trm svg.trm t410x.trm tek.trm texdraw.trm tgif.trm \
+tkcanvas.trm tpic.trm unixpc.trm unixplot.trm v384.trm vgagl.trm vws.trm \
+win.trm wxt.trm x11.trm xlib.trm 
+#
+postscript_DATA = PostScript/8859-15.ps PostScript/8859-1.ps \
+PostScript/8859-2.ps PostScript/8859-9.ps PostScript/cp1250.ps \
+PostScript/cp437.ps PostScript/cp850.ps PostScript/cp852.ps \
+PostScript/koi8r.ps PostScript/koi8u.ps PostScript/prologue.ps \
+PostScript/utf-8.ps PostScript/aglfn.txt 
+js_DATA = js/canvasmath.js js/canvastext.js js/gnuplot_common.js \
+js/gnuplot_mouse.js js/grid.png js/help.png js/nextzoom.png \
+js/previouszoom.png js/textzoom.png js/gnuplot_mouse.css js/README 
+lua_DATA = lua/gnuplot-tikz.lua 
+##trm-files-end
+
+Makefile.am: Makefile.am.in
+	rm -f $@ $@t
+	sed -n '1,/^##trm-files-begin/p' Makefile.am.in > $@t
+	echo CORETERM = *.trm | fmt | (tr '\012' @; echo) \
+	  |sed 's/@$$/%/;s/@/ \\@/g' | tr @% '\012 ' \
+	  >> $@t
+	echo '#' >> $@t
+	echo postscript_DATA = PostScript/*.ps PostScript/*.txt | fmt \
+	  | (tr '\012' @; echo) |sed 's/@$$/%/;s/@/ \\@/g' \
+	  | tr @% '\012 ' >> $@t
+	echo js_DATA = js/*.js js/*.png js/*.css js/README | fmt \
+	  | (tr '\012' @; echo) |sed 's/@$$/%/;s/@/ \\@/g' \
+	  | tr @% '\012 ' >> $@t
+	echo lua_DATA = lua/gnuplot-tikz.lua | fmt \
+	  | (tr '\012' @; echo) |sed 's/@$$/%/;s/@/ \\@/g' \
+	  | tr @% '\012 ' >> $@t
+	sed -n '/^##trm-files-end/,$$p' Makefile.am.in >> $@t
+	chmod a-w $@t
+	mv $@t $@
+
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/Makefile.in.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/Makefile.in.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/Makefile.in.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/Makefile.in.svn-base	2012-01-03 17:07:19.424351300 -0800
@@ -0,0 +1,511 @@
+# Makefile.in generated by automake 1.11 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+subdir = term
+DIST_COMMON = README $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/m4/alpha.m4 \
+	$(top_srcdir)/m4/apple.m4 $(top_srcdir)/m4/beos.m4 \
+	$(top_srcdir)/m4/msdos.m4 $(top_srcdir)/m4/next.m4 \
+	$(top_srcdir)/m4/pkg.m4 $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+SOURCES =
+DIST_SOURCES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
+am__install_max = 40
+am__nobase_strip_setup = \
+  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
+am__nobase_strip = \
+  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
+am__nobase_list = $(am__nobase_strip_setup); \
+  for p in $$list; do echo "$$p $$p"; done | \
+  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
+  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
+    if (++n[$$2] == $(am__install_max)) \
+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
+    END { for (dir in files) print dir, files[dir] }'
+am__base_list = \
+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
+  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+am__installdirs = "$(DESTDIR)$(jsdir)" "$(DESTDIR)$(luadir)" \
+	"$(DESTDIR)$(postscriptdir)"
+DATA = $(js_DATA) $(lua_DATA) $(postscript_DATA)
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CAIROPANGO_CFLAGS = @CAIROPANGO_CFLAGS@
+CAIROPANGO_LIBS = @CAIROPANGO_LIBS@
+CAIROPDF_CFLAGS = @CAIROPDF_CFLAGS@
+CAIROPDF_LIBS = @CAIROPDF_LIBS@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DIST_CONTACT = @DIST_CONTACT@
+DVIPS = @DVIPS@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EMACS = @EMACS@
+EXEEXT = @EXEEXT@
+GDLIB_CONFIG = @GDLIB_CONFIG@
+GIHDIR = @GIHDIR@
+GREP = @GREP@
+GTK28_CFLAGS = @GTK28_CFLAGS@
+GTK28_LIBS = @GTK28_LIBS@
+GTK_CFLAGS = @GTK_CFLAGS@
+GTK_LIBS = @GTK_LIBS@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+KPSEXPAND = @KPSEXPAND@
+LASERGNU = @LASERGNU@
+LATEX = @LATEX@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBRARIES_FOR_X = @LIBRARIES_FOR_X@
+LIBS = @LIBS@
+LINUXSUID = @LINUXSUID@
+LISPDIR = @LISPDIR@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LUA_CFLAGS = @LUA_CFLAGS@
+LUA_LIBS = @LUA_LIBS@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PANGO_1_10_2_CFLAGS = @PANGO_1_10_2_CFLAGS@
+PANGO_1_10_2_LIBS = @PANGO_1_10_2_LIBS@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PDFLATEX = @PDFLATEX@
+PDFLIB_CONFIG = @PDFLIB_CONFIG@
+PKG_CONFIG = @PKG_CONFIG@
+PLAINTEX = @PLAINTEX@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+TERMLIBS = @TERMLIBS@
+TERMXLIBS = @TERMXLIBS@
+TEXDIR = @TEXDIR@
+TEXHASH = @TEXHASH@
+TROFF = @TROFF@
+TUTORIAL = @TUTORIAL@
+U = @U@
+VERSION = @VERSION@
+VERSION_MAJOR = @VERSION_MAJOR@
+WX_CONFIG = @WX_CONFIG@
+WX_LIBS = @WX_LIBS@
+X11_APPDEFAULTS_DIR = @X11_APPDEFAULTS_DIR@
+XMKMF = @XMKMF@
+X_CFLAGS = @X_CFLAGS@
+X_EXTRA_LIBS = @X_EXTRA_LIBS@
+X_LIBS = @X_LIBS@
+X_PRE_LIBS = @X_PRE_LIBS@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build_alias = @build_alias@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host_alias = @host_alias@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+subdirs = @subdirs@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+AUTOMAKE_OPTIONS = foreign 1.2h
+EXTRA_DIST = README Makefile.am.in driver.h impcodes.h \
+object.h post.h $(CORETERM) PostScript lua js
+
+postscriptdir = $(pkgdatadir)/$(VERSION_MAJOR)/PostScript
+luadir = $(pkgdatadir)/$(VERSION_MAJOR)/lua
+jsdir = $(pkgdatadir)/$(VERSION_MAJOR)/js
+
+# List of terminal drivers, and list of postscript installation files
+# must be created prior to running automake
+CORETERM = aed.trm ai.trm amiga.trm apollo.trm aquaterm.trm be.trm \
+cairo.trm canvas.trm cgi.trm cgm.trm corel.trm debug.trm djsvga.trm \
+dumb.trm dxf.trm dxy.trm eepic.trm emf.trm emxvga.trm epson.trm \
+estimate.trm excl.trm fg.trm fig.trm gd.trm ggi.trm gnugraph.trm \
+gpic.trm gpr.trm grass.trm hp2648.trm hp26.trm hp500c.trm hpgl.trm \
+hpljii.trm hppj.trm imagen.trm kyo.trm latex.trm linux.trm lua.trm \
+mac.trm metafont.trm metapost.trm mgr.trm mif.trm next.trm openstep.trm \
+pbm.trm pc.trm pdf.trm pm.trm post.trm pslatex.trm pstricks.trm qms.trm \
+regis.trm rgip.trm sun.trm svg.trm t410x.trm tek.trm texdraw.trm tgif.trm \
+tkcanvas.trm tpic.trm unixpc.trm unixplot.trm v384.trm vgagl.trm vws.trm \
+win.trm wxt.trm x11.trm xlib.trm 
+
+#
+postscript_DATA = PostScript/8859-15.ps PostScript/8859-1.ps \
+PostScript/8859-2.ps PostScript/8859-9.ps PostScript/cp1250.ps \
+PostScript/cp437.ps PostScript/cp850.ps PostScript/cp852.ps \
+PostScript/koi8r.ps PostScript/koi8u.ps PostScript/prologue.ps \
+PostScript/utf-8.ps PostScript/aglfn.txt 
+
+js_DATA = js/canvasmath.js js/canvastext.js js/gnuplot_common.js \
+js/gnuplot_mouse.js js/grid.png js/help.png js/nextzoom.png \
+js/previouszoom.png js/textzoom.png js/gnuplot_mouse.css js/README 
+
+lua_DATA = lua/gnuplot-tikz.lua 
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign term/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign term/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+install-jsDATA: $(js_DATA)
+	@$(NORMAL_INSTALL)
+	test -z "$(jsdir)" || $(MKDIR_P) "$(DESTDIR)$(jsdir)"
+	@list='$(js_DATA)'; test -n "$(jsdir)" || list=; \
+	for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  echo "$$d$$p"; \
+	done | $(am__base_list) | \
+	while read files; do \
+	  echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(jsdir)'"; \
+	  $(INSTALL_DATA) $$files "$(DESTDIR)$(jsdir)" || exit $$?; \
+	done
+
+uninstall-jsDATA:
+	@$(NORMAL_UNINSTALL)
+	@list='$(js_DATA)'; test -n "$(jsdir)" || list=; \
+	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
+	test -n "$$files" || exit 0; \
+	echo " ( cd '$(DESTDIR)$(jsdir)' && rm -f" $$files ")"; \
+	cd "$(DESTDIR)$(jsdir)" && rm -f $$files
+install-luaDATA: $(lua_DATA)
+	@$(NORMAL_INSTALL)
+	test -z "$(luadir)" || $(MKDIR_P) "$(DESTDIR)$(luadir)"
+	@list='$(lua_DATA)'; test -n "$(luadir)" || list=; \
+	for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  echo "$$d$$p"; \
+	done | $(am__base_list) | \
+	while read files; do \
+	  echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(luadir)'"; \
+	  $(INSTALL_DATA) $$files "$(DESTDIR)$(luadir)" || exit $$?; \
+	done
+
+uninstall-luaDATA:
+	@$(NORMAL_UNINSTALL)
+	@list='$(lua_DATA)'; test -n "$(luadir)" || list=; \
+	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
+	test -n "$$files" || exit 0; \
+	echo " ( cd '$(DESTDIR)$(luadir)' && rm -f" $$files ")"; \
+	cd "$(DESTDIR)$(luadir)" && rm -f $$files
+install-postscriptDATA: $(postscript_DATA)
+	@$(NORMAL_INSTALL)
+	test -z "$(postscriptdir)" || $(MKDIR_P) "$(DESTDIR)$(postscriptdir)"
+	@list='$(postscript_DATA)'; test -n "$(postscriptdir)" || list=; \
+	for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  echo "$$d$$p"; \
+	done | $(am__base_list) | \
+	while read files; do \
+	  echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(postscriptdir)'"; \
+	  $(INSTALL_DATA) $$files "$(DESTDIR)$(postscriptdir)" || exit $$?; \
+	done
+
+uninstall-postscriptDATA:
+	@$(NORMAL_UNINSTALL)
+	@list='$(postscript_DATA)'; test -n "$(postscriptdir)" || list=; \
+	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
+	test -n "$$files" || exit 0; \
+	echo " ( cd '$(DESTDIR)$(postscriptdir)' && rm -f" $$files ")"; \
+	cd "$(DESTDIR)$(postscriptdir)" && rm -f $$files
+tags: TAGS
+TAGS:
+
+ctags: CTAGS
+CTAGS:
+
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(DATA)
+installdirs:
+	for dir in "$(DESTDIR)$(jsdir)" "$(DESTDIR)$(luadir)" "$(DESTDIR)$(postscriptdir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am: install-jsDATA install-luaDATA install-postscriptDATA
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-jsDATA uninstall-luaDATA \
+	uninstall-postscriptDATA
+
+.MAKE: install-am install-strip
+
+.PHONY: all all-am check check-am clean clean-generic distclean \
+	distclean-generic distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-jsDATA \
+	install-luaDATA install-man install-pdf install-pdf-am \
+	install-postscriptDATA install-ps install-ps-am install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic pdf \
+	pdf-am ps ps-am uninstall uninstall-am uninstall-jsDATA \
+	uninstall-luaDATA uninstall-postscriptDATA
+
+
+Makefile.am: Makefile.am.in
+	rm -f $@ $@t
+	sed -n '1,/^##trm-files-begin/p' Makefile.am.in > $@t
+	echo CORETERM = *.trm | fmt | (tr '\012' @; echo) \
+	  |sed 's/@$$/%/;s/@/ \\@/g' | tr @% '\012 ' \
+	  >> $@t
+	echo '#' >> $@t
+	echo postscript_DATA = PostScript/*.ps PostScript/*.txt | fmt \
+	  | (tr '\012' @; echo) |sed 's/@$$/%/;s/@/ \\@/g' \
+	  | tr @% '\012 ' >> $@t
+	echo js_DATA = js/*.js js/*.png js/*.css js/README | fmt \
+	  | (tr '\012' @; echo) |sed 's/@$$/%/;s/@/ \\@/g' \
+	  | tr @% '\012 ' >> $@t
+	echo lua_DATA = lua/gnuplot-tikz.lua | fmt \
+	  | (tr '\012' @; echo) |sed 's/@$$/%/;s/@/ \\@/g' \
+	  | tr @% '\012 ' >> $@t
+	sed -n '/^##trm-files-end/,$$p' Makefile.am.in >> $@t
+	chmod a-w $@t
+	mv $@t $@
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/Makefile.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/Makefile.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/Makefile.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/Makefile.svn-base	2012-01-03 17:07:18.759627500 -0800
@@ -0,0 +1,511 @@
+# Makefile.in generated by automake 1.11 from Makefile.am.
+# term/Makefile.  Generated from Makefile.in by configure.
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+
+
+
+pkgdatadir = $(datadir)/gnuplot
+pkgincludedir = $(includedir)/gnuplot
+pkglibdir = $(libdir)/gnuplot
+pkglibexecdir = $(libexecdir)/gnuplot
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+subdir = term
+DIST_COMMON = README $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/m4/alpha.m4 \
+	$(top_srcdir)/m4/apple.m4 $(top_srcdir)/m4/beos.m4 \
+	$(top_srcdir)/m4/msdos.m4 $(top_srcdir)/m4/next.m4 \
+	$(top_srcdir)/m4/pkg.m4 $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+SOURCES =
+DIST_SOURCES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
+am__install_max = 40
+am__nobase_strip_setup = \
+  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
+am__nobase_strip = \
+  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
+am__nobase_list = $(am__nobase_strip_setup); \
+  for p in $$list; do echo "$$p $$p"; done | \
+  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
+  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
+    if (++n[$$2] == $(am__install_max)) \
+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
+    END { for (dir in files) print dir, files[dir] }'
+am__base_list = \
+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
+  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+am__installdirs = "$(DESTDIR)$(jsdir)" "$(DESTDIR)$(luadir)" \
+	"$(DESTDIR)$(postscriptdir)"
+DATA = $(js_DATA) $(lua_DATA) $(postscript_DATA)
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = ${SHELL} /u/champioc/gnuplot-4.4.0/missing --run aclocal-1.11
+AMTAR = ${SHELL} /u/champioc/gnuplot-4.4.0/missing --run tar
+AUTOCONF = ${SHELL} /u/champioc/gnuplot-4.4.0/missing --run autoconf
+AUTOHEADER = ${SHELL} /u/champioc/gnuplot-4.4.0/missing --run autoheader
+AUTOMAKE = ${SHELL} /u/champioc/gnuplot-4.4.0/missing --run automake-1.11
+AWK = gawk
+CAIROPANGO_CFLAGS = -I/usr/include/cairo -I/usr/include/freetype2 -I/usr/include/libpng12 -I/usr/include/pango-1.0 -I/usr/include/glib-2.0 -I/usr/lib64/glib-2.0/include  
+CAIROPANGO_LIBS = -L/lib64 -lpangocairo-1.0 -lpango-1.0 -lcairo -lgobject-2.0 -lgmodule-2.0 -ldl -lglib-2.0  
+CAIROPDF_CFLAGS = -I/usr/include/cairo -I/usr/include/freetype2 -I/usr/include/libpng12 -I/usr/include/pango-1.0 -I/usr/include/glib-2.0 -I/usr/lib64/glib-2.0/include  
+CAIROPDF_LIBS = -L/lib64 -lz -lpangocairo-1.0 -lpango-1.0 -lcairo -lgobject-2.0 -lgmodule-2.0 -ldl -lglib-2.0  
+CC = gcc
+CCDEPMODE = depmode=gcc3
+CFLAGS = -g -O2
+CPP = gcc -E
+CPPFLAGS =   -I/usr/include -I/usr/include/cairo -I/usr/include/freetype2 -I/usr/include/libpng12 -I/usr/include/pango-1.0 -I/usr/include/glib-2.0 -I/usr/lib64/glib-2.0/include  
+CXX = g++
+CXXCPP = g++ -E
+CXXDEPMODE = depmode=gcc3
+CXXFLAGS = -g -O2
+CYGPATH_W = echo
+DEFS = -DHAVE_CONFIG_H
+DEPDIR = .deps
+DIST_CONTACT = 
+DVIPS = dvips
+ECHO_C = 
+ECHO_N = -n
+ECHO_T = 
+EGREP = /bin/grep -E
+EMACS = emacs
+EXEEXT = 
+GDLIB_CONFIG = /usr/bin/gdlib-config
+GIHDIR = ${datarootdir}/gnuplot/4.4
+GREP = /bin/grep
+GTK28_CFLAGS = 
+GTK28_LIBS = 
+GTK_CFLAGS = 
+GTK_LIBS = 
+INSTALL = /usr/bin/install -c
+INSTALL_DATA = ${INSTALL} -m 644
+INSTALL_PROGRAM = ${INSTALL}
+INSTALL_SCRIPT = ${INSTALL}
+INSTALL_STRIP_PROGRAM = $(install_sh) -c -s
+KPSEXPAND = kpsexpand
+LASERGNU = lasergnu-noinstall
+LATEX = latex
+LDFLAGS =  -L/usr/lib64
+LIBOBJS = 
+LIBRARIES_FOR_X =  -lX11 
+LIBS = -lm  -L/lib64 -lz -lpangocairo-1.0 -lpango-1.0 -lcairo -lgobject-2.0 -lgmodule-2.0 -ldl -lglib-2.0  
+LINUXSUID = 
+LISPDIR = lisp
+LN_S = ln -s
+LTLIBOBJS = 
+LUA_CFLAGS = 
+LUA_LIBS = 
+MAKEINFO = ${SHELL} /u/champioc/gnuplot-4.4.0/missing --run makeinfo
+MKDIR_P = /bin/mkdir -p
+OBJEXT = o
+PACKAGE = gnuplot
+PACKAGE_BUGREPORT = 
+PACKAGE_NAME = gnuplot
+PACKAGE_STRING = gnuplot 4.4.0
+PACKAGE_TARNAME = gnuplot
+PACKAGE_URL = 
+PACKAGE_VERSION = 4.4.0
+PANGO_1_10_2_CFLAGS = 
+PANGO_1_10_2_LIBS = 
+PATH_SEPARATOR = :
+PDFLATEX = pdflatex
+PDFLIB_CONFIG = 
+PKG_CONFIG = /usr/bin/pkg-config
+PLAINTEX = tex
+SET_MAKE = 
+SHELL = /bin/sh
+STRIP = 
+TERMLIBS =  -lreadline  -lncurses  -lz -lgd -lXpm -lX11 -ljpeg -lfontconfig -lfreetype -lpng12 -lz -lm -ljpeg -lfreetype -lpng
+TERMXLIBS = 
+TEXDIR = /usr/local/share/texmf/tex/latex/gnuplot
+TEXHASH = texhash
+TROFF = troff
+TUTORIAL = tutorial
+U = 
+VERSION = 4.4.0
+VERSION_MAJOR = 4.4
+WX_CONFIG = no
+WX_LIBS = 
+X11_APPDEFAULTS_DIR = /etc/X11/app-defaults/
+XMKMF = 
+X_CFLAGS = 
+X_EXTRA_LIBS = 
+X_LIBS = 
+X_PRE_LIBS =  -lSM -lICE
+abs_builddir = /u/champioc/gnuplot-4.4.0/term
+abs_srcdir = /u/champioc/gnuplot-4.4.0/term
+abs_top_builddir = /u/champioc/gnuplot-4.4.0
+abs_top_srcdir = /u/champioc/gnuplot-4.4.0
+ac_ct_CC = gcc
+ac_ct_CXX = g++
+am__include = include
+am__leading_dot = .
+am__quote = 
+am__tar = ${AMTAR} chof - "$$tardir"
+am__untar = ${AMTAR} xf -
+bindir = ${exec_prefix}/bin
+build_alias = 
+builddir = .
+datadir = ${datarootdir}
+datarootdir = ${prefix}/share
+docdir = ${datarootdir}/doc/${PACKAGE_TARNAME}
+dvidir = ${docdir}
+exec_prefix = ${prefix}
+host_alias = 
+htmldir = ${docdir}
+includedir = ${prefix}/include
+infodir = ${datarootdir}/info
+install_sh = ${SHELL} /u/champioc/gnuplot-4.4.0/install-sh
+libdir = ${exec_prefix}/lib
+libexecdir = ${exec_prefix}/libexec
+localedir = ${datarootdir}/locale
+localstatedir = ${prefix}/var
+mandir = ${datarootdir}/man
+mkdir_p = /bin/mkdir -p
+oldincludedir = /usr/include
+pdfdir = ${docdir}
+prefix = /usr/local
+program_transform_name = s,x,x,
+psdir = ${docdir}
+sbindir = ${exec_prefix}/sbin
+sharedstatedir = ${prefix}/com
+srcdir = .
+subdirs =  lisp
+sysconfdir = ${prefix}/etc
+target_alias = 
+top_build_prefix = ../
+top_builddir = ..
+top_srcdir = ..
+AUTOMAKE_OPTIONS = foreign 1.2h
+EXTRA_DIST = README Makefile.am.in driver.h impcodes.h \
+object.h post.h $(CORETERM) PostScript lua js
+
+postscriptdir = $(pkgdatadir)/$(VERSION_MAJOR)/PostScript
+luadir = $(pkgdatadir)/$(VERSION_MAJOR)/lua
+jsdir = $(pkgdatadir)/$(VERSION_MAJOR)/js
+
+# List of terminal drivers, and list of postscript installation files
+# must be created prior to running automake
+CORETERM = aed.trm ai.trm amiga.trm apollo.trm aquaterm.trm be.trm \
+cairo.trm canvas.trm cgi.trm cgm.trm corel.trm debug.trm djsvga.trm \
+dumb.trm dxf.trm dxy.trm eepic.trm emf.trm emxvga.trm epson.trm \
+estimate.trm excl.trm fg.trm fig.trm gd.trm ggi.trm gnugraph.trm \
+gpic.trm gpr.trm grass.trm hp2648.trm hp26.trm hp500c.trm hpgl.trm \
+hpljii.trm hppj.trm imagen.trm kyo.trm latex.trm linux.trm lua.trm \
+mac.trm metafont.trm metapost.trm mgr.trm mif.trm next.trm openstep.trm \
+pbm.trm pc.trm pdf.trm pm.trm post.trm pslatex.trm pstricks.trm qms.trm \
+regis.trm rgip.trm sun.trm svg.trm t410x.trm tek.trm texdraw.trm tgif.trm \
+tkcanvas.trm tpic.trm unixpc.trm unixplot.trm v384.trm vgagl.trm vws.trm \
+win.trm wxt.trm x11.trm xlib.trm 
+
+#
+postscript_DATA = PostScript/8859-15.ps PostScript/8859-1.ps \
+PostScript/8859-2.ps PostScript/8859-9.ps PostScript/cp1250.ps \
+PostScript/cp437.ps PostScript/cp850.ps PostScript/cp852.ps \
+PostScript/koi8r.ps PostScript/koi8u.ps PostScript/prologue.ps \
+PostScript/utf-8.ps PostScript/aglfn.txt 
+
+js_DATA = js/canvasmath.js js/canvastext.js js/gnuplot_common.js \
+js/gnuplot_mouse.js js/grid.png js/help.png js/nextzoom.png \
+js/previouszoom.png js/textzoom.png js/gnuplot_mouse.css js/README 
+
+lua_DATA = lua/gnuplot-tikz.lua 
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign term/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign term/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+install-jsDATA: $(js_DATA)
+	@$(NORMAL_INSTALL)
+	test -z "$(jsdir)" || $(MKDIR_P) "$(DESTDIR)$(jsdir)"
+	@list='$(js_DATA)'; test -n "$(jsdir)" || list=; \
+	for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  echo "$$d$$p"; \
+	done | $(am__base_list) | \
+	while read files; do \
+	  echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(jsdir)'"; \
+	  $(INSTALL_DATA) $$files "$(DESTDIR)$(jsdir)" || exit $$?; \
+	done
+
+uninstall-jsDATA:
+	@$(NORMAL_UNINSTALL)
+	@list='$(js_DATA)'; test -n "$(jsdir)" || list=; \
+	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
+	test -n "$$files" || exit 0; \
+	echo " ( cd '$(DESTDIR)$(jsdir)' && rm -f" $$files ")"; \
+	cd "$(DESTDIR)$(jsdir)" && rm -f $$files
+install-luaDATA: $(lua_DATA)
+	@$(NORMAL_INSTALL)
+	test -z "$(luadir)" || $(MKDIR_P) "$(DESTDIR)$(luadir)"
+	@list='$(lua_DATA)'; test -n "$(luadir)" || list=; \
+	for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  echo "$$d$$p"; \
+	done | $(am__base_list) | \
+	while read files; do \
+	  echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(luadir)'"; \
+	  $(INSTALL_DATA) $$files "$(DESTDIR)$(luadir)" || exit $$?; \
+	done
+
+uninstall-luaDATA:
+	@$(NORMAL_UNINSTALL)
+	@list='$(lua_DATA)'; test -n "$(luadir)" || list=; \
+	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
+	test -n "$$files" || exit 0; \
+	echo " ( cd '$(DESTDIR)$(luadir)' && rm -f" $$files ")"; \
+	cd "$(DESTDIR)$(luadir)" && rm -f $$files
+install-postscriptDATA: $(postscript_DATA)
+	@$(NORMAL_INSTALL)
+	test -z "$(postscriptdir)" || $(MKDIR_P) "$(DESTDIR)$(postscriptdir)"
+	@list='$(postscript_DATA)'; test -n "$(postscriptdir)" || list=; \
+	for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  echo "$$d$$p"; \
+	done | $(am__base_list) | \
+	while read files; do \
+	  echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(postscriptdir)'"; \
+	  $(INSTALL_DATA) $$files "$(DESTDIR)$(postscriptdir)" || exit $$?; \
+	done
+
+uninstall-postscriptDATA:
+	@$(NORMAL_UNINSTALL)
+	@list='$(postscript_DATA)'; test -n "$(postscriptdir)" || list=; \
+	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
+	test -n "$$files" || exit 0; \
+	echo " ( cd '$(DESTDIR)$(postscriptdir)' && rm -f" $$files ")"; \
+	cd "$(DESTDIR)$(postscriptdir)" && rm -f $$files
+tags: TAGS
+TAGS:
+
+ctags: CTAGS
+CTAGS:
+
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(DATA)
+installdirs:
+	for dir in "$(DESTDIR)$(jsdir)" "$(DESTDIR)$(luadir)" "$(DESTDIR)$(postscriptdir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am: install-jsDATA install-luaDATA install-postscriptDATA
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-jsDATA uninstall-luaDATA \
+	uninstall-postscriptDATA
+
+.MAKE: install-am install-strip
+
+.PHONY: all all-am check check-am clean clean-generic distclean \
+	distclean-generic distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-jsDATA \
+	install-luaDATA install-man install-pdf install-pdf-am \
+	install-postscriptDATA install-ps install-ps-am install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic pdf \
+	pdf-am ps ps-am uninstall uninstall-am uninstall-jsDATA \
+	uninstall-luaDATA uninstall-postscriptDATA
+
+
+Makefile.am: Makefile.am.in
+	rm -f $@ $@t
+	sed -n '1,/^##trm-files-begin/p' Makefile.am.in > $@t
+	echo CORETERM = *.trm | fmt | (tr '\012' @; echo) \
+	  |sed 's/@$$/%/;s/@/ \\@/g' | tr @% '\012 ' \
+	  >> $@t
+	echo '#' >> $@t
+	echo postscript_DATA = PostScript/*.ps PostScript/*.txt | fmt \
+	  | (tr '\012' @; echo) |sed 's/@$$/%/;s/@/ \\@/g' \
+	  | tr @% '\012 ' >> $@t
+	echo js_DATA = js/*.js js/*.png js/*.css js/README | fmt \
+	  | (tr '\012' @; echo) |sed 's/@$$/%/;s/@/ \\@/g' \
+	  | tr @% '\012 ' >> $@t
+	echo lua_DATA = lua/gnuplot-tikz.lua | fmt \
+	  | (tr '\012' @; echo) |sed 's/@$$/%/;s/@/ \\@/g' \
+	  | tr @% '\012 ' >> $@t
+	sed -n '/^##trm-files-end/,$$p' Makefile.am.in >> $@t
+	chmod a-w $@t
+	mv $@t $@
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/README.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/README.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/README.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/README.svn-base	2012-01-03 17:07:23.790674300 -0800
@@ -0,0 +1,701 @@
+DOCUMENTATION FOR GNUPLOT TERMINAL DRIVER WRITERS
+By Russell Lang 1/90
+
+Updated for new file layout by drd 4/95
+
+Paragraphs about inclusion of TERM_HELP added by rcc 1/96
+
+No change to the interface between gnuplot and the terminal drivers,
+but we would like to make the terminal drivers standalone
+
+1) in order move the support for the terminal drivers outside of the
+   support for the main program, thereby encouraging a library of
+   contributed drivers
+2) To make it easy for users to add contributed drivers, by adding
+   a single #include line to term.h
+3) To allow individual compilation on DOS, to save the overlay
+   manager from having to load _all_ drivers together.
+
+CORRECTION - scale() interface is no longer supported, since it
+is incompatible with multiplot.
+
+Whole of terminal driver should be contained in one <driver>.trm file,
+with a fairly strict layout as detailed below - this allows the
+gnuplot maintainers to change the way the terminal drivers are
+compiled without having to change the drivers themselves.
+
+term.h, and therefore each file.trm file, may be loaded more than once,
+with different sections selected by macros.
+
+Each driver provides all the functions it needs, and a table of
+function pointers and other data to interface to gnuplot.
+The table entry is currently defined as follows in term_api.h:
+
+struct TERMENTRY {
+
+/* required entries */
+
+    const char *name;
+    const char *description;
+    unsigned int xmax,ymax,v_char,h_char,v_tic,h_tic;
+
+    void (*options) __PROTO((void));
+    void (*init) __PROTO((void));
+    void (*reset) __PROTO((void));
+    void (*text) __PROTO((void));
+    int (*scale) __PROTO((double, double));
+    void (*graphics) __PROTO((void));
+    void (*move) __PROTO((unsigned int, unsigned int));
+    void (*vector) __PROTO((unsigned int, unsigned int));
+    void (*linetype) __PROTO((int));
+    void (*put_text) __PROTO((unsigned int, unsigned int, const char*));
+
+/* optional entries */
+
+    int (*text_angle) __PROTO((int));
+    int (*justify_text) __PROTO((enum JUSTIFY));
+    void (*point) __PROTO((unsigned int, unsigned int,int));
+    void (*arrow) __PROTO((unsigned int, unsigned int, unsigned int,
+                           unsigned int, TBOOLEAN));
+   int (*set_font) __PROTO((const char *font));  /* "font,size" */
+   void (*pointsize) __PROTO((double pointsize));
+   int flags;                       /* various flags */
+   void (*suspend) __PROTO((void)); /* after one plot of multiplot */
+   void (*resume) __PROTO((void));  /* before subsequent plot of multiplot */
+   void (*fillbox) __PROTO((int style, unsigned int x1, unsigned int y1, unsigned int width, unsigned int height)); /* clear part of multiplot */
+   void (*linewidth) __PROTO((double linewidth));
+#ifdef USE_MOUSE
+   int (*waitforinput) __PROTO((void));
+   void (*put_tmptext) __PROTO((int i, const char str[]));
+   void (*set_ruler) __PROTO((int x, int y));
+   void (*set_cursor) __PROTO((int c, int x, int y));
+   void (*set_clipboard) __PROTO((const char s[]));
+#endif
+   int (*make_palette)__PROTO((t_sm_palette *palette));
+   void (*previous_palette) __PROTO(());
+   void (*set_color) __PROTO((t_colorspec *colorspec));
+   void (*filled_polygon) __PROTO((int points, gpiPoint *corners));
+   void (*image) __PROTO((unsigned, unsigned, coordval *, gpiPoint *, t_imagecolor));
+/* Enhanced text mode driver call-backs */
+    void (*enhanced_open) __PROTO((char * fontname, double fontsize,
+               double base, TBOOLEAN widthflag, TBOOLEAN showflag,
+               int overprint));
+    void (*enhanced_flush) __PROTO((void));
+    void (*enhanced_writec) __PROTO((int c));
+/* Driver-specific synchronization or other layering commands */
+    void (*layer) __PROTO((t_termlayer syncpoint));
+/* Path control for end-joins of closed polygons on PostScript-like devices */
+    void (*path) __PROTO((int p));
+};
+
+One consequence of (1) is that we would like drivers to be backwards
+compatible - drivers in the correct form below should work in future
+versions of gnuplot without change. C compilers guarantee to fill
+uninitialised members of a structure to zero, so gnuplot can detect old
+drivers, in which fields have not been initialised, and can point
+new interface entry pointers to dummy functions.
+
+We can add fields to the terminal structure, but only at the end of the list.
+If you design a terminal that can't work without a new interface being defined,
+and consequent changes to the main gnuplot source, please contact
+gnuplot-beta@lists.sourceforge.net simply to ensure that you have the most
+up to date definition of the terminal structure. Also, please ensure that
+the 'set term' command checks for 0 values in added fields when an
+old driver is selected, and a pointer to a suitable 'can't do' function
+is provided. It is therefore not required (and in fact not possible)
+to add padding fields to the end of all drivers.
+
+Similarly, if you add an optional field to an old driver, take care
+to ensure that all intervening fields are padded with zeros.
+
+Some of the above fields are required - this should not be a problem,
+since they were all required in earlier releases of gnuplot.
+The later fields are interfaces to capabilities that not all devices
+can do, or for which the generic routines provided should be adequate.
+There are several null ('can't do') functions provided by term.c which
+a driver can reference in the table. Similarly, for bitmap devices, there
+are generic routines for lines and text provided by bitmap.c
+
+
+
+Here's a brief description of each variable:
+
+The char *name is a pointer to a string containing the name
+of the terminal.  This name is used by the 'set terminal' and 
+'show terminal' commands.  
+The name must be unique and must not be confused with an abbreviation 
+of another name.  For example if the name "postscript" exists, it is not
+possible to have another name "postscript2".
+Keep the name under 15 characters.
+
+The char *description is a pointer to a string containing a
+description of the terminal, which is displayed in response
+to the 'set terminal' command.  
+Keep the description under 60 characters.
+
+xmax is the maximum number of points in the x direction.  
+The range of points used by gnuplot is 0 to xmax-1.
+
+ymax is the maximum number of points in the y direction.  
+The range of points used by gnuplot is 0 to ymax-1.
+
+v_char is the height of characters, in the same units as xmax and ymax.
+The border for labelling at the top and bottom of the plot is 
+calculated using v_char.  
+v_char is used as the vertical line spacing for characters.
+
+h_char is the width of characters, in the same units as xmax and ymax.
+The border for labelling at the left and right of the plot is 
+calculated using h_char, for example.
+If the _justify_text function returns FALSE, h_char is used to justify 
+text right or centre.  If characters are not fixed width, then the 
+_justify_text function must correctly justify the text.
+
+v_tic is the vertical size of tics along the x axis, 
+in the same units as ymax.
+
+h_tic is the horizontal size of tics along the y axis, 
+in the same units as xmax.
+
+v_tic and h_tic should give tics of the same physical size on the
+output. The ratio of these two quantities is used by gnuplot to set the
+aspect ratio to 1 so that circles appear circular when 'set size square'
+is active.
+
+All the above values need not be static - values can be substituted
+into the table during terminal initialisation, based on options for
+example.
+
+
+
+Here's a brief description of what each term.c function does:
+
+_options()  Called when terminal type is selected.  Also called by
+'set termoption'. The two cases can be distinguished because on entry
+the value of c_token is either 3 or 2, respectively.
+This procedure should parse options on the command line.  A list of the 
+currently selected options should be stored in term_options[] in a form 
+suitable for use with the set term command.  term_options[] is used by 
+the save command.  Use options_null() if no options are available. 
+
+_init()  Called once, when the device is first selected.  This procedure
+should set up things that only need to be set once, like handshaking and
+character sets etc...
+There is a global variable 'pointsize' which you might want to use here.
+If set pointsize is issued after init has been called, the pointsize()
+function is called.
+
+_reset()  Called when gnuplot is exited, the output device changed or
+the terminal type changed.  This procedure should reset the device, 
+possibly flushing a buffer somewhere or generating a form feed.
+
+_scale(xs,ys) Called just before _graphics(). This takes the x and y
+scaling factors as information. If the terminal would like to do its
+own scaling, it returns TRUE. Otherwise, it can ignore the information
+and return FALSE: do_plot will do the scaling for you. null_scale is
+provided to do just this, so most drivers can ignore this function
+entirely. The Latex driver is currently the only one providing its own
+scaling. PLEASE DO NOT USE THIS INTERFACE - IT IS NOT COMPATIBLE WITH
+MULTIPLOT.
+
+_graphics()  Called just before a plot is going to be displayed.  This
+procedure should set the device into graphics mode.  Devices which can't
+be used as terminals (like plotters) will probably be in graphics mode 
+always and therefore won't need this.
+
+_text()  Called immediately after a plot is displayed.  This procedure 
+should set the device back into text mode if it is also a terminal, so
+that commands can be seen as they're typed.  Again, this will probably
+do nothing if the device can't be used as a terminal. This call can
+be used to trigger conversion and output for bitmap devices.
+
+_move(x,y)  Called at the start of a line.  The cursor should move to the
+(x,y) position without drawing.
+
+_vector(x,y)  Called when a line is to be drawn.  This should display a line
+from the last (x,y) position given by _move() or _vector() to this new (x,y)
+position.
+
+_linetype(lt)  Called to set the line type before text is displayed or
+line(s) plotted.  This procedure should select a pen color or line
+style if the device has these capabilities.  
+lt is an integer from -3 to 0 or greater.  
+An lt of -3 is solid and drawn with xor (for temporary interactive annotations).
+An lt of -2 is used for the border of the plot.
+An lt of -1 is used for the X and Y axes.  
+lt 0 and upwards are used for plots 0 and upwards.
+If _linetype() is called with lt greater than the available line types, 
+it should map it to one of the available line types.
+Most drivers provide 9 different linetypes (lt is 0 to 8).
+
+_put_text(x,y,str)  Called to display text at the (x,y) position, 
+while in graphics mode.   The text should be vertically (with respect 
+to the text) justified about (x,y).  The text is rotated according 
+to _text_angle and then horizontally (with respect to the text)
+justified according to _justify_text.
+
+
+The following are optional
+
+
+_text_angle(ang)  Called to rotate the text angle when placing the y label.
+Ang is the rotation angle in degrees. If ang = 0 then text is horizontal.  
+Returns TRUE if text can be rotated, FALSE otherwise.
+[But you must return TRUE if called with ang=0]
+
+_justify_text(mode)  Called to justify text left, right or centre.
+If mode = LEFT then text placed by _put_text is flushed left against (x,y).
+If mode = CENTRE then centre of text is at (x,y).  
+If mode = RIGHT then text is placed flushed right against (x,y).
+Returns TRUE if text can be justified
+Returns FALSE otherwise and then _put_text assumes text is flushed left;
+justification of text is then performed by calculating the text width
+using strlen(text) * h_char.
+
+_point(x,y,point)  Called to place a point at position (x,y).
+point is -1 or an integer from 0 upwards.  
+At least 6 point types (numbered 0 to 5) are normally provided.  
+Point type -1 is a dot. 'point' corresponds to (pointtype - 1),
+e.g. 'plot x with points pointtype 2' will call _point(x, y, 1).
+If possible, the driver should support the following 13 point types
+in the given order:
+
+    point  pointtype
+	0          1  plus
+	1          2  X
+	2          3  star
+	3          4  box
+	4          5  box                   filled
+	5          6  circle
+	6          7  circle (disk)         filled
+	7          8  triangle
+	8          9  triangle              filled
+	9         10  upside down triangle
+       10         11  upside down triangle  filled
+       11         12  diamond
+       12         13  diamond               filled
+
+If point is more than the available point types then it should 
+be mapped back to one of the available points.
+Two _point() functions called do_point() and line_and_point() are 
+provided in term.c and should be suitable for most drivers.  
+do_point() draws the points in the current line type.
+If your driver uses dotted line types (generally because it is
+monochrome), you should use line_and_point() which changes to 
+line type 0 before drawing the point.  line type 0 should be solid.
+
+There is a global variable 'pointsize' which is controlled by the
+set pointsize command. If possible, use that. pointsize should be
+examined at terminal init. If it is subsequently changed, the
+pointsize() function will be called.
+
+
+_arrow(sx,sy,ex,ey,head)  Called to draw an arrow from (sx,sy) to (ex,ey).
+A head is drawn on the arrow if head = TRUE.
+An _arrow() function called do_arrow() is provided in term.c which will
+draw arrows using the _move() and _vector() functions.  
+Drivers should use do_arrow unless it causes problems.
+
+_set_font() is called to set the font of labels, etc. [new 3.7 feature]
+  - fonts are selected as strings "name,size".
+  - _set_font("") restores the terminal's default font.
+
+_pointsize() is used to set the pointsize for subsequent points
+
+_flags stores various flags describing driver capabilities.
+  - TERM_CAN_MULTIPLOT - driver can do multiplot in interactive mode,
+  - TERM_CANNOT_MULTIPLOT - driver cannot multiplot, even if output
+    is redirected. (not used by any current driver)
+  - TERM_BINARY - output file must be opened in binary mode
+  - TERM_ENHANCED_TEXT - terminal is currently in enhanced text mode
+  - TERM_NO_OUTPUTFILE - terminal does not use gpoutfile
+
+_suspend() - Called before gnuplot issues a prompt in multiplot mode.
+   Called only in interactive mode, and only for drivers that have set the
+   flag TERM_CAN_MULTIPLOT.  Some of these must flip between text/graphics
+   mode (e.g. linuxvga).  X11 driver will take this opportunity to paint
+   the window on the display.
+
+_resume() - called after suspend(), before subsequent plots of a multiplot.
+   Called only in interactive mode, and only for drivers that have set the
+   flag TERM_CAN_MULTIPLOT.
+
+_fillbox() - draws a filled axis-aligned rectangular box. The first
+   argument controls the type of fill-in: either a solid color at some
+   percentage of full intensity, or a hatch pattern.  Used by plot style
+   "with filledboxes" and by the "clear" command (with background as
+   fill colour) to do inset plots via multiplot.
+
+_linewidth() - sets the linewidth
+
+The next five functions are used for mouse support, and should be
+conditioned on USE_MOUSE:
+
+_waitforinput() - used for mouse input.  Return the next character
+   that can be read from stdin.  In the mean time, process any mouse
+   events.
+
+_put_tmptext(int i, const char str[]) - Display temporary text, after
+   erasing any temporary text displayed previously at this location.
+   The int determines where: 0=statusline, 1,2: at corners of zoom
+   box, with \r separating text above and below the point.
+
+_set_ruler(int x, int y) - Draw a ruler (crosshairs) centered at the
+   indicated screen coordinates.  If x<0, switch ruler off.
+
+_set_cursor(int c, int x, int y) - Set cursor style and corner of
+   rubber band rectangle.  c selects the action: -2=warp the cursor to
+   the given point, -1=start zooming, 0=standard cross-hair cursor,
+   1=cursor during rotation, 2=cursor during scaling, 3=cursor during
+   zooming, -3=draw line between ruler and current mouse position,
+   -4=don't draw (erase) line between ruler and current mouse position.
+
+_set_clipboard(const char s[]) - Write a string to the clipboard.
+
+
+The following four functions were conditioned on #ifdef PM3D; this necessity
+was removed in August 2005. For further documentation about pm3d routines,
+see also pm3d/old-docs/README-pm3d.
+
+_make_palette(t_sm_palette *palette) - If argument is NULL, return
+   number of colors available.  If the number of colors is not limited
+   (continuously shaded colors can be generated), return 0.
+   Otherwise, allocate the palette.  (t_sm_palette is defined in
+   src/color.h.)
+
+_set_color(t_colorspec *colorspec) - EAM November 2004 ***CHANGED***
+   This routine used to accept a single double value, which was 
+   interpreted as a fractional index into the current color palette.
+   Changing the parameter to a colorspec allows terminals to support
+   other methods of specifying a color. If a given driver can not
+   support a particular color request mechanism, it ignores it.
+   If (colorspec->type == TC_FRAC)  (this was the old behavior):
+   Set current color according to colorspec->value, where 0 <= value <= 1.
+   If using a palette, first map value to an integer i in the interval
+   [0...num_colors-1], then set to the ith color in the palette.
+   If (colorspec->type == TC_RGB):
+   Set current color to the rgb triple given in colorspec->lt.
+
+_filled_polygon(int points, gpiPoint *corners) - Draw a polygon with
+   the fill color set by set_color, and no border.  (gpiPoint is
+   defined in src/color.h.)
+
+_previous_palette() - Release the palette that the above routine
+   allocated and get back the palette that was active before.  Some
+   terminals, like displays, may draw parts of the figure using their
+   own palette. Terminals that use only one palette for the whole plot
+   don't need this routine.
+
+The following 3 functions are required for drivers that support enhanced
+text mode. They are called only by the term.c routine enhanced_recursion().
+
+_enhanced_open()   - initialize state variables to process an enhanced text
+		     fragment
+_enhanced_writec() - write (or buffer) a single character of the text fragment
+                     being constructed
+_enhanced_flush()  - finish processing of previous fragment and write it to
+                     the output stream
+
+_image(unsigned M, unsigned N, coordval *image, gpiPoint *corner, t_imagecolor color_mode)
+   Plot a pixel-based image on the display device.
+   'M' is the number of pixels along the y-dimension of the image and
+   'N' is the number of pixels along the x-dimension of the image.  The
+   coordval pointer 'image' is the pixel values normalized to the range
+   [0:1].  These values should be scaled appropriately for the output
+   device.  The 'image' data starts in the upper left corner and scans
+   along rows finishing in the lower right corner.  If 'color_mode' is
+   IC_PALETTE, the terminal is to use palette lookup to generate color
+   information.  In this scenario the size of 'image' is M*N.  If
+   'color_mode' is IC_RGB, the terminal is to use RGB components.  In
+   this scenario the size of 'image' is 3*M*N.  The data appears in RGB
+   triples, i.e., image[0] = R(1,1), image[1] = G(1,1), image[2] =
+   B(1,1), image[3] = R(1,2), image[4] = G(1,2), ..., image[3*M*N-1] =
+   B(M,N).  The 'image' is actually an "input" image in the sense that
+   it must also be properly resampled for the output device.  Many output
+   media, e.g., PostScript, do this work via various driver functions.
+   To determine the appropriate rescaling, the 'corner' information
+   should be used.  There are four entries in the gpiPoint data array.
+   'corner[0]' is the upper left corner (in terms of plot location) of
+   the outer edge of the image.  Similarly, 'corner[1]' is the lower
+   right corner of the outer edge of the image.  (Outer edge means the
+   outer extent of the corner pixels, not the middle of the corner
+   pixels.)  'corner[2]' is the upper left corner of the visible part
+   of the image, and 'corner[3]' is the lower right corner of the visible
+   part of the image.  The information is provided in this way because
+   often it is necessary to clip a portion of the outer pixels of the
+   image.
+
+
+_layer(t_termlayer syncpoint)
+   Driver-specific synchronization or other layering commands.
+   As of this point (Jan 2009) used only by fig lua post pslatex and svg.
+   See term_api.h for defined synchronization points. Any driver that 
+   implements term->layer() must silently ignore unrecognized syncpoints.
+
+_path(int p)
+   PostScript-like devices make a distinction between the end of a 
+   line segment that is internal to a polyline and one that has no
+   line-join to another segment.  In order to treat the endpoints of
+   a closed polygon as "internal" line-joins, one must bracket the
+   polygon segments with "newpath ... closepath". 
+   term->path(0) triggers a "newpath"
+   term->path(1) triggers a "closepath"
+   These calls are optional, and only required by a few drivers.
+   
+
+The following should illustrate the order in which calls to these
+routines are made:
+
+ _options()
+  _init()
+    _scale(xs,ys)
+    _graphics()
+      _linewidth(lw)
+      _linetype(lt)
+      _path(0)
+         _move(x,y)
+         _vector(x,y)
+      _path(1)
+      _pointsize(size)
+      _point(x,y,point)
+      _text_angle(angle)
+      _justify_text(mode)
+      _set_font(font)
+      _put_text(x,y,text)
+         _enhanced_open(fontname,fontsize,base,width,show,overprint)
+	 _enhanced_writec(char)
+	 _enhanced_flush()
+      _arrow(sx,sy,ex,ey)
+      _image(M,N,image,corner,color_mode)
+    _text()
+    _graphics()
+      .
+    _suspend()
+    _set_pointsize()
+    _resume()
+      .
+    _text()
+  _reset()
+
+
+------------------------------------
+
+BITMAP DEVICES
+
+A file bitmap.c is provided, implementing a generic set of bitmap
+routines. It provides all the routines required to generate a
+bitmap in memory, drawing lines and writing text. A simple driver
+need provide only a text() entry point, which converts and outputs
+the stored bitmap in the format required by the device.
+
+Internally, the bitmap is built of one or more planes of 1
+bit per pixel. In fact, I think the library would be easier to
+use if it offered one or more planes of pixels with 1,2,4 or 8
+bits per pixel, since not all bitmap devices are based on planes,
+and the planes have to be recombined at the end at present.
+In general, a device would use either planes or bits-per-pixel,
+though I guess a 24-bit bitmap could use 3 planes of 8 bits
+per pixel..?
+
+
+The pixels are currently organised horizontally packed into bytes.
+
+i.e.
+
+********%%%%%%%%$$$$$$$$!!!!!!!! etc
+^^^^^^^^@@@@@@@@########++++++++ etc
+
+where like symbols are stored in one byte. Vertical packing can be
+arranged by reversing x and y dimensions and setting the global
+b_rastermode to TRUE.  (e.g. Epson 8-pin dot-matrix printer)
+
+
+Functions provided are
+
+(internal functions ? - should probably be static, not external ?)
+b_setpixel(x,y,value)     
+b_setmaskpixel(x,y,value)
+b_putc(x,y,char,angle)
+b_setvalue(size)
+
+setting up stuff
+
+b_makebitmap(x,y,planes)  - make a bitmap of size x * y
+b_freebitmap()            - free bitmap
+b_charsize(size)
+
+
+gnuplot driver interface functions  (can go straight into gnuplot structure)
+
+b_setlinetype(linetype)
+b_move(x,y)
+b_vector(x,y)
+b_put_text(x,y,*str)
+b_text_angle(ang)
+
+
+
+I think that the library could be made easier to use if we defined
+a structure which described the bitmap (raster mode, planes, bits-per-pixel,
+colours, etc) and then added to the gnuplot term struct a pointer to
+this structure. Then we could have b_graphics() routine which did all
+the initialisation that presently has to be done by the driver graphics()
+entry point.  Also, one day I would like to have parsing, including
+terminal driver options, table-driven, but I'm getting ahead of myself
+here.
+
+
+At present, bitmap.c is linked into gnuplot unconditionally. Perhaps
+it should be put into a library, so that it is linked in only if
+any of the user-selected drivers require bitmap support.
+
+There may be scope to do similar things with some of the other
+stuff that is shared by several drivers. Rather than requiring,
+for example, that LATEX driver is required if EMTEX is to be used,
+the shared routines could be extracted to a library and linked
+if any of the drivers which use them are used.  Just a thought...
+
+------------------------------------
+
+FILE LAYOUT
+-----------
+
+I think a file layout like the following will leave most flexibility
+to the gnuplot maintainers. I use REGIS for example.
+
+
+#include "driver.h"
+
+
+#ifdef TERM_REGISTER
+register_term(regis) /* no ; */
+#endif
+
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void REGISinit __PROTO((void));
+TERM_PUBLIC void REGISgraphics __PROTO((void));
+/* etc */
+#define GOT_REGIS_PROTO
+#endif
+
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+TERM_PUBLIC void REGISinit()
+{
+  /* etc */
+}
+
+/* etc */
+
+#endif
+
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(regis_driver)
+  /* no { */
+  "regis", "REGIS graphics language",
+  REGISXMAX, /* etc */
+  /* no } */
+TERM_TABLE_END(regis_driver)
+
+#undef LAST_TERM
+#define LAST_TERM regis_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+
+
+
+#ifdef TERM_HELP
+START_HELP(regis)
+"1 regis",
+"?set terminal regis",
+"?regis",
+" The `regis` terminal device generates output in the REGIS graphics language.",
+" It has the option of using 4 (the default) or 16 colors.",
+"",
+" Syntax:",
+"         set term regis {4 | 16}"
+END_HELP(regis)
+#endif
+
+
+--------------
+
+The first three lines in the TERM_HELP section must contain the same
+name as that specified by register_term, since this is the name that
+will be entered into the list of available terminals.  If more than
+one name is registered, the additional names should have their own
+two "?" lines, but not the "1" line.
+
+Each record is enclosed in double-quotes and (except for the last
+record) followed by a comma.  The text is copied as a single string
+into gnuplot.doc, so the syntax must obey the rules of that entity.
+If the text includes double-quotes or backslashes, these must be
+escaped by preceding each occurrence with a backslash.
+
+--------------
+
+Rationale:
+
+We may want to compile all drivers into term.c or one driver at a time
+this layout should support both
+TERM_PUBLIC will be static  if all modules are in term.c, or blank
+otherwise.
+Please make private support functions static if possible.
+
+
+We may include term.h, and therefore all these files, one or more times.
+If just once (all modules compiled into term.c) putting the four
+parts in this order should make it work.
+
+We may compile the table entries into either an array or a linked list.
+This organisation should support both.
+
+For separate compilation, we may write a program which
+defines TERM_REGISTER and #include term.h to find out which drivers are
+selected in term.h and thereby generate a makefile.
+
+
+
+For a driver which depends on another (e.g. enhpost and pslatex on post)
+the driver can do something like
+
+#ifndef GOT_POST_PROTO
+#define TERM_PROTO_ONLY
+#include "post.trm"
+#undef TERM_PROTO_ONLY
+#endif
+
+this is probably needed only in the TERM_TABLE section, but may
+also be used in the body. The TERM_PROTO_ONLY means that we pick up
+only the prototypes from post.trm, even if current driver is being compiled
+with TERM_BODY or TERM_TABLE
+
+If we do it the linked-list way, the argument to TERM_TABLE_START will be
+the name of the variable, so any valid, unique name is fine.
+The TERM_TABLE_START macro will do all the work of linking the entries
+together, probably using LAST_TERM
+
+The inclusion of the TERM_HELP section (and removal of terminal documentation
+from the master gnuplot.doc file) means that the online help will include
+discussions of only those terminals available to the user.  For generation
+of the printed manual, all can be included.
+
+
+Please make as many things as possible static, but do still try to use unique
+names since all drivers may be compiled into term.o
+
+The bit in the PROTO section is basically what you would put into a .h
+file if we had them - everything that is needed by the TABLE_ENTRY
+should be defined in this part. In particular, don't forget all the maxes
+and character sizes and things for the table entry.
+
+Don't forget to put TERM_PUBLIC in the definitions of the functions as
+well as the prototypes. It will probably always expand to 'static'
+except for PCs.
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/aed.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/aed.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/aed.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/aed.trm.svn-base	2012-01-03 17:07:24.044332100 -0800
@@ -0,0 +1,224 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: aed.trm,v 1.14 2006/07/21 02:35:45 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - aed.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *   AED terminals
+ *
+ * AUTHORS
+ *     Colin Kelley, Thomas Williams, Russell Lang
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+
+/*
+ * adapted to the new terminal layout by Stefan Bodewig (Dez. 1995)
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(aed512)
+register_term(aed767)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void AED_init __PROTO((void));
+TERM_PUBLIC void AED_graphics __PROTO((void));
+TERM_PUBLIC void AED_text __PROTO((void));
+TERM_PUBLIC void AED_linetype __PROTO((int linetype));
+TERM_PUBLIC void AED_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void AED_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void AED_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC void AED_reset __PROTO((void));
+
+#define AED_XMAX 768
+#define AED_YMAX 575
+
+#define AED_VCHAR	13
+#define AED_HCHAR	8
+#define AED_VTIC	8
+#define AED_HTIC	7
+
+/* slightly different for AED 512 */
+#define AED5_XMAX 512
+#endif
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+#define AED_XLAST (AED_XMAX - 1)
+#define AED_YLAST (AED_YMAX - 1)
+
+#define AED5_XLAST (AED5_XMAX - 1)
+
+TERM_PUBLIC void
+AED_init()
+{
+    fputs("\033SEN3DDDN.SEC.7.SCT.0.1.80.80.90.SBC.0.AAV2.MOV.0.9.CHR.0.FFD", gpoutfile);
+/*         2            3     4                5     7    6       1
+	1. Clear Screen
+	2. Set Encoding
+	3. Set Default Color
+	4. Set Backround Color Table Entry
+	5. Set Backround Color
+	6. Move to Bottom Lefthand Corner
+	7. Anti-Alias Vectors
+*/
+}
+
+
+TERM_PUBLIC void
+AED_graphics()
+{
+    fputs("\033FFD\033", gpoutfile);
+}
+
+
+TERM_PUBLIC void
+AED_text()
+{
+    fputs("\033MOV.0.9.SEC.7.XXX", gpoutfile);
+}
+
+
+
+TERM_PUBLIC void
+AED_linetype(int linetype)
+{
+    static int color[2 + 9] = { 7, 1, 6, 2, 3, 5, 1, 6, 2, 3, 5 };
+    static int type[2 + 9] = { 85, 85, 255, 255, 255, 255, 255, 85, 85, 85, 85 };
+
+    if (linetype <= -3)
+	return;
+    if (linetype >= 10)
+	linetype %= 10;
+
+    fprintf(gpoutfile, "\
+\033SLS%d.255.\
+\033SEC%d.",
+	    type[linetype + 2],
+	    color[linetype + 2]);
+}
+
+
+
+TERM_PUBLIC void
+AED_move(unsigned int x, unsigned int y)
+{
+    fprintf(gpoutfile, "\033MOV%d.%d.", x, y);
+}
+
+
+TERM_PUBLIC void
+AED_vector(unsigned int x, unsigned int y)
+{
+    fprintf(gpoutfile, "\033DVA%d.%d.", x, y);
+}
+
+
+TERM_PUBLIC void
+AED_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    AED_move(x, y - AED_VCHAR / 2 + 2);
+    fprintf(gpoutfile, "\033XXX%s\033", str);
+}
+
+
+#define hxt (AED_HTIC/2)
+#define hyt (AED_VTIC/2)
+
+TERM_PUBLIC void
+AED_reset()
+{
+    fputs("\033SCT0.1.0.0.0.SBC.0.FFD", gpoutfile);
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+TERM_TABLE_START(aed512_driver)
+    "aed512", "AED 512 Terminal",
+    AED5_XMAX, AED_YMAX, AED_VCHAR, AED_HCHAR,
+    AED_VTIC, AED_HTIC, options_null, AED_init, AED_reset,
+    AED_text, null_scale, AED_graphics, AED_move, AED_vector,
+    AED_linetype, AED_put_text, null_text_angle,
+    null_justify_text, do_point, do_arrow, set_font_null
+TERM_TABLE_END(aed512_driver)
+
+#undef LAST_TERM
+#define LAST_TERM aed512_driver
+
+TERM_TABLE_START(aed767_driver)
+    "aed767", "AED 767 Terminal",
+    AED_XMAX, AED_YMAX, AED_VCHAR, AED_HCHAR,
+    AED_VTIC, AED_HTIC, options_null, AED_init, AED_reset,
+    AED_text, null_scale, AED_graphics, AED_move, AED_vector,
+    AED_linetype, AED_put_text, null_text_angle,
+    null_justify_text, do_point, do_arrow, set_font_null
+TERM_TABLE_END(aed767_driver)
+
+#undef LAST_TERM
+#define LAST_TERM aed767_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(aed767)
+"1 aed767",
+"?commands set terminal aed767",
+"?set terminal aed767",
+"?set term aed767",
+"?terminal aed767",
+"?term aed767",
+"?aed767",
+"?commands set terminal aed512",
+"?set terminal aed512",
+"?set term aed512",
+"?terminal aed512",
+"?term aed512",
+"?aed512",
+" The `aed512` and `aed767` terminal drivers support AED graphics terminals.",
+" The two drivers differ only in their horizontal ranges, which are 512 and",
+" 768 pixels, respectively.  Their vertical range is 575 pixels.  There are",
+" no options for these drivers."
+END_HELP(aed767)
+#endif
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/ai.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/ai.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/ai.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/ai.trm.svn-base	2012-01-03 17:07:24.237833900 -0800
@@ -0,0 +1,563 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: ai.trm,v 1.21 2006/07/29 22:35:43 tlecomte Exp $
+ *
+ */
+
+/* GNUPLOT - ai.trm */
+
+/*[
+ * Copyright 1991, 1992, 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *     aifm
+ *
+ * AUTHORS
+ *  Ray Ghanbari
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ * The 'aifm' driver produces files editable by Adobe Illustrator 3.0
+ * To change font to Courier and font size to 20pts use
+ * 'set term aifm "Courier" 20'.
+ * To switch to color output use
+ * 'set term aifm color'.
+ */
+
+ /* AIFM driver by Ray Ghanbari, ray@mtl.mit.edu,
+  *   based on PostScript driver by Russell Lang, rjl@monu1.cc.monash.edu.au */
+
+/* Changed to 3.6 terminal format, David C. Schooley, 9/29/95 */
+/* Improved multiple plot support, David C. Schooley, 6/5/95 */
+/* Compatiblity with Illustrator 7.0, David C. Schooley, 6/5/95 */
+/* Font and size support for labels, David C. Schooley, 6/5/95 */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(aifm)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void AI_init __PROTO((void));
+TERM_PUBLIC void AI_graphics __PROTO((void));
+TERM_PUBLIC void AI_text __PROTO((void));
+TERM_PUBLIC void AI_linetype __PROTO((int linetype));
+TERM_PUBLIC void AI_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void AI_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void AI_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC int AI_text_angle __PROTO((int ang));
+TERM_PUBLIC void AI_reset __PROTO((void));
+TERM_PUBLIC void AI_options __PROTO((void));
+TERM_PUBLIC int AI_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC void AI_suspend __PROTO((void));
+TERM_PUBLIC void AI_resume __PROTO((void));
+TERM_PUBLIC int AI_set_font __PROTO((const char *font));
+
+#define AI_XOFF	50		/* page offset in pts */
+#define AI_YOFF	50
+
+#define AI_XMAX 5000
+#define AI_YMAX 3500
+
+#define AI_XLAST (AI_XMAX - 1)
+#define AI_YLAST (AI_YMAX - 1)
+
+#define AI_VTIC (AI_YMAX/80)
+#define AI_HTIC (AI_YMAX/80)
+
+#define AI_SC (10.0)		/* scale is 1pt = 10 units */
+#define AI_LW (0.5*AI_SC)	/* linewidth = 0.5 pts */
+
+#define AI_VCHAR (14*AI_SC)	/* default is 14 point characters */
+#define AI_HCHAR (14*AI_SC*6/10)
+
+#endif /* TERM_PROTO */
+
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+enum AI_id { AI_DEFAULT, AI_MONOCHROME, AI_COLOUR, AI_OTHER };
+
+static struct gen_table AI_opts[] =
+{
+    { "d$efault", AI_DEFAULT },
+    { "m$onochrome", AI_MONOCHROME },
+    { "c$olor", AI_COLOUR },
+    { "c$olour", AI_COLOUR },
+    { NULL, AI_OTHER }
+};
+
+#define DEFAULT_FONT "Times-Roman"
+
+/* name of font */
+static char ai_font[MAX_ID_LEN + 1] = DEFAULT_FONT;
+
+/* size of font in pts */
+static int ai_fontsize = 14;
+
+/* name of font */
+static char ai_oldfont[MAX_ID_LEN + 1] = DEFAULT_FONT;
+
+/* size of font in pts */
+static int ai_oldfontsize = 14;
+
+static TBOOLEAN ai_color = FALSE;
+static TBOOLEAN ai_stroke = FALSE;
+static int ai_page = 0;		/* page count */
+static int ai_path_count = 0;		/* count of lines in path */
+static int ai_ang = 0;			/* text angle */
+static int ai_subgroup_level = 0;	/* depth of sub-groups */
+static int ai_multiplot_group = 0;	/* group for multiplot */
+static enum JUSTIFY ai_justify = LEFT;	/* text is flush left */
+
+
+TERM_PUBLIC void
+AI_options()
+{
+    while (!END_OF_COMMAND) {
+        switch(lookup_table(&AI_opts[0],c_token)) {
+	case AI_DEFAULT:
+	    c_token++;
+	    ai_color = FALSE;
+	    strncpy(ai_font,DEFAULT_FONT,sizeof(ai_font));
+	    ai_fontsize = 14;
+	    strncpy(ai_oldfont,DEFAULT_FONT,sizeof(ai_oldfont));
+	    ai_oldfontsize = 14;
+	    break;
+	case AI_MONOCHROME:
+	    c_token++;
+	    ai_color = FALSE;
+	    break;
+	case AI_COLOUR:
+	    c_token++;
+	    ai_color = TRUE;
+	    break;
+	case AI_OTHER:
+	default:
+	    if (isstring(c_token)) {
+		quote_str(ai_font, c_token, MAX_ID_LEN);
+		strcpy(ai_oldfont, ai_font);
+		c_token++;
+	    } else { /* is a number */
+		/* We have font size specified */
+		struct value a;
+		ai_fontsize = (int) real(const_express(&a));
+		ai_oldfontsize = ai_fontsize;
+		term->v_char = (unsigned int) (ai_fontsize * AI_SC);
+		term->h_char = (unsigned int) (ai_fontsize * AI_SC * 6 / 10);
+ 	    }
+	    break;
+        }
+    }
+
+    sprintf(term_options, "%s \"%s\" %d",
+	    ai_color ? "color" : "monochrome", ai_font, ai_fontsize);
+}
+
+
+TERM_PUBLIC
+void AI_init()
+{
+    ai_page = 0;
+
+    fprintf(gpoutfile, "%%!PS-Adobe-2.0 EPSF-1.2\n\
+%%%%Creator: Adobe Illustrator(TM) 3.2\n\
+%%%%TrueCreator: gnuplot %s patchlevel %s ai terminal\n\
+%%%%BoundingBox: %d %d %d %d\n\
+%%%%Template:\n\
+%%%%EndComments\n\
+%%%%EndProlog\n",
+	    gnuplot_version, gnuplot_patchlevel,
+	    AI_XOFF, AI_YOFF,
+	    (int) ((AI_XMAX) / AI_SC + 0.5 + AI_XOFF),
+	    (int) ((AI_YMAX) / AI_SC + 0.5 + AI_YOFF));
+}
+
+
+TERM_PUBLIC void
+AI_graphics()
+{
+    ai_page++;
+/*	fprintf(gpoutfile,"%%%%Page: %d %d\n",ai_page,ai_page);*/
+    fputs("\
+0 G\n\
+1 j\n\
+1 J\n\
+u\n", gpoutfile);
+    ai_path_count = 0;
+    ai_stroke = FALSE;
+}
+
+
+TERM_PUBLIC void
+AI_text()
+{
+    if (ai_stroke) {
+	fputs("S\n", gpoutfile);
+	ai_stroke = FALSE;
+    }
+    while (ai_subgroup_level) {
+	fputs("U\n", gpoutfile);
+	ai_subgroup_level--;
+    }
+    fputs("U\n", gpoutfile);
+    ai_path_count = 0;
+    ai_multiplot_group = 0;
+}
+
+
+TERM_PUBLIC void
+AI_reset()
+{
+    fputs("%%Trailer\n", gpoutfile);
+/*	fprintf(gpoutfile,"%%%%Pages: %d\n",ai_page);*/
+}
+
+
+TERM_PUBLIC void
+AI_linetype(int linetype)
+{
+    if (ai_stroke) {
+	fputs("S\n", gpoutfile);
+	ai_stroke = FALSE;
+    }
+    if (ai_subgroup_level) {
+	fputs("U\n", gpoutfile);
+	ai_subgroup_level--;
+    }
+    if (linetype == LT_BLACK && multiplot) {
+	/* for each new plot, line_type gets called twice with a value of LT_BLACK.
+	   It gets called once for the border and again for the tics.
+	   This code will need to be changed if gnuplot's behavior changes.
+	 */
+	switch (ai_multiplot_group) {
+	case 0:
+	    fputs("u\n", gpoutfile);
+	    ai_subgroup_level++;
+	    ai_multiplot_group = 1;
+	    break;
+	case 1:
+	    ai_multiplot_group = 2;
+	    break;
+	case 2:
+	    ai_multiplot_group = 1;
+	    fputs("U\nu\n", gpoutfile);
+	    break;
+	}
+    }
+    if (linetype == LT_BLACK && !multiplot) {
+	if (ai_multiplot_group) {
+	    fputs("U\n", gpoutfile);
+	    ai_subgroup_level--;
+	    ai_multiplot_group = 0;
+	}
+    }
+    fputs("u\n", gpoutfile);
+    ai_subgroup_level++;
+
+    switch (linetype) {
+    case LT_BLACK:
+	fprintf(gpoutfile, "%.2f w\n", AI_LW / AI_SC * 2.0);
+	if (ai_color) {
+	    fputs("0 0 0 1 K\n", gpoutfile);
+	} else {
+	    fputs("[] 0 d\n", gpoutfile);
+	}
+	break;
+
+    case LT_AXIS:
+	fprintf(gpoutfile, "%.2f w\n", AI_LW / AI_SC / 2.0);
+	if (ai_color) {
+	    fputs("0 0 0 1 K\n", gpoutfile);
+	} else {
+	    fputs("[1 2] 0 d\n", gpoutfile);
+	}
+	break;
+
+    case 0:
+	fprintf(gpoutfile, "%.2f w\n", AI_LW / AI_SC);
+	if (ai_color) {
+	    fputs("1 0 1 0 K\n", gpoutfile);
+	} else {
+	    fputs("[] 0 d\n", gpoutfile);
+	}
+	break;
+
+    case 1:
+	fprintf(gpoutfile, "%.2f w\n", AI_LW / AI_SC);
+	if (ai_color) {
+	    fputs("1 1 0 0 K\n", gpoutfile);
+	} else {
+	    fputs("[4 2] 0 d\n", gpoutfile);
+	}
+	break;
+
+    case 2:
+	fprintf(gpoutfile, "%.2f w\n", AI_LW / AI_SC);
+	if (ai_color) {
+	    fputs("0 1 1 0 K\n", gpoutfile);
+	} else {
+	    fputs("[2 3] 0 d\n", gpoutfile);
+	}
+	break;
+
+    case 3:
+	fprintf(gpoutfile, "%.2f w\n", AI_LW / AI_SC);
+	if (ai_color) {
+	    fputs("0 1 0 0 K\n", gpoutfile);
+	} else {
+	    fputs("[1 1.5] 0 d\n", gpoutfile);
+	}
+	break;
+
+    case 4:
+	fprintf(gpoutfile, "%f w\n", AI_LW / AI_SC);
+	if (ai_color) {
+	    fputs("1 0 0 0 K\n", gpoutfile);
+	} else {
+	    fputs("[5 2 1 2] 0 d\n", gpoutfile);
+	}
+	break;
+
+    case 5:
+	fprintf(gpoutfile, "%.2f w\n", AI_LW / AI_SC);
+	if (ai_color) {
+	    fputs("0 0 1 0 K\n", gpoutfile);
+	} else {
+	    fputs("[4 3 1 3] 0 d\n", gpoutfile);
+	}
+	break;
+
+    case 6:
+	fprintf(gpoutfile, "%.2f w\n", AI_LW / AI_SC);
+	if (ai_color) {
+	    fputs("0 0 0 1 K\n", gpoutfile);
+	} else {
+	    fputs("[2 2 2 4] 0 d\n", gpoutfile);
+	}
+	break;
+
+    case 7:
+	fprintf(gpoutfile, "%.2f w\n", AI_LW / AI_SC);
+	if (ai_color) {
+	    fputs("0 0.7 1 0 K\n", gpoutfile);
+	} else {
+	    fputs("[2 2 2 2 2 4] 0 d\n", gpoutfile);
+	}
+	break;
+
+    case 8:
+	fprintf(gpoutfile, "%.2f w\n", AI_LW / AI_SC);
+	if (ai_color) {
+	    fputs("0.5 0.5 0.5 0 K\n", gpoutfile);
+	} else {
+	    fputs("[2 2 2 2 2 2 2 4] 0 d\n", gpoutfile);
+	}
+	break;
+    }
+
+    ai_path_count = 0;
+}
+
+
+TERM_PUBLIC void
+AI_move(unsigned int x, unsigned int y)
+{
+    if (ai_stroke)
+	fputs("S\n", gpoutfile);
+    fprintf(gpoutfile, "%.2f %.2f m\n", x / AI_SC, y / AI_SC);
+    ai_path_count += 1;
+    ai_stroke = TRUE;
+}
+
+
+TERM_PUBLIC void
+AI_vector(unsigned int x, unsigned int y)
+{
+    fprintf(gpoutfile, "%.2f %.2f l\n", x / AI_SC, y / AI_SC);
+    ai_path_count += 1;
+    ai_stroke = TRUE;
+    if (ai_path_count >= 400) {
+	fprintf(gpoutfile, "S\n%.2f %.2f m\n", x / AI_SC, y / AI_SC);
+	ai_path_count = 0;
+    }
+}
+
+
+TERM_PUBLIC void
+AI_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    char ch;
+    if (ai_stroke) {
+	fputs("S\n", gpoutfile);
+	ai_stroke = FALSE;
+    }
+    switch (ai_justify) {
+    case LEFT:
+	fprintf(gpoutfile, "/_%s %d 0 0 0 z\n", ai_font, ai_fontsize);
+	break;
+    case CENTRE:
+	fprintf(gpoutfile, "/_%s %d 0 0 1 z\n", ai_font, ai_fontsize);
+	break;
+    case RIGHT:
+	fprintf(gpoutfile, "/_%s %d 0 0 2 z\n", ai_font, ai_fontsize);
+	break;
+    }
+    if (ai_ang == 0) {
+	fprintf(gpoutfile, "[ 1 0 0 1 %.2f %.2f] e\n",
+		x / AI_SC, y / AI_SC - ai_fontsize / 3.0);
+    } else {
+	fprintf(gpoutfile, "[ 0 1 -1 0 %.2f %.2f] e\n",
+		x / AI_SC - ai_fontsize / 3.0, y / AI_SC);
+    }
+
+    putc('(', gpoutfile);
+    ch = *str++;
+    while (ch != '\0') {
+	if ((ch == '(') || (ch == ')') || (ch == '\\'))
+	    putc('\\', gpoutfile);
+	putc(ch, gpoutfile);
+	ch = *str++;
+    }
+    fputs(") t\nT\n", gpoutfile);
+    ai_path_count = 0;
+}
+
+TERM_PUBLIC int
+AI_text_angle(int ang)
+{
+    ai_ang = ang;
+    return TRUE;
+}
+
+TERM_PUBLIC int
+AI_justify_text(enum JUSTIFY mode)
+{
+    ai_justify = mode;
+    return TRUE;
+}
+
+TERM_PUBLIC int
+AI_set_font(const char *font)
+{
+    char name[32];
+    size_t sep;
+    int size;
+
+    if (font && *font) {
+	sep = strcspn(font, ",");
+	assert(sep < sizeof(name));
+	strncpy(name, font, sep);
+	name[sep] = '\0';
+	size = ai_fontsize;
+	sscanf(&(font[sep + 1]), "%d", &size);
+	if (*name)
+	    strcpy(ai_font, name);
+	if (size)
+	    ai_fontsize = size;
+    } else {
+	ai_fontsize = ai_oldfontsize;
+	strcpy(ai_font, ai_oldfont);
+    }
+    return TRUE;
+}
+
+
+TERM_PUBLIC void
+AI_suspend()
+{
+}
+
+TERM_PUBLIC void
+AI_resume()
+{
+}
+
+
+#endif
+
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(aifm_driver)
+    "aifm", "Adobe Illustrator 3.0 Format",
+    AI_XMAX, AI_YMAX, AI_VCHAR, AI_HCHAR,
+    AI_VTIC, AI_HTIC, AI_options, AI_init, AI_reset,
+    AI_text, null_scale, AI_graphics, AI_move, AI_vector,
+    AI_linetype, AI_put_text, AI_text_angle,
+    AI_justify_text, do_point, do_arrow, AI_set_font,
+    NULL, 0, AI_suspend, AI_resume
+TERM_TABLE_END(aifm_driver)
+
+#undef LAST_TERM
+#define LAST_TERM aifm_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(aifm)
+"1 aifm",
+"?commands set terminal aifm",
+"?set terminal aifm",
+"?set term aifm",
+"?terminal aifm",
+"?term aifm",
+"?aifm",
+"",
+" NOTE: this terminal driver is outdated. Since Adobe Illustrator understands",
+" PostScript level 1 directly, you should use `set terminal post level1`",
+" instead.",
+"",
+" Several options may be set in `aifm`---the Adobe Illustrator 3.0+ driver.",
+"",
+" Syntax:",
+"       set terminal aifm {<color>} {\"<fontname>\"} {<fontsize>}",
+"",
+" <color> is either `color` or `monochrome`; \"<fontname>\" is the name of a",
+" valid PostScript font; <fontsize> is the size of the font in PostScript",
+" points, before scaling by the `set size` command.  Selecting `default` sets",
+" all options to their default values: `monochrome`, \"Times-Roman\", and 14pt.",
+"",
+" Since AI does not really support multiple pages, multiple graphs will be",
+" drawn directly on top of one another.  However, each graph will be grouped",
+" individually, making it easy to separate them inside AI (just pick them up",
+" and move them).",
+"",
+" Examples:",
+"       set term aifm",
+"       set term aifm 22",
+"       set size 0.7,1.4; set term aifm color \"Times-Roman\" 14"
+END_HELP(ai)
+#endif /* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/amiga.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/amiga.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/amiga.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/amiga.trm.svn-base	2012-01-03 17:07:24.441361700 -0800
@@ -0,0 +1,832 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: amiga.trm,v 1.20 2006/07/21 02:35:45 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - amiga.trm */
+
+/*[
+ * Copyright 1991, 1992, 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *   Amiga Custom Screen
+ *
+ * AUTHORS
+ *   Carsten Steger
+ *
+ *   Pat R. Empleo      Slightly modified for Aztec C v5.2a (beta); sort of
+ *   08/27/91           supports overscan; for large WB 2.0 virtual screens,
+ *                      we limit the plot size so we don't have to scroll
+ *                      around (not fun).
+ *
+ *   Carsten Steger     Modified to support Kickstart 2.0.
+ *   09/11/91           Opens a text overscan screen when used with WB 2.0.
+ *                      Discerns between NTSC and PAL Amigas when used with
+ *                      WB 1.3 and lower.
+ *
+ *   Pat R. Empleo      Defined some 2.0 stuff in order to get Aztec C to
+ *   09/20/91           work with Carsten's new code (see above).  When
+ *                      KS/WB 2.0 support gets implemented in Aztec C, this
+ *                      kludge will get deleted!
+ *                      (Aztec C release 5.2 beta)
+ *
+ *   Carsten Steger     Converted to new terminal layout.
+ *   10/01/95
+ *
+ *   Lars Hecking       Add code from George Coulouris <glc5@cornell.edu> to
+ *   06/20/97           implement window option, requires AmigaOS 3.0+.
+ *                      General cleanup, better readability.
+ *
+ *   Lars Hecking       Replace static arrays for AMIGA_FontName and temporary
+ *   06/21/97           arrays with AllocMem()'d memory.
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(amiga)
+#endif
+
+#ifdef TERM_PROTO
+
+#define AMIGA_XMAX 640
+#define AMIGA_YMAX 512
+
+#define AMIGA_VCHAR 12
+#define AMIGA_HCHAR 8
+#define AMIGA_VTIC  5
+#define AMIGA_HTIC  5
+
+TERM_PUBLIC void AMIGA_reset __PROTO((void));
+TERM_PUBLIC void AMIGA_init __PROTO((void));
+TERM_PUBLIC void AMIGA_options __PROTO((void));
+TERM_PUBLIC void AMIGA_text __PROTO((void));
+TERM_PUBLIC void AMIGA_graphics __PROTO((void));
+TERM_PUBLIC void AMIGA_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void AMIGA_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void AMIGA_linetype __PROTO((int linetype));
+TERM_PUBLIC void AMIGA_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC int AMIGA_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC int AMIGA_set_font __PROTO((const char *font));
+TERM_PUBLIC void AMIGA_suspend __PROTO((void));
+TERM_PUBLIC void AMIGA_resume __PROTO((void));
+
+#define GOT_AMIGA_PROTO
+
+#endif /* TERM_PROTO */
+
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+#ifdef AMIGA_AC_5
+#include <intuition/intuitionbase.h>
+#include <intuition/screens.h>
+#include <graphics/text.h>
+#include <graphics/gfxbase.h>
+#else
+/* You will have to use the Kickstart 2.0 header files for this to compile */
+#include <exec/types.h>
+#include <dos/dos.h>
+#include <intuition/intuitionbase.h>
+#include <graphics/gfxbase.h>
+#include <proto/intuition.h>
+#include <proto/graphics.h>
+#include <proto/exec.h>
+#include <proto/diskfont.h>
+#endif /* !AMIGA_AC_5 */
+
+#ifdef HAVE_ATEXIT
+void AMIGA_exit(void);
+# define ATEXIT(x) (atexit(x) != 0)
+# ifdef AMIGA_SC_6_1
+/* #  define ATEXIT(x) (onexit(x) == 0) */
+#  define RAWCON(x) rawcon(x)
+# else
+#  define RAWCON(x)		/* nought */
+# endif				/* SAS */
+#else
+# define ATEXIT(x) 0
+#endif /* HAVE_ATEXIT */
+
+#ifndef RETURN_FAIL
+# define RETURN_FAIL 20
+#endif
+
+#define LIB_VERSION(LibBase)    ((LibBase)->LibNode.lib_Version)
+
+#define AMIGA_ERROR(string,rc)  {fprintf (stderr,"%s\n",string);\
+				 AMIGA_reset (); exit (rc);}
+
+/* from plot.c */
+extern TBOOLEAN interactive;
+
+/* The origin is in the upper left hand corner, so we have to translate */
+/* and flip the coordinates: */
+#define AMIGA_VTF(y) (AMIGA_ymax-1-(y))
+
+
+/* Libraries */
+struct IntuitionBase *IntuitionBase;
+struct GfxBase *GfxBase;
+struct Library *DiskfontBase;
+
+
+/* Name of font, size in pts */
+static char *AMIGA_FontName = NULL;
+static int AMIGA_FontNameLen = 0;
+static int AMIGA_FontSize = 8;
+static char AMIGA_default_font[MAX_ID_LEN+1] = {'\0'};
+#define AMIGA_DEFAULTFONT "topaz"
+
+/* Font stuff */
+static struct TextAttr AMIGA_Font =
+{
+    "topaz.font", TOPAZ_EIGHTY, FS_NORMAL, FPF_ROMFONT
+};
+static struct TextFont *AMIGA_TextFont;
+
+
+/* Screen stuff */
+static struct NewScreen AMIGA_NewScreen =
+{
+    0, 0, AMIGA_XMAX, AMIGA_YMAX, 4, 15, 0, HIRES | LACE,
+    CUSTOMSCREEN | SCREENBEHIND | SCREENQUIET, NULL, NULL, NULL, NULL
+};
+static struct Screen *AMIGA_Screen;
+static struct TagItem AMIGA_ScrTagList[] =
+{
+    { SA_Overscan, OSCAN_TEXT },
+    { TAG_DONE, 0 }
+};
+
+
+/* Window stuff */
+/* FALSE: plot to screen; TRUE: plot to window */
+static TBOOLEAN AMIGA_window_mode = FALSE;
+
+#define AMIGA_WIN_XMAX 512
+#define AMIGA_WIN_YMAX 320
+
+static struct Window *AMIGA_Window;
+static struct TagItem AMIGA_WinTagList[] =
+{
+    { WA_InnerWidth, AMIGA_WIN_XMAX },
+    { WA_InnerHeight, AMIGA_WIN_YMAX },
+    { WA_Title, (ULONG) "gnuplot" },
+    { WA_DragBar, TRUE },
+    { WA_DepthGadget, TRUE },
+    { WA_WBenchWindow, TRUE },
+    { WA_SmartRefresh, TRUE },
+    { WA_GimmeZeroZero, TRUE },
+    { WA_AutoAdjust, TRUE },
+    { TAG_DONE, 0 }
+};
+
+/*
+ * This  is the palette.  Values are stored as 0xrrggbb, where rr, gg, and, bb
+ * are big-endian 8-bit intensities for red, green, and blue, respectively.
+ */
+static unsigned int palette[] =
+{
+    0xffffff,			/* white */
+    0x000000,			/* black */
+    0xff0000,			/* red */
+    0x00ff00,			/* green */
+    0x0000ff,			/* blue */
+    0x00ffff,			/* cyan */
+    0xff00ff,			/* magenta */
+    0xffff00,			/* yellow */
+    0x7f007f,			/* purple */
+    0xff7f00,			/* orange */
+};
+
+#define PALETTE_SIZE (sizeof (palette) / sizeof (unsigned int))
+
+/* This is the color look-up table, indexed in the same order as
+ * the above palette. The values stored in this table are pen numbers;
+ * e.g clut[2] is the pen which represents the color "red".
+ */
+static unsigned int clut[PALETTE_SIZE];
+
+
+/* Colors */
+static UWORD AMIGA_Colors[] =
+{
+    0x000, 0xfff, 0xbbb, 0x0f0, 0xf00, 0x00f, 0x3ca, 0xf0f,
+    0x94d, 0x0ff, 0x82f, 0xff0, 0x0af, 0xc5e, 0xfa2, 0xf44
+};
+
+
+/* Misc */
+static int AMIGA_slinetype;
+static enum JUSTIFY AMIGA_justify = LEFT;
+static unsigned int AMIGA_ymax, AMIGA_xmax;
+static WORD AMIGA_cwd, AMIGA_cht, AMIGA_bsl, AMIGA_vadj;
+/* Common RastPort */
+static struct RastPort *AMIGA_RastPort;
+
+
+enum AMIGA_id { AMI_SCREEN, AMI_WINDOW, AMI_OTHER };
+
+static struct gen_table AMIGA_opts[] =
+{
+    {"scr$een", AMI_SCREEN },
+    {"win$dow", AMI_WINDOW },
+    { NULL, AMI_OTHER }
+};
+
+
+/*
+ * Scan terminal options
+ */
+TERM_PUBLIC void
+AMIGA_options()
+{
+
+    while (!END_OF_COMMAND) {
+	switch(lookup_table(&AMIGA_opts[0],c_token)) {
+	case AMI_SCREEN:
+	    AMIGA_window_mode = FALSE;
+	    c_token++;
+	    break;
+	case AMI_WINDOW:
+	    AMIGA_window_mode = TRUE;
+	    c_token++;
+	    break;
+	case AMI_OTHER:
+	default:
+	    /* Font name */
+	    if (isstring(c_token)) {
+		if (AMIGA_FontName != NULL) {
+		    FreeMem(AMIGA_FontName,AMIGA_FontNameLen);
+		    AMIGA_FontName = NULL;
+		    AMIGA_FontNameLen = 0;
+		}
+
+		AMIGA_FontNameLen = token_len(c_token);
+
+		AMIGA_FontName = AllocMem(AMIGA_FontNameLen,0);
+		if (AMIGA_FontName == NULL)
+		    AMIGA_ERROR("No memory for font name", RETURN_FAIL);
+		quote_str(AMIGA_FontName, c_token, AMIGA_FontNameLen);
+		c_token++;
+	    } else {
+		/* Font size */
+		struct value a;
+		AMIGA_FontSize = (int) real(const_express(&a));
+	    }
+
+	    break;
+	}
+    }
+
+    if (AMIGA_FontName == NULL && AMIGA_FontSize != 0) {
+	AMIGA_FontNameLen = strlen(AMIGA_DEFAULTFONT) + 1;
+	AMIGA_FontName = AllocMem(AMIGA_FontNameLen,0);
+	if (AMIGA_FontName == NULL)
+	    AMIGA_ERROR("No memory for font name", RETURN_FAIL);
+	strcpy(AMIGA_FontName, AMIGA_DEFAULTFONT);
+    }
+    if (AMIGA_FontName != NULL && AMIGA_FontSize == 0)
+	AMIGA_FontSize = 8;
+
+    if (AMIGA_FontName != NULL && AMIGA_FontSize != 0) {
+	sprintf(AMIGA_default_font, "%s,%d", AMIGA_FontName, AMIGA_FontSize);
+	sprintf(term_options, "%s \"%s\" %d", \
+		(AMIGA_window_mode != TRUE ? "screen" : "window"), \
+		AMIGA_FontName, AMIGA_FontSize);
+    } else
+	sprintf(term_options, "%s", (AMIGA_window_mode != TRUE ? "screen" : "window"));
+}
+
+
+/*
+ * Close open font, screen and libraries.
+ */
+TERM_PUBLIC void
+AMIGA_reset()
+{
+    if (AMIGA_window_mode == TRUE) {
+	int i = 0;
+
+	/* Free the pens */
+	while (i < PALETTE_SIZE) {
+	    if (clut[i] != -1)
+		ReleasePen(AMIGA_Window->WScreen->ViewPort.ColorMap, clut[i]);
+
+	    i++;
+	}
+
+	/* Close the window */
+	if (AMIGA_Window != NULL)
+	    CloseWindow(AMIGA_Window);
+
+	AMIGA_Window = NULL;
+	AMIGA_window_mode = FALSE;
+    }
+    if (AMIGA_TextFont != NULL)
+	CloseFont(AMIGA_TextFont);
+
+    if (DiskfontBase != NULL)
+	CloseLibrary(DiskfontBase);
+
+    if (AMIGA_Screen != NULL)
+	CloseScreen(AMIGA_Screen);
+
+    if (IntuitionBase != NULL)
+	CloseLibrary((struct Library *) IntuitionBase);
+
+    if (GfxBase != NULL)
+	CloseLibrary((struct Library *) GfxBase);
+
+    if (AMIGA_FontName != NULL)
+	FreeMem(AMIGA_FontName,AMIGA_FontNameLen);
+
+    AMIGA_FontName = NULL;
+    AMIGA_FontNameLen = 0;
+    AMIGA_TextFont = NULL;
+    DiskfontBase = NULL;
+    AMIGA_Screen = NULL;
+    IntuitionBase = NULL;
+    GfxBase = NULL;
+
+    AMIGA_RastPort = NULL;
+}
+
+
+/*
+ * Init terminal.
+ */
+TERM_PUBLIC void
+AMIGA_init()
+{
+
+    /* Install exit trap in case of abnormal termination (see below). */
+    if (ATEXIT(AMIGA_exit))
+	AMIGA_ERROR("Couldn't set exit trap", RETURN_FAIL);
+
+    /* Open needed libraries */
+    GfxBase = (struct GfxBase *) OpenLibrary("graphics.library", 0);
+    if (GfxBase == NULL)
+	AMIGA_ERROR("No Graphics-Library", RETURN_FAIL);
+
+    IntuitionBase = (struct IntuitionBase *) OpenLibrary("intuition.library", 0);
+    if (IntuitionBase == NULL)
+	AMIGA_ERROR("No Intuition-Library", RETURN_FAIL);
+
+    if (AMIGA_window_mode == TRUE) {
+	int i = 0;
+
+	/* Initialize the clut */
+	while (i < PALETTE_SIZE)
+	    clut[i++] = -1;
+    }
+    if (LIB_VERSION(IntuitionBase) <= 34) {
+	/* We compute the vertical resolution for those poor NTSC-souls   :-)   */
+	if (GfxBase->DisplayFlags & PAL)
+	    AMIGA_ymax = 512;
+	else
+	    AMIGA_ymax = 400;
+
+	AMIGA_xmax = 640;
+	AMIGA_NewScreen.Width = AMIGA_xmax;
+	AMIGA_NewScreen.Height = AMIGA_ymax;
+
+	AMIGA_Screen = OpenScreen(&AMIGA_NewScreen);
+
+	if (AMIGA_Screen == NULL)
+	    AMIGA_ERROR("No Screen", RETURN_FAIL);
+
+	AMIGA_RastPort = &AMIGA_Screen->RastPort;
+
+    } else {			/* Intuition version > 34 */
+	/* Kickstart 2.0 support */
+	AMIGA_NewScreen.Width = STDSCREENWIDTH;
+	AMIGA_NewScreen.Height = STDSCREENHEIGHT;
+
+	if (AMIGA_window_mode != TRUE) {
+
+	    AMIGA_Screen = OpenScreenTagList(&AMIGA_NewScreen, AMIGA_ScrTagList);
+
+	    if (AMIGA_Screen == NULL)
+		AMIGA_ERROR("No Screen", RETURN_FAIL);
+
+	    AMIGA_RastPort = &AMIGA_Screen->RastPort;
+
+	    AMIGA_xmax = AMIGA_Screen->Width;
+	    AMIGA_ymax = AMIGA_Screen->Height;
+	} else if (LIB_VERSION(GfxBase) >= 39) { /* AMIGA_window_mode == TRUE */
+	    /* Open the plot window */
+
+	    AMIGA_Window = (struct Window *)OpenWindowTagList(NULL, AMIGA_WinTagList);
+
+	    /* Don't do this: fall back to screen */
+	    if (AMIGA_Window == NULL)
+		AMIGA_ERROR("Could not open plot window", RETURN_FAIL);
+
+	    AMIGA_RastPort = AMIGA_Window->RPort;
+
+	    AMIGA_xmax = AMIGA_WIN_XMAX;
+	    AMIGA_ymax = AMIGA_WIN_YMAX;
+
+	}			/* Gfx version >= 39 */
+    }				/* Intuition version <= 34 */
+
+    term->xmax = AMIGA_xmax;
+    term->ymax = AMIGA_ymax;
+
+    if (AMIGA_window_mode != TRUE) {
+	char *name =  NULL;
+/*	assert(AMIGA_FontName != NULL); */
+	/* should even do for ridiculously large FontSize :) */
+	name = AllocMem(AMIGA_FontNameLen + 1 + INT_STR_LEN + 1,0);
+	if (name == NULL)
+	    AMIGA_ERROR("No memory for font name", RETURN_FAIL);
+	sprintf(name, "%s,%d", AMIGA_FontName, AMIGA_FontSize);
+	AMIGA_set_font(name);
+	FreeMem(name,AMIGA_FontNameLen + INT_STR_LEN + 2);
+
+	LoadRGB4(&AMIGA_Screen->ViewPort, AMIGA_Colors, 16);
+	RemakeDisplay();
+	AMIGA_slinetype = 1;
+	SetAPen(&AMIGA_Screen->RastPort, AMIGA_slinetype);
+    } else {
+	int i, r, g, b;
+
+	AMIGA_bsl = AMIGA_Window->RPort->TxBaseline;	/* Reference line */
+	AMIGA_cht = AMIGA_Window->RPort->TxHeight;	/* Height of characters */
+
+	/* Allocate pens */
+	for (i = 0; i < PALETTE_SIZE; i++) {
+	    r = (palette[i] << 8) & 0xFF000000;
+	    g = (palette[i] << 16) & 0xFF000000;
+	    b = (palette[i] << 24) & 0xFF000000;
+	    clut[i] = ObtainBestPenA(AMIGA_Window->WScreen->ViewPort.ColorMap, r, g, b, NULL);
+	}
+
+    }
+
+    SetDrMd(AMIGA_RastPort, JAM1);
+
+}
+
+
+/*
+ *
+ */
+TERM_PUBLIC void
+AMIGA_text()
+{
+    if (AMIGA_window_mode != TRUE) {
+	if (interactive == TRUE) {
+	    FILE *fp;
+
+	    if ((fp = fopen("*", "r")) != NULL) {
+		int c = getc(fp);
+
+		ungetc(c, stdin);
+		fclose(fp);
+	    }
+	    ScreenToBack(AMIGA_Screen);
+	}
+    }
+}
+
+
+/*
+ *
+ */
+TERM_PUBLIC void
+AMIGA_graphics()
+{
+
+    SetRast(AMIGA_RastPort, 0);
+
+    if (AMIGA_window_mode == TRUE) {
+	/* clear the window */
+	SetAPen(AMIGA_Window->RPort, clut[0]);
+	RectFill(AMIGA_Window->RPort, 0, 0, 640, 400);
+	AMIGA_slinetype = clut[1];
+    }
+    SetAPen(AMIGA_RastPort, AMIGA_slinetype);
+    AMIGA_resume();
+}
+
+
+/*
+ *
+ */
+TERM_PUBLIC void
+AMIGA_move(unsigned int x, unsigned int y)
+{
+    if ((x >= AMIGA_xmax) || (y >= AMIGA_ymax))
+	return;
+
+    Move(AMIGA_RastPort, x, AMIGA_VTF(y));
+}
+
+
+/*
+ *
+ */
+TERM_PUBLIC void
+AMIGA_vector(unsigned int x, unsigned int y)
+{
+    if ((x >= AMIGA_xmax) || (y >= AMIGA_ymax))
+	return;
+
+    Draw(AMIGA_RastPort, x, AMIGA_VTF(y));
+}
+
+
+/*
+ *
+ */
+TERM_PUBLIC void
+AMIGA_linetype(int linetype)
+{
+    if (AMIGA_window_mode != TRUE) {
+	if (linetype >= 13)
+	    linetype %= 13;
+
+	if (linetype < -3)
+	    linetype = LT_BLACK;
+
+	AMIGA_slinetype = linetype + 3;
+    } else {
+	if (linetype >= 0)
+	    linetype = (linetype % 9) + 1;
+
+	if (linetype < 0)
+	    linetype = 1;
+
+	AMIGA_slinetype = clut[linetype];
+    }
+    SetAPen(AMIGA_RastPort, AMIGA_slinetype);
+}
+
+
+/*
+ *
+ */
+TERM_PUBLIC void
+AMIGA_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    LONG len, tx_len;
+    WORD x_min, x_max, y_min, y_max;
+
+    len = strlen(str);
+
+    tx_len = TextLength(AMIGA_RastPort, str, len);
+
+    switch (AMIGA_justify) {
+    case LEFT:
+	x_min = x;
+	x_max = x + tx_len;
+	break;
+    case CENTRE:
+	x_min = x - tx_len / 2;
+	x_max = x + tx_len - tx_len / 2;	/* avoid roundoff errors ! */
+	break;
+    default:			/* does this make sense ?? */
+    case RIGHT:
+	x_min = x - tx_len;
+	x_max = x;
+	break;
+    }
+
+    y_min = AMIGA_VTF(y) - AMIGA_vadj;
+    y_max = y_min + AMIGA_cht;
+
+    /* Check if character-string lies completely within the screen: */
+    /* What about clipping? */
+    if ((x_max >= AMIGA_xmax) || (y_min < 0) || (y_max >= AMIGA_ymax))
+	return;
+
+    Move(AMIGA_RastPort, x_min, y_min + AMIGA_bsl);
+    Text(AMIGA_RastPort, str, len);
+}
+
+
+/*
+ *
+ */
+TERM_PUBLIC int
+AMIGA_justify_text(enum JUSTIFY mode)
+{
+    AMIGA_justify = mode;
+    return TRUE;
+}
+
+
+/*
+ *
+ */
+TERM_PUBLIC int
+AMIGA_set_font(const char *font)
+{
+    static char test_str[] =
+    " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
+    static WORD test_len, test_pxl;
+
+    /* Disable for window mode */
+    if (AMIGA_window_mode != TRUE) {
+	char *name = NULL;
+	int size, sep, namelen;
+
+	/* Allow caller to pass "" to indicate default font */
+	if (!font || !(*font))
+	    font = AMIGA_default_font;
+
+	sep = strcspn(font, ",");
+	namelen = strlen(font) + strlen(".font") + 1;
+	name = AllocMem(namelen,0);
+	if (name == NULL)
+	    AMIGA_ERROR("No memory for font name", RETURN_FAIL);
+	strcpy(name,font);
+	name[sep] = NUL;
+	size = AMIGA_FontSize;
+	if (font[sep] == ',')
+	    sscanf(&(font[sep + 1]), "%d", &size);
+
+	if (name != NULL && strcmp(name, "") != 0) {
+	    strcat(name, ".font");
+
+	    /* Avoid opening "diskfont.library" if a built-in font is desired */
+	    if ((strcmp("topaz.font", name) == 0) &&
+		((size == TOPAZ_EIGHTY) || (size == TOPAZ_SIXTY))) {
+		AMIGA_Font.ta_Name = name;
+		AMIGA_Font.ta_YSize = size;
+		AMIGA_Font.ta_Style = FS_NORMAL;
+		AMIGA_Font.ta_Flags = FPF_ROMFONT;
+		AMIGA_TextFont = OpenFont(&AMIGA_Font);
+
+		if (AMIGA_TextFont != NULL)
+		    SetFont(&AMIGA_Screen->RastPort, AMIGA_TextFont);
+
+	    } else {
+		DiskfontBase = OpenLibrary("diskfont.library", 0);
+
+		if (DiskfontBase != NULL) {
+		    AMIGA_Font.ta_Name = name;
+		    AMIGA_Font.ta_YSize = size;
+		    AMIGA_Font.ta_Style = FS_NORMAL;
+		    AMIGA_Font.ta_Flags = FPF_ROMFONT | FPF_DISKFONT;
+		    AMIGA_TextFont = OpenDiskFont(&AMIGA_Font);
+
+		    if (AMIGA_TextFont != NULL)
+			SetFont(&AMIGA_Screen->RastPort, AMIGA_TextFont);
+		}
+	    }
+	}
+	/* Width of characters: This works better for proportional fonts than */
+	/* AMIGA_Screen->RastPort.TxWidth + AMIGA_Screen->RastPort.TxSpacing */
+	test_len = strlen(test_str);
+	test_pxl = TextLength(&AMIGA_Screen->RastPort, test_str, test_len);
+
+	AMIGA_cwd = test_pxl / test_len;
+	AMIGA_cht = AMIGA_Screen->RastPort.TxHeight;	/* Height of characters */
+	AMIGA_bsl = AMIGA_Screen->RastPort.TxBaseline;	/* Reference line */
+
+	/* Amount by which characters have to be shifted upwards to be */
+	/* vertically justified: */
+	AMIGA_vadj = AMIGA_bsl / 2;
+	term->v_char = AMIGA_cht + 4;	/* So lines won't be too close */
+	term->h_char = AMIGA_cwd;
+
+	FreeMem(name,namelen);
+    }				/* !window_mode */
+    return TRUE;
+}
+
+
+/*
+ *
+ */
+TERM_PUBLIC void
+AMIGA_suspend()
+{
+    if (AMIGA_window_mode != TRUE) {
+	if (interactive == TRUE) {
+	    FILE *fp;
+
+	    if ((fp = fopen("*", "r")) != NULL) {
+		int c = getc(fp);
+
+		ungetc(c, stdin);
+		fclose(fp);
+	    }
+	    ScreenToBack(AMIGA_Screen);
+	}
+    }
+}
+
+
+/*
+ *
+ */
+TERM_PUBLIC void
+AMIGA_resume()
+{
+    if (AMIGA_window_mode != TRUE)
+	ScreenToFront(AMIGA_Screen);
+    else
+	WindowToFront(AMIGA_Window);
+}
+
+
+#ifdef HAVE_ATEXIT
+/* This function is mainly included if the program terminates abnormally
+ * and the screen and libraries are still open. It closes down all opened
+ * libraries and screens. This happens e.g. when loading "bivariat.demo"
+ * and the stack is smaller than 120000 bytes.
+ */
+void
+AMIGA_exit()
+{
+    AMIGA_reset();
+    RAWCON(0);
+}
+
+#endif /* HAVE_ATEXIT */
+
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(amiga_driver)
+    "amiga", "Amiga Custom Screen/Window [screen window]",
+    AMIGA_XMAX, AMIGA_YMAX, AMIGA_VCHAR, AMIGA_HCHAR,
+    AMIGA_VTIC, AMIGA_HTIC, AMIGA_options, AMIGA_init, AMIGA_reset,
+    AMIGA_text, null_scale, AMIGA_graphics, AMIGA_move, AMIGA_vector,
+    AMIGA_linetype, AMIGA_put_text, null_text_angle,
+    AMIGA_justify_text, do_point, do_arrow, AMIGA_set_font,
+    0,				/* pointsize */
+    TERM_CAN_MULTIPLOT, AMIGA_suspend, AMIGA_resume
+TERM_TABLE_END(amiga_driver)
+
+#undef LAST_TERM
+#define LAST_TERM amiga_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+
+#ifdef TERM_HELP
+START_HELP(amiga)
+"1 amiga",
+"?commands set terminal amiga",
+"?set terminal amiga",
+"?set term amiga",
+"?terminal amiga",
+"?term amiga",
+"?amiga",
+" The `amiga` terminal, for Commodore Amiga computers, allows the user to",
+" plot either to a screen (default), or, if Kickstart 3.0 or higher is",
+" installed, to a window on the current public screen. The font and its size",
+" can also be selected.",
+"",
+" Syntax:",
+"       set terminal amiga {screen | window} {\"<fontname>\"} {<fontsize>}",
+"",
+" The default font is 8-point \"topaz\".",
+"",
+" The screen option uses a virtual screen, so it is possible that the graph",
+" will be larger than the screen."
+END_HELP(amiga)
+#endif /* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/android.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/android.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/android.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/android.trm.svn-base	2012-05-21 16:37:04.671050500 -0700
@@ -0,0 +1,207 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: android.trm,v 1.15 2006/07/21 02:35:48 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - android.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *  ANDROID devices
+ *
+ * AUTHORS
+ *  Corbin Champion
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+
+#include "driver.h"
+
+#ifdef TERM_ANDROID
+android_term(android)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void ANDROID_options __PROTO((void));
+TERM_PUBLIC void ANDROID_init __PROTO((void));
+TERM_PUBLIC void ANDROID_reset __PROTO((void));
+TERM_PUBLIC void ANDROID_text __PROTO((void));
+TERM_PUBLIC void ANDROID_graphics __PROTO((void));
+TERM_PUBLIC void ANDROID_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void ANDROID_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void ANDROID_linetype __PROTO((int linetype));
+TERM_PUBLIC void ANDROID_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC int ANDROID_text_angle __PROTO((int ang));
+
+#define ANDROIDXMAX 480
+#define ANDROIDYMAX 480
+
+#define ANDROIDXLAST (ANDROIDXMAX - 1)
+#define ANDROIDYLAST (ANDROIDYMAX - 1)
+
+#define ANDROIDVCHAR		18
+#define ANDROIDHCHAR		11
+#define ANDROIDVTIC		18
+#define ANDROIDHTIC		18
+
+/* is defined in plot.h
+#define TRUE 1
+#define FALSE 0
+*/
+#endif
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+TERM_PUBLIC void
+ANDROID_init()
+{
+   printf("ANDROIDTERM,init\n");
+}
+
+TERM_PUBLIC void
+ANDROID_graphics()
+{
+   printf("ANDROIDTERM,graphics\n");
+}
+
+TERM_PUBLIC void
+ANDROID_text()
+{
+   printf("ANDROIDTERM,text\n");
+}
+
+TERM_PUBLIC void
+ANDROID_linewidth(int linetype)
+{
+   printf("ANDROIDTERM,linetype,%d\n",linetype);
+}
+
+TERM_PUBLIC void
+ANDROID_linetype(int linetype)
+{
+   printf("ANDROIDTERM,linetype,%d\n",linetype);
+}
+
+TERM_PUBLIC void
+ANDROID_move(unsigned int x, unsigned int y)
+{
+   printf("ANDROIDTERM,move,%d,%d\n", x, y);
+}
+
+TERM_PUBLIC void
+ANDROID_vector(unsigned int x, unsigned int y)
+{
+   printf("ANDROIDTERM,vector,%d,%d\n", x, y);
+}
+
+TERM_PUBLIC void
+ANDROID_put_text(unsigned int x, unsigned int y, const char *str)
+{
+   printf("ANDROIDTERM,put_text,%d,%d,%s\n",x,y,str);
+}
+
+TERM_PUBLIC int 
+ANDROID_text_angle(int ang)
+{
+   printf("ANDROIDTERM,text_angle,%d\n",ang);
+}
+
+TERM_PUBLIC int
+ANDROID_justify_text(enum JUSTIFY mode)
+{
+    switch (mode) {
+    case LEFT:
+	printf("ANDROIDTERM,justify_text,%s\n","LEFT");
+	break;
+    case CENTRE:
+	printf("ANDROIDTERM,justify_text,%s\n","CENTRE");
+	break;
+    case RIGHT:
+	printf("ANDROIDTERM,justify_text,%s\n","RIGHT");
+	break;
+	/* shouldn't happen */
+    default:
+	printf("ANDROIDTERM,justify_text,%s\n","LEFT");
+	return (FALSE);
+	break;
+    }
+    return (TRUE);
+}
+
+TERM_PUBLIC void
+ANDROID_reset()
+{
+   printf("ANDROIDTERM,reset\n");
+}
+
+TERM_PUBLIC void
+ANDROID_options()
+{
+}
+
+#endif
+
+#ifdef TERM_TABLE
+TERM_TABLE_START(android_driver)
+    "android", "ANDROID canvas",
+    ANDROIDXMAX, ANDROIDYMAX, ANDROIDVCHAR, ANDROIDHCHAR,
+    ANDROIDVTIC, ANDROIDHTIC, ANDROID_options, ANDROID_init, ANDROID_reset,
+    ANDROID_text, null_scale, ANDROID_graphics, ANDROID_move, ANDROID_vector,
+    ANDROID_linetype, ANDROID_put_text, null_text_angle,
+    ANDROID_justify_text, line_and_point, do_arrow, set_font_null
+TERM_TABLE_END(android_driver)
+
+#undef LAST_TERM
+#define LAST_TERM android_driver
+#endif
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(android)
+"1 android",
+"?commands set terminal android",
+"?set terminal android",
+"?set term android",
+"?terminal android",
+"?term android",
+"?android",
+" The `android` terminal device generates output into an Android canvas through some JNI.",
+"",
+" Syntax:",
+"       set terminal android"
+END_HELP(android)
+#endif
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/apollo.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/apollo.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/apollo.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/apollo.trm.svn-base	2012-01-03 17:07:24.657923300 -0800
@@ -0,0 +1,610 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: apollo.trm,v 1.14 2006/07/21 02:35:45 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - apollo.trm */
+/*
+    Apollo terminal driver for gnuplot.
+
+    Open a pad for the graphics, and use GPR routines.  For additional
+    speed, we do the graphics to a separate bitmap, and the blt the
+    entire bitmap to the display.  When the user specifies an output
+    file name, however, we draw directly to the screen, so the graphics
+    are written to the file correctly.  Thus, the user can save the
+    graphics in a file, to be viewed later.  If we try the bitmap
+    trick, it looks funny.
+
+    Ray Lischner (uunet!mntgfx!lisch)
+    4 October 1989	file created for gnuplot 1.1
+    26 March 1990	updated for gnuplot 2.0
+    30 October 1991	fixed minor problem in apollo_tic_sizes
+
+    As of 13 January 1999, this file has been placed in the
+    public domain by Ray Lischner.
+
+*/
+
+/*
+ * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(apollo)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void APOLLO_init __PROTO((void));
+TERM_PUBLIC void APOLLO_graphics __PROTO((void));
+TERM_PUBLIC void APOLLO_linetype __PROTO((int ltype));
+TERM_PUBLIC void APOLLO_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void APOLLO_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void APOLLO_text __PROTO((void));
+TERM_PUBLIC int APOLLO_text_angle __PROTO((int ang));
+TERM_PUBLIC int APOLLO_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC void APOLLO_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
+TERM_PUBLIC void APOLLO_reset __PROTO((void));
+/* default tick sizes for small windows */
+#define APOLLO_VTIC	 6
+#define APOLLO_HTIC	 6
+#endif
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+#include <apollo/base.h>
+#include <apollo/error.h>
+#include <apollo/pad.h>
+#include <apollo/gpr.h>
+
+int apollo_isa_pad __PROTO((void));
+static void apollo_font_info __PROTO((struct termentry * tbl, char *fname));
+static void apollo_gpr_init __PROTO((struct termentry * tbl, pad_$window_desc_t * window));
+static void apollo_tic_sizes __PROTO((struct termentry * tbl));
+static void apollo_gpr_terminate __PROTO((void));
+static void apollo_redo_window __PROTO((pad_$window_desc_t * window));
+static void apollo_xy_error __PROTO((char *s, int x, int y, status_$t status));
+
+/* issue an error message, using additional text "s" */
+#define apollo_error(s)	error_$print_name(status, (s), strlen(s))
+
+/* if "status" indicates an error, then issue an error message */
+#define apollo_check(s)	if (status.all != status_$ok) apollo_error(s)
+
+static ios_$id_t stream = -1;	/* the stream for the pad */
+static gpr_$bitmap_desc_t screen_desc;	/* the screen's bitmap */
+static gpr_$bitmap_desc_t bitmap_desc;	/* the graphics bitmap */
+static gpr_$attribute_desc_t attr;	/* attribute block for saved bitmap */
+static int APOLLO_XMAX, APOLLO_YMAX;	/* window size */
+static short draw_width;	/* default GPR draw width */
+static name_$long_pname_t font_name;	/* font path name */
+static boolean use_bitmap;	/* use a separate bitmap? */
+
+/* return whether stdout is a DM pad */
+int
+apollo_isa_pad()
+{
+    status_$t status;
+    pad_$isa(1, &status);
+    return (status.all == status_$ok);
+}
+
+/*
+    Find out what the default font is for the pad, and save the
+    character height and width information.
+
+    Note that we must save the font file name because we need
+    to reload the font file everytime the window changes size.
+*/
+static void
+apollo_font_info(struct termentry *tbl, char *fname)
+{
+    short fwidth, fheight, flen;
+    status_$t status;
+
+    /* get the font size & update the termentry table */
+    pad_$inq_font(stream, &fwidth, &fheight, fname, name_$long_pnamlen_max,
+		  &flen, &status);
+    apollo_check("inq_font");
+    fname[flen] = NUL;
+
+    tbl->v_char = fheight;
+    tbl->h_char = fwidth;
+}
+
+/*
+    Initialize all the GPR stuff.  To save time, we draw into a separate
+    bitmap, and then blt it onto the screen all at once.  This results
+    in 5-10 times speed-up in the graphics, with only a little
+    complication.  Most of the complication is right here, making sure
+    we allocate the right bitmaps, etc., in the right order.  The rest
+    is in APOLLO_text(), where we actually BLT the bitmap onto the screen.
+    Everything else is the same.
+
+    The bitmaps have the same size as the window.  If the window changes
+    size, then the bitmaps retain the same size, so the user sees part
+    of the plot or a lot of space around the plot.  Drawing a new plot,
+    or replotting the previous one causes APOLLO_graphics() to see if
+    the window has changed size, in which case the GPR is terminated,
+    and this routine is called again.  Thus, make sure any changes
+    preserve this ability.  Anything that should only be done once
+    to the pad should be handled by APOLLO_init().
+
+    By the way, we save the current draw width, to be used later
+    for drawing extra wide lines.  This way we don't need to know
+    anything about the current output device characteristics;
+    we can just draw the default width, or twice the default width, etc.
+*/
+static void
+apollo_gpr_init(struct termentry *tbl, pad_$window_desc_t * window)
+{
+    gpr_$offset_t size;
+    short fontid;
+    status_$t status;
+
+    size.x_size = APOLLO_XMAX = tbl->xmax = window->width;
+    size.y_size = APOLLO_YMAX = tbl->ymax = window->height;
+
+    /* now initialize GPR */
+    gpr_$init(gpr_$frame, stream, size, 1, &screen_desc, &status);
+    apollo_check("gpr_$init");
+
+    if (use_bitmap) {
+	/* allocate the bitmap and its attribute block */
+	gpr_$allocate_attribute_block(&attr, &status);
+	apollo_check("allocate_attribute_block");
+
+	gpr_$allocate_bitmap(size, 1, attr, &bitmap_desc, &status);
+	apollo_check("allocate_bitmap");
+
+	gpr_$set_bitmap(bitmap_desc, &status);
+	apollo_check("set_bitmap");
+    }
+    /* set the font file */
+    gpr_$load_font_file(font_name, strlen(font_name), &fontid, &status);
+    apollo_check(font_name);
+
+    gpr_$set_text_font(fontid, &status);
+    apollo_check("set_text_font");
+
+    gpr_$inq_draw_width(&draw_width, &status);
+    apollo_check("inq_draw_width");
+}
+
+/*
+    Determine the tick sizes to be used for labelling borders.
+    By default, we use 1/50 of the window size, which looks nice to me.
+    If this makes the ticks too small, however, we use a minimum
+    size, to make sure they are visible.  The minimum size was also
+    determined experimentally.
+
+    Feel free to changes the sizes to something you feel looks better.
+
+    This routine must be called after apollo_gpr_init(), because we
+    need to know the window size, as stored in the termentry table.
+*/
+static void
+apollo_tic_sizes(struct termentry *tbl)
+{
+    /* base the tick size on the window size */
+    tbl->v_tic = tbl->ymax / 50;
+    if (tbl->v_tic < APOLLO_VTIC)
+	tbl->v_tic = APOLLO_VTIC;
+    tbl->h_tic = tbl->xmax / 50;
+    if (tbl->h_tic < APOLLO_HTIC)
+	tbl->h_tic = APOLLO_HTIC;
+}
+
+/*
+    Terminate the GPR.  This is called whenever the window size
+    changes, and we need to reinitialize the GPR.  I assume that
+    calling gpr_$terminate() also deallocates the bitmaps and
+    attribute blocks because deallocating the screen's bitmap
+    causes terminate() to think GPR has already been terminated.
+
+    Since this can be called many times, make sure nothing
+    drastic is done here, like closing the stream to the pad.
+    The only actions should be those that will be reinitialized
+    by apollo_gpr_init().
+*/
+static void
+apollo_gpr_terminate()
+{
+    status_$t status;
+
+    gpr_$terminate(false, &status);
+    apollo_check("terminate");
+}
+
+/*
+    Initialize the graphics.  This is called once, so we do things
+    here that should be done exactly once, such as opening the window.
+    I like to give windows names, so it is obvious what the window's
+    contents are, but this causes a transcript to be kept in a file
+    whose name is the window's name.  This might be nice in some
+    circumstances, but to me it is a nuisance, so the file is
+    deleted immediately.  The name is unlikely to appear normally,
+    so there should be little interference with users' normal files.
+    If the user has explicitly set the output file, however, then
+    we use that name, and do not delete the file.  Thus, the
+    user can get a metafile of the plot.  We can tell if the
+    output file has been set because outstr is NULL.  Otherwise,
+    outstr is the filename, in alloc-ed store.
+
+    The DM defaults are used for window sizes and positions.  If
+    the user doesn't like it, he or she can change is and issue
+    a replot command (assuming a plot has already been generated).
+
+    Note, also, that we must call pad_$set_scale() or else
+    pad_$inq_windows() returns scaled values, which is not what
+    we want.  Setting the scale to one (1) turns off the scaling,
+    so we get real pixel sizes.
+
+    Finally, we get the name and size of the default font.  The
+    name is kept, as explained earlier.  Then we can initialize
+    the GPR stuff.
+
+    Note that there is a way that APOLLO_init() gets called more
+    than once.  If the user issues the "set terminal apollo" command
+    more than once, then this is called, so we need to make sure
+    that we do not keep creating windows.
+
+    An alternative strategy would be to interpret multiple "set term
+    apollo"s to mean create multiple windows.  The user could only
+    access the most recent window because gnuplot has no concept of
+    multiple terminals.  The user would, in fact, have no way of
+    removing old windows because they are still active.  We could try
+    catching keyboard events to see if the user presses EXIT, but I do
+    not want to start getting into that mess.  If the user really
+    wants this kind of functionality, then he or she can run gnuplot
+    multiple times.  I think that is a lot cleaner, don't you?
+*/
+TERM_PUBLIC void
+APOLLO_init()
+{
+    /* only initialize once */
+    if (stream == -1) {
+	struct termentry *tbl;
+	pad_$window_desc_t window;
+	name_$long_name_t wname;
+	short wnum;		/* junk needed by pad_$inq_windows() */
+	boolean unlink_wname;
+	status_$t status;
+
+	tbl = term;
+
+	/* make the window name unique, with "gnuplot" in the label */
+	if (outstr == NULL) {
+	    sprintf(wname, "gnuplot-%d", getpid());
+	    unlink_wname = true;
+	} else {
+	    strcpy(wname, outstr);
+	    unlink_wname = false;
+	}
+
+	use_bitmap = unlink_wname;
+
+	/* use the default window position and size */
+	window.top = window.left = window.width = window.height = 0;
+	pad_$create_window(wname, strlen(wname), pad_$transcript, 1, window,
+			   &stream, &status);
+	apollo_check("create_window");
+
+	/* if this is not the user's name, then delete the file */
+	if (unlink_wname)
+	    unlink(wname);
+
+	/* remove all scaling, to revert to pixel units, not char. units */
+	pad_$set_scale(stream, 1, 1, &status);
+	apollo_check("set_scale");
+
+	/* get rid of the window when the program exits */
+	pad_$set_auto_close(stream, 1, true, &status);
+	apollo_check("set_auto_close");
+
+	/* now determine the window size & update the termentry table */
+	pad_$inq_windows(stream, &window, 1, &wnum, &status);
+	apollo_check("inq_windows");
+
+	/* the order of the next three calls is important */
+	apollo_font_info(tbl, font_name);
+	apollo_gpr_init(tbl, &window);
+	apollo_tic_sizes(tbl);
+    }
+}
+
+/*
+    Prepare for graphics output.  Since this is what the user wants to
+    do when preparing a new plot, this is a meaningful time to see if
+    the window has changed size.  Thus, we avoid mucking about with
+    asynchronous traps, and we avoid the bigger problem of dealing
+    with a half-finished plot when the window changes size.
+
+    Simply put, get the current window size, and if it has changed,
+    then get rid of the old bitmaps, etc., and allocate new ones at
+    the new size.  We also need to update the termentry table.
+    If the window stays the same size, then just clear it.
+*/
+static void
+apollo_redo_window(pad_$window_desc_t * window)
+{
+    struct termentry *tbl = term;
+    status_$t status;
+
+    /* the order of the following calls is important */
+    apollo_gpr_terminate();
+    apollo_gpr_init(tbl, window);
+    apollo_tic_sizes(tbl);
+}
+
+TERM_PUBLIC void
+APOLLO_graphics()
+{
+    pad_$window_desc_t window;
+    short wnum;
+    status_$t status;
+
+    pad_$inq_windows(stream, &window, 1, &wnum, &status);
+    apollo_check("inq_windows");
+
+    if (window.width != APOLLO_XMAX || window.height != APOLLO_YMAX)
+	apollo_redo_window(&window);
+    else {
+	gpr_$clear(0, &status);
+	apollo_check("clear");
+    }
+}
+
+/* set a line type:
+   -2 heavy, solid	(border)
+   -1 heavy, dotted	(axis)
+   0  solid		(normal)
+   1  dots		(other curves)
+   2  short dash
+   3  long dash
+   4  dash dot
+
+   Apparently, GPUplot draws a lot of short line segments, and each
+   one starts a new pattern.  This makes the patterns somewhat useless,
+   but one can still tell the difference between solid, dotted, and
+   dashed lines.  The utility of fancier styles is limited, however.
+
+   On a color workstation, we should use different colors, but I
+   don't have one.
+*/
+
+/*
+    To draw different line styles on an Apollo, we use two different
+    parameters.  One is a line thickness, which is just an integral
+    multiple of the default line thickness.  The second is a 16-bit
+    pattern that is repeated.  We could use fancier patterns, since
+    GPR supports up to 64-bits, but, as I explained earlier, this
+    really does not buy us anything.
+
+    I used patterns that do not start with all bits on because
+    gnuplot seems to use lots of short line segments to draw
+    a curve, and this might make a very curvey plot seem like
+    a solid line, regardless of pattern.  I don't want to start
+    with too many zeros, however, or else the curve might not
+    appear at all!  All the patterns, therefore, start with one
+    bit on.  The rest of the bits determine the true pattern.
+
+    By examining graphics.c, we see that linetype -2 is used exclusively
+    for the border, -1 for the axes, and the non-negative integers for
+    the curves.  We use heavy lines for the border and axes, and normal
+    width lines for the curves.
+
+    Since C arrays start at zero, make sure all the offsets are correct,
+    so that it is easy to access the array with -2...n linetypes.
+*/
+
+typedef struct {
+    short width;
+    short pattern;
+} APOLLO_LINE;
+
+static APOLLO_LINE apollo_lines[] =
+{
+    {2, ~0},			/* heavy, solid */
+    {2, 0x6666},		/* heavy, dotted */
+    {1, ~0},			/* normal */
+    {1, 0xAAAA},		/* dotted */
+    {1, 0xC3C3},		/* short dash */
+    {1, 0xE01F},		/* long dash */
+    {1, 0x87F8},		/* dash dot */
+    {1, 0x6666},		/* big dots */
+};
+
+#define BITS_PER_LINETYPE	16
+
+/* apollo_line(-2) is the border style, etc. */
+#define apollo_line(x)		apollo_lines[(x)+2]
+#define apollo_pattern(x)	&apollo_line(x).pattern
+#define apollo_width(x)		apollo_line(x).width
+
+#define APOLLO_MIN_LINE		(-2)
+#define APOLLO_MAX_LINE		(sizeof(apollo_lines)/sizeof(*apollo_lines)-2)
+
+/* set the line style */
+TERM_PUBLIC void
+APOLLO_linetype(int ltype)
+{
+    status_$t status;
+
+    if (ltype < APOLLO_MIN_LINE)
+	ltype = APOLLO_MIN_LINE;
+    if (ltype >= APOLLO_MAX_LINE)
+	ltype %= APOLLO_MAX_LINE;
+
+    gpr_$set_line_pattern(1, apollo_pattern(ltype), BITS_PER_LINETYPE, &status);
+    apollo_check("set_line_pattern");
+
+    gpr_$set_draw_width(draw_width * apollo_width(ltype), &status);
+    apollo_check("set_draw_width");
+}
+
+/* issue an error message that includes an (x, y) coordinate */
+static void
+apollo_xy_error(char *s, int x, int y, status_$t status)
+{
+    char buffer[128];
+
+    sprintf(buffer, "%s(%d, %d)", s, x, y);
+    apollo_error(buffer);
+}
+
+#define apollo_xy_check(s)	\
+    if (status.all != status_$ok) apollo_xy_error((s), x, y, status)
+
+/*
+    Note that gnuplot and GPR have reversed ideas of where the Y origin is.
+    This means subtracting the Y coordinate from Y max.
+*/
+#define plot_to_gpr(y)		(APOLLO_YMAX - (y))
+
+/* move to a new position */
+TERM_PUBLIC void
+APOLLO_move(unsigned int x, unsigned int y)
+{
+    status_$t status;
+
+    gpr_$move((gpr_$coordinate_t) x, plot_to_gpr(y), &status);
+    apollo_xy_check("move");
+}
+
+/* draw a line to a new position */
+TERM_PUBLIC void
+APOLLO_vector(unsigned int x, unsigned int y)
+{
+    status_$t status;
+
+    gpr_$line((gpr_$coordinate_t) x, plot_to_gpr(y), &status);
+    apollo_xy_check("line");
+}
+
+/*
+    On terminals, this switches to text mode.  The real meaning,
+    however, is that the graphics are finished.  This means we can
+    now display the saved bitmap.
+*/
+TERM_PUBLIC void
+APOLLO_text()
+{
+    if (use_bitmap) {
+	static gpr_$position_t pos;	/* always zero */
+	gpr_$window_t window;
+	status_$t status;
+
+	/* bitblt the entire bitmap to the entire window */
+	window.window_base.x_coord = 0;
+	window.window_base.y_coord = 0;
+	window.window_size.x_size = APOLLO_XMAX;
+	window.window_size.y_size = APOLLO_YMAX;
+
+	gpr_$set_bitmap(screen_desc, &status);
+	apollo_check("set_bitmap(screen_desc)");
+
+	gpr_$pixel_blt(bitmap_desc, window, pos, &status);
+	apollo_check("bitblt");
+
+	gpr_$set_bitmap(bitmap_desc, &status);
+	apollo_check("set_bitmap(bitmap_desc)");
+    }
+}
+
+TERM_PUBLIC int
+APOLLO_text_angle(int ang)
+{
+    status_$t status;
+
+    gpr_$set_text_path(ang ? gpr_$up : gpr_$right, &status);
+    apollo_check("set_text_path");
+    return TRUE;
+}
+
+static enum JUSTIFY apollo_text_mode;
+
+TERM_PUBLIC int
+APOLLO_justify_text(enum JUSTIFY mode)
+{
+    apollo_text_mode = mode;
+    return TRUE;
+}
+
+/*
+    Write "str" right justified on row "row".  A row is assumed to
+    have whatever height the current text has.  Make sure the
+    text does not cover the tick marks.
+*/
+TERM_PUBLIC void
+APOLLO_put_text(unsigned int x, unsigned int y, const char str[])
+{
+    gpr_$offset_t size;
+    status_$t status;
+
+    gpr_$inq_text_extent(str, strlen(str), &size, &status);
+    apollo_check("inq_text_extent");
+
+    y -= size.y_size / 2;	/* center around "y" */
+    switch (apollo_text_mode) {
+    case LEFT:
+	break;
+    case CENTRE:
+	x -= size.x_size / 2;
+	break;
+    case RIGHT:
+	x -= size.x_size;
+	break;
+    }
+    APOLLO_move(x, y);
+
+    gpr_$text(str, strlen(str), &status);
+    apollo_check("put_text");
+}
+
+/* reset the graphics state and terminate */
+TERM_PUBLIC void
+APOLLO_reset()
+{
+    if (stream != -1) {
+	apollo_gpr_terminate();
+	stream = -1;
+    }
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+TERM_TABLE_START(apollo_driver)
+    "apollo",
+    "Apollo Graphics Primitive Resource, rescaling of subsequent plots after window resizing",
+    0, 0, 0, 0,	/* APOLLO_XMAX, APOLLO_YMAX, APOLLO_VCHAR, APOLLO_HCHAR, are filled in at run-time */
+    APOLLO_VTIC, APOLLO_HTIC, options_null, APOLLO_init, APOLLO_reset,
+    APOLLO_text, null_scale, APOLLO_graphics, APOLLO_move, APOLLO_vector,
+    APOLLO_linetype, APOLLO_put_text, APOLLO_text_angle,
+    APOLLO_justify_text, line_and_point, do_arrow, set_font_null
+TERM_TABLE_END(apollo_driver)
+
+#undef LAST_TERM
+#define LAST_TERM apollo_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(apollo)
+"1 apollo",
+"?commands set terminal apollo",
+"?set terminal apollo",
+"?set term apollo",
+"?terminal apollo",
+"?term apollo",
+"?apollo",
+" The `apollo` terminal driver supports the Apollo Graphics Primitive Resource",
+" with rescaling after window resizing.  It has no options.",
+"",
+" If a fixed-size window is desired, the `gpr` terminal may be used instead."
+END_HELP(apollo)
+#endif /* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/aquaterm.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/aquaterm.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/aquaterm.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/aquaterm.trm.svn-base	2012-01-03 17:07:24.866464100 -0800
@@ -0,0 +1,940 @@
+/* -*- objc -*-
+ * $Id: aquaterm.trm,v 1.40.2.2 2009/07/04 21:18:07 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - aquaTerm.trm */
+
+
+/*
+ * This file is included by ../term.c via ../term.h.
+ *
+ * This terminal driver supports:
+ *     Aqua (Mac OS X/Cocoa)
+ *
+ * AUTHORS
+ *  Per Persson from openstep.trm by Robert Lutwak
+ *
+ * Homepage: http://aquaterm.sourceforge.net
+ * send your comments or suggestions to (persquare@users.sourceforge.net).
+ *
+ * This terminal attempts to connect, via the Mac OS X Distributed
+ * Objects system, to the "aquatermServer."  If there is no such
+ * service registered with the OS, the terminal attempts to fire
+ * up AquaTerm.app.  If the user has not set the environment variable
+ * AQUATERM_PATH, the terminal searches for AquaTerm.app in standard
+ * locations like /Applications, ~/Applications, etc.
+ * In order to use this filter, you MUST have AquaTerm.app installed
+ * on your system.
+ *
+ * Once connected to the server, all gnuplot graphs are sent,
+ * via the D.O. system, to AquaTerm.app, which produces renders graphs,
+ * manages the windows, takes care of printing etc.
+ *
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(aqua)
+#endif
+
+#ifdef TERM_PROTO
+/* Required entries */
+TERM_PUBLIC void AQUA_options __PROTO((void));
+TERM_PUBLIC void AQUA_init __PROTO((void));
+TERM_PUBLIC void AQUA_reset __PROTO((void));
+TERM_PUBLIC void AQUA_text __PROTO((void));
+TERM_PUBLIC void AQUA_graphics __PROTO((void));
+TERM_PUBLIC void AQUA_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void AQUA_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void AQUA_linetype __PROTO((int linetype));
+TERM_PUBLIC void AQUA_put_text __PROTO((unsigned int x, unsigned int y,const char *str));
+/* Optional entries */
+TERM_PUBLIC int AQUA_text_angle __PROTO((int));
+TERM_PUBLIC int AQUA_justify_text __PROTO((enum JUSTIFY));
+TERM_PUBLIC int AQUA_set_font __PROTO((const char *font));  /* "font,size" */
+TERM_PUBLIC void AQUA_set_pointsize __PROTO((double size)); /* notification of set pointsize */
+TERM_PUBLIC void AQUA_point __PROTO((unsigned int, unsigned int, int));
+TERM_PUBLIC int flags; /* various flags */
+TERM_PUBLIC void AQUA_suspend __PROTO((void)); /* after one plot of multiplot */
+TERM_PUBLIC void AQUA_resume __PROTO((void));  /* before subsequent plot of multiplot */
+TERM_PUBLIC void AQUA_boxfill __PROTO((int style, unsigned int x1, unsigned int y1, unsigned int width, unsigned int height)); /* clear part of multiplot */
+TERM_PUBLIC void AQUA_linewidth __PROTO((double linewidth));
+TERM_PUBLIC void AQUA_pointsize __PROTO((double pointsize));
+TERM_PUBLIC int AQUA_make_palette __PROTO((t_sm_palette *palette));
+TERM_PUBLIC void AQUA_previous_palette __PROTO((void));
+TERM_PUBLIC void AQUA_set_color __PROTO((t_colorspec *));
+TERM_PUBLIC void AQUA_filled_polygon __PROTO((int points, gpiPoint *corners));
+TERM_PUBLIC void AQUA_image __PROTO((unsigned, unsigned, coordval *, gpiPoint *, t_imagecolor));
+TERM_PUBLIC void ENHAQUA_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
+TERM_PUBLIC void ENHAQUA_open __PROTO((char * fontname, double fontsize,
+				       double base, TBOOLEAN widthflag, TBOOLEAN showflag,
+				       int overprint));
+TERM_PUBLIC void ENHAQUA_flush __PROTO((void));
+TERM_PUBLIC void ENHAQUA_writec __PROTO((int c));
+/* End of entries */
+
+#define AQUA_RESOLUTION (20.0)                    /* Increase resolution */
+#define AQUA_XMAX (11.75 * 72 * AQUA_RESOLUTION)  /* = paper width (in) times screen resolution */
+#define AQUA_YMAX (8.25 * 72 * AQUA_RESOLUTION)	  /* = paper height (in) times screen resolution */
+#define AQUA_VTIC (8.0*AQUA_RESOLUTION)
+#define AQUA_HTIC (8.0*AQUA_RESOLUTION)
+#define AQUA_VCHAR (16.0*AQUA_RESOLUTION)         /* default font is Times at 14 points */
+#define AQUA_HCHAR (AQUA_VCHAR*6.0/10.0)
+#define AQUA_DASH_PATTERNS 8
+#define AQUA_DEFAULT_DASHLENGTH_FACTOR 0.5
+
+#define SPECIAL_COLORS 4
+#define CYCLIC_COLORS 9
+
+#define GOT_AQUA_PROTO
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+
+#ifdef TERM_BODY
+#import <aquaterm/AQTAdapter.h>
+
+#import <Foundation/NSAutoreleasePool.h>
+#import <Foundation/NSArray.h>
+#import <Foundation/NSDictionary.h>
+#import <Foundation/NSAttributedString.h>
+#import <stdarg.h>
+
+/* Debugging extras */
+static inline void NOOP_(id x, ...) {;}
+
+#ifdef LOGGING
+#define LOG  NSLog
+#else
+#define LOG  NOOP_
+#endif	/* LOGGING */
+
+/* AquaTerm specific */
+static NSAutoreleasePool *arpool;
+static NSAutoreleasePool *loopPool;
+static AQTAdapter *adapter;
+
+/* Supported features */
+static TBOOLEAN AQUA_hasAlphaSupport = FALSE;
+
+/* Internal state */
+static int AQUA_plotRef = 0; /* A ref to the current plot */
+static char AQUA_title[MAX_LINE_LEN + 1] = "Figure 0"; /* Plot title (in windowbar) */
+
+static unsigned int AQUA_xSize = AQUA_XMAX; /* plot horizontal size */
+static unsigned int AQUA_ySize = AQUA_YMAX; /* plot vertical size*/
+
+static int AQUA_LineType = -3; /* current line type*/
+static float AQUA_LineWidth = 1.0; /* current line width*/
+static float AQUA_TextAngle = 0.0; /* current text orientation*/
+static enum JUSTIFY AQUA_TextJust = LEFT; /* current text justification*/
+
+/* default text font family: */
+static char AQUA_fontNameDef[MAX_ID_LEN + 1] = "Times-Roman";
+static double AQUA_fontSizeDef = 14; /* default text size*/
+/* current text font family: */
+static char AQUA_fontNameCur[MAX_ID_LEN + 1] = "Times-Roman";
+static double AQUA_fontSizeCur = 14; /* current text size*/
+
+/* dash patterns */
+static TBOOLEAN AQUA_dashedlines = FALSE;
+static float AQUA_dashlength_factor = AQUA_DEFAULT_DASHLENGTH_FACTOR;
+static int AQUA_dashPatternLengths[AQUA_DASH_PATTERNS] = {0, 2, 2, 2, 4, 4, 4, 6};
+static int AQUA_dashPatterns[AQUA_DASH_PATTERNS][6] = {
+        {0, 0, 0, 0, 0, 0},
+        {8, 8, 0, 0, 0, 0},
+        {4, 6, 0, 0, 0, 0},
+        {2, 3, 0, 0, 0, 0},
+        {12, 4, 2, 4, 0, 0},
+        {6, 6, 2, 6, 0, 0},
+        {4, 4, 4, 12, 0, 0},
+        {1, 4, 12, 4, 1, 4}
+    };
+
+/* Helper functions */
+static NSString* AQUA_convert_using_encoding __PROTO((const char *string));
+
+/*
+ * ----------------------------------------------------------------
+ * Aquaterm driver implementation
+ * ----------------------------------------------------------------
+ *
+ *   Current options are:
+ *   <n> title "theTitle" size <x> <y> fname "fontface" fsize <fontsize>
+ */
+TERM_PUBLIC void
+AQUA_options()
+{
+  char *s;
+  TBOOLEAN set_number = FALSE;
+  
+  AQUA_title[0] = '\0'; /* Force re-interpretation of title string */
+
+  while (!END_OF_COMMAND) {
+  
+    if (almost_equals(c_token, "ti$tle"))  {
+	c_token++;
+
+	if (!(s = try_to_get_string()))
+	    int_error(c_token,"fname: expecting plot title");
+	strncpy(AQUA_title,s,sizeof(AQUA_title));
+	free(s);
+	continue;
+    }
+
+    if (almost_equals(c_token, "s$ize")) {
+	double value;
+
+	c_token++;
+
+	if (END_OF_COMMAND)
+	    int_error(c_token,"expecting x size");
+	value = real_expression();
+	if (value < 2 || value > 2048)
+	    int_error(c_token,"x size out of range");
+	AQUA_xSize = (unsigned int) value * AQUA_RESOLUTION;
+
+	if (END_OF_COMMAND)
+	    int_error(c_token,"expecting y size");
+	if (equals(c_token, ","))
+	    c_token++;
+	value = real_expression();
+	if (value < 2 || value > 2048)
+	    int_error(c_token,"y size out of range");
+	AQUA_ySize = (unsigned int) value * AQUA_RESOLUTION;
+	continue;
+    }
+
+    if (almost_equals(c_token, "fn$ame") || almost_equals(c_token, "font"))  {
+        char *comma;
+        c_token++;
+    
+	if (!(s = try_to_get_string()))
+	    int_error(c_token,"expecting font specifier");
+        comma = strrchr(s, ',');
+	if (comma && (1 == sscanf(comma+1, "%lf", &AQUA_fontSizeCur)))
+	    *comma = '\0';
+	if (*s)
+	    strncpy(AQUA_fontNameCur, s, sizeof(AQUA_fontNameCur));
+	free(s);
+	continue;
+    }
+
+    if (almost_equals(c_token, "fs$ize")) {
+	c_token++;
+
+	if (END_OF_COMMAND)
+	    int_error(c_token,"expecting font size");
+	AQUA_fontSizeCur = real_expression();
+	continue;
+    }
+
+	if (equals(c_token, "solid")) {
+	    c_token++;
+	    AQUA_dashedlines = FALSE;
+	    continue;
+	}
+	
+	if (almost_equals(c_token, "dash$ed")) {
+	    c_token++;
+	    AQUA_dashedlines = TRUE;
+	    continue;
+	}
+
+	if (equals(c_token, "dl") || almost_equals(c_token, "dashl$ength")) {
+	    c_token++;
+	    if (END_OF_COMMAND)
+		int_error(c_token, "expecting dashlength multiplier");
+	    AQUA_dashlength_factor = real_expression();
+	    if (AQUA_dashlength_factor < 0.0)
+		AQUA_dashlength_factor = AQUA_DEFAULT_DASHLENGTH_FACTOR;
+	    continue;
+	}
+
+    if (almost_equals(c_token, "enh$anced")) {
+      term->put_text = ENHAQUA_put_text;
+      c_token++;
+      term->flags |= TERM_ENHANCED_TEXT;
+      continue;
+    }
+
+    if (almost_equals(c_token, "noenh$anced")) {
+      term->put_text = AQUA_put_text;
+      c_token++;
+      term->flags &= ~TERM_ENHANCED_TEXT;
+      continue;
+    }
+
+    if (!set_number) { /* plot ref number*/
+	AQUA_plotRef = int_expression();
+	set_number = TRUE;
+	continue;
+    }
+
+    int_error(c_token, "unexpected text at end of command");
+  }
+
+  if (AQUA_title[0]=='\0') /* always set title */
+    sprintf(AQUA_title, "Figure %d", AQUA_plotRef);
+  /* Save options back into options string in normalized format */
+  sprintf(term_options, "%d title \"%s\" size %d,%d font \"%s,%g\" %s %s",
+	  AQUA_plotRef,
+	  AQUA_title,
+	  (unsigned int) (AQUA_xSize/AQUA_RESOLUTION), (unsigned int) (AQUA_ySize/AQUA_RESOLUTION),
+	  AQUA_fontNameCur, AQUA_fontSizeCur,
+	  term->put_text == ENHAQUA_put_text?"enhanced":"noenhanced", 
+	  AQUA_dashedlines?"dashed":"solid");
+  if (AQUA_dashedlines)
+    sprintf(&(term_options[strlen(term_options)]), " dl %3.1f", AQUA_dashlength_factor);
+}
+
+static NSString* 
+AQUA_convert_using_encoding(const char *string)
+{
+  static bool didCheckEncodingSupport = false;
+  static bool hasStringEncodingSupport = false;
+  NSStringEncoding currentEncoding;
+  NSString *translatedString;
+
+  /* Check encoding support in system on first call */
+  if(!didCheckEncodingSupport) {
+    didCheckEncodingSupport = true;
+    hasStringEncodingSupport = [NSString respondsToSelector:@selector(stringWithCString:encoding:)];
+  }
+  /* Set encoding as requested by user via "set encoding" */
+  switch(encoding){
+  case S_ENC_ISO8859_1:
+    currentEncoding = NSISOLatin1StringEncoding;
+    break;
+  case S_ENC_ISO8859_2:
+    currentEncoding = NSISOLatin2StringEncoding;
+    break;
+  case S_ENC_ISO8859_9:
+    currentEncoding = NSWindowsCP1254StringEncoding;
+    break;
+  case S_ENC_CP1250:
+    currentEncoding = NSWindowsCP1250StringEncoding;
+    break;
+    /* FIXME: Add more encodings... */
+  case S_ENC_DEFAULT:  /* Fallthrough */
+  default :
+    /* UTF8 is 'default' */
+    currentEncoding = NSUTF8StringEncoding;
+    break;
+  }
+  /* Perform translation (into UTF8 encoding used by Mac OS X) */
+  if (hasStringEncodingSupport) {
+    translatedString = [NSString stringWithCString:string encoding:currentEncoding];
+  } else {
+    translatedString = [NSString stringWithCString:string];
+  }
+  /* Check for nil result before returning */
+  return translatedString?translatedString:@"";
+}
+
+TERM_PUBLIC void
+AQUA_init()
+{
+  float fontSize, fontWHRatio;
+  NSString *title;
+
+  LOG(@"Aqua Init (open plot)");
+  if (arpool == NULL) {
+    /* FIXME: This should be removed when pools are handled in gnuplot proper */
+    arpool = [[NSAutoreleasePool alloc] init];
+  }
+  if (adapter == NULL) {
+    adapter = [[AQTAdapter alloc] init];
+    if (!adapter) { /* server could be invalid (=nil) for several reasons */
+      /* FIXME: Issue warning here? */
+    }
+  }
+
+  /* Must open plot before all other commands */
+  [adapter openPlotWithIndex:AQUA_plotRef];
+
+  /* Check for support of version-dependent features */
+   AQUA_hasAlphaSupport = [AQTAdapter respondsToSelector:@selector(setColorRed:green:blue:alpha:)];
+
+  /* set xmax, ymax*/
+  term->xmax = AQUA_xSize;
+  term->ymax = AQUA_ySize;
+  /* set current font*/
+  [adapter setFontname:AQUA_convert_using_encoding(AQUA_fontNameCur)];
+  [adapter setFontsize:AQUA_fontSizeCur];
+  /* set h_char, v_char*/
+  term->h_char = (int) (AQUA_fontSizeCur * 0.6 * AQUA_RESOLUTION);
+  term->v_char = (int) (AQUA_fontSizeCur * 1.5 * AQUA_RESOLUTION);
+  /* set h_tic, v_tic*/
+  term->h_tic = term->v_char / 3;
+  term->v_tic = term->v_char / 3;
+
+  [adapter setPlotSize:NSMakeSize(AQUA_xSize/AQUA_RESOLUTION, AQUA_ySize/AQUA_RESOLUTION)];
+  [adapter setPlotTitle:AQUA_convert_using_encoding(AQUA_title)];
+
+  /*
+   * Set up the basic indexed colormap for gnuplot
+   */
+  /*  Special colors */
+  [adapter setColormapEntry:0 red:0.1 green:0.1 blue:0.1]; /* linetype -4 */
+  [adapter setColormapEntry:1 red:0.9 green:0.9 blue:0.9]; /* linetype -3 (xor;interactive) light gray */
+  [adapter setColormapEntry:2 red:0.0 green:0.0 blue:0.0]; /* linetype -2 (border) black */
+  [adapter setColormapEntry:3 red:0.8 green:0.8 blue:0.8]; /* linetype -1 (gridlines) light grey */
+  /*  Cyclic colors */
+  [adapter setColormapEntry:4 red:1.0 green:0.0 blue:0.0]; /* red */
+  [adapter setColormapEntry:5 red:0.0 green:1.0 blue:0.0]; /* green */
+  [adapter setColormapEntry:6 red:0.0 green:0.0 blue:1.0]; /* blue */
+  [adapter setColormapEntry:7 red:1.0 green:0.0 blue:1.0]; /* magenta */
+  [adapter setColormapEntry:8 red:0.0 green:1.0 blue:1.0]; /* cyan */
+  [adapter setColormapEntry:9 red:0.6275 green:0.3216 blue:0.1765]; /* sienna */
+  [adapter setColormapEntry:10 red:1.0 green:0.6471 blue:0.0]; /* orange */
+  [adapter setColormapEntry:11 red:0.5 green:0.4980 blue:0.3137]; /* coral */
+  [adapter setColormapEntry:12 red:0.25 green:0.25 blue:0.25]; /* grey */
+
+}
+
+TERM_PUBLIC void
+AQUA_reset()
+{
+  LOG(@"Aqua reset");
+}
+
+TERM_PUBLIC void
+AQUA_text()
+{
+  LOG(@"Aqua text (render)");
+  [adapter renderPlot];
+}
+
+TERM_PUBLIC void
+AQUA_graphics()
+{
+#ifdef LOGGING
+  /* Keep the compiler quiet when not debugging */
+  LOG(@"Pre:  (arpool + loopPool, loopPool) =(%d, %d)", [NSAutoreleasePool autoreleasedObjectCount],
+      [NSAutoreleasePool topAutoreleasePoolCount]);
+#endif
+  /* Avoid buildup of objects in the autoreleasepools */
+  [loopPool release];
+  loopPool = [[NSAutoreleasePool alloc] init];
+#ifdef LOGGING
+  /* Keep the compiler quiet when not debugging */
+  LOG(@"Post: (arpool + loopPool, loopPool) =(%d, %d)",[NSAutoreleasePool autoreleasedObjectCount],
+      [NSAutoreleasePool topAutoreleasePoolCount]);
+#endif
+  [adapter eraseRect:NSMakeRect(0.0, 0.0, AQUA_xSize/AQUA_RESOLUTION, AQUA_ySize/AQUA_RESOLUTION)];
+}
+
+TERM_PUBLIC void
+AQUA_move(unsigned int x, unsigned int y)
+{
+  [adapter moveToPoint:NSMakePoint(x/AQUA_RESOLUTION, y/AQUA_RESOLUTION)];
+}
+
+TERM_PUBLIC void
+AQUA_vector(unsigned int x, unsigned int y)
+{
+  [adapter addLineToPoint:NSMakePoint(x/AQUA_RESOLUTION, y/AQUA_RESOLUTION)];
+}
+
+TERM_PUBLIC void
+AQUA_linetype(int linetype)
+{
+  float dash[8];
+  int i, style;
+  LOG(@"AQUA_linetype(%d) ---> entry: %d", linetype, (linetype%CYCLIC_COLORS)+SPECIAL_COLORS);
+  if (linetype != AQUA_LineType) {
+    /* Note: this operation maps linestyle -4 to -1 onto colormap entries 0 to 3 */
+    AQUA_LineType = linetype;
+    [adapter takeColorFromColormapEntry:(linetype%CYCLIC_COLORS)+SPECIAL_COLORS];
+  }
+  if (AQUA_dashedlines) {
+    style = linetype%AQUA_DASH_PATTERNS;
+    if (style <= 0) {
+       [adapter setLinestyleSolid];
+    } else {      
+       // Set up a dash array
+	   for(i = 0; i<AQUA_dashPatternLengths[style]; i++) {
+	      dash[i] = AQUA_dashPatterns[style][i] * AQUA_dashlength_factor;
+	   }
+       [adapter setLinestylePattern:dash count:AQUA_dashPatternLengths[style] phase:0.0];
+    }
+  }
+}
+
+TERM_PUBLIC void
+AQUA_put_text(unsigned int x, unsigned int y, const char *str)
+{
+  if (!strlen(str))
+    return;
+  [adapter  addLabel:AQUA_convert_using_encoding(str)
+	     atPoint:NSMakePoint(x/AQUA_RESOLUTION, y/AQUA_RESOLUTION)
+	       angle:AQUA_TextAngle
+	       align:(AQUA_TextJust | AQTAlignMiddle)];
+}
+
+TERM_PUBLIC int
+AQUA_justify_text (enum JUSTIFY mode)
+{
+  AQUA_TextJust = mode;
+  return (TRUE);
+}
+
+TERM_PUBLIC int
+AQUA_text_angle (int angle)
+{
+  AQUA_TextAngle = (float)angle;
+  return (TRUE);
+}
+
+TERM_PUBLIC int
+AQUA_set_font(const char *font) /* "font,size" */
+{
+  /* Obtain default fontname and fontsize. If these are invalid, AquaTerm will handle it. */
+  NSString *fontFace = AQUA_convert_using_encoding(AQUA_fontNameCur);
+  float fontSize = AQUA_fontSizeCur;
+  
+  if (strlen(font) > 0) {
+    /* Try to split the non-empty string into array parts (as string objects) */
+    NSArray *parts = [AQUA_convert_using_encoding(font) componentsSeparatedByString:@","];
+    /* Check that we have both non-empty name and size, otherwise stay with defaults */
+    if ([parts count] > 0 && ![[parts objectAtIndex:0] isEqualToString:@""] ) {
+      fontFace = [parts objectAtIndex:0]; /* fontname */
+      if ([parts count] > 1 && ![[parts objectAtIndex:1] isEqualToString:@""] ) {
+        fontSize = [[parts objectAtIndex:1] floatValue]; /* Convert (optional) 2nd string object (fontsize) to float */ 
+      }   
+    }
+  }
+
+  LOG(@"Setting:(%@,%f)", fontFace, fontSize);
+  [adapter setFontname:fontFace];
+  [adapter setFontsize:fontSize];
+
+  term->h_char = (int) (fontSize * 0.6 * AQUA_RESOLUTION);
+  term->v_char = (int) (fontSize * 1.5 * AQUA_RESOLUTION);
+
+  return (TRUE);
+}
+
+TERM_PUBLIC void
+AQUA_set_pointsize(double size) /* notification of set pointsize */
+{
+  LOG(@"AQUA_set_pointsize(%f)", size);
+}
+
+TERM_PUBLIC void
+AQUA_point(unsigned int x, unsigned int y, int number)
+{
+  /* The default dot-routine doesn't work with AQT */
+  [adapter setLinestyleSolid]; /* Symbols should never be dashed */
+  [adapter setLinewidth:1.0];  
+  [adapter setLineCapStyle:AQTRoundLineCapStyle]; /* Set line cap style to round to create a dot */
+  [adapter moveToPoint:NSMakePoint(x/AQUA_RESOLUTION-0.005, y/AQUA_RESOLUTION)];
+  [adapter addLineToPoint:NSMakePoint(x/AQUA_RESOLUTION+0.005, y/AQUA_RESOLUTION)];
+  [adapter moveToPoint:NSMakePoint(0,0)]; /* Force a path end  to work around a bug in AquaTerm 1.0.0 */
+  /* Round caps results in nicer symbols too */  
+  if (number>=0) {
+    do_point(x, y, number);
+  }
+  [adapter moveToPoint:NSMakePoint(0,0)]; /* Force a path end to work around a bug in AquaTerm 1.0.0 */
+  [adapter setLineCapStyle:AQTButtLineCapStyle]; /* Reset line capstyle */
+}
+
+/* after one plot of multiplot */
+TERM_PUBLIC void
+AQUA_suspend()
+{
+  [adapter renderPlot];
+}
+
+/* before subsequent plot of multiplot */
+TERM_PUBLIC void
+AQUA_resume()
+{
+}
+
+/* clear part of multiplot */
+TERM_PUBLIC void
+AQUA_boxfill(int style, unsigned int x1, unsigned int y1, unsigned int width, unsigned int height)
+{
+  float r,g,b;
+
+  LOG(@"\nstyle=%d\nstyle & 0xf = %d\nfillpar=%d\n", style, style & 0xf, style >> 4);
+  /* Save current color */
+  [adapter getColorRed:&r green:&g blue:&b];
+
+  /* fillpar:
+   * - solid   : 0 - 100
+   * - pattern : 0 - 100
+   */
+  int fillpar = style >> 4;
+  style &= 0xf;
+
+  switch (style) {
+  case 0: /* fill with background color */
+    {
+      float rb, gb, bb;
+      [adapter getBackgroundColorRed:&rb green:&gb blue:&bb];
+      [adapter setColorRed:rb green:gb blue:bb];
+    }
+    break;
+  case FS_TRANSPARENT_SOLID:
+    if (AQUA_hasAlphaSupport) {
+      float alpha = fillpar * 0.01;
+      [adapter setColorRed:r green:g blue:b alpha:alpha];
+      break;
+    } else
+      /* fall through */
+  case FS_SOLID: /* solid fill */
+    {
+      float density = (100 - fillpar)*0.01;
+      [adapter setColorRed:r*(1-density) + density
+	             green:g*(1-density) + density
+	              blue:b*(1-density) + density];
+    }
+    break;
+  case FS_PATTERN: /* pattern fill */
+  case FS_TRANSPARENT_PATTERN:
+    /* Can't do pattern easily, using colors. */
+    [adapter takeColorFromColormapEntry:(fillpar%CYCLIC_COLORS)+SPECIAL_COLORS];
+    break;
+  default:
+    break;
+  }
+
+  NSRect scaledRect = NSMakeRect(x1/AQUA_RESOLUTION, y1/AQUA_RESOLUTION, width/AQUA_RESOLUTION, height/AQUA_RESOLUTION);
+  [adapter eraseRect:scaledRect];
+  [adapter addFilledRect:scaledRect];
+  /* Restore color */
+  [adapter setColorRed:r green:g blue:b];
+}
+
+TERM_PUBLIC void
+AQUA_linewidth(double linewidth)
+{
+  [adapter setLinewidth:linewidth];
+}
+
+TERM_PUBLIC void
+AQUA_pointsize(double pointsize)
+{
+  LOG(@"AQUA_pointsize(%f)", pointsize);
+  term_pointsize = pointsize;
+}
+
+TERM_PUBLIC int
+AQUA_make_palette(t_sm_palette *palette)
+{
+  if (palette == NULL) {
+    /* AquaTerm can do continuous colors */
+    return 0;
+  }
+  return 0;
+}
+
+TERM_PUBLIC void
+AQUA_set_color(t_colorspec *colorspec)
+{
+  rgb_color color;
+  
+  switch (colorspec->type) {
+  case TC_FRAC:
+    rgb1maxcolors_from_gray(colorspec->value, &color);
+    [adapter setColorRed:color.r green:color.g blue:color.b];
+    break;
+  case TC_RGB:
+    color.r = (double)((colorspec->lt >> 16 ) & 255) / 255.;
+    color.g = (double)((colorspec->lt >> 8 ) & 255) / 255.;
+    color.b = (double)(colorspec->lt & 255) / 255.;
+    [adapter setColorRed:color.r green:color.g blue:color.b];
+    break;
+  case TC_LT:
+    [adapter takeColorFromColormapEntry:((colorspec->lt)%CYCLIC_COLORS)+SPECIAL_COLORS];
+    break;
+  default:
+    break;
+  }
+  AQUA_LineType = LT_UNDEFINED;
+}
+
+TERM_PUBLIC void
+AQUA_filled_polygon(int pc, gpiPoint *corners)
+{
+  int i;
+  int fillpar = corners->style >> 4;
+  float r,g,b;
+
+  [adapter getColorRed:&r green:&g blue:&b];
+ 
+  /* This switch is a clone of the one in AQUA_boxfill() */
+  switch (corners->style & 0xf) {
+  case 0: /* fill with background color */
+    {
+      float rb, gb, bb;
+      [adapter getBackgroundColorRed:&rb green:&gb blue:&bb];
+      [adapter setColorRed:rb green:gb blue:bb];
+    }
+    break;
+  case FS_TRANSPARENT_SOLID:
+    if (AQUA_hasAlphaSupport) {
+      float alpha = fillpar * 0.01;
+      [adapter setColorRed:r green:g blue:b alpha:alpha];
+      break;
+    } else
+      /* fall through */
+  case FS_SOLID: /* solid fill */
+    {
+      float density = (100 - fillpar)*0.01;
+      [adapter setColorRed:r*(1-density) + density
+	             green:g*(1-density) + density
+	              blue:b*(1-density) + density];
+    }
+    break;
+  case FS_PATTERN: /* pattern fill */
+  case FS_TRANSPARENT_PATTERN:
+    /* Can't do pattern easily, using colors. */
+    [adapter takeColorFromColormapEntry:(fillpar%CYCLIC_COLORS)+SPECIAL_COLORS];
+    break;
+  default:
+    break;
+  }
+
+  [adapter moveToVertexPoint:NSMakePoint(corners[0].x/AQUA_RESOLUTION,
+					 corners[0].y/AQUA_RESOLUTION)];
+  for (i=1; i<pc; i++) {
+    [adapter addEdgeToVertexPoint:NSMakePoint(corners[i].x/AQUA_RESOLUTION,
+					      corners[i].y/AQUA_RESOLUTION)];
+  }
+}
+
+TERM_PUBLIC void
+AQUA_previous_palette()
+{
+}
+
+TERM_PUBLIC void
+AQUA_image (unsigned int M, unsigned int N, coordval *image, gpiPoint *corner, t_imagecolor color_mode)
+{
+  float width = (corner[1].x - corner[0].x)/AQUA_RESOLUTION;   
+  float height = (corner[0].y - corner[1].y)/AQUA_RESOLUTION;
+  float xPos = corner[0].x/AQUA_RESOLUTION;
+  float yPos = corner[1].y/AQUA_RESOLUTION;  
+  int bitmapSize = M*N;
+  int targetSize = 3 * bitmapSize;
+  int srcSize;
+  unsigned char *bitmap;
+  int i;
+
+  bitmap = malloc(targetSize*sizeof(unsigned char));
+  if (bitmap != nil) {
+    if (color_mode == IC_RGB) {
+      srcSize = targetSize;
+      for (i=0;i<srcSize;i++) {
+	bitmap[i] = (unsigned char)(255*image[i]);
+      }
+    } else if (color_mode == IC_PALETTE) {
+      rgb_color color;
+      unsigned char *bitmapPtr = bitmap;
+      srcSize = bitmapSize;
+      for (i=0;i<srcSize;i++) {
+	rgb1maxcolors_from_gray(image[i], &color);
+	*bitmapPtr = (unsigned char)(255*color.r);
+	bitmapPtr++;
+	*bitmapPtr = (unsigned char)(255*color.g);
+	bitmapPtr++;
+	*bitmapPtr = (unsigned char)(255*color.b);
+	bitmapPtr++;
+      }
+    } else {
+      NSLog(@"Unknown bitmap format");
+    }
+    [adapter addImageWithBitmap:bitmap 
+	     size:NSMakeSize(M, N)
+	     bounds:NSMakeRect(xPos, yPos, width, height)];
+    free(bitmap);
+  }
+  return;
+}
+
+/*
+ * Per Persson 20041019
+ * Support for enhanced text mode
+ * 
+ * Known issues:
+ *   - Overprinting not implemented 
+ *   - The sub/superscript level is determined from relative fontsize,
+ *     it may break if fontsize is changed for individual characters.
+ */
+
+static NSMutableAttributedString *enhString;
+static NSMutableDictionary *attributes;
+
+TERM_PUBLIC void 
+ENHAQUA_put_text(unsigned int x, unsigned int y, const char str[])
+{
+  if (!strpbrk(str, "{}^_@&~"))
+    {
+      AQUA_put_text(x,y,str);
+      return;
+    }
+  /* set up the global variables needed by enhanced_recursion() */
+  enhanced_fontscale = 1;
+  strncpy(enhanced_escape_format,"\\%o",sizeof(enhanced_escape_format));
+  
+  /* Clear the attributed string */
+  [enhString release];
+  enhString = [[NSMutableAttributedString alloc] init];
+  [enhString setAttributedString:[[NSAttributedString alloc] initWithString:@""]];
+
+  while (*(str = enhanced_recursion((char *)str, TRUE, AQUA_fontNameCur,
+				    (double)(AQUA_fontSizeCur), 0.0, TRUE, TRUE, 0))) {
+    /* I think we can only get here if *str == '}' */
+    enh_err_check(str);
+
+    if (!*++str)
+      break; /* end of string */
+    /* else carry on and process the rest of the string */
+  }
+
+  /* Now, send the attributed string to the adapter */
+  [adapter  addLabel:enhString
+	    atPoint:NSMakePoint(x/AQUA_RESOLUTION, y/AQUA_RESOLUTION)
+	    angle:AQUA_TextAngle
+	    align:(AQUA_TextJust | AQTAlignMiddle)];
+
+}
+
+TERM_PUBLIC void 
+ENHAQUA_open(char * fontname, double fontsize,
+	     double base, TBOOLEAN widthflag, TBOOLEAN showflag,
+	     int overprint)
+{
+  LOG(@"%s %.1f %.1f %s %s %d", fontname, fontsize, base,
+      widthflag ? "true" : "false",
+      showflag ? "true" : "false",
+      overprint);
+  
+  if (overprint != 0)
+    return;
+  
+  [attributes release];
+  attributes = [[NSMutableDictionary alloc] initWithCapacity:16]; 
+  [attributes setObject:AQUA_convert_using_encoding(fontname) forKey:@"AQTFontname"];
+
+  if (abs(base)>0.01) { 
+    /* consider this as super/subscript, and compute subscript level */
+    int n = (int)round(log(fontsize/AQUA_fontSizeCur)/log(0.8)); 
+    [attributes setObject:[NSNumber numberWithInt:(base > 0)?n:-n] 
+		   forKey:@"NSSuperScript"];
+  } else if (abs(fontsize - AQUA_fontSizeCur)>0.01) {
+    /* Fontsize was set explicitly */
+    [attributes setObject:[NSNumber numberWithFloat:fontsize] forKey:@"AQTFontsize"];
+  }
+
+  if (!showflag)
+    [attributes setObject:[NSNumber numberWithInt:1] 
+		   forKey:@"AQTNonPrintingChar"];
+}
+
+/* Local buffer used in encoding conversion */
+#define ENHAQUA_CSTRBUFLEN 1023
+static char cStrBuf[ENHAQUA_CSTRBUFLEN + 1]; 
+static unsigned int cStrBufIndex = 0;
+
+TERM_PUBLIC void 
+ENHAQUA_flush(void)
+{
+  /* Convert cStrBuf UTF8 according to encoding, use convert_using_encoding()
+     and apply attributes before adding to enhString 
+  */
+  NSAttributedString *aStr;
+  cStrBuf[cStrBufIndex] = '\0';
+  cStrBufIndex = 0; 
+  aStr = [[NSAttributedString alloc] initWithString:AQUA_convert_using_encoding(cStrBuf) attributes:attributes];
+  [enhString appendAttributedString:aStr];
+  [aStr release];
+}
+
+TERM_PUBLIC void 
+ENHAQUA_writec(int c)
+{ 
+  /* Buffer byte sequence into cStrBuf */
+  LOG(@"int c = 0x%04x", c);
+  cStrBuf[cStrBufIndex] = (char)(c+0x100) & 0xFF; /* FIXME: Sometimes c is overflowed */
+  if (cStrBufIndex < ENHAQUA_CSTRBUFLEN) 
+    cStrBufIndex++;
+}
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(aqua_driver)
+  "aqua",
+  "Interface to graphics terminal server for Mac OS X",
+  0 /* xmax */ , 0 /* ymax */ , 0 /* vchar */ , 0 /* hchar */ ,
+  0 /* vtic */ , 0 /* htic */ ,
+  AQUA_options, AQUA_init, AQUA_reset,
+  AQUA_text, null_scale, AQUA_graphics, AQUA_move, AQUA_vector,
+  AQUA_linetype, AQUA_put_text,
+  /* optionals */
+  AQUA_text_angle,
+  AQUA_justify_text, AQUA_point, do_arrow, AQUA_set_font,
+  AQUA_pointsize, TERM_CAN_MULTIPLOT|TERM_NO_OUTPUTFILE|TERM_CAN_DASH,
+  AQUA_suspend, AQUA_resume,
+  AQUA_boxfill, AQUA_linewidth
+#ifdef USE_MOUSE
+  , 0, 0, 0, 0, 0
+#endif /* USE_MOUSE */
+  , AQUA_make_palette,
+  AQUA_previous_palette,
+  AQUA_set_color,
+  AQUA_filled_polygon,
+  AQUA_image,
+  ENHAQUA_open, ENHAQUA_flush, ENHAQUA_writec
+TERM_TABLE_END(aqua_driver)
+
+#undef LAST_TERM
+#define LAST_TERM aqua_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(aqua)
+"1 aqua",
+"?commands set terminal aqua",
+"?set terminal aqua",
+"?set term aqua",
+"?terminal aqua",
+"?term aqua",
+"?aqua",
+"?Aqua",
+" This terminal relies on AquaTerm.app for display on Mac OS X.",
+"",
+" Syntax:",
+"       set terminal aqua {<n>} {title \"<wintitle>\"} {size <x> <y>}",
+"                         {font \"<fontname>{,<fontsize>}\"}",
+"                         {{no}enhanced} {solid|dashed} {dl <dashlength>}}",
+"",
+" where <n> is the number of the window to draw in (default is 0),",
+" <wintitle> is the name shown in the title bar (default \"Figure <n>\"),",
+" <x> <y> is the size of the plot (default is 846x594 pt = 11.75x8.25 in).",
+"",
+" Use <fontname> to specify the font to use (default is \"Times-Roman\"),",
+" and <fontsize> to specify the font size (default is 14.0 pt). The old syntax",
+" {fname \"<fontname>\"} {fsize <fontsize>} is still supported.",
+"",
+" The aqua terminal supports enhanced text mode (see `enhanced`), except for",
+" overprint. Font support is limited to the fonts available on the system.",
+" Character encoding can be selected by `set encoding` and currently supports",
+" iso_latin_1, iso_latin_2, cp1250, and default which equals UTF8.",
+"",
+" Lines can be drawn either solid or dashed, (default is solid) and the dash",
+" spacing can be modified by <dashlength> which is a multiplier > 0.",
+""
+END_HELP(aqua)
+#endif /* TERM_HELP */
+
+
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/be.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/be.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/be.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/be.trm.svn-base	2012-01-03 17:07:25.070994500 -0800
@@ -0,0 +1,692 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: be.trm,v 1.18 2006/07/21 02:35:45 sfeam Exp $
+ *
+ */
+
+/*[
+ * Copyright 1986 - 1993, 1998, 2004   Thomas Williams, Colin Kelley
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * be.trm  --- inboard terminal driver for BE
+ *
+ * AUTHOR
+ *   Xavier Pianet
+ *
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(be)
+#endif
+
+#ifdef TERM_PROTO
+int BE_args __PROTO((int argc, char *argv[]));
+TERM_PUBLIC void BE_options __PROTO((void));
+TERM_PUBLIC void BE_init __PROTO((void));
+TERM_PUBLIC void BE_graphics __PROTO((void));
+TERM_PUBLIC void BE_text __PROTO((void));
+TERM_PUBLIC void BE_reset __PROTO((void));
+TERM_PUBLIC void BE_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void BE_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void BE_linewidth __PROTO((double lw));
+TERM_PUBLIC void BE_pointsize __PROTO((double ps));
+TERM_PUBLIC void BE_linetype __PROTO((int lt));
+TERM_PUBLIC void BE_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
+TERM_PUBLIC int BE_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC void BE_point __PROTO((unsigned int x, unsigned int y, int number));
+TERM_PUBLIC void BE_fillbox __PROTO((int style, unsigned int x, unsigned y, unsigned int width, unsigned int height));
+#define BE_XMAX 4096
+#define BE_YMAX 4096
+
+/* approximations for typical font/screen sizes */
+#define BE_VCHAR (BE_YMAX/25)
+#define BE_HCHAR (BE_XMAX/100)
+#define BE_VTIC (BE_YMAX/100)
+#define BE_HTIC (BE_XMAX/150)
+#endif
+
+
+#ifndef TERM_PROTO_ONLY
+
+#ifdef TERM_BODY
+
+/* non-zero if '-display' found on command line */
+int BE_Display = 0;
+
+static void BE_atexit __PROTO((void));
+
+typedef enum { hasNoArg, hasArg } OptionArg;
+
+static struct beopt {
+    const char *option;	/* Name of option */
+    OptionArg arg;	/* Whether option has argument */
+}  BE_cmdargs[] =
+{
+   { "-mono", hasNoArg }, { "-gray", hasNoArg }, { "-clear", hasNoArg },
+   { "-pointsize", hasArg },
+   { "-iconic", hasNoArg }, { "-rv", hasNoArg },
+   { "-reverse", hasNoArg }, { "+rv", hasNoArg },
+   { "-synchronous", hasNoArg },
+   { "-display", hasArg }, { "-geometry", hasArg }, { "-bg", hasArg },
+   { "-background", hasArg }, { "-bd", hasArg },
+   { "-bordercolor", hasArg }, { "-bw", hasArg },
+   { "-borderwidth", hasArg }, { "-fg", hasArg },
+   { "-foreground", hasArg }, { "-fn", hasArg }, { "-font", hasArg },
+   { "-name", hasArg },
+   { "-title", hasArg },
+   /* { "-xnllanguage", hasArg }, { "-xrm", hasArg }, */
+   { "-raise", hasNoArg }, { "-noraise", hasNoArg },
+   { "-persist", hasNoArg }
+};
+
+#define BE_nopts (sizeof(BE_cmdargs) / sizeof(BE_cmdargs[0]))
+
+static FILE *BE_ipc;
+
+static char **xargv = (char **)NULL;
+static char *optvec[2*BE_nopts+1];
+
+static char BE_command[] = "gnuplot_be";
+
+/* Almost not worth the hassle, be want a uniform interface */
+enum BE_id { BE_RESET, BE_OTHER };
+
+static struct gen_table BE_opts[] =
+{
+    { "res$et", BE_RESET },
+    { NULL, BE_OTHER }
+};
+
+static unsigned int BE_plot_number;
+
+TERM_PUBLIC void
+BE_options()
+{
+    struct value a;
+
+    while (!END_OF_COMMAND) {
+	switch(lookup_table(&BE_opts[0],c_token)) {
+	case BE_RESET:
+	    c_token++;
+	    BE_atexit ();	/* tell gnuplot_be to shut down */
+	    break;
+	case BE_OTHER:
+	default:
+	    BE_plot_number = (int) real(const_express(&a));
+	    /* let gnuplot_be check range */
+	    break;
+	}
+    }
+
+    sprintf(term_options, "%d", BE_plot_number);
+}
+
+
+/* BE_args - scan gnuplot command line for standard Toolkit options (to be
+ * done) called from plot.c so must not be TERM_PUBLIC (which may be static)
+ */
+
+int
+BE_args(int argc, char *argv[])
+{
+    int nbe = 0, i = 0, n;
+
+    xargv = (char **) gp_alloc (argc*sizeof(char *), "<xargv>");
+
+    if (!xargv) {
+	fputs ("not enough memory to copy argv - quitting\n", stderr);
+	exit (EXIT_FAILURE);
+    }
+
+    /* We make a copy of the argument vector because
+     * argv is modified later. */
+    memcpy (xargv, argv, argc*sizeof(char *));
+    optvec[i++] = BE_command;
+
+    while (++argv, --argc > 0) {
+	for (n = 0; n < BE_nopts; n++) {
+	    if (strcmp(*argv, BE_cmdargs[n].option) == 0) {
+		optvec[i++] = *xargv;
+		if (strcmp(*argv, "-display") == 0)
+		    BE_Display++;
+		if (BE_cmdargs[n].arg == hasArg) {
+		    if (--argc <= 0)
+			return nbe;
+		    optvec[i++] = *++xargv, ++argv;
+		    nbe++;
+		}
+		nbe++;
+		break;
+	    }
+	}
+	if (n == BE_nopts)
+	    break;
+    }
+    return nbe;
+}
+
+
+/* we do not want to have to duplicate all the code, so we
+ * do most of it with macros.
+ * PRINT0(format), PRINT1(format, p1), PRINT2(format, p1, p2) etc
+ * also  FLUSH0(format), etc, which do an additional flush
+ */
+
+
+/*
+ *   The Be terminal driver uses popen() pipe IPC
+ */
+static void
+BE_atexit ()
+{
+    if (BE_ipc) {
+	fputs("R\n", BE_ipc);
+	fclose(BE_ipc);
+	/* dont wait(), since they might be -persist */
+	BE_ipc = NULL;
+    }
+}
+
+TERM_PUBLIC void
+BE_init()
+{
+    if (!BE_ipc) {
+	/* first time through or after a reset */
+	int fdes[2];
+	pipe(fdes);
+	if (fork() == 0) {
+	    /* child */
+	    close(fdes[1]);
+	    dup2(fdes[0], 0);	/* stdin from pipe */
+	    execvp(BE_command, optvec);
+	    /* if we get here, something went wrong */
+	    perror("exec failed");
+	    exit(1);
+	}
+	/* parent */
+	close(fdes[0]);		/* read end of pipe */
+	BE_ipc = fdopen(fdes[1], "w");
+    } {
+	static int been_here = 0;
+	if (!been_here) {
+	    atexit(BE_atexit);
+	    been_here = 1;
+	}
+    }
+}
+
+TERM_PUBLIC void
+BE_reset()
+{
+    /* leave the pipe alone, until exit or  set term be reset */
+}
+
+#define PRINT0(fmt)		  			fprintf(BE_ipc, fmt)
+#define PRINT1(fmt,p1)	   			fprintf(BE_ipc, fmt,p1)
+#define PRINT2(fmt,p1,p2)			fprintf(BE_ipc, fmt,p1,p2)
+#define PRINT3(fmt,p1,p2,p3) 		fprintf(BE_ipc, fmt,p1,p2,p3)
+#define PRINT4(fmt,p1,p2,p3,p4) 	fprintf(BE_ipc, fmt,p1,p2,p3,p4)
+#define PRINT5(fmt,p1,p2,p3,p4,p5)	fprintf(BE_ipc, fmt,p1,p2,p3,p4,p5)
+
+#define FFLUSH()			 fflush(BE_ipc)
+
+#define BEFORE_GRAPHICS		/* nowt */
+#define AFTER_TEXT		/* nowt */
+
+
+/* common stuff, using macros defined above */
+
+
+TERM_PUBLIC void
+BE_graphics()
+{
+    BEFORE_GRAPHICS;		/* kludge for crippled select */
+    PRINT1("G%d\n", BE_plot_number);	/* for VMS sake, keep as separate prints */
+}
+
+TERM_PUBLIC void
+BE_text()
+{
+    PRINT0("E\n");
+    FFLUSH();
+    AFTER_TEXT;			/* kludge for crippled select */
+}
+
+
+TERM_PUBLIC void
+BE_move(unsigned int x, unsigned int y)
+{
+    PRINT2("M%04d%04d\n", x, y);
+}
+
+TERM_PUBLIC void
+BE_vector(unsigned int x, unsigned int y)
+{
+    PRINT2("V%04d%04d\n", x, y);
+}
+
+TERM_PUBLIC void
+BE_pointsize(double ps)
+{
+    if (ps < 0)
+	ps = 1;
+    PRINT2("P7%04d%04d\n",	/* size of point symbols */
+	   (int) (term->h_tic * ps * 0.5), (int) (term->v_tic * ps * 0.5));
+}
+
+TERM_PUBLIC void
+BE_linewidth(double lw)
+{
+    PRINT1("W%04d\n", (int) lw);
+}
+
+TERM_PUBLIC void
+BE_linetype(int lt)
+{
+    PRINT1("L%04d\n", lt);
+}
+
+TERM_PUBLIC void
+BE_put_text(unsigned int x, unsigned int y, const char str[])
+{
+    /* badly outrange labels can overflow into text field */
+    if (x < 10000 && y < 10000) {
+	PRINT3("T%04d%04d%s\n", x, y, str);
+    }
+}
+
+TERM_PUBLIC int
+BE_justify_text(enum JUSTIFY mode)
+{
+    PRINT1("J%04d\n", mode);
+    return (TRUE);
+}
+
+TERM_PUBLIC void
+BE_point(unsigned int x, unsigned int y, int number)
+{
+    if (number >= 0)
+	number %= POINT_TYPES;
+    number += 1;
+    PRINT3("P%01d%04d%04d\n", number, x, y);
+}
+
+TERM_PUBLIC void
+BE_fillbox(
+    int style;
+    unsigned int x, unsigned int y,
+    unsigned int w, unsigned int h)
+{
+    PRINT5("F%04d%04u%04u%04u%04u\n", style, x, y, w, h);
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(be_driver)
+    "be", "BeOS Window System",
+    BE_XMAX, BE_YMAX, BE_VCHAR, BE_HCHAR,
+    BE_VTIC, BE_HTIC, BE_options, BE_init, BE_reset,
+    BE_text, null_scale, BE_graphics, BE_move, BE_vector,
+    BE_linetype, BE_put_text, null_text_angle,
+    BE_justify_text, BE_point, do_arrow, set_font_null,
+    BE_pointsize, TERM_CAN_MULTIPLOT|TERM_NO_OUTPUTFILE,
+    BE_text /* suspend can use same routine */ , 0 /* resume */ ,
+    BE_fillbox, BE_linewidth
+TERM_TABLE_END(be_driver)
+
+#undef LAST_TERM
+#define LAST_TERM be_driver
+
+TERM_TABLE_START(BE_driver)
+    "BE", "BE Window System (identical to be)",
+    BE_XMAX, BE_YMAX, BE_VCHAR, BE_HCHAR,
+    BE_VTIC, BE_HTIC, BE_options, BE_init, BE_reset,
+    BE_text, null_scale, BE_graphics, BE_move, BE_vector,
+    BE_linetype, BE_put_text, null_text_angle,
+    BE_justify_text, BE_point, do_arrow, set_font_null,
+    BE_pointsize, TERM_CAN_MULTIPLOT,
+    BE_text /* suspend can use same routine */ , 0 /* resume */ ,
+    BE_fillbox, BE_linewidth
+TERM_TABLE_END(BE_driver)
+
+#undef LAST_TERM
+#define LAST_TERM be_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+
+#ifdef TERM_HELP
+START_HELP(be)
+"1 be",
+"?commands set terminal be",
+"?set terminal be",
+"?set term be",
+"?terminal be",
+"?term be",
+"?be",
+"?BE",
+" `gnuplot` provides the `be` terminal type for use with X servers.  This",
+" terminal type is set automatically at startup if the `DISPLAY` environment",
+" variable is set, if the `TERM` environment variable is set to `xterm`, or",
+" if the `-display` command line option is used.",
+"",
+" Syntax:",
+"           set terminal be {reset} {<n>}",
+"",
+" Multiple plot windows are supported: `set terminal be <n>` directs the",
+" output to plot window number n.  If n>0, the terminal number will be",
+" appended to the window title and the icon will be labeled `gplt <n>`.",
+" The active window may distinguished by a change in cursor (from default",
+" to crosshair.)",
+"",
+" Plot windows remain open even when the `gnuplot` driver is changed to a",
+" different device.  A plot window can be closed by pressing the letter q",
+" while that window has input focus, or by choosing `close` from a window",
+" manager menu.  All plot windows can be closed by specifying `reset`, which",
+" actually terminates the subprocess which maintains the windows (unless",
+" `-persist` was specified).",
+"",
+" Plot windows will automatically be closed at the end of the session",
+" unless the `-persist` option was given.",
+"",
+" The size or aspect ratio of a plot may be changed by resizing the `gnuplot`",
+" window.",
+"",
+" Linewidths and pointsizes may be changed from within `gnuplot` with",
+" `set linestyle`.",
+"",
+" For terminal type `be`, `gnuplot` accepts (when initialized) the standard",
+" X Toolkit options and resources such as geometry, font, and name from the",
+" command line arguments or a configuration file.  See the X(1) man page",
+" (or its equivalent) for a description of such options.",
+"",
+" A number of other `gnuplot` options are available for the `be` terminal.",
+" These may be specified either as command-line options when `gnuplot` is",
+" invoked or as resources in the configuration file \".Xdefaults\".  They are",
+" set upon initialization and cannot be altered during a `gnuplot` session.",
+"2 command-line_options",
+"?commands set terminal be command-line-options",
+"?set terminal be command-line-options",
+"?set term be command-line-options",
+"?be command-line-options",
+" In addition to the X Toolkit options, the following options may be specified",
+" on the command line when starting `gnuplot` or as resources in your",
+" \".Xdefaults\" file:",
+"@start table - first is interactive cleartext form",
+"  `-mono`        forces monochrome rendering on color displays.",
+"  `-gray`        requests grayscale rendering on grayscale or color displays.",
+"                         (Grayscale displays receive monochrome rendering by default.)",
+"  `-clear`   requests that the window be cleared momentarily before a",
+"                         new plot is displayed.",
+"  `-raise`   raises plot window after each plot",
+"  `-noraise` does not raise plot window after each plot",
+"  `-persist` plots windows survive after main gnuplot program exits",
+"#\\begin{tabular}{|cl|} \\hline",
+"#`-mono`  & forces monochrome rendering on color displays.\\\\",
+"#`-gray`  & requests grayscale rendering on grayscale or color displays.\\\\",
+"#                 & (Grayscale displays receive monochrome rendering by default.) \\\\",
+"#`-clear` & requests that the window be cleared momentarily before a\\\\",
+"#                 & new plot is displayed. \\\\",
+"#`-raise` & raises plot window after each plot. \\\\",
+"#`-noraise` & does not raise plot window after each plot. \\\\",
+"#`-persist`&plots windows survive after main gnuplot program exits. \\\\",
+"%c l .",
+"%`-mono`@forces monochrome rendering on color displays.",
+"%`-gray`@requests grayscale rendering on grayscale or color displays.",
+"%           @(Grayscale displays receive monochrome rendering by default.)",
+"%`-clear`@requests that the window be cleared momentarily before a",
+"%                @new plot is displayed.",
+"%`-raise`@raises plot window after each plot",
+"%`-noraise`@does not raise plot window after each plot",
+"%`-persist`@plots windows survive after main gnuplot program exits",
+"@end table",
+" The options are shown above in their command-line syntax.  When entered as",
+" resources in \".Xdefaults\", they require a different syntax.",
+"",
+" Example:",
+"           gnuplot*gray: on",
+"",
+" `gnuplot` also provides a command line option (`-pointsize <v>`) and a",
+" resource, `gnuplot*pointsize: <v>`, to control the size of points plotted",
+" with the `points` plotting style.  The value `v` is a real number (greater",
+" than 0 and less than or equal to ten) used as a scaling factor for point",
+" sizes.  For example, `-pointsize 2` uses points twice the default size, and",
+" `-pointsize 0.5` uses points half the normal size.",
+"2 monochrome_options",
+"?commands set terminal be monochrome_options",
+"?set terminal be monochrome_options",
+"?set term be monochrome_options",
+"?be monochrome_options",
+" For monochrome displays, `gnuplot` does not honor foreground or background",
+" colors.  The default is black-on-white.  `-rv` or `gnuplot*reverseVideo: on`",
+" requests white-on-black.",
+"",
+"2 color_resources",
+"?commands set terminal be color_resources",
+"?set terminal be color_resources",
+"?set term be color_resources",
+"?be color_resources",
+" For color displays, `gnuplot` honors the following resources (shown here",
+" with their default values) or the greyscale resources.  The values may be",
+" color names as listed in the BE rgb.txt file on your system, hexadecimal",
+" RGB color specifications (see BE documentation), or a color name followed",
+" by a comma and an `intensity` value from 0 to 1.  For example, `blue, 0.5`",
+" means a half intensity blue.",
+"@start table - first is interactive cleartext form",
+"  gnuplot*background:  white",
+"  gnuplot*textColor:   black",
+"  gnuplot*borderColor: black",
+"  gnuplot*axisColor:   black",
+"  gnuplot*line1Color:  red",
+"  gnuplot*line2Color:  green",
+"  gnuplot*line3Color:  blue",
+"  gnuplot*line4Color:  magenta",
+"  gnuplot*line5Color:  cyan",
+"  gnuplot*line6Color:  sienna",
+"  gnuplot*line7Color:  orange",
+"  gnuplot*line8Color:  coral",
+"#\\begin{tabular}{|cl|} \\hline",
+"#&gnuplot*background: white\\\\",
+"#&gnuplot*textColor: black\\\\",
+"#&gnuplot*borderColor: black\\\\",
+"#&gnuplot*axisColor: black\\\\",
+"#&gnuplot*line1Color: red\\\\",
+"#&gnuplot*line2Color: green\\\\",
+"#&gnuplot*line3Color: blue\\\\",
+"#&gnuplot*line4Color: magenta\\\\",
+"#&gnuplot*line5Color: cyan\\\\",
+"#&gnuplot*line6Color: sienna\\\\",
+"#&gnuplot*line7Color: orange\\\\",
+"#&gnuplot*line8Color: coral\\\\",
+"%c l .",
+"%@gnuplot*background: white",
+"%@gnuplot*textColor: black",
+"%@gnuplot*borderColor: black",
+"%@gnuplot*axisColor: black",
+"%@gnuplot*line1Color: red",
+"%@gnuplot*line2Color: green",
+"%@gnuplot*line3Color: blue",
+"%@gnuplot*line4Color: magenta",
+"%@gnuplot*line5Color: cyan",
+"%@gnuplot*line6Color: sienna",
+"%@gnuplot*line7Color: orange",
+"%@gnuplot*line8Color: coral",
+"@end table",
+"",
+" The command-line syntax for these is, for example,",
+"",
+" Example:",
+"           gnuplot -background coral",
+"",
+"2 grayscale_resources",
+"?commands set terminal be grayscale_resources",
+"?set terminal be grayscale_resources",
+"?set term be grayscale_resources",
+"?be grayscale_resources",
+" When `-gray` is selected, `gnuplot` honors the following resources for",
+" grayscale or color displays (shown here with their default values).  Note",
+" that the default background is black.",
+"@start table - first is interactive cleartext form",
+"  gnuplot*background: black",
+"  gnuplot*textGray:   white",
+"  gnuplot*borderGray: gray50",
+"  gnuplot*axisGray:   gray50",
+"  gnuplot*line1Gray:  gray100",
+"  gnuplot*line2Gray:  gray60",
+"  gnuplot*line3Gray:  gray80",
+"  gnuplot*line4Gray:  gray40",
+"  gnuplot*line5Gray:  gray90",
+"  gnuplot*line6Gray:  gray50",
+"  gnuplot*line7Gray:  gray70",
+"  gnuplot*line8Gray:  gray30",
+"#\\begin{tabular}{|cl|} \\hline",
+"#&gnuplot*background: black\\\\",
+"#&gnuplot*textGray: white\\\\",
+"#&gnuplot*borderGray: gray50\\\\",
+"#&gnuplot*axisGray: gray50\\\\",
+"#&gnuplot*line1Gray: gray100\\\\",
+"#&gnuplot*line2Gray: gray60\\\\",
+"#&gnuplot*line3Gray: gray80\\\\",
+"#&gnuplot*line4Gray: gray40\\\\",
+"#&gnuplot*line5Gray: gray90\\\\",
+"#&gnuplot*line6Gray: gray50\\\\",
+"#&gnuplot*line7Gray: gray70\\\\",
+"#&gnuplot*line8Gray: gray30\\\\",
+"%c l .",
+"%@gnuplot*background: black",
+"%@gnuplot*textGray: white",
+"%@gnuplot*borderGray: gray50",
+"%@gnuplot*axisGray: gray50",
+"%@gnuplot*line1Gray: gray100",
+"%@gnuplot*line2Gray: gray60",
+"%@gnuplot*line3Gray: gray80",
+"%@gnuplot*line4Gray: gray40",
+"%@gnuplot*line5Gray: gray90",
+"%@gnuplot*line6Gray: gray50",
+"%@gnuplot*line7Gray: gray70",
+"%@gnuplot*line8Gray: gray30",
+"@end table",
+"",
+"2 line_resources",
+"?commands set terminal be line_resources",
+"?set terminal be line_resources",
+"?set term be line_resources",
+"?be line_resources",
+" `gnuplot` honors the following resources for setting the width (in pixels) of",
+" plot lines (shown here with their default values.)  0 or 1 means a minimal",
+" width line of 1 pixel width.  A value of 2 or 3 may improve the appearance of",
+" some plots.",
+"@start table - first is interactive cleartext form",
+"  gnuplot*borderWidth: 2",
+"  gnuplot*axisWidth:   0",
+"  gnuplot*line1Width:  0",
+"  gnuplot*line2Width:  0",
+"  gnuplot*line3Width:  0",
+"  gnuplot*line4Width:  0",
+"  gnuplot*line5Width:  0",
+"  gnuplot*line6Width:  0",
+"  gnuplot*line7Width:  0",
+"  gnuplot*line8Width:  0",
+"#\\begin{tabular}{|cl|} \\hline",
+"#&gnuplot*borderWidth: 2\\\\",
+"#&gnuplot*axisWidth: 0\\\\",
+"#&gnuplot*line1Width: 0\\\\",
+"#&gnuplot*line2Width: 0\\\\",
+"#&gnuplot*line3Width: 0\\\\",
+"#&gnuplot*line4Width: 0\\\\",
+"#&gnuplot*line5Width: 0\\\\",
+"#&gnuplot*line6Width: 0\\\\",
+"#&gnuplot*line7Width: 0\\\\",
+"#&gnuplot*line8Width: 0\\\\",
+"%c l .",
+"%@gnuplot*borderWidth: 2",
+"%@gnuplot*axisWidth: 0",
+"%@gnuplot*line1Width: 0",
+"%@gnuplot*line2Width: 0",
+"%@gnuplot*line3Width: 0",
+"%@gnuplot*line4Width: 0",
+"%@gnuplot*line5Width: 0",
+"%@gnuplot*line6Width: 0",
+"%@gnuplot*line7Width: 0",
+"%@gnuplot*line8Width: 0",
+"@end table",
+"",
+" `gnuplot` honors the following resources for setting the dash style used for",
+" plotting lines.  0 means a solid line.  A two-digit number `jk` (`j` and `k`",
+" are >= 1  and <= 9) means a dashed line with a repeated pattern of `j` pixels",
+" on followed by `k` pixels off.  For example, '16' is a \"dotted\" line with one",
+" pixel on followed by six pixels off.  More elaborate on/off patterns can be",
+" specified with a four-digit value.  For example, '4441' is four on, four off,",
+" four on, one off.  The default values shown below are for monochrome displays",
+" or monochrome rendering on color or grayscale displays.  For color displays,",
+" the default for each is 0 (solid line) except for `axisDashes` which defaults",
+" to a '16' dotted line.",
+"@start table - first is interactive cleartext form",
+"  gnuplot*borderDashes:   0",
+"  gnuplot*axisDashes:        16",
+"  gnuplot*line1Dashes:        0",
+"  gnuplot*line2Dashes:   42",
+"  gnuplot*line3Dashes:   13",
+"  gnuplot*line4Dashes:   44",
+"  gnuplot*line5Dashes:   15",
+"  gnuplot*line6Dashes: 4441",
+"  gnuplot*line7Dashes:   42",
+"  gnuplot*line8Dashes:   13",
+"#\\begin{tabular}{|cl|} \\hline",
+"#&gnuplot*borderDashes: 0\\\\",
+"#&gnuplot*axisDashes: 16\\\\",
+"#&gnuplot*line1Dashes: 0\\\\",
+"#&gnuplot*line2Dashes: 42\\\\",
+"#&gnuplot*line3Dashes: 13\\\\",
+"#&gnuplot*line4Dashes: 44\\\\",
+"#&gnuplot*line5Dashes: 15\\\\",
+"#&gnuplot*line6Dashes: 4441\\\\",
+"#&gnuplot*line7Dashes: 42\\\\",
+"#&gnuplot*line8Dashes: 13\\\\",
+"%c l .",
+"%@gnuplot*borderDashes: 0",
+"%@gnuplot*axisDashes: 16",
+"%@gnuplot*line1Dashes: 0",
+"%@gnuplot*line2Dashes: 42",
+"%@gnuplot*line3Dashes: 13",
+"%@gnuplot*line4Dashes: 44",
+"%@gnuplot*line5Dashes: 15",
+"%@gnuplot*line6Dashes: 4441",
+"%@gnuplot*line7Dashes: 42",
+"%@gnuplot*line8Dashes: 13",
+"@end table"
+END_HELP(be)
+#endif /* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/cairo.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/cairo.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/cairo.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/cairo.trm.svn-base	2012-01-03 17:07:25.502112500 -0800
@@ -0,0 +1,1090 @@
+/*
+ * $Id: cairo.trm,v 1.29.2.3 2009/09/13 17:54:09 sfeam Exp $
+ */
+
+/* GNUPLOT - cairo.trm */
+
+/*[
+ * Copyright 2007   Timothee Lecomte
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * Modifications:
+ *	Peter Danenberg, Ethan Merritt	- handle png output as well as pdf
+ *	Peter Danenberg - crop for PNGs
+ */
+
+#ifdef TERM_REGISTER
+register_term (pdfcairo)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void cairotrm_options __PROTO ((void));
+TERM_PUBLIC void cairotrm_init __PROTO ((void));
+TERM_PUBLIC void cairotrm_graphics __PROTO ((void));
+TERM_PUBLIC void cairotrm_text __PROTO ((void));
+TERM_PUBLIC void cairotrm_linetype __PROTO ((int linetype));
+TERM_PUBLIC void cairotrm_move __PROTO ((unsigned int x, unsigned int y));
+TERM_PUBLIC void cairotrm_vector __PROTO ((unsigned int x, unsigned int y));
+TERM_PUBLIC void cairotrm_put_text __PROTO ((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC void cairotrm_enhanced_flush();
+TERM_PUBLIC void cairotrm_enhanced_writec(int c);
+TERM_PUBLIC void cairotrm_enhanced_open(char* fontname, double fontsize, double base, TBOOLEAN widthflag, TBOOLEAN showflag, int overprint);
+TERM_PUBLIC void cairotrm_reset __PROTO ((void));
+TERM_PUBLIC int cairotrm_justify_text __PROTO ((enum JUSTIFY mode));
+TERM_PUBLIC void cairotrm_point __PROTO ((unsigned int x, unsigned int y, int pointstyle));
+TERM_PUBLIC void cairotrm_linewidth __PROTO ((double linewidth));
+TERM_PUBLIC int cairotrm_text_angle __PROTO ((int ang));
+TERM_PUBLIC void cairotrm_fillbox __PROTO ((int style, unsigned int x1, unsigned int y1, unsigned int width, unsigned int height));
+TERM_PUBLIC int cairotrm_set_font __PROTO ((const char *font));
+TERM_PUBLIC void cairotrm_pointsize __PROTO ((double ptsize));
+TERM_PUBLIC void cairotrm_image __PROTO ((unsigned int M, unsigned int N, coordval * image, gpiPoint * corner, t_imagecolor color_mode));
+TERM_PUBLIC int cairotrm_make_palette __PROTO ((t_sm_palette *palette));
+TERM_PUBLIC void cairotrm_set_color __PROTO ((t_colorspec *colorspec));
+TERM_PUBLIC void cairotrm_filled_polygon __PROTO ((int n, gpiPoint * corners));
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+
+#ifdef TERM_BODY
+
+#include "cairo-pdf.h"
+#include "wxterminal/gp_cairo.h"
+#include "wxterminal/gp_cairo_helpers.h"
+#include "glib.h"		/* For guint32 */
+
+#define CAIROTRM_DEFAULT_FONTNAME "Sans"
+
+/* terminal state */
+TBOOLEAN cairotrm_enhanced_enabled = FALSE;
+TBOOLEAN cairotrm_dashed = FALSE;
+TBOOLEAN cairotrm_mono = FALSE;
+TBOOLEAN cairotrm_rounded = FALSE;
+TBOOLEAN cairotrm_transparent = FALSE;
+TBOOLEAN cairotrm_crop = FALSE;
+/* default text font family: */
+char cairotrm_set_fontname[MAX_ID_LEN + 1] = "";
+/* default text size*/
+int cairotrm_set_fontsize = 0;
+
+/* default sizes vary with the terminal type */
+#define CAIROPDF_DEFAULT_WIDTH  5*72 /* PDF  5x3 inches */
+#define CAIROPDF_DEFAULT_HEIGHT 3*72
+#define CAIROPNG_DEFAULT_WIDTH  640  /* PNG 640x480 pixels */
+#define CAIROPNG_DEFAULT_HEIGHT 480
+float cairopdf_width = CAIROPDF_DEFAULT_WIDTH;
+float cairopdf_height = CAIROPDF_DEFAULT_HEIGHT;
+float cairopng_width = CAIROPNG_DEFAULT_WIDTH;
+float cairopng_height = CAIROPNG_DEFAULT_HEIGHT;
+float cairotrm_width, cairotrm_height;
+float cairotrm_default_fontsize;
+
+float cairopdf_base_linewidth = 0.25;
+float cairopng_base_linewidth = 1.0;
+float cairotrm_base_linewidth;
+
+/* Default multipliers for linewidths and dashlengths */
+float cairotrm_lw = 1.0;
+float cairotrm_dl = 1.0;
+
+
+plot_struct plot;
+
+enum CAIROTRM_id {
+    CAIROTRM_FONT,
+    CAIROTRM_ENHANCED,
+    CAIROTRM_NOENHANCED,
+    CAIROTRM_SIZE,
+    CAIROTRM_ROUNDED,
+    CAIROTRM_BUTT,
+    CAIROTRM_LINEWIDTH,
+    CAIROTRM_DASHED,
+    CAIROTRM_SOLID,
+    CAIROTRM_MONO,
+    CAIROTRM_COLOR,
+    CAIROTRM_DASHLENGTH,
+    CAIROTRM_TRANSPARENT,
+    CAIROTRM_NOTRANSPARENT,
+    CAIROTRM_CROP,
+    CAIROTRM_NOCROP,
+    CAIROTRM_OTHER
+};
+
+static struct gen_table cairotrm_opts[] = {
+    {"f$ont",   CAIROTRM_FONT},
+    {"enh$anced", CAIROTRM_ENHANCED},
+    {"noenh$anced", CAIROTRM_NOENHANCED},
+    {"si$ze", CAIROTRM_SIZE},
+    {"round$ed", CAIROTRM_ROUNDED},
+    {"butt", CAIROTRM_BUTT},
+    {"lw", CAIROTRM_LINEWIDTH},
+    {"linew$idth", CAIROTRM_LINEWIDTH},
+    {"dash$ed", CAIROTRM_DASHED},
+    {"solid", CAIROTRM_SOLID},
+    {"mono$chrome", CAIROTRM_MONO},
+    {"color", CAIROTRM_COLOR},
+    {"col$our", CAIROTRM_COLOR},
+    {"dl", CAIROTRM_DASHLENGTH},
+    {"dashl$ength", CAIROTRM_DASHLENGTH},
+    {"transp$arent", CAIROTRM_TRANSPARENT},
+    {"notransp$arent", CAIROTRM_NOTRANSPARENT},
+    {"crop", CAIROTRM_CROP},
+    {"nocrop", CAIROTRM_NOCROP},
+    {NULL, CAIROTRM_OTHER}
+};
+
+/* "Called when terminal type is selected. This procedure should parse options on the command line.
+* A list of the currently selected options should be stored in term_options[],
+* in a form suitable for use with the set term command.
+* term_options[] is used by the save command.  Use options_null() if no options are available." */
+TERM_PUBLIC void cairotrm_options()
+{
+	char *s = NULL;
+	char *font_setting = NULL;
+	int sep;
+	TBOOLEAN duplication = FALSE;
+	TBOOLEAN set_enhanced = FALSE, set_font = FALSE, set_size = FALSE;
+	TBOOLEAN set_capjoin = FALSE;
+	size_units cairotrm_explicit_units;
+	char tmp_term_options[MAX_LINE_LEN+1] = "";
+#if 0
+	/* terminals should not reset options during "set term" call */
+	cairotrm_dashed = FALSE;	/* Dashed lines? (default is solid) */
+	cairotrm_mono = FALSE;  	/* Mono? (default is color) */
+	cairotrm_transparent = FALSE;
+	cairotrm_crop = FALSE;
+#endif
+
+	/* Initialize terminal-dependent values */
+	if (!strcmp(term->name,"pngcairo")) {
+		cairotrm_explicit_units = PIXELS;
+		cairotrm_default_fontsize = 12;
+	} else {
+		cairotrm_explicit_units = INCHES;
+		cairotrm_default_fontsize = 6;
+	}
+
+	while (!END_OF_COMMAND) {
+		FPRINTF((stderr, "processing token\n"));
+		switch (lookup_table(&cairotrm_opts[0], c_token)) {
+		case CAIROTRM_FONT:
+			c_token++;
+			if (!(s = try_to_get_string()))
+				int_error(c_token,"font: expecting string");
+			if (!(*s)) {
+				strcpy (cairotrm_set_fontname, "");
+				cairotrm_set_fontsize = 0;
+			} else {
+				sep = strcspn(s,",");
+				if (sep > 0) {
+					strncpy(cairotrm_set_fontname, s, sep);
+					cairotrm_set_fontname[sep] = '\0';
+				}
+				if (s[sep] == ',')
+					sscanf(&(s[sep+1]), "%d", &cairotrm_set_fontsize);
+			}
+			font_setting = (char*) gp_alloc(strlen(s) + 1,"cairo terminal font");
+			strcpy(font_setting,s);
+			free(s);
+			if (set_font) duplication=TRUE;
+			set_font = TRUE;
+			break;
+		case CAIROTRM_ENHANCED:
+			c_token++;
+			cairotrm_enhanced_enabled = TRUE;
+			term->flags |= TERM_ENHANCED_TEXT;
+			if (set_enhanced) duplication=TRUE;
+			set_enhanced = TRUE;
+			break;
+		case CAIROTRM_NOENHANCED:
+			c_token++;
+			cairotrm_enhanced_enabled = FALSE;
+			term->flags &= ~TERM_ENHANCED_TEXT;
+			if (set_enhanced) duplication=TRUE;
+			set_enhanced = TRUE;
+			break;
+		case CAIROTRM_SIZE:
+			c_token++;
+			if (!strcmp(term->name,"pngcairo"))
+			    cairotrm_explicit_units = parse_term_size(&cairopng_width, &cairopng_height, PIXELS);
+			else
+			    cairotrm_explicit_units = parse_term_size(&cairopdf_width, &cairopdf_height, INCHES);
+			if (set_size) duplication=TRUE;
+			set_size = TRUE;
+			break;
+		case CAIROTRM_ROUNDED:
+			c_token++;
+			if (set_capjoin) duplication=TRUE;
+			cairotrm_rounded = TRUE;
+			set_capjoin = TRUE;
+			break;
+		case CAIROTRM_BUTT:
+			c_token++;
+			if (set_capjoin) duplication=TRUE;
+			cairotrm_rounded = FALSE;
+			set_capjoin = TRUE;
+			break;
+		case CAIROTRM_LINEWIDTH:
+			c_token++;
+			cairotrm_lw = real_expression();
+			if (cairotrm_lw < 0.0)
+			    cairotrm_lw = 1.0;
+			break;
+		case CAIROTRM_DASHED:
+			c_token++;
+			cairotrm_dashed = TRUE;
+			break;
+		case CAIROTRM_SOLID:
+			c_token++;
+			cairotrm_dashed = FALSE;
+			break;
+		case CAIROTRM_MONO:
+			c_token++;
+			cairotrm_mono = TRUE;
+			term->flags |= TERM_MONOCHROME;
+			break;
+		case CAIROTRM_COLOR:
+			c_token++;
+			cairotrm_mono = FALSE;
+			term->flags &= ~TERM_MONOCHROME;
+			break;
+		case CAIROTRM_DASHLENGTH:
+			c_token++;
+			cairotrm_dl = real_expression();
+			if (cairotrm_dl < 0.0)
+			    cairotrm_dl = 1.0;
+			break;
+		case CAIROTRM_TRANSPARENT:
+			c_token++;
+			if (!strcmp(term->name,"pngcairo"))
+			    cairotrm_transparent = TRUE;
+			break;
+		case CAIROTRM_NOTRANSPARENT:
+			c_token++;
+			if (!strcmp(term->name,"pngcairo"))
+			    cairotrm_transparent = FALSE;
+			break;
+		case CAIROTRM_CROP:
+			c_token++;
+			if (!strcmp(term->name,"pngcairo"))
+			    cairotrm_crop = TRUE;
+			break;
+		case CAIROTRM_NOCROP:
+			c_token++;
+			if (!strcmp(term->name,"pngcairo"))
+			    cairotrm_crop = FALSE;
+			break;
+		case CAIROTRM_OTHER:
+			/* Ignore irrelevant keywords used by other png/pdf drivers */
+			if (almost_equals(c_token,"true$color")
+			||  almost_equals(c_token,"inter$lace")
+			||  almost_equals(c_token,"nointer$lace")) {
+			    c_token++;
+			    break;
+			}
+		default:
+			int_error(c_token, "unrecognized terminal option");
+			break;
+		}
+
+		if (duplication)
+			int_error(c_token-1, "Duplicated or contradicting arguments in cairo terminal options.");
+	}
+
+	/* Copy terminal-dependent values to the generic equivalent */
+	if (!strcmp(term->name,"pngcairo")) {
+		cairotrm_width = cairopng_width;
+		cairotrm_height = cairopng_height;
+		cairotrm_base_linewidth = cairopng_base_linewidth;
+	} else {
+		cairotrm_width = cairopdf_width;
+		cairotrm_height = cairopdf_height;
+		cairotrm_base_linewidth = cairopdf_base_linewidth;
+	}
+
+
+	/* Save options back into options string in normalized format */
+	if (cairotrm_transparent)
+		strncat(term_options, " transparent", sizeof(term_options)-strlen(term_options));
+
+	if (cairotrm_crop)
+		strncat(term_options, " crop", sizeof(term_options)-strlen(term_options));
+
+	if (set_enhanced)
+		strncat(term_options, " enhanced", sizeof(term_options)-strlen(term_options));
+
+	if (set_font) {
+		snprintf(tmp_term_options, sizeof(tmp_term_options), " font \"%s\"", font_setting);
+		free(font_setting);
+		strncat(term_options, tmp_term_options, sizeof(term_options)-strlen(term_options));
+	}
+
+	if (cairotrm_mono)
+		strncat(term_options, " monochrome", sizeof(term_options)-strlen(term_options));
+
+	if (cairotrm_dashed)
+		strncat(term_options, " dashed", sizeof(term_options)-strlen(term_options));
+
+	if (1 || set_size) {
+		if (cairotrm_explicit_units == CM)
+			snprintf(tmp_term_options,
+				sizeof(tmp_term_options),
+				" size %.2fcm, %.2fcm ",
+				2.54*cairotrm_width/72., 2.54*cairotrm_height/72.);
+		else if (cairotrm_explicit_units == PIXELS)
+			snprintf(tmp_term_options,
+				sizeof(tmp_term_options),
+				" size %d, %d ",
+				(int)cairotrm_width, (int)cairotrm_height);
+		else
+			snprintf(tmp_term_options,
+				sizeof(tmp_term_options),
+				" size %.2fin, %.2fin ",
+				cairotrm_width/72., cairotrm_height/72.);
+		strncat(term_options, tmp_term_options, sizeof(term_options)-strlen(term_options));
+	}
+
+	if (set_capjoin) {
+		strncat(term_options, cairotrm_rounded ? " rounded" : " butt",
+			sizeof(term_options)-strlen(term_options));
+	}
+
+	if (cairotrm_lw != 1.0) {
+		snprintf(tmp_term_options,sizeof(tmp_term_options), " linewidth %g", cairotrm_lw);
+		strncat(term_options, tmp_term_options, sizeof(term_options)-strlen(term_options));
+	}
+
+	if (cairotrm_dl != 1.0) {
+		snprintf(tmp_term_options,sizeof(tmp_term_options), " dashlength %g", cairotrm_dl);
+		strncat(term_options, tmp_term_options, sizeof(term_options)-strlen(term_options));
+	}
+}
+
+/* "Called once, when the device is first selected."
+ * Is the 'main' function of the terminal. */
+void cairotrm_init()
+{
+	cairo_surface_t *surface = NULL;
+
+	FPRINTF((stderr,"Init\n"));
+
+	/* do a sanity check for once */
+	if (strcmp(term->name,"pdfcairo") && strcmp(term->name,"pngcairo"))
+		int_error(c_token,"Unrecognized cairo terminal");
+
+	/* initialisations */
+	gp_cairo_initialize_plot(&plot);
+	plot.device_xmax = (double) cairotrm_width;
+	plot.device_ymax = (double) cairotrm_height;
+	plot.dashlength = cairotrm_dl;
+
+	/* is supposed to be done in cairotrm_reset */
+	if ( plot.cr )
+		cairo_destroy(plot.cr);
+
+	if (!strcmp(term->name,"pdfcairo")) {
+		surface = cairo_pdf_surface_create(outstr,
+				plot.device_xmax /*double width_in_points*/,
+				plot.device_ymax /*double height_in_points*/);
+		/* it is up to the pdf viewer to do the hinting */
+		plot.hinting = 0;
+		/* disable OPERATOR_SATURATE, not implemented in cairo pdf backend,
+		 * results in bitmap fallback. However, polygons are drawn with seams
+		 * between each other. */
+		plot.polygons_saturate = FALSE;
+		/* Empirical correction to make pdf output look more like wxt and png */
+		plot.dashlength /= 2;
+	} else if (!strcmp(term->name,"pngcairo")) {
+		surface = cairo_image_surface_create( CAIRO_FORMAT_ARGB32,
+				plot.device_xmax /*double width_in_points*/,
+				plot.device_ymax /*double height_in_points*/);
+		/* png is bitmapped, let's do the full hinting */
+		plot.hinting = 100;
+		/* png is produced by cairo "image" backend, which has full support
+		 * of OPERATOR_SATURATE */
+		plot.polygons_saturate = TRUE;
+	}
+
+	plot.cr = cairo_create(surface);
+	cairo_surface_destroy( surface );
+
+	FPRINTF((stderr,"status = %s\n",cairo_status_to_string(cairo_status(plot.cr))));
+	FPRINTF((stderr,"Init finished \n"));
+}
+
+/* "Called just before a plot is going to be displayed."
+ * Should clear the terminal. */
+void cairotrm_graphics()
+{
+	/* Initialize background to solid white */
+	if (cairotrm_transparent)
+		gp_cairo_clear_background(&plot);
+	else
+		gp_cairo_solid_background(&plot);
+
+
+	/* update the window scale factor first, cairo needs it */
+	plot.xscale = 1.0;
+	plot.yscale = 1.0;
+
+	/* update graphics state properties */
+	plot.rounded = cairotrm_rounded;
+
+	FPRINTF((stderr,"Graphics1\n"));
+
+	/* set the transformation matrix of the context, and other details */
+	/* depends on plot.xscale and plot.yscale */
+	gp_cairo_initialize_context(&plot);
+
+	/* set or refresh terminal size according to the window size */
+	/* oversampling_scale is updated in gp_cairo_initialize_context */
+	term->xmax = (unsigned int) plot.device_xmax*plot.oversampling_scale;
+	term->ymax = (unsigned int) plot.device_ymax*plot.oversampling_scale;
+	term->tscale = plot.oversampling_scale;
+	plot.xmax = term->xmax;
+	plot.ymax = term->ymax;
+	/* initialize encoding */
+	plot.encoding = encoding;
+
+	/* set font details (h_char, v_char) according to settings */
+	cairotrm_set_font("");
+
+	term->v_tic = (unsigned int) (term->v_char/2.5);
+	term->h_tic = (unsigned int) (term->v_char/2.5);
+
+	FPRINTF((stderr,"Graphics xmax %d ymax %d v_char %d h_char %d\n",
+		term->xmax, term->ymax, term->v_char, term->h_char));
+}
+
+
+/* cairo mechanism to allow writing to an output stream */
+cairo_status_t
+cairopng_write(void *closure, unsigned char *data, unsigned int length)
+{
+	if (length != fwrite(data, 1, length, gpoutfile))
+		return CAIRO_STATUS_WRITE_ERROR;
+	return CAIRO_STATUS_SUCCESS;
+}
+
+cairo_surface_t *
+cairopng_do_crop()
+{
+  cairo_surface_t *surface = cairo_get_target(plot.cr);
+  unsigned char *data = cairo_image_surface_get_data(surface);
+  int width = cairo_image_surface_get_width(surface);
+  int height = cairo_image_surface_get_height(surface);
+  int stride = cairo_image_surface_get_stride(surface);
+  int  i, j, x1 = 0, y1 = 0, x2 = width, y2 = height;
+
+  guint32 *row;
+  guint32 BG = (cairotrm_transparent) ? 0x0 : ~0x0;
+
+  /* return unadulterated surface if we're not cropping */
+  if (!cairotrm_crop)
+	return(surface);
+
+  /* Row-wise, top-down iteration */
+  for (i = 0; i < height; i++) {
+    row = (guint32 *) (data + i * stride);
+    for (j = 0; j < width; j++) {
+      if (row[j] != BG) {
+	y1 = i;
+	goto found_y1;
+      }
+    }
+  }
+ found_y1:
+  /* Row-wise, bottom-up iteration */
+  for (i = height - 1; i >= y1; i--) {
+    row = (guint32 *)(data + i * stride);
+    for (j = 0; j < width; j++) {
+      if (row[j] != BG) {
+	y2 = i;
+	goto found_y2;
+      }
+    }
+  }
+ found_y2:
+  /* Column-wise, left-to-right iteration */
+  for (j = 0; j < width; j++) {
+    for (i = y1; i <= y2; i++) {
+      row = (guint32 *) (data + i * stride);
+      if (row[j] != BG) {
+	x1 = j;
+	goto found_x1;
+      }
+    }
+  }
+ found_x1:
+  /* Column-wise, right-to-left iteration */
+  for (j = width - 1; j >= x1; j--) {
+    for (i = y1; i <= y2; i++) {
+      row = (guint32 *) (data + i * stride);
+      if (row[j] != BG) {
+	x2 = j;
+	goto found_x2;
+      }
+    }
+  }
+ found_x2:
+  {
+  const int padding = 10;
+  int clip_width = GPMIN(x2 - x1 + padding, width);
+  int clip_height = GPMIN(y2 - y1 + padding, height);
+  cairo_surface_t *clip = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, 
+  			clip_width, clip_height);
+  cairo_t *clip_cr = cairo_create(clip);
+  cairo_set_source_surface(clip_cr, cairo_get_target(plot.cr),
+			-GPMAX(x1 - padding / 2, 0),
+			-GPMAX(y1 - padding / 2, 0));
+  cairo_rectangle(clip_cr, 0, 0, clip_width, clip_height);
+  cairo_fill(clip_cr);
+  return clip;
+  }
+}
+
+void cairotrm_text()
+{
+	FPRINTF((stderr,"Text0\n"));
+
+	/* don't forget to stroke the last path if vector was the last command */
+	gp_cairo_stroke(&plot);
+	/* and don't forget to draw the polygons if draw_polygon was the last command */
+	gp_cairo_end_polygon(&plot);
+
+	FPRINTF((stderr,"status = %s\n",cairo_status_to_string(cairo_status(plot.cr))));
+
+	/* finish the page - cairo_destroy still has to be called for the whole documentation
+	 * to be written */
+	cairo_show_page(plot.cr);
+	if (!strcmp(term->name,"pngcairo")) {
+		int error_data[1];
+		cairo_surface_write_to_png_stream(cairopng_do_crop(),
+			(cairo_write_func_t)cairopng_write, error_data);
+	}
+
+	FPRINTF((stderr,"status = %s\n",cairo_status_to_string(cairo_status(plot.cr))));
+
+	FPRINTF((stderr,"Text finished\n"));
+}
+
+/* sent when gnuplot exits and when the terminal or the output change.*/
+void cairotrm_reset()
+{
+	/* finish the document */
+	cairo_destroy(plot.cr);
+
+	FPRINTF((stderr,"cairotrm_reset\n"));
+}
+
+void cairotrm_move(unsigned int x, unsigned int y)
+{
+	gp_cairo_move(&plot, x, term->ymax - y);
+}
+
+void cairotrm_vector(unsigned int x, unsigned int y)
+{
+	gp_cairo_vector(&plot, x, term->ymax - y);
+}
+
+void cairotrm_put_text(unsigned int x, unsigned int y, const char * string)
+{
+	/* if ignore_enhanced_text is set, draw with the normal routine.
+	 * This is meant to avoid enhanced syntax when the enhanced mode is on */
+	if (cairotrm_enhanced_enabled && !ignore_enhanced_text) {
+		/* Uses enhanced_recursion() to analyse the string to print.
+		 * enhanced_recursion() calls _enhanced_open() to initialize the text drawing,
+		 * then it calls _enhanced_writec() which buffers the characters to draw,
+		 * and finally _enhanced_flush() to draw the buffer with the correct justification. */
+
+		gp_cairo_enhanced_init(&plot, strlen(string));
+
+		/* set up the global variables needed by enhanced_recursion() */
+		enhanced_fontscale = 1.0;
+		strncpy(enhanced_escape_format, "%c", sizeof(enhanced_escape_format));
+
+		/* Set the recursion going. We say to keep going until a
+		* closing brace, but we don't really expect to find one.
+		* If the return value is not the nul-terminator of the
+		* string, that can only mean that we did find an unmatched
+		* closing brace in the string. We inplot->crement past it (else
+		* we get stuck in an infinite loop) and try again. */
+
+		while (*(string = enhanced_recursion((char*)string, TRUE, plot.fontname,
+				plot.fontsize, 0.0, TRUE, TRUE, 0))) {
+			cairotrm_enhanced_flush();
+
+			/* we can only get here if *str == '}' */
+			enh_err_check(string);
+
+			if (!*++string)
+				break; /* end of string */
+			/* else carry on and process the rest of the string */
+		}
+
+		/* finish */
+		gp_cairo_enhanced_finish(&plot, x, term->ymax - y);
+		return;
+	}
+
+	gp_cairo_draw_text(&plot, x, term->ymax - y, string);
+}
+
+void cairotrm_enhanced_flush()
+{
+	gp_cairo_enhanced_flush(&plot);
+}
+
+void cairotrm_enhanced_writec(int c)
+{
+	gp_cairo_enhanced_writec(&plot, c);
+}
+
+void cairotrm_enhanced_open(char* fontname, double fontsize, double base, TBOOLEAN widthflag, TBOOLEAN showflag, int overprint)
+{
+	gp_cairo_enhanced_open(&plot, fontname, fontsize, base, widthflag, showflag, overprint);
+}
+
+void cairotrm_linetype(int lt)
+{
+	gp_cairo_set_linetype(&plot, lt);
+
+	if (cairotrm_dashed || lt == -1)
+	    gp_cairo_set_linestyle(&plot,  GP_CAIRO_DASH);
+	else
+	    gp_cairo_set_linestyle(&plot,  GP_CAIRO_SOLID);
+
+	if (cairotrm_mono && lt >= -1)
+	    gp_cairo_set_color(&plot, gp_cairo_linetype2color( -1 ));
+	else
+	    gp_cairo_set_color(&plot, gp_cairo_linetype2color( lt ));
+
+}
+
+
+/* - fonts are selected as strings "name,size".
+ * - _set_font("") restores the terminal's default font.*/
+int cairotrm_set_font (const char *font)
+{
+	char fontname[MAX_ID_LEN + 1] = "";
+	int fontsize = 0;
+
+	if (!font || !(*font)) {
+		strncpy(fontname, "", sizeof(fontname));
+		fontsize = 0;
+	} else {
+		int sep;
+
+		sep = strcspn(font,",");
+		if (sep > 0) {
+			strncpy(fontname, font, sep);
+			fontname[sep] = '\0';
+		}
+		if (font[sep] == ',')
+			sscanf(&(font[sep+1]), "%d", &fontsize);
+	}
+
+	if ( strlen(fontname) == 0 ) {
+		if ( strlen(cairotrm_set_fontname) == 0 )
+			strncpy(fontname, CAIROTRM_DEFAULT_FONTNAME, sizeof(fontname));
+		else
+			strncpy(fontname, cairotrm_set_fontname, sizeof(fontname));
+	}
+
+	if ( fontsize == 0 ) {
+		if ( cairotrm_set_fontsize == 0 )
+			fontsize = cairotrm_default_fontsize;
+		else
+			fontsize = cairotrm_set_fontsize;
+	}
+
+
+	/* Reset the term variables (hchar, vchar, h_tic, v_tic).
+	 * They may be taken into account in next plot commands */
+	gp_cairo_set_font(&plot, fontname, fontsize);
+	gp_cairo_set_termvar(&plot, &(term->v_char),
+				    &(term->h_char));
+
+	/* the returned int is not used anywhere */
+	return 1;
+}
+	
+
+int cairotrm_justify_text(enum JUSTIFY mode)
+{
+	gp_cairo_set_justify(&plot,mode);
+
+	return 1; /* we can justify */
+}
+
+void cairotrm_point(unsigned int x, unsigned int y, int pointstyle)
+{
+	gp_cairo_draw_point(&plot, x, term->ymax - y, pointstyle);
+}
+
+void cairotrm_pointsize(double ptsize)
+{
+	/* same behaviour as x11 terminal */
+	if (ptsize<0) ptsize = 1;
+
+	gp_cairo_set_pointsize(&plot, ptsize);
+}
+
+void cairotrm_linewidth(double lw)
+{
+	lw *= cairotrm_lw * cairotrm_base_linewidth;
+	gp_cairo_set_linewidth(&plot, lw);
+}
+
+int cairotrm_text_angle(int angle)
+{
+	/* a double is needed to compute cos, sin, etc. */
+	gp_cairo_set_textangle(&plot, (double) angle);
+
+	return 1; /* 1 means we can rotate */
+}
+
+void cairotrm_fillbox(int style, unsigned int x, unsigned int y, unsigned int width, unsigned int height)
+{
+	gp_cairo_draw_fillbox(&plot, x, term->ymax - y,
+				width, height,
+				style);
+}
+
+int cairotrm_make_palette(t_sm_palette * palette)
+{
+	/* we can do continuous colors */
+	return 0;
+}
+
+void cairotrm_set_color(t_colorspec *colorspec)
+{
+	rgb_color rgb1;
+
+	if (colorspec->type == TC_LT) {
+		rgb1 = gp_cairo_linetype2color(colorspec->lt);
+	} else if (colorspec->type == TC_FRAC && cairotrm_mono) {
+		int save_colorMode = sm_palette.colorMode;
+		sm_palette.colorMode = SMPAL_COLOR_MODE_GRAY;
+		rgb1maxcolors_from_gray( colorspec->value, &rgb1 );
+		sm_palette.colorMode = save_colorMode;
+	} else if (colorspec->type == TC_FRAC) {
+		rgb1maxcolors_from_gray( colorspec->value, &rgb1 );
+	} else if (colorspec->type == TC_RGB) {
+		rgb1.r = (double) ((colorspec->lt >> 16) & 0xff)/255;
+		rgb1.g = (double) ((colorspec->lt >> 8) & 0xff)/255;
+		rgb1.b = (double) ((colorspec->lt) & 0xff)/255;
+	} else return;
+
+	gp_cairo_set_color(&plot, rgb1);
+}
+
+
+/* here we send the polygon command */
+void cairotrm_filled_polygon(int n, gpiPoint *corners)
+{
+	gpiPoint *mirrored_corners = (gpiPoint*) gp_alloc(n*sizeof(gpiPoint),"mirrored_corners");
+	/* can't use memcpy() here, as we have to mirror the y axis */
+	gpiPoint *corners_copy = mirrored_corners;
+	while (corners_copy < (mirrored_corners + n)) {
+		*corners_copy = *corners++;
+		corners_copy->y = term->ymax - corners_copy->y;
+		++corners_copy;
+	}
+
+	gp_cairo_draw_polygon(&plot, n, mirrored_corners);
+	free(mirrored_corners);
+}
+
+void cairotrm_image(unsigned int M, unsigned int N, coordval * image, gpiPoint * corner, t_imagecolor color_mode)
+{
+	/* This routine is to plot a pixel-based image on the display device.
+	'M' is the number of pixels along the y-dimension of the image and
+	'N' is the number of pixels along the x-dimension of the image.  The
+	coordval pointer 'image' is the pixel values normalized to the range
+	[0:1].  These values should be scaled accordingly for the output
+	device.  They 'image' data starts in the upper left corner and scans
+	along rows finishing in the lower right corner.  If 'color_mode' is
+	IC_PALETTE, the terminal is to use palette lookup to generate color
+	information.  In this scenario the size of 'image' is M*N.  If
+	'color_mode' is IC_RGB, the terminal is to use RGB components.  In
+	this scenario the size of 'image' is 3*M*N.  The data appears in RGB
+	tripples, i.e., image[0] = R(1,1), image[1] = G(1,1), image[2] =
+	B(1,1), image[3] = R(1,2), image[4] = G(1,2), ..., image[3*M*N-1] =
+	B(M,N).  The 'image' is actually an "input" image in the sense that
+	it must also be properly resampled for the output device.  Many output
+	mediums, e.g., PostScript, do this work via various driver functions.
+	To determine the appropriate rescaling, the 'corner' information
+	should be used.  There are four entries in the gpiPoint data array.
+	'corner[0]' is the upper left corner (in terms of plot location) of
+	the outer edge of the image.  Similarly, 'corner[1]' is the lower
+	right corner of the outer edge of the image.  (Outer edge means the
+	outer extent of the corner pixels, not the middle of the corner
+	pixels.)  'corner[2]' is the upper left corner of the visible part
+	of the image, and 'corner[3]' is the lower right corner of the visible
+	part of the image.  The information is provided in this way because
+	often it is necessary to clip a portion of the outer pixels of the
+	image. */
+
+	/* we will draw an image, scale and resize it */
+	/* FIXME add palette support ??? */
+
+	unsigned int *image255 = gp_cairo_helper_coordval_to_chars(image, M, N, color_mode);
+	gp_cairo_draw_image(&plot, image255,
+			corner[0].x, term->ymax - corner[0].y,
+			corner[1].x, term->ymax - corner[1].y,
+			corner[2].x, term->ymax - corner[2].y,
+			corner[3].x, term->ymax - corner[3].y,
+			M, N);
+	free(image255);
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+TERM_TABLE_START (pdfcairo_driver)
+    "pdfcairo", "pdf terminal based on cairo",
+    /* the following values are overriden by cairotrm_graphics */
+    1 /* xmax */ , 1 /* ymax */ , 1 /* vchar */ , 1 /* hchar */ ,
+    1 /* vtic */ , 1 /* htic */ ,
+    cairotrm_options, cairotrm_init, cairotrm_reset, cairotrm_text, null_scale, cairotrm_graphics,
+    cairotrm_move, cairotrm_vector, cairotrm_linetype, cairotrm_put_text,
+    cairotrm_text_angle, cairotrm_justify_text,
+    cairotrm_point, do_arrow, cairotrm_set_font,
+    cairotrm_pointsize,
+    TERM_CAN_MULTIPLOT|TERM_BINARY|TERM_CAN_DASH|TERM_LINEWIDTH,
+    0 /* suspend */, 0 /* resume */, cairotrm_fillbox, cairotrm_linewidth
+#ifdef USE_MOUSE
+    , 0, 0, 0, 0, 0
+#endif
+    , cairotrm_make_palette, 0 /* cairotrm_previous_palette */, cairotrm_set_color, cairotrm_filled_polygon
+    , cairotrm_image
+    , cairotrm_enhanced_open, cairotrm_enhanced_flush, cairotrm_enhanced_writec
+    , 0, 0, 1.0
+TERM_TABLE_END (pdfcairo_driver)
+
+#undef LAST_TERM
+#define LAST_TERM pdfcairo_driver
+
+
+TERM_TABLE_START (pngcairo_driver)
+    "pngcairo", "png terminal based on cairo",
+    /* the following values are overriden by cairotrm_graphics */
+    1 /* xmax */ , 1 /* ymax */ , 1 /* vchar */ , 1 /* hchar */ ,
+    1 /* vtic */ , 1 /* htic */ ,
+    cairotrm_options, cairotrm_init, cairotrm_reset, cairotrm_text, null_scale, cairotrm_graphics,
+    cairotrm_move, cairotrm_vector, cairotrm_linetype, cairotrm_put_text,
+    cairotrm_text_angle, cairotrm_justify_text,
+    cairotrm_point, do_arrow, cairotrm_set_font,
+    cairotrm_pointsize,
+    TERM_BINARY|TERM_CAN_DASH|TERM_ALPHA_CHANNEL|TERM_LINEWIDTH,
+    0 /* suspend */, 0 /* resume */, cairotrm_fillbox, cairotrm_linewidth
+#ifdef USE_MOUSE
+    , 0, 0, 0, 0, 0
+#endif
+    , cairotrm_make_palette, 0 /* cairotrm_previous_palette */, cairotrm_set_color, cairotrm_filled_polygon
+    , cairotrm_image
+    , cairotrm_enhanced_open, cairotrm_enhanced_flush, cairotrm_enhanced_writec
+    , 0, 0, 1.0
+TERM_TABLE_END (pngcairo_driver)
+
+#undef LAST_TERM
+#define LAST_TERM pngcairo_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(pdfcairo)
+"1 pdfcairo",
+"?set terminal pdfcairo",
+"?terminal pdfcairo",
+"?set term pdfcairo",
+"?term pdfcairo",
+"?pdfcairo",
+" The `pdfcairo` terminal device generates output in pdf. The actual",
+" drawing is done via cairo, a 2D graphics library, and pango, a library for",
+" laying out and rendering text.",
+"",
+" Syntax:",
+"         set term pdfcairo",
+"                      {{no}enhanced} {mono|color} {solid|dashed}",
+"                      {font <font>}",
+"                      {linewidth <lw>} {rounded|butt} {dashlength <dl>}",
+"                      {size <XX>{unit},<YY>{unit}}",
+"",
+" This terminal supports an enhanced text mode, which allows font and other",
+" formatting commands (subscripts, superscripts, etc.) to be embedded in labels",
+" and other text strings. The enhanced text mode syntax is shared with other",
+" gnuplot terminal types. See `enhanced` for more details.",
+"",
+" The width of all lines in the plot can be modified by the factor <lw>",
+" specified in `linewidth`. The default linewidth is 0.25 points.",
+" (1 \"PostScript\" point = 1/72 inch = 0.353 mm)",
+"",
+" `rounded` sets line caps and line joins to be rounded; `butt` is the",
+" default, butt caps and mitered joins.",
+"",
+" The default size for the output is 5 inches x 3 inches. The `size` option",
+" changes this to whatever the user requests. By default the X and Y sizes are",
+" taken to be in inches, but other units are possibly (currently only cm).",
+" Screen coordinates always run from 0.0 to 1.0 along the full length of the",
+" plot edges as specified by the `size` option.",
+"",
+" <font> is in the format \"FontFace,FontSize\", i.e. the face and the size",
+" comma-separated in a single string. FontFace is a usual font face name, such",
+" as \'Arial\'. If you do not provide FontFace, the pdfcairo terminal will use",
+" \'Sans\'. FontSize is the font size, in points. If you do not provide it,",
+" the pdfcairo terminal will use a size of 6 points.",
+"    For example :",
+"       set term pdfcairo font \"Arial,12\"",
+"       set term pdfcairo font \"Arial\" # to change the font face only",
+"       set term pdfcairo font \",12\" # to change the font size only",
+"       set term pdfcairo font \"\" # to reset the font name and size",
+"",
+" The fonts are retrieved from the usual fonts subsystems. Under Windows,",
+" those fonts are to be found and configured in the entry \"Fonts\" of the",
+" control panel. Under UNIX, they are handled by \"fontconfig\".",
+"",
+" Pango, the library used to layout the text, is based on utf-8. Thus, the pdfcairo",
+" terminal has to convert from your encoding to utf-8. The default input",
+" encoding is based on your \'locale\'. If you want to use another encoding,",
+" make sure gnuplot knows which one you are using. See `encoding` for more",
+" details.",
+"",
+" Pango may give unexpected results with fonts that do not respect the unicode",
+" mapping. With the Symbol font, for example, the pdfcairo terminal will use the map",
+" provided by http://www.unicode.org/ to translate character codes to unicode.",
+" Note that \"the Symbol font\" is to be understood as the Adobe",
+" Symbol font, distributed with Acrobat Reader as \"SY______.PFB\".",
+" Alternatively, the OpenSymbol font, distributed with OpenOffice.org as",
+" \"opens___.ttf\", offers the same characters. Microsoft has distributed a",
+" Symbol font (\"symbol.ttf\"), but it has a different character set with",
+" several missing or moved mathematic characters. If you experience problems",
+" with your default setup (if the demo enhancedtext.dem is not displayed",
+" properly for example), you probably have to install one of the Adobe or",
+" OpenOffice Symbol fonts, and remove the Microsoft one.",
+" Other non-conform fonts, such as \"wingdings\" have been observed working.",
+"",
+" The rendering of the plot cannot be altered yet. To obtain the best output",
+" possible, the rendering involves two mechanisms : antialiasing and",
+" oversampling.",
+" Antialiasing allows to display non-horizontal and non-vertical lines",
+" smoother.",
+" Oversampling combined with antialiasing provides subpixel accuracy,",
+" so that gnuplot can draw a line from non-integer coordinates. This avoids",
+" wobbling effects on diagonal lines ('plot x' for example).",
+""
+END_HELP(pdfcairo)
+#endif /* TERM_HELP */
+
+#ifdef TERM_HELP
+START_HELP(pngcairo)
+"1 pngcairo",
+"?set terminal pngcairo",
+"?terminal pngcairo",
+"?set term pngcairo",
+"?term pngcairo",
+"?pngcairo",
+" The `pngcairo` terminal device generates output in png. The actual",
+" drawing is done via cairo, a 2D graphics library, and pango, a library for",
+" laying out and rendering text.",
+"",
+" Syntax:",
+"         set term pngcairo",
+"                      {{no}enhanced} {mono|color} {solid|dashed}",
+"                      {{no}transparent} {{no}crop} {font <font>}",
+"                      {linewidth <lw>} {rounded|butt} {dashlength <dl>}",
+"                      {size <XX>{unit},<YY>{unit}}",
+"",
+" This terminal supports an enhanced text mode, which allows font and other",
+" formatting commands (subscripts, superscripts, etc.) to be embedded in labels",
+" and other text strings. The enhanced text mode syntax is shared with other",
+" gnuplot terminal types. See `enhanced` for more details.",
+"",
+" The width of all lines in the plot can be modified by the factor <lw>",
+" specified in `linewidth`. The default linewidth is 0.25 points.",
+" (1 \"PostScript\" point = 1/72 inch = 0.353 mm)",
+"",
+" `rounded` sets line caps and line joins to be rounded; `butt` is the",
+" default, butt caps and mitered joins.",
+"",
+" The default size for the output is 5 inches x 3 inches. The `size` option",
+" changes this to whatever the user requests. By default the X and Y sizes are",
+" taken to be in inches, but other units are possibly (currently only cm).",
+" Screen coordinates always run from 0.0 to 1.0 along the full length of the",
+" plot edges as specified by the `size` option.",
+"",
+" <font> is in the format \"FontFace,FontSize\", i.e. the face and the size",
+" comma-separated in a single string. FontFace is a usual font face name, such",
+" as \'Arial\'. If you do not provide FontFace, the pngcairo terminal will use",
+" \'Sans\'. FontSize is the font size, in points. If you do not provide it,",
+" the pngcairo terminal will use a size of 6 points.",
+"    For example :",
+"       set term pngcairo font \"Arial,12\"",
+"       set term pngcairo font \"Arial\" # to change the font face only",
+"       set term pngcairo font \",12\" # to change the font size only",
+"       set term pngcairo font \"\" # to reset the font name and size",
+"",
+" The fonts are retrieved from the usual fonts subsystems. Under Windows,",
+" those fonts are to be found and configured in the entry \"Fonts\" of the",
+" control panel. Under UNIX, they are handled by \"fontconfig\".",
+"",
+" Pango, the library used to layout the text, is based on utf-8. Thus, the pngcairo",
+" terminal has to convert from your encoding to utf-8. The default input",
+" encoding is based on your \'locale\'. If you want to use another encoding,",
+" make sure gnuplot knows which one you are using. See `encoding` for more",
+" details.",
+"",
+" Pango may give unexpected results with fonts that do not respect the unicode",
+" mapping. With the Symbol font, for example, the pngcairo terminal will use the map",
+" provided by http://www.unicode.org/ to translate character codes to unicode.",
+" Note that \"the Symbol font\" is to be understood as the Adobe",
+" Symbol font, distributed with Acrobat Reader as \"SY______.PFB\".",
+" Alternatively, the OpenSymbol font, distributed with OpenOffice.org as",
+" \"opens___.ttf\", offers the same characters. Microsoft has distributed a",
+" Symbol font (\"symbol.ttf\"), but it has a different character set with",
+" several missing or moved mathematic characters. If you experience problems",
+" with your default setup (if the demo enhancedtext.dem is not displayed",
+" properly for example), you probably have to install one of the Adobe or",
+" OpenOffice Symbol fonts, and remove the Microsoft one.",
+" Other non-conform fonts, such as \"wingdings\" have been observed working.",
+"",
+" The rendering of the plot cannot be altered yet. To obtain the best output",
+" possible, the rendering involves two mechanisms : antialiasing and",
+" oversampling.",
+" Antialiasing allows to display non-horizontal and non-vertical lines",
+" smoother.",
+" Oversampling combined with antialiasing provides subpixel accuracy,",
+" so that gnuplot can draw a line from non-integer coordinates. This avoids",
+" wobbling effects on diagonal lines ('plot x' for example).",
+""
+END_HELP(pngcairo)
+#endif /* TERM_HELP */
+
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/canvas.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/canvas.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/canvas.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/canvas.trm.svn-base	2012-01-03 17:07:25.742736500 -0800
@@ -0,0 +1,1172 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: canvas.trm,v 1.25.2.6 2010/02/01 16:29:28 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - canvas.trm */
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *   W3C HTML <canvas> tag
+ *
+ * AUTHOR
+ *   Bruce Lueckenhoff, Aug 2008
+ *   Bruce_Lueckenhoff@yahoo.com
+ *
+ * Additions
+ *   Ethan A Merritt, Jan 2009
+ *	CANVAS_set_color(), CANVAS_make_palette(), CANVAS_fillbox(), fillstyles, 
+ *	CANVAS_point(), CANVAS_pointsize()
+ *	"name <foo>" option to create only a callable javascript file foo.js
+ *	"fsize <F>" option to select font size (default remains 10.0)
+ *   Ethan A Merritt, Jan 2009
+ *	Prototype mousing code in separate file gnuplot_mouse.js
+ *   Ethan A Merritt, Feb 2009
+ *	Enhanced text support. Note: character placement could be done more
+ *	precisely by moving the enhanced text code into the javascript routines,
+ *	where exact character widths are known, and save/restore can be used.
+ *   Ethan A Merritt, Mar 2009
+ *	Oversampling and client-side zoom/unzoom, hotkeys
+ *   Ethan A Merritt, May 2009
+ *	Give each plot its own namespace for mousing (allows multiple mouseable
+ *	plots in a single HTML document).
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(canvas_driver)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void CANVAS_options __PROTO((void));
+TERM_PUBLIC void CANVAS_init __PROTO((void));
+TERM_PUBLIC void CANVAS_graphics __PROTO((void));
+TERM_PUBLIC int CANVAS_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC void CANVAS_text __PROTO((void));
+TERM_PUBLIC void CANVAS_reset __PROTO((void));
+TERM_PUBLIC void CANVAS_linetype __PROTO((int linetype));
+TERM_PUBLIC void CANVAS_fillbox __PROTO((int style, unsigned int x1, unsigned int y1,
+					unsigned int width, unsigned int height));
+TERM_PUBLIC void CANVAS_linewidth __PROTO((double linewidth));
+TERM_PUBLIC void CANVAS_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void CANVAS_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void CANVAS_point __PROTO((unsigned int x, unsigned int y, int number));
+TERM_PUBLIC void CANVAS_pointsize __PROTO((double size));
+TERM_PUBLIC void CANVAS_put_text __PROTO((unsigned int x, unsigned int y,
+					const char *str));
+TERM_PUBLIC int CANVAS_text_angle __PROTO((int ang));
+TERM_PUBLIC void CANVAS_filled_polygon __PROTO((int, gpiPoint *));
+TERM_PUBLIC void CANVAS_set_color __PROTO((t_colorspec *colorspec));
+TERM_PUBLIC int CANVAS_make_palette __PROTO((t_sm_palette *palette));
+TERM_PUBLIC void CANVAS_layer __PROTO((t_termlayer));
+TERM_PUBLIC void CANVAS_path __PROTO((int));
+
+TERM_PUBLIC void ENHCANVAS_OPEN __PROTO((char *, double, double, TBOOLEAN, TBOOLEAN, int));
+TERM_PUBLIC void ENHCANVAS_FLUSH __PROTO((void));
+TERM_PUBLIC void ENHCANVAS_put_text __PROTO((unsigned int, unsigned int, const char *));
+
+#define CANVAS_OVERSAMPLE	10.
+#define CANVAS_XMAX		(600 * CANVAS_OVERSAMPLE) 
+#define CANVAS_YMAX 		(400 * CANVAS_OVERSAMPLE)
+#define CANVASVTIC		(10  * CANVAS_OVERSAMPLE)
+#define CANVASHTIC		(10  * CANVAS_OVERSAMPLE)
+#define CANVASVCHAR		(10  * CANVAS_OVERSAMPLE)
+#define CANVASHCHAR		(8   * CANVAS_OVERSAMPLE)
+
+#endif /* TERM_PROTO */
+
+#ifdef TERM_BODY
+
+#define CANVAS_AXIS_CONST '\1'
+#define CANVAS_BORDER_CONST '\2'
+
+static int canvas_x = -1;	/* current X position */
+static int canvas_y = -1;	/* current Y position */
+static int canvas_xmax = CANVAS_XMAX;
+static int canvas_ymax = CANVAS_YMAX;
+static int canvas_line_type = LT_UNDEFINED;
+static double canvas_linewidth = 1.0;
+static double CANVAS_ps = 1;	/* pointsize multiplier */
+static double canvas_font_size = 10;
+static char *canvas_justify = "";
+static int canvas_text_angle = 0;
+static int canvas_in_a_path = FALSE;
+static int already_closed = FALSE;
+static TBOOLEAN CANVAS_mouseable = FALSE;
+static TBOOLEAN CANVAS_standalone = TRUE;
+static char *CANVAS_name = NULL;
+static char *CANVAS_scriptdir = NULL;
+static char *CANVAS_title = NULL;
+
+static struct {
+    int  previous_linewidth;
+    char color[18];		/* rgb(rrr,ggg,bbb) */
+    char previous_color[18];	/* rgb(rrr,ggg,bbb) */
+    char previous_fill[24];	/* rgba(rrr,ggg,bbb,aaaa) */
+} canvas_state;
+
+enum CANVAS_case {
+    CANVAS_SIZE, CANVAS_FSIZE, CANVAS_NAME, CANVAS_STANDALONE, CANVAS_TITLE,
+    CANVAS_LINEWIDTH, CANVAS_MOUSING, CANVAS_JSDIR, CANVAS_ENH, CANVAS_NOENH,
+    CANVAS_OTHER
+};
+
+static struct gen_table CANVAS_opts[] =
+{
+    { "fsize", CANVAS_FSIZE },
+    { "name", CANVAS_NAME },
+    { "size", CANVAS_SIZE },
+    { "standalone", CANVAS_STANDALONE },
+    { "mous$ing", CANVAS_MOUSING },
+    { "mouse", CANVAS_MOUSING },
+    { "js$dir", CANVAS_JSDIR },
+    { "enh$anced", CANVAS_ENH },
+    { "noenh$anced", CANVAS_NOENH },
+    { "lw", CANVAS_LINEWIDTH },
+    { "linew$idth", CANVAS_LINEWIDTH },
+    { "title", CANVAS_TITLE },
+    { NULL, CANVAS_OTHER }
+};
+
+static void
+CANVAS_start (void)
+{
+    if (canvas_in_a_path)
+	return;
+    fprintf(gpoutfile, "ctx.beginPath();\n");
+    canvas_in_a_path = TRUE;
+    already_closed = FALSE;
+}
+
+static void
+CANVAS_finish (void)
+{
+    if (!canvas_in_a_path)
+	return;
+    fprintf(gpoutfile, "ctx.stroke();\n");
+
+    if (!already_closed)
+	fprintf(gpoutfile, "ctx.closePath();\n");
+    canvas_in_a_path = FALSE;
+    already_closed = TRUE;
+}
+
+TERM_PUBLIC void
+CANVAS_options()
+{
+    /* (c_token == 2) only in the case of 'set termoption'	*/
+    /* which is after we have already initialized everything.	*/
+    if (c_token != 2) {
+	/* Re-initialize a few things */
+	canvas_font_size = 10;
+	CANVAS_standalone = TRUE;
+	CANVAS_mouseable = FALSE;
+	free(CANVAS_name);
+	CANVAS_name = NULL;
+	free(CANVAS_title);
+	CANVAS_title = NULL;
+	free(CANVAS_scriptdir);
+	CANVAS_scriptdir = NULL;
+	canvas_linewidth = 1.0;
+    }
+
+    while (!END_OF_COMMAND) {
+	switch(lookup_table(&CANVAS_opts[0],c_token++)) {
+	case CANVAS_SIZE:
+	    if (END_OF_COMMAND) {
+		canvas_xmax = CANVAS_XMAX;
+		canvas_ymax = CANVAS_YMAX;
+	    } else {
+		canvas_xmax = int_expression() * CANVAS_OVERSAMPLE;
+		if (equals(c_token,",")) {
+		    c_token++;
+		    canvas_ymax = int_expression() * CANVAS_OVERSAMPLE;
+		}
+	    }
+	    if (canvas_xmax <= 0)
+		canvas_xmax = CANVAS_XMAX;
+	    if (canvas_ymax <= 0)
+		canvas_ymax = CANVAS_YMAX;
+	    term->xmax = canvas_xmax;
+	    term->ymax = canvas_ymax;
+ 	    break;
+
+	case CANVAS_TITLE:
+	    CANVAS_title = try_to_get_string();
+	    if (!CANVAS_title)
+		int_error(c_token,"expecting an HTML title string");
+	    break;
+
+	case CANVAS_NAME:
+	    CANVAS_name = try_to_get_string();
+	    if (!CANVAS_name)
+		    int_error(c_token,"expecting a javascript function name");
+	    if (CANVAS_name[strspn(CANVAS_name,
+	        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_1234567890")])
+		    int_error(c_token-1,"illegal javascript function name");
+	    CANVAS_standalone = FALSE;
+	    break;
+
+	case CANVAS_STANDALONE:
+	    CANVAS_standalone = TRUE;
+	    break;
+
+	case CANVAS_FSIZE:
+	    canvas_font_size = real_expression();
+	    if (canvas_font_size <= 0)
+		canvas_font_size = 10;
+	    break;
+
+	case CANVAS_MOUSING:
+	    CANVAS_mouseable = TRUE;
+	    break;
+
+	case CANVAS_JSDIR:
+	    CANVAS_scriptdir = try_to_get_string();
+	    break;
+
+	case CANVAS_ENH:
+	    term->put_text = ENHCANVAS_put_text;
+	    term->flags |= TERM_ENHANCED_TEXT;
+	    break;
+
+	case CANVAS_NOENH:
+	    term->put_text = CANVAS_put_text;
+	    term->flags &= ~TERM_ENHANCED_TEXT;
+	    break;
+
+	case CANVAS_LINEWIDTH:
+	    canvas_linewidth = real_expression();
+	    if (canvas_linewidth <= 0)
+		canvas_linewidth = 1.0;
+	    break;
+
+	default:
+	    int_warn(c_token-1,"unrecognized terminal option");
+ 	    break;
+	}
+    }
+
+    term->v_char = canvas_font_size * CANVAS_OVERSAMPLE;
+    term->h_char = canvas_font_size * 0.8 * CANVAS_OVERSAMPLE;
+
+    sprintf(term_options, "size %d,%d", (int)(term->xmax/CANVAS_OVERSAMPLE), (int)(term->ymax/CANVAS_OVERSAMPLE));
+    sprintf(term_options + strlen(term_options), "%s fsize %g lw %g", 
+	term->put_text == ENHCANVAS_put_text ? " enhanced" : "",
+	canvas_font_size, canvas_linewidth);
+    if (CANVAS_name)
+	sprintf(term_options + strlen(term_options), " name \"%s\"", CANVAS_name);
+    else {
+	sprintf(term_options + strlen(term_options), " standalone");
+	if (CANVAS_mouseable)
+	    sprintf(term_options + strlen(term_options), " mousing");
+	if (CANVAS_title)
+	    sprintf(term_options + strlen(term_options), " title \"%s\"", CANVAS_title);
+    }
+    if (CANVAS_scriptdir)
+	sprintf(term_options + strlen(term_options), " jsdir \"%s\"", CANVAS_scriptdir);
+}
+
+
+TERM_PUBLIC void
+CANVAS_init()
+{
+}
+
+TERM_PUBLIC void
+CANVAS_graphics()
+{
+#if !defined(VMS)
+    int len;
+#endif
+    /* Force initialization at the beginning of each plot */
+    canvas_line_type = LT_UNDEFINED;
+    canvas_text_angle = 0;
+    canvas_in_a_path = FALSE;
+    canvas_state.previous_linewidth = -1;
+    canvas_state.previous_color[0] = '\0';
+    canvas_state.previous_fill[0] = '\0';
+    strcpy(canvas_state.color,"rgb(000,000,000)");
+
+    /* Figure out where the javascript should come from when the page is viewed */
+    if (CANVAS_scriptdir == NULL) {
+	char *canvas_default_jsdir = "";
+#ifdef GNUPLOT_JS_DIR
+# if defined(_Windows)
+	/* retrieve path relative to the gnuplot executable,
+	 * whose path is in szModuleName (winmain.c) */
+	/* EAM FIXME: memory leak */
+	canvas_default_jsdir = gp_alloc(strlen((char*) szPackageDir)
+			+ strlen(GNUPLOT_JS_DIR) + 2, "jsdir");
+	strcpy(canvas_default_jsdir, (char*) szPackageDir);
+	len = strlen(canvas_default_jsdir);
+	if (*canvas_default_jsdir && canvas_default_jsdir[len-1] != '\\' && canvas_default_jsdir[len-1] != '/')
+	    strcat(canvas_default_jsdir, "\\");
+	/* GNUPLOT_JS_DIR is _relative_ path */
+	strcat(canvas_default_jsdir, GNUPLOT_JS_DIR);
+# else /* !_Windows */
+	/* use hardcoded _absolute_ path */
+	canvas_default_jsdir = GNUPLOT_JS_DIR;
+# endif
+#endif /* GNUPLOT_JS_DIR */
+	CANVAS_scriptdir = gp_strdup(canvas_default_jsdir);
+    }
+
+#if !defined(VMS)
+    len = strlen(CANVAS_scriptdir);
+# if defined(_Windows)
+    if (*CANVAS_scriptdir && CANVAS_scriptdir[len-1] != '\\' && CANVAS_scriptdir[len-1] != '/') {
+	CANVAS_scriptdir = gp_realloc(CANVAS_scriptdir, len+2, "jsdir");
+	if (CANVAS_scriptdir[len-1] == '\\') /* use backslash if used in jsdir, otherwise slash */
+	    strcat(CANVAS_scriptdir,"\\");
+	else
+	    strcat(CANVAS_scriptdir,"/");
+    }
+# else
+    if (*CANVAS_scriptdir && CANVAS_scriptdir[len-1] != '/') {
+	CANVAS_scriptdir = gp_realloc(CANVAS_scriptdir, len+2, "jsdir");
+	strcat(CANVAS_scriptdir,"/");
+    }
+# endif
+#endif
+
+    if (CANVAS_standalone) {
+	fprintf(gpoutfile,
+		"<html>\n"
+		"<head>\n"
+		"<title>%s</title>\n",
+		CANVAS_title ? CANVAS_title : "Gnuplot Canvas Graph"
+		);
+	if (encoding == S_ENC_UTF8)
+	    fprintf(gpoutfile,
+		"<meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\">\n"
+	    );
+	fprintf(gpoutfile,
+		"<!--[if IE]><script type=\"text/javascript\" src=\"excanvas.js\"></script><![endif]-->\n"
+		"<script src=\"%scanvastext.js\"></script>\n"
+		"<script src=\"%sgnuplot_common.js\"></script>\n"
+		, CANVAS_scriptdir
+		, CANVAS_scriptdir);
+	if (CANVAS_mouseable)
+	    fprintf(gpoutfile,
+		"<script src=\"%sgnuplot_mouse.js\"></script>\n"
+		, CANVAS_scriptdir);
+	fprintf(gpoutfile,
+		"<script type=\"text/javascript\">\n"
+		"var canvas, ctx;\n"
+		"var grid_lines = true;\n"
+		"var zoomed = false;\n"
+		"var active_plot_name = \"gnuplot_canvas\";\n\n"
+		"function gnuplot_canvas() {\n"
+		"canvas = document.getElementById(\"gnuplot_canvas\");\n"
+		"ctx = canvas.getContext(\"2d\");\n"
+	);
+
+    } else {
+	fprintf(gpoutfile,
+		"function %s() {\n"
+		"canvas = document.getElementById(\"%s\");\n"
+		"ctx = canvas.getContext(\"2d\");\n",
+		CANVAS_name, CANVAS_name
+	);
+	fprintf(gpoutfile,
+	    "// Reinitialize mouse tracking and zoom for this particular plot\n"
+	    "if ((typeof(active_plot) == \"undefined\" || active_plot != %s)  &&  typeof(mouse_update) != \"undefined\") {\n"
+	    "  active_plot_name = \"%s\";\n"
+	    "  active_plot = %s;\n"
+	    "  canvas.onmousemove = mouse_update;\n"
+	    "  canvas.onmouseup = zoom_in;\n"
+	    "  canvas.onmousedown = saveclick;\n"
+	    "  canvas.onkeypress = do_hotkey;\n"
+	    "  if (canvas.attachEvent) {canvas.attachEvent('mouseover', %s);}\n"
+	    "  else if (canvas.addEventListener) {canvas.addEventListener('mouseover', %s, false);} \n"
+	    "  zoomed = false;\n"
+	    "  zoom_axis_width = 0;\n"
+	    "  zoom_in_progress = false;\n"
+	    "  ctx.clearRect(0,0,%d,%d);\n"
+	    "}\n",
+		CANVAS_name, CANVAS_name, CANVAS_name, CANVAS_name, CANVAS_name,
+		(int)(term->xmax / CANVAS_OVERSAMPLE), (int)(term->ymax / CANVAS_OVERSAMPLE)
+	);
+    }
+
+    fprintf(gpoutfile,
+	    "CanvasTextFunctions.enable(ctx);\n"
+	    "ctx.strokeStyle = \"rgb(215,215,215)\";\n"
+	    "ctx.lineWidth = %.1g;\n",
+	canvas_linewidth
+    );
+}
+
+
+TERM_PUBLIC void
+CANVAS_text()
+{
+    CANVAS_finish();
+
+    /* FIXME: I am not sure whether these variable names should always be the */
+    /* same, so that they are re-used by all plots in a document, or whether  */
+    /* they should be tied to the function name and hence private.            */
+    if (TRUE) {
+	struct udvt_entry *udv;
+	fprintf(gpoutfile, "\n// plot boundaries and axis scaling information for mousing \n");
+	fprintf(gpoutfile, "plot_term_xmax = %d;\n", (int)(term->xmax / CANVAS_OVERSAMPLE));
+	fprintf(gpoutfile, "plot_term_ymax = %d;\n", (int)(term->ymax / CANVAS_OVERSAMPLE));
+	fprintf(gpoutfile, "plot_xmin = %.1f;\n", (double)plot_bounds.xleft / CANVAS_OVERSAMPLE);
+	fprintf(gpoutfile, "plot_xmax = %.1f;\n", (double)plot_bounds.xright / CANVAS_OVERSAMPLE);
+	fprintf(gpoutfile, "plot_ybot = %.1f;\n", (double)(term->ymax-plot_bounds.ybot) / CANVAS_OVERSAMPLE);
+	fprintf(gpoutfile, "plot_ytop = %.1f;\n", (double)(term->ymax-plot_bounds.ytop) / CANVAS_OVERSAMPLE);
+	fprintf(gpoutfile, "plot_width = %.1f;\n", (double)(plot_bounds.xright - plot_bounds.xleft) / CANVAS_OVERSAMPLE);
+	fprintf(gpoutfile, "plot_height = %.1f;\n", (double)(plot_bounds.ytop - plot_bounds.ybot) / CANVAS_OVERSAMPLE);
+
+	/* Get true axis ranges as used in the plot */
+	update_gpval_variables(1);
+
+#define	MOUSE_PARAM( GP_NAME, js_NAME ) \
+	if ((udv = add_udv_by_name(GP_NAME))) { \
+	    if (udv->udv_value.type == INTGR)   \
+		fprintf(gpoutfile, "%s = %d;\n", js_NAME, udv->udv_value.v.int_val); \
+	    else if (udv->udv_value.type == CMPLX) \
+		fprintf(gpoutfile, "%s = %g;\n", js_NAME, udv->udv_value.v.cmplx_val.real); \
+	}
+	MOUSE_PARAM("GPVAL_X_MIN", "plot_axis_xmin");
+	MOUSE_PARAM("GPVAL_X_MAX", "plot_axis_xmax");
+	MOUSE_PARAM("GPVAL_Y_MIN", "plot_axis_ymin");
+	MOUSE_PARAM("GPVAL_Y_MAX", "plot_axis_ymax");
+
+	if ((axis_array[SECOND_X_AXIS].ticmode & TICS_MASK) != NO_TICS) {
+	    MOUSE_PARAM("GPVAL_X2_MIN", "plot_axis_x2min");
+	    MOUSE_PARAM("GPVAL_X2_MAX", "plot_axis_x2max");
+	} else
+	    fprintf(gpoutfile, "plot_axis_x2min = \"none\"\n");
+	if ((axis_array[SECOND_Y_AXIS].ticmode & TICS_MASK) != NO_TICS) {
+	    MOUSE_PARAM("GPVAL_Y2_MIN", "plot_axis_y2min");
+	    MOUSE_PARAM("GPVAL_Y2_MAX", "plot_axis_y2max");
+	} else
+	    fprintf(gpoutfile, "plot_axis_y2min = \"none\"\n");
+#undef MOUSE_PARAM
+
+	fprintf(gpoutfile, "plot_logaxis_x = %d;\n",
+		axis_array[FIRST_X_AXIS].log ? 1: 0);
+	fprintf(gpoutfile, "plot_logaxis_y = %d;\n",
+		axis_array[FIRST_Y_AXIS].log ? 1: 0);
+
+	fprintf(gpoutfile, "plot_axis_width = plot_axis_xmax - plot_axis_xmin;\n");
+	fprintf(gpoutfile, "plot_axis_height = plot_axis_ymax - plot_axis_ymin;\n");
+
+    } /* End of section writing out variables for mousing */
+
+    fprintf(gpoutfile, "}\n");
+
+    if (CANVAS_standalone) {
+	fprintf(gpoutfile,
+		"</script>\n"
+		"<link text=\"text/css\" href=\"%sgnuplot_mouse.css\" rel=\"stylesheet\">\n"
+		"</head>\n"
+		"<body onload=\"gnuplot_canvas(); gnuplot_init();\" oncontextmenu=\"return false;\">\n\n"
+		"<div class=\"gnuplot\">\n",
+			CANVAS_scriptdir ? CANVAS_scriptdir : ""
+	);
+
+	/* The format of the plot box and in particular the mouse tracking box
+	 * are determined by the CSS specs in customizable file gnuplot_mouse.css
+	 * We could make this even more customizable by providing an external HTML
+	 * template, but in that case the user might as well just create a *.js
+	 * file and provide his own wrapping HTML document.
+	 */
+	if (CANVAS_mouseable) {
+	    fprintf(gpoutfile,
+		"<table class=\"mbleft\"><tr><td class=\"mousebox\">\n"
+
+		"<table class=\"mousebox\" border=0>\n"
+		"  <tr><td class=\"mousebox\">\n"
+		"    <table class=\"mousebox\" id=\"gnuplot_mousebox\" border=0>\n"
+		"    <tr><td class=\"mbh\"></td></tr>\n"
+		"    <tr><td class=\"mbh\">\n"
+		"      <table class=\"mousebox\">\n"
+		"	<tr>\n"
+		"	  <td class=\"icon\"></td>\n"
+		"	  <td class=\"icon\" onclick=toggle_grid><img src=\"%sgrid.png\" id=\"gnuplot_grid_icon\" align=right alt=\"#\" title=\"toggle grid\"></td>\n"
+		"	  <td class=\"icon\" onclick=unzoom><img src=\"%spreviouszoom.png\" id=\"gnuplot_unzoom_icon\" align=right alt=\"unzoom\" title=\"unzoom\"></td>\n"
+		"	  <td class=\"icon\" onclick=rezoom><img src=\"%snextzoom.png\" id=\"gnuplot_rezoom_icon\" align=right alt=\"rezoom\" title=\"rezoom\"></td>\n"
+		"	  <td class=\"icon\" onclick=toggle_zoom_text><img src=\"%stextzoom.png\" id=\"gnuplot_textzoom_icon\" align=right alt=\"zoom text\" title=\"zoom text with plot\"></td>\n"
+		"	  <td class=\"icon\"><img src=\"%shelp.png\" id=\"gnuplot_help_icon\" align=right alt=\"?\" title=\"help\"></td>\n"
+		"	</tr>\n"
+		"      </table>\n"
+		"  </td></tr>\n"
+		"</table></td></tr><tr><td class=\"mousebox\">\n",
+		CANVAS_scriptdir ? CANVAS_scriptdir : "", CANVAS_scriptdir ? CANVAS_scriptdir : "",
+		CANVAS_scriptdir ? CANVAS_scriptdir : "", CANVAS_scriptdir ? CANVAS_scriptdir : "",
+		CANVAS_scriptdir ? CANVAS_scriptdir : ""
+	    );
+
+	    fprintf(gpoutfile,
+		"<table class=\"mousebox\" id=\"gnuplot_mousebox\" border=1>\n"
+		"<tr> <td class=\"mb0\">x&nbsp;</td> <td class=\"mb1\"><span id=\"gnuplot_canvas_x\">&nbsp;</span></td> </tr>\n"
+		"<tr> <td class=\"mb0\">y&nbsp;</td> <td class=\"mb1\"><span id=\"gnuplot_canvas_y\">&nbsp;</span></td> </tr>\n"
+	    );
+
+	    if ((axis_array[SECOND_X_AXIS].ticmode & TICS_MASK) != NO_TICS)
+	      fprintf(gpoutfile,
+		"<tr> <td class=\"mb0\">x2&nbsp;</td> <td class=\"mb1\"><span id=\"gnuplot_canvas_x2\">&nbsp;</span></td> </tr>\n");
+	    if ((axis_array[SECOND_Y_AXIS].ticmode & TICS_MASK) != NO_TICS)
+	      fprintf(gpoutfile,
+		"<tr> <td class=\"mb0\">y2&nbsp;</td> <td class=\"mb1\"><span id=\"gnuplot_canvas_y2\">&nbsp;</span></td> </tr>\n");
+
+	    fprintf(gpoutfile,
+		"</table></td></tr>\n"
+		"</table>\n"
+	    );
+
+	    fprintf(gpoutfile,
+	        "</td><td>\n"
+	    );
+	} /* End if (CANVAS_mouseable) */
+
+
+	fprintf(gpoutfile,
+		"<table class=\"plot\">\n"
+		"<tr><td>\n"
+		"    <canvas id=\"gnuplot_canvas\" width=\"%d\" height=\"%d\" tabindex=\"0\">\n"
+		"	Sorry, your browser seems not to support the HTML 5 canvas element\n"
+		"    </canvas>\n"
+		"</td></tr>\n"
+		"</table>\n",
+			(int)(term->xmax/CANVAS_OVERSAMPLE), (int)(term->ymax/CANVAS_OVERSAMPLE)
+        );
+
+	if (CANVAS_mouseable) {
+	    fprintf(gpoutfile,
+		"</td></tr></table>\n"
+	    );
+	}
+
+	fprintf(gpoutfile,
+		"</div>\n\n"
+		"</body>\n"
+		"</html>\n"
+        );
+    }
+
+    fflush(gpoutfile);
+}
+
+
+TERM_PUBLIC void
+CANVAS_reset()
+{
+    ;
+}
+
+
+TERM_PUBLIC void
+CANVAS_linetype(int linetype)
+{
+    /* NB: These values are manipulated as numbers; */
+    /* it does not work to give only the color name */
+    static const char * pen_type[17] = {
+	"rgb(255,255,255)", /* should be background */
+	"rgb(000,000,000)", /* black */
+	"rgb(160,160,160)", /* grey */
+	"rgb(255,000,000)", /* red */
+	"rgb(000,171,000)", /* green */
+	"rgb(000,000,225)", /* blue */
+        "rgb(190,000,190)", /* purple */ 
+	"rgb(000,255,255)", /* cyan */
+	"rgb(021,117,069)", /* pine green*/
+	"rgb(000,000,148)", /* navy */
+	"rgb(255,153,000)", /* orange */
+	"rgb(000,153,161)", /* green blue*/
+	"rgb(214,214,069)", /* olive*/
+	"rgb(163,145,255)", /* cornflower*/
+	"rgb(255,204,000)", /* gold*/
+	"rgb(214,000,120)", /* mulberry*/
+	"rgb(171,214,000)", /* green yellow*/
+    };
+    if (linetype == canvas_line_type)
+	return;
+    canvas_line_type = linetype;
+    CANVAS_finish();
+
+    if (linetype >= 14)
+	linetype %= 14;
+    if (linetype <= LT_BACKGROUND) /* LT_NODRAW, LT_BACKGROUND, LT_UNDEFINED */
+	linetype = -3;
+    strcpy(canvas_state.color,pen_type[linetype + 3]);
+    if (strcmp(canvas_state.color, canvas_state.previous_color)) {
+	fprintf(gpoutfile, "ctx.strokeStyle = \"%s\";\n", canvas_state.color);
+	strcpy(canvas_state.previous_color, canvas_state.color);
+    }
+}
+
+
+TERM_PUBLIC void
+CANVAS_move(unsigned int arg_x, unsigned int arg_y)
+{
+    if (canvas_in_a_path && (canvas_x == arg_x) && (canvas_y == arg_y)) {
+        return;
+    }
+    CANVAS_start();
+    fprintf(gpoutfile,
+	    "M(%u,%u);\n",
+            arg_x, canvas_ymax - arg_y);
+    canvas_x = arg_x;
+    canvas_y = arg_y;
+}
+
+TERM_PUBLIC void
+CANVAS_vector(unsigned int arg_x, unsigned int arg_y)
+{
+    if ((canvas_x == arg_x) && (canvas_y == arg_y))
+        return;
+
+    if (!canvas_in_a_path) {
+ 	/* Force a new path */
+	CANVAS_move(canvas_x, canvas_y);
+    }
+
+    fprintf(gpoutfile,
+	    "L(%u,%u);\n",
+            arg_x, canvas_ymax - arg_y
+           );
+    canvas_x = arg_x;
+    canvas_y = arg_y;
+}
+
+
+TERM_PUBLIC int
+CANVAS_justify_text(enum JUSTIFY mode)
+{
+    switch (mode) {
+    case (CENTRE):
+	canvas_justify = "Center";
+	break;
+    case (RIGHT):
+	canvas_justify = "Right";
+	break;
+    default:
+    case (LEFT):
+        canvas_justify = "";
+	break;
+    }
+    return (TRUE);
+}
+
+TERM_PUBLIC void
+CANVAS_point(unsigned int x, unsigned int y, int number)
+{
+    double width  = CANVAS_ps * 0.6 * CANVASHTIC / CANVAS_OVERSAMPLE;
+    int pt = number % 9;
+
+    CANVAS_finish();
+
+    switch (pt) {
+    default:
+	fprintf(gpoutfile, "Dot(%.1f,%.1f);\n",
+		x/CANVAS_OVERSAMPLE, (canvas_ymax-y)/CANVAS_OVERSAMPLE);
+	break;
+    case 4:
+    case 6:
+    case 8:
+	if (strcmp(canvas_state.previous_fill, canvas_state.color)) {
+	    fprintf(gpoutfile, "ctx.fillStyle = \"%s\";\n", canvas_state.color);
+	    strcpy(canvas_state.previous_fill, canvas_state.color);
+	}
+	/* Fall through */
+    case 0:
+    case 1:
+    case 2:
+    case 3:
+    case 5:
+    case 7:
+	fprintf(gpoutfile, "Pt(%d,%.1f,%.1f,%.1f);\n", pt,
+		x/CANVAS_OVERSAMPLE, (canvas_ymax-y)/CANVAS_OVERSAMPLE, width);
+	break;
+    }
+}
+
+TERM_PUBLIC void
+CANVAS_pointsize(double ptsize)
+{
+    if (ptsize < 0)
+	CANVAS_ps = 1;
+    else
+	CANVAS_ps = ptsize;
+}
+
+
+TERM_PUBLIC int
+CANVAS_text_angle(int ang)
+{
+    canvas_text_angle = -1 * ang;
+    return TRUE;
+}
+
+
+TERM_PUBLIC void
+CANVAS_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    if (!str || !(*str))
+	return;
+
+    CANVAS_finish();
+    if (0 != canvas_text_angle) {
+	fprintf(gpoutfile,
+		"TR(%d,%d,%d,%.1f,\"%s\",\"",
+		    x, (int)(canvas_ymax + 5*CANVAS_OVERSAMPLE - y),
+		    canvas_text_angle, canvas_font_size, canvas_justify);
+    } else {
+	fprintf(gpoutfile, "T(%d,%d,%.1f,\"%s\",\"",
+		x, (int)(canvas_ymax + 5*CANVAS_OVERSAMPLE - y), canvas_font_size,
+		canvas_justify);
+    }
+
+    /* Sanitize string by escaping quote characters */
+    do {
+	if (*str == '"' || *str == '\\')
+	    fputc('\\', gpoutfile);
+	fputc(*str++, gpoutfile);
+    } while (*str);
+
+    fprintf(gpoutfile, "\");\n");
+}
+
+
+TERM_PUBLIC void
+CANVAS_linewidth(double linewidth)
+{
+    CANVAS_finish();
+    if (canvas_state.previous_linewidth != linewidth) {
+	fprintf(gpoutfile, "ctx.lineWidth = %g;\n", linewidth * canvas_linewidth);
+	canvas_state.previous_linewidth = linewidth;
+    }
+}
+
+TERM_PUBLIC void
+CANVAS_set_color(t_colorspec *colorspec)
+{
+    rgb255_color rgb255;
+
+    if (colorspec->type == TC_LT) {
+	CANVAS_linetype(colorspec->lt);
+	return;
+    } else if (colorspec->type == TC_RGB) {
+	rgb255.r = colorspec->lt >> 16;
+	rgb255.g = (colorspec->lt >> 8) & 0xff;
+	rgb255.b = colorspec->lt & 0xff;
+    } else if (colorspec->type == TC_FRAC) {
+	rgb255maxcolors_from_gray(colorspec->value, &rgb255);
+    } else
+	/* Other color types not yet supported */
+	return;
+
+    CANVAS_finish();
+
+    sprintf(canvas_state.color,"rgb(%03d,%03d,%03d)", rgb255.r, rgb255.g, rgb255.b);
+    if (strcmp(canvas_state.color, canvas_state.previous_color)) {
+	fprintf(gpoutfile, "ctx.strokeStyle = \"%s\";\n", canvas_state.color);
+	strcpy(canvas_state.previous_color, canvas_state.color);
+    }
+    canvas_line_type = LT_UNDEFINED;
+}
+
+TERM_PUBLIC int
+CANVAS_make_palette(t_sm_palette *palette)
+{
+    /* We can do full RGB color */
+    return 0;
+}
+
+static char *
+CANVAS_fillstyle(int style)
+{
+    float density = (float)(style >> 4) / 100.;
+    static char fillcolor[24];
+
+    switch (style & 0xf) {
+	case FS_TRANSPARENT_SOLID:
+		sprintf(fillcolor,"rgba(%11.11s,%4.2f)%c",
+			&canvas_state.color[4], density, '\0');
+		break;
+	case FS_EMPTY:
+		strcpy(fillcolor,"rgba(255,255,255,0.00)");
+		break;
+	case FS_PATTERN:
+	case FS_TRANSPARENT_PATTERN:
+		/* Patterns are possible, but not yet implemented */
+		switch ((style >> 4) % 5) {
+			case 0: density = 0.00; break;
+			case 1: density = 1.00; break;
+			case 2: density = 0.25; break;
+			case 3: density = 0.75; break;
+			case 4: density = 0.50; break;
+		}	/* fall through */
+	case FS_SOLID:
+		if (density == 1) {
+		    strcpy(fillcolor,canvas_state.color);
+		} else {
+		    int r = atoi(&canvas_state.color[4]);
+		    int g = atoi(&canvas_state.color[8]);
+		    int b = atoi(&canvas_state.color[12]);
+		    r = (float)r*density + 255.*(1.-density);
+		    g = (float)g*density + 255.*(1.-density);
+		    b = (float)b*density + 255.*(1.-density);
+		    sprintf(fillcolor,"rgb(%3d,%3d,%3d)%c", r, g, b, '\0');
+		}
+		break;
+	default:
+		/* Use current color, wherever it came from */
+		sprintf(fillcolor,"%s%c",canvas_state.color,'\0');
+    }
+
+    return fillcolor;
+}
+
+TERM_PUBLIC void
+CANVAS_filled_polygon(int points, gpiPoint *corners)
+{
+    int		i;
+
+    CANVAS_finish();
+
+    if (corners->style != FS_OPAQUE && corners->style != FS_DEFAULT) {
+	char *fillcolor = CANVAS_fillstyle(corners->style);
+	if (strcmp(canvas_state.previous_fill, fillcolor)) {
+	    fprintf(gpoutfile, "ctx.fillStyle = \"%s\";\n", fillcolor);
+	    strcpy(canvas_state.previous_fill, fillcolor);
+	}
+    }
+
+    fprintf(gpoutfile,
+	    "bp(%d, %d);\n"
+            , corners[0].x, canvas_ymax - corners[0].y);
+
+    for (i = 1; i < points; i++) {
+	fprintf(gpoutfile,
+		"L(%d, %d);\n"
+                , corners[i].x, canvas_ymax - corners[i].y);
+    }
+
+    if (corners->style != FS_OPAQUE && corners->style != FS_DEFAULT)
+	/* Fill with separate fillStyle color */
+	fprintf(gpoutfile, "cfp();\n");
+    else
+	/* Fill with stroke color */
+	fprintf(gpoutfile, "cfsp();\n");
+}
+
+TERM_PUBLIC void
+CANVAS_fillbox(int style, unsigned int x1, unsigned int y1, unsigned int width, unsigned int height)
+{
+    char *fillcolor = CANVAS_fillstyle(style);
+
+    /* Since filled-rectangle is a primitive operation for the canvas element */
+    /* it's worth making this a special case rather than using filled_polygon */
+	if (strcmp(canvas_state.previous_fill, fillcolor)) {
+	    fprintf(gpoutfile, "ctx.fillStyle = \"%s\";\n", fillcolor);
+	    strcpy(canvas_state.previous_fill, fillcolor);
+	}
+
+	fprintf(gpoutfile, "R(%d,%d,%d,%d);\n",
+		x1, canvas_ymax - (y1+height), width, height);
+}
+
+TERM_PUBLIC void 
+CANVAS_layer(t_termlayer layer)
+{
+	if (layer == TERM_LAYER_BEGIN_GRID) {
+	    fprintf(gpoutfile, "if (grid_lines) {\n"
+			"var saveWidth = ctx.lineWidth;\n"
+			"ctx.lineWidth = ctx.lineWidth * 0.5;\n");
+	} else if (layer == TERM_LAYER_END_GRID) {
+	    fprintf(gpoutfile,
+			"ctx.lineWidth = saveWidth;\n"
+			"} // grid_lines\n");
+	}
+}
+
+TERM_PUBLIC void
+CANVAS_path(int p)
+{
+    switch (p) {
+	case 1: /* Close path */
+		fprintf(gpoutfile, "ctx.closePath();\n");
+		already_closed = TRUE;
+		break;
+	case 0:
+		break;
+    }
+}
+
+/* Enhanced text mode support starts here */
+
+static double ENHCANVAS_base = 0.0;
+static double ENHCANVAS_fontsize = 0;
+static TBOOLEAN ENHCANVAS_opened_string = FALSE;
+static TBOOLEAN ENHCANVAS_show = TRUE;
+static TBOOLEAN ENHCANVAS_sizeonly = FALSE;
+static TBOOLEAN ENHCANVAS_widthflag = TRUE;
+static TBOOLEAN ENHCANVAS_overprint = FALSE;
+
+TERM_PUBLIC void
+ENHCANVAS_OPEN(
+    char *fontname,
+    double fontsize, double base,
+    TBOOLEAN widthflag, TBOOLEAN showflag,
+    int overprint)
+{
+    static int save_x, save_y;
+    /* overprint = 1 means print the base text (leave position in center)
+     * overprint = 2 means print the overlying text
+     * overprint = 3 means save current position
+     * overprint = 4 means restore saved position
+     */
+    if (overprint == 3) {
+	save_x = canvas_x;
+	save_y = canvas_y;
+	return;
+    }
+    if (overprint == 4) {
+	canvas_x = save_x;
+	canvas_y = save_y;
+	return;
+    }
+
+    if (!ENHCANVAS_opened_string) {
+	ENHCANVAS_opened_string = TRUE;
+	enhanced_cur_text = &enhanced_text[0];
+	ENHCANVAS_fontsize = fontsize;
+	ENHCANVAS_base = base * CANVAS_OVERSAMPLE;
+	ENHCANVAS_show = showflag;
+	ENHCANVAS_widthflag = widthflag;
+	ENHCANVAS_overprint = overprint;
+    }
+}
+
+/*
+ * Since we only have the one font, and the character widths are known,
+ * we can go to the trouble of actually counting character widths.
+ * As it happens, the averages width of ascii characters is 20.
+ */
+static int utf8strlen(char *s)
+{
+    int width = 0;
+    char *end = s + strlen(s);
+
+    while (*s) {
+	if ((*s & 0x80) == 0) {
+		if      (strchr("iIl|", *s)) width += 8;
+		else if (strchr("j`',;:!.", *s)) width += 10;
+		else if (strchr("ftr", *s)) width += 12;
+		else if (strchr("()[]{}\\", *s)) width += 14;
+		else if (strchr(" JTv^_\"*ykLsxz", *s)) width += 16;
+		else if (strchr("AceFV?abdEghnopqu", *s)) width += 18;
+		else if (strchr("M~<>%W=&@", *s)) width += 24;
+		else if (strchr("m", *s)) width += 30;
+		else width += 20;
+		s++;
+		continue;
+	}
+	else if (encoding != S_ENC_UTF8) s++;
+	else if ((*s & 0xE0) == 0xC0) s += 2;
+	else if ((*s & 0xF0) == 0xE0) s += 3;
+	else s += 4; 
+	width += 18;	/* Assumed average width for UTF8 characters */
+	if (s > end) break;
+    }
+    return (width);
+}
+
+TERM_PUBLIC void
+ENHCANVAS_FLUSH()
+{
+    double save_fontsize;
+    int x,y;
+    double w;
+
+    if (ENHCANVAS_opened_string) {
+	ENHCANVAS_opened_string = FALSE;
+	*enhanced_cur_text = '\0';
+
+	save_fontsize = canvas_font_size;
+	x = canvas_x;
+	y = canvas_y;
+	w = utf8strlen(enhanced_text) * CANVAS_OVERSAMPLE * ENHCANVAS_fontsize/25.;
+
+	canvas_font_size = ENHCANVAS_fontsize;
+	x -= sin((double)canvas_text_angle * M_PI_2/90.) * ENHCANVAS_base;
+	y += cos((double)canvas_text_angle * M_PI_2/90.) * ENHCANVAS_base;
+	if (ENHCANVAS_show && !ENHCANVAS_sizeonly)
+		CANVAS_put_text(x, y, enhanced_text);
+
+	if (ENHCANVAS_overprint == 1) {
+	    canvas_x += w * cos((double)canvas_text_angle * M_PI_2/90.)/2;
+	    canvas_y -= w * sin((double)canvas_text_angle * M_PI_2/90.)/2;
+	} else if (ENHCANVAS_widthflag) {
+	    canvas_x += w * cos((double)canvas_text_angle * M_PI_2/90.);
+	    canvas_y -= w * sin((double)canvas_text_angle * M_PI_2/90.);
+	}
+	canvas_font_size = save_fontsize;
+    }
+}
+
+TERM_PUBLIC void
+ENHCANVAS_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    char *original_string = (char *)str;
+
+    /* Save starting font properties */
+    double fontsize = canvas_font_size;
+    char *fontname = "";
+
+    if (!strlen(str))
+	return;
+
+    if (ignore_enhanced_text || !strpbrk(str, "{}^_@&~")) {
+	CANVAS_put_text(x, y, str);
+	return;
+    }
+
+    CANVAS_move(x,y);
+
+    /* Set up global variables needed by enhanced_recursion() */
+    enhanced_fontscale = 1.0;
+    strncpy(enhanced_escape_format,"%c",sizeof(enhanced_escape_format));
+    ENHCANVAS_opened_string = FALSE;
+    ENHCANVAS_fontsize = canvas_font_size;
+    if (!strcmp(canvas_justify,"Right") || !strcmp(canvas_justify,"Center"))
+	ENHCANVAS_sizeonly = TRUE;
+
+    while (*(str = enhanced_recursion((char *)str, TRUE,
+			fontname, fontsize, 0.0, TRUE, TRUE, 0))) {
+	(term->enhanced_flush)();
+	enh_err_check(str);
+	if (!*++str)
+	    break; /* end of string */
+    }
+
+    /* We can do text justification by running the entire top level string */
+    /* through 2 times, with the ENHgd_sizeonly flag set the first time.   */
+    /* After seeing where the final position is, we then offset the start  */
+    /* point accordingly and run it again without the flag set.            */
+    if (!strcmp(canvas_justify,"Right") || !strcmp(canvas_justify,"Center")) {
+	char *justification = canvas_justify;
+	int x_offset = canvas_x - x;
+	int y_offset = (canvas_text_angle == 0) ? 0 : canvas_y - y;
+
+	canvas_justify = "";
+	ENHCANVAS_sizeonly = FALSE;
+
+	if (!strcmp(justification,"Right")) {
+	    ENHCANVAS_put_text(x - x_offset, y - y_offset, original_string);
+	} else if (!strcmp(justification,"Center")) {
+	    ENHCANVAS_put_text(x - x_offset/2, y - y_offset/2, original_string);
+	}
+	canvas_justify = justification;
+    }
+
+    /* Make sure we leave with the same font properties as on entry */
+	canvas_font_size = fontsize;
+	ENHCANVAS_base = 0;
+
+    return;
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+TERM_TABLE_START(canvas_driver)
+    "canvas", "HTML Canvas object",
+    CANVAS_XMAX, CANVAS_YMAX, CANVASVCHAR, CANVASHCHAR,
+    CANVASVTIC, CANVASHTIC, CANVAS_options, CANVAS_init, CANVAS_reset,
+    CANVAS_text, null_scale, CANVAS_graphics, CANVAS_move, CANVAS_vector,
+    CANVAS_linetype, CANVAS_put_text, CANVAS_text_angle,
+    CANVAS_justify_text, CANVAS_point, do_arrow, 
+    set_font_null,
+    CANVAS_pointsize,
+    TERM_CAN_MULTIPLOT|TERM_ALPHA_CHANNEL|TERM_LINEWIDTH,
+    NULL, NULL, CANVAS_fillbox, CANVAS_linewidth
+#ifdef USE_MOUSE
+    , NULL, NULL, NULL, NULL, NULL
+#endif
+    , CANVAS_make_palette, NULL, CANVAS_set_color
+    , CANVAS_filled_polygon
+    , NULL /* image */
+    , ENHCANVAS_OPEN, ENHCANVAS_FLUSH, do_enh_writec
+    , CANVAS_layer
+    , CANVAS_path		/* path */
+TERM_TABLE_END(canvas_driver)
+
+#undef LAST_TERM
+#define LAST_TERM canvas_driver
+
+#endif /* TERM_TABLE */
+
+#ifdef TERM_HELP
+START_HELP(canvas)
+"1 canvas",
+"?commands set terminal canvas",
+"?set terminal canvas",
+"?set term canvas",
+"?terminal canvas",
+"?term canvas",
+"",
+" Syntax:",
+"       set terminal canvas {size <xsize>, <ysize>} {fsize <fontsize>}",
+"                           {{no}enhanced} {linewidth <lw>}",
+"                           {standalone {mousing} | name '<funcname>'}",
+"                           {jsdir 'URL/for/javascripts'}",
+"                           {title '<some string>'}",
+"",
+" where <xsize> and <ysize> set the size of the plot area in pixels.",
+" The default size in standalone mode is 600 by 400 pixels.",
+" The default font size is 10.  NB: Only one font is available, the ascii",
+" portion of Hershey simplex Roman provided in the file canvastext.js.",
+" You can replace this with the file canvasmath.js, which contains also",
+" UTF-8 encoded Hershey simplex Greek and math symbols.",
+"",
+" The default `standalone` mode creates an html page containing javascript",
+" code that renders the plot using the HTML 5 canvas element.  The html page",
+" links to two required javascript files 'canvastext.js' and 'gnuplot_common.js'.",
+" By default these point to local files, on unix-like systems usually in",
+" directory /usr/local/share/gnuplot/<version>/js.  See installation notes for",
+" other platforms. You can change this by using the `jsdir` option to specify",
+" either a different local directory or a general URL.  The latter is usually",
+" appropriate if the plot is exported for viewing on remote client machines.",
+"",
+" All plots produced by the canvas terminal are mouseable.  The additional",
+" keyword `mousing` causes the `standalone` mode to add a mouse-tracking box",
+" underneath the plot. It also adds a link to a javascript file",
+" 'gnuplot_mouse.js' and to a stylesheet for the mouse box 'gnuplot_mouse.css'",
+" in the same local or URL directory as 'canvastext.js'.",
+"",
+" The `name` option creates a file containing only javascript. Both the",
+" javascript function it contains and the id of the canvas element that it",
+" draws onto are taken from the following string parameter.  The commands",
+"       set term canvas name 'fishplot'",
+"       set output 'fishplot.js'",
+" will create a file containing a javascript function fishplot() that will",
+" draw onto a canvas with id=fishplot.  An html page that invokes this",
+" javascript function must also load the canvastext.js function as described",
+" above.  A minimal html file to wrap the fishplot created above might be:",
+"",
+"       <html>",
+"       <head>",
+"           <script src=\"canvastext.js\"></script>",
+"           <script src=\"gnuplot_common.js\"></script>",
+"       </head>",
+"       <body onload=\"fishplot();\">",
+"           <script src=\"fishplot.js\"></script>",
+"           <canvas id=\"fishplot\" width=600 height=400>",
+"               <div id=\"err_msg\">No support for HTML 5 canvas element</div>",
+"           </canvas>",
+"       </body>",
+"       </html>",
+""
+END_HELP(canvas)
+#endif /* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/cgi.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/cgi.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/cgi.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/cgi.trm.svn-base	2012-01-03 17:07:25.973334500 -0800
@@ -0,0 +1,342 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: cgi.trm,v 1.14 2006/07/21 02:35:45 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - cgi.trm */
+
+/*[
+ * Copyright (C) 1990 - 1993 Ronald Florence
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.h.
+ *
+ * This terminal driver supports SCO CGI drivers
+ *
+ * AUTHOR
+ *   Ronald Florence <ron@18james.com>
+ */
+
+/*
+ * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(cgi)
+register_term(hcgi)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void CGI_init __PROTO((void));
+TERM_PUBLIC void HCGI_init __PROTO((void));
+TERM_PUBLIC void CGI_graphics __PROTO((void));
+TERM_PUBLIC void CGI_text __PROTO((void));
+TERM_PUBLIC void CGI_reset __PROTO((void));
+TERM_PUBLIC void CGI_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void CGI_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void CGI_linetype __PROTO((int linetype));
+TERM_PUBLIC void CGI_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC int CGI_text_angle __PROTO((int ang));
+TERM_PUBLIC int CGI_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC void CGI_point __PROTO((unsigned int x, unsigned int y, int num));
+#define CGI_XMAX	32767
+#define CGI_YMAX	32767
+#define CGI_VTIC	(CGI_YMAX / 75)
+#define CGI_HTIC	term->h_tic
+#define CGI_VCHAR	term->v_char
+#define CGI_HCHAR	term->h_char
+#endif
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+#ifdef VGA_MONO
+static short rgb[16][3] =
+{
+    0, 0, 0,			/* Black        */
+    1000, 1000, 1000,		/* White        */
+    800, 800, 0,		/* Red          */
+    0, 600, 0,			/* Green        */
+    0, 800, 800,		/* Blue         */
+    1000, 1000, 400,		/* Yellow       */
+    0, 600, 600,		/* Cyan         */
+    600, 600, 600,		/* Magenta      */
+    800, 800, 0,		/* Brown        */
+    600, 600, 600,		/* Lt. Grey     */
+    400, 600, 400,		/* Dark Grey    */
+    400, 600, 1000,		/* Lt. Blue     */
+    400, 1000, 400,		/* Lt Green     */
+    400, 1000, 1000,		/* Lt Cyan      */
+    1000, 600, 400,		/* Lt Red       */
+    600, 600, 1000		/* Lt Magenta   */
+};
+#endif
+
+#define CRT		(gout[45] == 0)
+#define CGICOLORS	gout[13]
+#define CGILINES	gout[6]
+#define CGIROTATES	gout[36]
+#define CGITEXTALIGN	gout[48]
+
+static short gout[66];
+static short cgidev;
+static short vect[4];
+static short gin[19] =
+{
+    0,				/* default aspect ratio */
+    1,				/* solid line */
+    1,				/* line color */
+    1,				/* marker type . */
+    1,				/* marker color */
+    1,				/* graphics text font */
+    1,				/* graphics text color */
+    0,				/* fill interior style */
+    0,				/* fill style index */
+    1,				/* fill color index */
+    1				/* prompt for paper changes */
+};
+
+char *cgidriver, *getenv();
+
+
+TERM_PUBLIC void
+CGI_init()
+{
+    if (getenv(cgidriver = "CGIDISP") == NULL)
+	HCGI_init();
+}
+
+
+TERM_PUBLIC void
+HCGI_init()
+{
+    if (getenv(cgidriver = "CGIPRNT") == NULL)
+	int_error(NO_CARET, "no CGI driver");
+}
+
+
+TERM_PUBLIC void
+CGI_graphics()
+{
+    int i, aspect;
+    char *s;
+    short font_cap[9];
+
+    if ((s = getenv("ASPECT")) != NULL && (aspect = atoi(s)) >= 0 && aspect <= 3)
+	gin[0] = aspect;
+    for (i = 0; cgidriver[i]; i++)
+	gin[11 + i] = cgidriver[i];
+    gin[18] = ' ';
+
+    if (v_opnwk(gin, &cgidev, gout) < 0) {
+	int_error(NO_CARET, "CGI error %d opening %s", -vq_error(), cgidriver);
+    }
+    vqt_representation(cgidev, 9, font_cap);
+    CGI_VCHAR = font_cap[8] * 3 / 2;
+    CGI_HCHAR = font_cap[7];
+    CGI_HTIC = CGI_VTIC * ((double) gout[1] / (double) gout[4]) /
+	((double) gout[0] / (double) gout[3]);
+#ifdef VGA_MONO
+    if (CGICOLORS > 2)
+	vsc_table(cgidev, 0, CGICOLORS, rgb);
+#endif
+}
+
+
+TERM_PUBLIC void
+CGI_text()
+{
+    if (CRT) {
+	short ptin[2];
+	char strin[2];
+
+	ptin[0] = 0;
+	ptin[1] = 0;
+	vrq_string(cgidev, 1, 0, ptin, strin);
+    }
+    v_clswk(cgidev);
+}
+
+
+TERM_PUBLIC void
+CGI_reset()
+{
+}
+
+
+TERM_PUBLIC void
+CGI_move(unsigned int x, unsigned int y)
+{
+    vect[0] = x;
+    vect[1] = y;
+}
+
+TERM_PUBLIC void
+CGI_vector(unsigned int x, unsigned int y)
+{
+    vect[2] = x;
+    vect[3] = y;
+    v_pline(cgidev, 2, vect);
+    vect[0] = x;
+    vect[1] = y;
+}
+
+
+TERM_PUBLIC void
+CGI_linetype(int linetype)
+{
+    short lcolor;
+
+    if (CGICOLORS > 2) {
+	lcolor = (linetype + 2) % CGICOLORS + 1;
+	vsl_color(cgidev, lcolor);
+	vsm_color(cgidev, lcolor);
+    }
+    vsl_type(cgidev, (linetype < 1) ? 1 : (linetype % CGILINES) + 1);
+}
+
+
+TERM_PUBLIC void
+CGI_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    v_gtext(cgidev, (short) x, (short) y, str);
+}
+
+
+TERM_PUBLIC int
+CGI_text_angle(int ang)
+{
+    if (!CGIROTATES)
+	return FALSE;
+    /* angles are 1/10 degree ccw */
+    vst_rotation(cgidev, (ang) ? 900 : 0);
+    return TRUE;
+}
+
+
+TERM_PUBLIC int
+CGI_justify_text(enum JUSTIFY mode)
+{
+    short hor_in, hor_out, vert_out;
+
+    if (!CGITEXTALIGN)
+	return FALSE;
+
+    switch (mode) {
+    case LEFT:
+	hor_in = 0;
+	break;
+    case CENTRE:
+	hor_in = 1;
+	break;
+    case RIGHT:
+	hor_in = 2;
+	break;
+    }
+    vst_alignment(cgidev, hor_in, 1, &hor_out, &vert_out);
+    return TRUE;
+}
+
+
+#define POINT_TYPES 6
+
+TERM_PUBLIC void
+CGI_point(unsigned int x, unsigned y, int num)
+{
+    short point[2];
+    static short cgimarker[POINT_TYPES] = { 1, 2, 6, 4, 5, 3 };
+    /* .  +  <> [] X  * */
+    if (num < 0) {
+	CGI_move(x, y);
+	CGI_vector(x, y);
+    } else {
+	vsm_type(cgidev, cgimarker[num % POINT_TYPES]);
+	point[0] = x;
+	point[1] = y;
+	v_pmarker(cgidev, 1, point);
+    }
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(cgi_driver)
+    "cgi", "SCO CGI drivers (requires CGIDISP or CGIPRNT env variable)",
+    CGI_XMAX, CGI_YMAX, 0, 0,
+    CGI_VTIC, 0, options_null, CGI_init, CGI_reset,
+    CGI_text, null_scale, CGI_graphics, CGI_move, CGI_vector,
+    CGI_linetype, CGI_put_text, CGI_text_angle,
+    CGI_justify_text, CGI_point, do_arrow, set_font_null
+TERM_TABLE_END(cgi_driver)
+
+#undef LAST_TERM
+#define LAST_TERM cgi_driver
+
+TERM_TABLE_START(hcgi_driver)
+    "hcgi", "SCO CGI drivers (hardcopy, requires CGIPRNT env variable)",
+    CGI_XMAX, CGI_YMAX, 0, 0,
+    CGI_VTIC, 0, options_null, HCGI_init, CGI_reset,
+    CGI_text, null_scale, CGI_graphics, CGI_move, CGI_vector,
+    CGI_linetype, CGI_put_text, CGI_text_angle,
+    CGI_justify_text, CGI_point, do_arrow, set_font_null
+TERM_TABLE_END(hcgi_driver)
+
+#undef LAST_TERM
+#define LAST_TERM hcgi_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(cgi)
+"1 cgi",
+"?commands set terminal cgi",
+"?set terminal cgi",
+"?set term cgi",
+"?terminal cgi",
+"?term cgi",
+"?cgi",
+"?commands set terminal hcgi",
+"?set terminal hcgi",
+"?set term hcgi",
+"?terminal hcgi",
+"?term hcgi",
+"?hcgi",
+" The `cgi` and `hcgi` terminal drivers support SCO CGI drivers.  `hcgi` is for",
+" printers; the environment variable CGIPRNT must be set.  `cgi` may be used",
+" for either a display or hardcopy; if the environment variable CGIDISP is set,",
+" then that display is used.  Otherwise CGIPRNT is used.",
+"",
+" These terminals have no options."
+END_HELP(cgi)
+#endif
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/cgm.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/cgm.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/cgm.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/cgm.trm.svn-base	2012-01-03 17:07:26.178867500 -0800
@@ -0,0 +1,2032 @@
+/* Hey Emacs this is -*- C -*-
+ * $Id: cgm.trm,v 1.91.2.3 2010/02/24 20:16:57 sfeam Exp $
+ */
+
+/* GNUPLOT - cgm.trm */
+
+/*[
+ * Copyright 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c and ../docs/termdoc.c.
+ *
+ * This terminal driver supports:
+ *   Computer Graphics Metafile
+ *
+ * TODO
+ *   better control over plot size (never cutting off labels, correct font
+ *   sizes)
+
+ * REFERENCES
+ *
+ *   ISO 8632-1:1992 Computer Graphics Metafile (CGM), Part 1,
+ *   Functional Specification.
+ *
+ *   ISO 8632-1:1992 Computer Graphics Metafile (CGM), Part 3,
+ *   Binary Encoding.
+ *
+ *   FIPS PUB 128 - Computer Graphics Metafile (CGM).
+ *
+ *   MIL-STD-2301A Computer Graphics Metafile (CGM) Implementation
+ *   Standard for the National Imagery Transmission Format Standard, 5
+ *   June 1998, http://164.214.2.51/ntb/baseline/docs/2301a/.  Only a
+ *   subset of CGM version 1, but does include the binary format for
+ *   that subset.
+ *
+ *   MIL-D-28003A "Digital Representation for Communication of
+ *   Illustration Data: CGM Application Profile", 15 November 1991,
+ *   http://www-cals.itsi.disa.mil/core/standards/28003aa1.pdf.
+ *
+ *   "The computer graphics metafile", Lofton R. Henderson and Anne
+ *   M. Mumford, Butterworths, London, 1990, ISBN 0-408-02680-4.
+ *
+ * AUTHOR
+ *   Jim Van Zandt <jrvz@comcast.net>
+ *
+ * send your comments or suggestions to the author or
+ * gnuplot-info@lists.sourceforge.net.
+*/
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(cgm)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void CGM_options __PROTO((void));
+TERM_PUBLIC void CGM_init __PROTO((void));
+TERM_PUBLIC void CGM_reset __PROTO((void));
+TERM_PUBLIC void CGM_text __PROTO((void));
+TERM_PUBLIC void CGM_graphics __PROTO((void));
+TERM_PUBLIC void CGM_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void CGM_dashed_vector __PROTO((unsigned int ux, unsigned int uy));
+TERM_PUBLIC void CGM_solid_vector __PROTO((unsigned int ux, unsigned int uy));
+TERM_PUBLIC void CGM_linetype __PROTO((int linetype));
+TERM_PUBLIC void CGM_linecolor __PROTO((int color));
+TERM_PUBLIC void CGM_dashtype __PROTO((int dashtype));
+TERM_PUBLIC void CGM_linewidth __PROTO((double width));
+TERM_PUBLIC void CGM_put_text __PROTO((unsigned int x, unsigned int y,
+				       const char *str));
+TERM_PUBLIC int CGM_text_angle __PROTO((int ang));
+TERM_PUBLIC int CGM_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC int CGM_set_font __PROTO((const char *font));
+TERM_PUBLIC void CGM_point __PROTO((unsigned int x, unsigned int y,
+				    int number));
+TERM_PUBLIC void CGM_fillbox __PROTO((int style, unsigned int x1, unsigned int y1,
+				unsigned int width, unsigned int height));
+TERM_PUBLIC int CGM_make_palette __PROTO((t_sm_palette *palette));
+TERM_PUBLIC void CGM_set_color __PROTO((t_colorspec *));
+
+TERM_PUBLIC void CGM_filled_polygon __PROTO((int points, gpiPoint *corner));
+
+TERM_PUBLIC void CGM_set_pointsize __PROTO((double size));
+
+#define FATAL(msg) { fprintf(stderr, "%s\nFile %s line %d\n", msg, __FILE__, __LINE__); exit(EXIT_FAILURE); }
+
+#define CGM_LARGE 32767
+#define CGM_SMALL 32767/18*13	/* aspect ratio 1:.7222 */
+#define CGM_MARGIN (CGM_LARGE/180)
+				/* convert from plot units to pt */
+#define CGM_PT ((term->xmax + CGM_MARGIN)/cgm_plotwidth)
+#define CGM_LINE_TYPES 9	/* number of line types we support */
+#define CGM_COLORS 96		/* must not exceed size of pm3d_color_names_tbl[] */
+#define CGM_POINTS 13		/* number of markers we support */
+#define CGM_MAX_SEGMENTS 16382	/* maximum # polyline coordinates */
+#define CGM_VCHAR (CGM_SMALL/360*12)
+#define CGM_HCHAR (CGM_SMALL/360*12*5/9)
+#define CGM_VTIC (CGM_LARGE/80)
+#define CGM_HTIC (CGM_LARGE/80)
+#endif
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+static int CGM_find_font __PROTO((const char *name, int len, double *relwidth));
+static int CGM_find_nearest_color __PROTO((t_colorspec *colorspec));
+/*
+ * on NeXTstep, id is an identifier (in ObjC) and causes a parse error
+ * since some asserts below are mistaken as casts. datum is a type
+ * defined in ndbm.h which also causes a parse error (ndbm.h is
+ * included as part of appkit.h, I think).  Strangely enough, both
+ * errors only happen with cpp-precomp -smart, not with the regular
+ * cpp. (AL)
+ */
+
+#ifdef NEXT
+#define id id_
+#define datum datum_
+#endif
+
+#include <ctype.h>		/* for isspace() */
+
+#ifndef assert
+#define assert(x) 0		/* defeat assertions */
+#endif
+
+/* uncomment the following to enable assertions for this module only,
+   regardless of compiler switches
+#ifdef NDEBUG
+#define DEFEAT_ASSERTIONS
+#endif
+#undef NDEBUG
+#include <assert.h>
+ */
+
+#define CGM_ADJ (sizeof(int)/sizeof(short))
+
+static unsigned int cgm_posx;
+static unsigned int cgm_posy;
+static unsigned int cgm_linetype = 1;
+static unsigned int cgm_linetypes = CGM_LINE_TYPES + 3;
+static unsigned int cgm_dashtype = 0;
+static unsigned int cgm_color = 0;
+static int *cgm_polyline; /* stored polyline coordinates */
+static int cgm_coords = 0;	/* # polyline coordinates saved */
+static int cgm_doing_polygon = 0; /* nonzero if creating polygon, else
+				   * creating polyline */
+/* static enum JUSTIFY cgm_justify = LEFT; */ /* unused */
+static int cgm_step_sizes[8];	/* array of currently used dash
+				   lengths in plot units */
+static int cgm_step_index = 0;	/* index into cgm_step_sizes[] */
+static int cgm_step = 0;	/* amount of current dash not yet
+				   drawn, in plot units */
+static int cgm_tic, cgm_tic707, cgm_tic866, cgm_tic500, cgm_tic1241, cgm_tic1077, cgm_tic621;	/* marker dimensions */
+struct cgm_properties {
+  double angle;			/* angle of text baseline (radians
+                                   counter-clockwise from horizontal) */
+  int font_index;		/* font index */
+  int char_height;		/* character height in picture units */
+  enum JUSTIFY justify_mode;	/* how text is justified */
+
+  int edge_visibility;		/* nonzero if edge is visible */
+  int edge_color;
+  int fill_color;
+  int interior_style;
+  int hatch_index;
+};
+
+static struct cgm_properties
+    cgm_current={-1,-1,-1,(enum JUSTIFY)-1,-1,-1,-1,-1,-1}, /* written to file */
+    cgm_next={0,-2,-2,LEFT,-2,-2,-2,-1,-1}, /* needed for next text string/marker */
+    cgm_reset={-1,-1,-1,(enum JUSTIFY)-1,-1,-1,-1,-1,-1}; /* invalid entries */
+
+static int cgm_user_color_count = 0;
+static int cgm_user_color_max = 0;
+static int cgm_smooth_colors = 0;
+static int GPFAR *cgm_user_color_table = (int GPFAR*)0;
+static int cgm_maximum_color_index = 255;	/* Size of color table we will write */
+
+struct fontdata {
+  char *name;			/* the name of the font */
+  double width;			/* the width of the font, relative to
+                                   Times Bold Italic.  The width
+                                   adjustment can only be approximate.
+                                   Of the standard fonts, only the
+                                   four versions of "Courier" are
+                                   monospaced. Also, metrics of the
+                                   same font from different foundaries
+                                   are sometimes different.  */
+};
+
+static struct fontdata cgm_basic_font_data[]={
+    /* these are WebCGM recommended fonts */
+    {"Helvetica",1.039},
+    {"Helvetica Oblique",1.099},
+    {"Helvetica Bold",1.083},
+    {"Helvetica Bold Oblique",1.011},
+    {"Times Roman",.981},
+    {"Times Bold",.985},
+    {"Times Italic",.959},
+    {"Times Bold Italic",1.0},
+    {"Courier",1.327},
+    {"Courier Bold",1.327},
+    {"Courier Oblique",1.218},
+    {"Courier Bold Oblique",1.341},
+    {"Symbol",.897},
+
+    /* These are basic public domain fonts required by MIL-D-28003A */
+    {"Hershey/Cartographic_Roman",1.2404},
+    {"Hershey/Cartographic_Greek",.9094},
+    {"Hershey/Simplex_Roman",1.2369},
+    {"Hershey/Simplex_Greek",.9129},
+    {"Hershey/Simplex_Script",1.4181},
+    {"Hershey/Complex_Roman",1.1150},
+    {"Hershey/Complex_Greek",.9059},
+    {"Hershey/Complex_Script",1.3868},
+    {"Hershey/Complex_Italic",1.4146},
+    {"Hershey/Complex_Cyrillic",1.2056},
+    {"Hershey/Duplex_Roman",1.1707},
+    {"Hershey/Triplex_Roman",1.3240},
+    {"Hershey/Triplex_Italic",1.3310},
+    {"Hershey/Gothic_German",1.2056},
+    {"Hershey/Gothic_English",1.2021},
+    {"Hershey/Gothic_Italian",1.2021},
+    {"Hershey/Symbol_Set_1",.9059},
+    {"Hershey/Symbol_Set_2",.9059},
+    {"Hershey/Symbol_Math",.9059},
+
+    /* These are available in the Microsoft Office import filter.  By
+       default, the script font can apparently be accessed only via
+       the name "15".  */
+    {"ZapfDingbats",1.583},
+    {"Script",1.139},
+    {"15",1.139},
+
+    /* in the Microsoft Office and Corel Draw import filters, these
+       are pseudonyms for some of the above */
+    {"Helvetica Italic",1.099},
+    {"Helvetica Bold Italic",1.011},
+    {"Courier Italic",1.218},
+    {"Courier Bold Italic",1.341},
+    {"Times Oblique",.959},
+    {"Times Bold Oblique",1.0},
+
+    {0,0}
+};
+
+static struct fontdata *cgm_font_data = cgm_basic_font_data;
+
+#define DEFAULT_CGMFONT "Helvetica Bold"
+static char CGM_default_font[MAX_ID_LEN+1] = {'\0'};
+
+/* variables to record the options */
+static char cgm_font[32] = DEFAULT_CGMFONT;
+static unsigned int cgm_fontsize = 12;
+static unsigned cgm_linewidth;	/* line width in plot units */
+static unsigned cgm_linewidth_pt = 1;	/* line width in pt */
+static TBOOLEAN cgm_monochrome = FALSE;		/* colors enabled? */
+static int cgm_plotwidth = 432;	/* assumed width of plot in pt. */
+static TBOOLEAN cgm_portrait = FALSE;	/* portrait orientation? */
+static TBOOLEAN cgm_rotate = TRUE;	/* text rotation enabled? */
+static TBOOLEAN cgm_dashed = TRUE;	/* dashed linestyles enabled? */
+static TBOOLEAN cgm_nofontlist_mode = FALSE;	/* omit font list? */
+
+/* prototypes for static functions */
+static void CGM_local_reset __PROTO((void));
+static void CGM_flush_polyline __PROTO((void));
+static void CGM_flush_polygon __PROTO((void));
+static void CGM_write_char_record __PROTO((int class, int cgm_id, int length,
+					   char *data));
+static void CGM_write_code __PROTO((int class, int cgm_id, int length));
+static void CGM_write_int __PROTO((int value));
+static void CGM_write_int_record __PROTO((int class, int cgm_id, int length,
+					  int *data));
+static void CGM_write_mixed_record __PROTO((int class, int cgm_id,
+					    int numint, int *int_data,
+					    int numchar, const char *char_data));
+static void CGM_write_byte_record __PROTO((int class, int cgm_id, int length,
+					   char *data));
+
+enum CGM_id {
+    /* cgm mode */
+    CGM_PORTRAIT, CGM_LANDSCAPE, CGM_DEFAULT,
+    /* color */
+    CGM_MONOCHROME, CGM_COLOR,
+    /* rotation */
+    CGM_ROTATE, CGM_NOROTATE,
+    CGM_DASHED, CGM_SOLID,
+    CGM_LINEWIDTH, CGM_WIDTH, CGM_NOFONTLIST, CGM_OTHER
+};
+
+static struct gen_table CGM_opts[] =
+{
+    { "p$ortrait", CGM_PORTRAIT },
+    { "la$ndscape", CGM_LANDSCAPE },
+    { "de$fault", CGM_DEFAULT },
+    { "nof$ontlist", CGM_NOFONTLIST },
+    { "win$word6", CGM_NOFONTLIST }, /* deprecated */
+    { "m$onochrome", CGM_MONOCHROME },
+    { "c$olor", CGM_COLOR },
+    { "c$olour", CGM_COLOR },
+    { "r$otate", CGM_ROTATE },
+    { "nor$otate", CGM_NOROTATE },
+    { "da$shed", CGM_DASHED },
+    { "s$olid", CGM_SOLID },
+    { "li$newidth", CGM_LINEWIDTH },
+    { "lw", CGM_LINEWIDTH },
+    { "wid$th", CGM_WIDTH },
+    { NULL, CGM_OTHER }
+};
+
+
+TERM_PUBLIC void
+CGM_options()
+{
+    char *string;
+
+    /* Annoying hack to handle the case of 'set termoption' after */
+    /* we have already initialized the terminal.                  */
+    if (c_token != 2)
+	CGM_local_reset();
+
+    while (!END_OF_COMMAND) {
+	switch(lookup_table(&CGM_opts[0],c_token)) {
+	case CGM_PORTRAIT:
+	    cgm_portrait = TRUE;
+	    c_token++;
+	    break;
+	case CGM_LANDSCAPE:
+	    cgm_portrait = FALSE;
+	    c_token++;
+	    break;
+	case CGM_DEFAULT:
+	    CGM_local_reset();
+	    c_token++;
+	    break;
+	case CGM_NOFONTLIST:
+	    cgm_nofontlist_mode = TRUE;
+	    c_token++;
+	    break;
+	case CGM_MONOCHROME:
+	    cgm_monochrome = TRUE;
+	    term->flags |= TERM_MONOCHROME;
+	    c_token++;
+	    break;
+	case CGM_COLOR:
+	    cgm_monochrome = FALSE;
+	    term->flags &= ~TERM_MONOCHROME;
+	    c_token++;
+	    break;
+	case CGM_ROTATE:
+	    cgm_rotate = TRUE;
+	    c_token++;
+	    break;
+	case CGM_NOROTATE:
+	    cgm_rotate = FALSE;
+	    c_token++;
+	    break;
+	case CGM_DASHED:
+	    cgm_dashed = TRUE;
+	    c_token++;
+	    break;
+	case CGM_SOLID:
+	    cgm_dashed = FALSE;
+	    c_token++;
+	    break;
+	case CGM_LINEWIDTH:
+	    c_token++;
+	    if (!END_OF_COMMAND) {
+		cgm_linewidth_pt = int_expression();
+		if (cgm_linewidth_pt == 0 || cgm_linewidth_pt > 10000) {
+		    int_warn(c_token,"linewidth out of range");
+		    cgm_linewidth_pt = 1;
+		}
+	    }
+	    break;
+	case CGM_WIDTH:
+	    c_token++;
+	    if (!END_OF_COMMAND) {
+		cgm_plotwidth = int_expression();
+		if (cgm_plotwidth < 0 || cgm_plotwidth > 10000) {
+		    int_warn(c_token,"width out of range");
+		    cgm_plotwidth = 6 * 72;
+		}
+	    }
+	    break;
+	case CGM_OTHER:
+	default:
+	    string = gp_input_line + token[c_token].start_index;
+
+	    if (string[0] == 'x') { /* set color */
+	        unsigned short red, green, blue;
+
+		if (sscanf(string, "x%2hx%2hx%2hx", &red, &green, &blue ) != 3)
+		     int_error(c_token, "invalid color spec, must be xRRGGBB");
+		if (cgm_user_color_count >= cgm_user_color_max) {
+		     cgm_user_color_max = cgm_user_color_max*2 + 4;
+		     cgm_user_color_table =
+			  gp_realloc(cgm_user_color_table,
+				     (cgm_user_color_max*3+1)*sizeof(int),
+				     "CGM color table");
+		     /* 1st table entry is the minimum color index value */
+		     cgm_user_color_table[0] = 0;
+		}
+		cgm_user_color_table[1 + 3*cgm_user_color_count] = red;
+		cgm_user_color_table[2 + 3*cgm_user_color_count] = green;
+		cgm_user_color_table[3 + 3*cgm_user_color_count] = blue;
+		cgm_user_color_count++;
+		++c_token;
+	    } else {
+		if (equals(c_token,"font"))
+		    c_token++;
+		if (isstringvalue(c_token)) {
+		    double relwidth;
+		    int font_index;
+		    char *s = try_to_get_string();
+		    char *comma = strchr(s,',');
+		    if (comma && (1 == sscanf(comma+1,"%d",&cgm_fontsize)))
+			   *comma = '\0';
+		    if (*s)
+		      	   font_index = CGM_find_font(s, strlen(s), &relwidth);
+		    else
+			   font_index = CGM_find_font(cgm_font, strlen(cgm_font), &relwidth);
+		    if (font_index == 0) {
+			/* insert the font in the font table */
+			struct fontdata *new_font_data;
+			int i, n;
+			for (n=0; cgm_font_data[n].name; n++)
+				;
+			new_font_data = gp_alloc((n + 2)*sizeof(struct fontdata), "CGM font list");
+			new_font_data->name = s;
+			/* punt, since we don't know the real font width */
+			new_font_data->width = 1.0;
+			for (i = 0; i <= n; i++)
+			     new_font_data[i+1] = cgm_font_data[i];
+			cgm_font_data = new_font_data;
+			font_index = 1;
+		    } else
+			free(s);
+		    strncpy(cgm_font, cgm_font_data[font_index-1].name, sizeof(cgm_font));
+
+		} else {
+		      /* the user is specifying the font size */
+		      cgm_fontsize = int_expression();
+		}
+		 break;
+	    }
+	}
+    }
+
+    if (cgm_portrait) {
+	term->xmax = CGM_SMALL - CGM_MARGIN;
+	term->ymax = CGM_LARGE - CGM_MARGIN;
+    } else {
+	term->xmax = CGM_LARGE - CGM_MARGIN;
+	term->ymax = CGM_SMALL - CGM_MARGIN;
+    }
+
+    {   /* cgm_font, cgm_fontsize, and/or term->v_char may have changed */
+        double w;
+	CGM_find_font(cgm_font, strlen(cgm_font), &w);
+	term->v_char = (unsigned int) (cgm_fontsize*CGM_PT);
+	term->h_char = (unsigned int) (cgm_fontsize*CGM_PT*.527*w);
+    }
+
+    sprintf(CGM_default_font, "%s,%d", cgm_font, cgm_fontsize);
+    /* CGM_default_font holds the font and size set at 'set term' */
+    sprintf(term_options, "%s %s %s %s %s width %d linewidth %d \"%s\" %d",
+	    cgm_portrait ? "portrait" : "landscape",
+	    cgm_monochrome ? "monochrome" : "color",
+	    cgm_rotate ? "rotate" : "norotate",
+	    cgm_dashed ? "dashed" : "solid",
+	    cgm_nofontlist_mode ? "nofontlist" : "",
+	    cgm_plotwidth,
+	    cgm_linewidth_pt,
+	    cgm_font, cgm_fontsize);
+
+    if (cgm_user_color_count) {
+	 int i, red, green, blue;
+	 for (i = 0; i < cgm_user_color_count &&
+		   (strlen(term_options) + 9 < MAX_LINE_LEN); i++) {
+	      red = cgm_user_color_table[1 + 3*i];
+	      green = cgm_user_color_table[2 + 3*i];
+	      blue = cgm_user_color_table[3 + 3*i];
+	      sprintf(term_options + strlen(term_options),
+		      " x%02x%02x%02x", red, green, blue);
+	 }
+    }
+
+    if (cgm_user_color_count < CGM_COLORS) {
+	int i, j;
+
+	/* fill in colors not set by the user with the default colors */
+
+	/* 1st table entry is the minimum color index value */
+	cgm_user_color_table = gp_realloc(cgm_user_color_table,
+		(CGM_COLORS * 3 + 1) * sizeof (int), "CGM color table");
+	cgm_user_color_table[0] = 0;
+
+	for (i = cgm_user_color_count, j = cgm_user_color_count * 3;
+		     i < CGM_COLORS; i++, j+=3) {
+		cgm_user_color_table[j+1] = (pm3d_color_names_tbl[i].value >> 16) & 0xff;
+		cgm_user_color_table[j+2] = (pm3d_color_names_tbl[i].value >>  8) & 0xff;
+		cgm_user_color_table[j+3] = (pm3d_color_names_tbl[i].value      ) & 0xff;
+	}
+
+	cgm_user_color_count = CGM_COLORS;
+    }
+
+}
+
+static void
+CGM_local_reset()
+{
+    double w;
+    strcpy(cgm_font, DEFAULT_CGMFONT);
+    CGM_find_font(cgm_font, strlen(cgm_font), &w);
+    cgm_fontsize = 12;
+    term->v_char = (unsigned int) (cgm_fontsize * CGM_PT);
+    term->h_char = (unsigned int) (cgm_fontsize * CGM_PT * .527 * w);
+    cgm_linewidth_pt = 1;
+    cgm_monochrome = FALSE;
+    cgm_plotwidth = 6 * 72;
+    cgm_portrait = FALSE;
+    cgm_rotate = TRUE;
+    cgm_dashed = TRUE;
+    cgm_nofontlist_mode = FALSE;
+    cgm_current = cgm_reset;
+    cgm_user_color_count = 0;
+}
+
+TERM_PUBLIC void
+CGM_init()
+{
+    cgm_posx = cgm_posy = 0;
+    cgm_linetype = 0;
+    cgm_next.angle = 0;
+    cgm_next.interior_style = 1;
+    cgm_next.hatch_index = 1;
+    cgm_polyline = gp_alloc(CGM_MAX_SEGMENTS*sizeof(int),"cgm polylines");
+}
+
+TERM_PUBLIC void
+CGM_graphics()
+{
+    register struct termentry *t = term;
+    static int version_data[] = { 1 };
+    static int vdc_type_data[] = { 0 };
+    static int integer_precision_data[] = { 16 };
+    static int real_precision_data[] = { 1, 16, 16 };
+    static int index_precision_data[] = { 16 };
+    static int color_precision_data[] = { 16 };
+    static int color_index_precision_data[] = { 16 };
+    static int scaling_mode_data[] = { 0, 0, 0 };
+    static int color_value_extent_data[] = { 0, 0, 0, 255, 255, 255 };
+    static int color_selection_mode_data[] = { 0 };
+    static int linewidth_specification_mode_data[] = { 0 };
+    static int edge_width_specification_mode_data[] = { 0 };
+    static int marker_size_specification_mode_data[] = { 0 };
+    static int vdc_extent_data[] = { 0, 0, 0, 0 };
+    static int line_type_data[] = { 1 };
+    static int interior_style_data[] = { 1 }; /* 0=hollow 1=filled
+					       * 2=pattern 3=hatch
+					       * 4=empty */
+    static int hatch_index_data[] = { 1 }; /* 1=horizontal 2=vertical
+					    * 3=positive slope
+					    * 4=negative slope
+					    * 5=horizontal/vertical
+					    * crosshatch
+					    * 6=positive/negative
+					    * slope crosshatch */
+
+    static int GPFAR elements_list_data[] =
+    {
+	0,			/* will be set to # elements in this list */
+	0, 1,			/* Begin Metafile */
+	0, 2,			/* End Metafile */
+	0, 3,			/* Begin Picture */
+	0, 4,			/* Begin Picture Body */
+	0, 5,			/* End Picture */
+	1, 1,			/* Metafile Version */
+	1, 2,			/* Metafile Description */
+	1, 3,			/* VDC Type */
+	1, 4,			/* Integer Precision */
+	1, 5,			/* Real Precision */
+	1, 6,			/* Index Precision */
+	1, 7,			/* Color Precision */
+	1, 8,			/* Color Index Precision */
+	1, 9,			/* Maximum Color Index */
+	1, 10,			/* Color Value Extent */
+	1, 13,			/* Font List */
+	2, 1,			/* Scaling Mode */
+	2, 2,			/* Color Selection Mode */
+	2, 3,			/* Line Width Specification Mode */
+	2, 4,			/* Marker Size Specification Mode */
+	2, 5,			/* Edge Width Specification Mode */
+	2, 6,			/* VDC Extent */
+#ifdef NEVER
+	/* disabled due to complaints from CGM import filters */
+	3, 1,			/* VDC Integer Precision */
+	3, 4,			/* Transparency */
+	3, 6,			/* Clip Indicator */
+#endif
+	4, 1,			/* Polyline */
+	4, 3,			/* Polymarker */
+	4, 4,			/* Text */
+	4, 7,			/* Polygon */
+	4, 11,			/* Rectangle */
+	4, 12,			/* Circle */
+	4, 15,			/* Circular Arc Center */
+	4, 16,			/* Circular Arc Center Close */
+	4, 17,			/* Ellipse */
+	4, 18,			/* Elliptical Arc */
+	4, 19,			/* Elliptical Arc Close */
+	5, 2,			/* Line Type */
+	5, 3,			/* Line Width */
+	5, 4,			/* Line Color */
+	5, 6,			/* Marker Type */
+	5, 7,			/* Marker Size */
+	5, 8,			/* Marker Color */
+	5, 10,			/* Text Font Index */
+	5, 14,			/* Text Color */
+	5, 15,			/* Character Height */
+	5, 16,			/* Character Orientation */
+	5, 18,			/* Text Alignment */
+	5, 22,			/* Interior Style */
+	5, 23,			/* Fill Color */
+	5, 24,			/* Hatch Index */
+	5, 27,			/* Edge Type */
+	5, 28,			/* Edge Width */
+	5, 29,			/* Edge Color */
+	5, 30,			/* Edge Visibility */
+	5, 34,			/* Color Table */
+	6, 1,			/* Escape */
+	7, 2			/* Application Data */
+    };
+
+    /* metafile description (class 1), including filename if available */
+    if (!outstr)
+	CGM_write_char_record(0, 1, 1, outstr);
+    else
+	CGM_write_char_record(0, 1, strlen(outstr) + 1, outstr);
+    CGM_write_int_record(1, 1, 2, version_data);
+    {
+      char description_data[256];
+      sprintf(description_data, "\
+Gnuplot version %s patchlevel %s,\
+ Computer Graphics Metafile version 1 per MIL-D-28003A/BASIC-1.%d",
+	      gnuplot_version, gnuplot_patchlevel, cgm_monochrome?0:2);
+	CGM_write_char_record(1, 2, strlen(description_data),
+			      description_data);
+    }
+    elements_list_data[0] = (sizeof(elements_list_data) / CGM_ADJ - 2) / 4;
+    CGM_write_int_record(1, 11, sizeof(elements_list_data) / CGM_ADJ,
+			 elements_list_data);
+    CGM_write_int_record(1, 3, 2, vdc_type_data);
+    CGM_write_int_record(1, 4, 2, integer_precision_data);
+    CGM_write_int_record(1, 5, 6, real_precision_data);
+    CGM_write_int_record(1, 6, 2, index_precision_data);
+    CGM_write_int_record(1, 7, 2, color_precision_data);
+    CGM_write_int_record(1, 8, 2, color_index_precision_data);
+    CGM_write_int_record(1, 9, 2, &cgm_maximum_color_index);
+    CGM_write_int_record(1, 10, sizeof(color_value_extent_data) / CGM_ADJ,
+			 color_value_extent_data);
+    if (cgm_nofontlist_mode == FALSE)
+      {
+	char *buf, *s;
+	int i, lgh = 0;
+	for (i = 0; cgm_font_data[i].name; i++)
+	  lgh += strlen(cgm_font_data[i].name) + 1;
+	buf = gp_alloc(lgh + 1, "CGM font list");
+	for (s = buf, i = 0; cgm_font_data[i].name; i++)
+	  {
+	    int lgh = strlen(cgm_font_data[i].name);
+	    *s++ = (char)lgh;
+	    strcpy(s, cgm_font_data[i].name);
+	    s += lgh;
+	  }
+	CGM_write_byte_record(1, 13, lgh, buf);
+	free(buf);
+      }
+
+    /* picture description (classes 2 and 3) */
+    CGM_write_char_record(0, 3, 8, "PICTURE1");
+    CGM_write_int_record(2, 1, 6, scaling_mode_data);
+    CGM_write_int_record(2, 2, 2, color_selection_mode_data);
+    CGM_write_int_record(2, 3, 2, linewidth_specification_mode_data);
+    CGM_write_int_record(2, 4, 2, marker_size_specification_mode_data);
+    CGM_write_int_record(2, 5, 2, edge_width_specification_mode_data);
+    vdc_extent_data[2] = t->xmax + CGM_MARGIN;
+    vdc_extent_data[3] = t->ymax + CGM_MARGIN;
+    CGM_write_int_record(2, 6, 8, vdc_extent_data);
+
+    /* picture body (classes 4 and 5) */
+    CGM_write_int_record(0, 4, 0, NULL);
+
+#ifdef NEVER		/* no need for these, since we accept the defaults */
+    {
+      static int vdc_integer_precision_data[] = { 16 };
+      CGM_write_int_record(3, 1, 2, vdc_integer_precision_data);
+    }
+    {
+      static int transparency_data[] = { 1 }; /* text background:
+						 0=auxiliary color
+						 1=transparent */
+      CGM_write_int_record(3, 4, sizeof(transparency_data) / CGM_ADJ,
+			   transparency_data);
+    }
+    {
+      static int clip_indicator_data[] = { 0 };
+      CGM_write_int_record(3, 6, sizeof(clip_indicator_data) / CGM_ADJ,
+			   clip_indicator_data);
+    }
+#endif
+    if (!cgm_monochrome)
+	CGM_write_int_record(5, 34, (cgm_user_color_count*3+1)*
+			     sizeof(cgm_user_color_table[0])/CGM_ADJ,
+			     cgm_user_color_table);
+    CGM_write_int_record(5, 2, sizeof(line_type_data) / CGM_ADJ,
+			 line_type_data); /* line type 1=SOLID */
+    cgm_linewidth = cgm_linewidth_pt * CGM_PT;
+    CGM_write_int_record(5, 3, sizeof(cgm_linewidth) / CGM_ADJ,
+			 (int *) &cgm_linewidth); /* line width */
+    CGM_write_int_record(5, 28, sizeof(cgm_linewidth) / CGM_ADJ,
+			 (int *) &cgm_linewidth); /* edge width */
+    CGM_write_int_record(5, 27,  sizeof(line_type_data) / CGM_ADJ,
+			 line_type_data); /* edge type 1=SOLID */
+    CGM_linecolor(0);
+
+    cgm_current = cgm_reset;
+    cgm_next.char_height = t->v_char;
+
+    CGM_write_int_record(5, 22, 2, interior_style_data);
+    CGM_write_int_record(5, 24, 2, hatch_index_data);
+    {
+	char buf[45];
+	sprintf(buf, "%.31s,%d", cgm_font, cgm_fontsize);
+	CGM_set_font(buf);
+    }
+    CGM_set_pointsize(pointsize);
+
+    /* Fill with background color if user has specified one */
+    if (!cgm_monochrome && cgm_user_color_count > 0) {
+	CGM_linecolor(LT_BACKGROUND);
+	CGM_fillbox(FS_SOLID, 0, 0, t->xmax, t->ymax);
+    }
+
+}
+
+/* Return the index for the font with the name `name'.  The index for
+   the first font is 1.  Set relwidth to the width of the font,
+   relative to Times Bold Italic.  If the font is not in the table,
+   set *relwidth to 1.0 and return 0. */
+static int
+CGM_find_font(const char *name, int numchar, double *relwidth)
+{
+    int i;
+    *relwidth = 1.;
+    for (i=0; cgm_font_data[i].name; i++)
+      /* strncasecmp is not standard, but defined by stdfn.c if not available */
+      if (strlen(cgm_font_data[i].name) == numchar &&
+	  strncasecmp(name, cgm_font_data[i].name, numchar) == 0)
+	{
+	  *relwidth = cgm_font_data[i].width;
+	  return i+1;
+	}
+
+    return 0;
+}
+
+TERM_PUBLIC int
+CGM_set_font(const char *font)
+{
+    register struct termentry *t = term;
+    int size, font_index;
+    char *comma = strchr(font, ',');
+    int len;
+    double width;
+
+    /* Allow null string to indicaute default font */
+    if (!font || !(*font))
+	font = CGM_default_font;
+
+    /* find font in font table, or use 1st font */
+    if (comma)
+	len = comma - font;
+    else
+	len = strlen(font);
+
+    font_index = CGM_find_font(font, len, &width);
+    if (font_index == 0)
+	font_index = 1;
+    cgm_next.font_index = font_index;
+
+    {
+      char *s = cgm_font_data[font_index-1].name;
+
+      len = strlen(s);
+      if (len > 31)
+	len = 31;
+      strncpy(cgm_font, s, len);
+      cgm_font[len] = NUL;
+    }
+
+    /* set font size */
+    size = cgm_fontsize;
+    if (comma)
+	sscanf(comma + 1, "%d", &size);
+    t->v_char = size * CGM_PT;
+    t->h_char = size * CGM_PT * .527 * width;
+
+    cgm_next.char_height = t->v_char;
+
+    return TRUE;
+}
+
+TERM_PUBLIC void
+CGM_text()
+{
+    CGM_flush_polyline();
+    CGM_write_int_record(0, 5, 0, NULL);	/* end picture */
+    CGM_write_int_record(0, 2, 0, NULL);	/* end metafile */
+}
+
+TERM_PUBLIC void
+CGM_linetype(int linetype)
+{
+    if (linetype < LT_NODRAW)
+	linetype = LT_NODRAW;
+
+    if (linetype == cgm_linetype)
+	return;
+    cgm_linetype = linetype;
+
+    CGM_linecolor(linetype);
+    if (cgm_dashed) {
+	CGM_dashtype(linetype);	/* DBT 10-8-98    use dashes */
+    } else {
+	/* dashes for gridlines, solid for everything else */
+	CGM_dashtype(linetype == -1 ? 2 : 0);
+    }
+}
+
+TERM_PUBLIC void
+CGM_linecolor(int linecolor)
+{
+    if (linecolor >= 0) {
+	/* subtract 2 due to linetypes -2 / -1 */
+	if (cgm_linetypes > 3)
+	    linecolor %= (cgm_linetypes - 3);
+	else
+	    linecolor = 0;
+    } else if (linecolor == LT_BACKGROUND && !cgm_monochrome) {
+	linecolor = -3;
+    } else if (linecolor <= LT_NODRAW)
+	return;
+
+    linecolor += 3;
+    if (cgm_monochrome)
+	cgm_color = linecolor = 1;
+    if (linecolor == cgm_color)
+	return;
+    cgm_color = linecolor;
+    cgm_next.fill_color = linecolor;
+
+    CGM_flush_polyline();
+    CGM_write_int_record(5,  4, 2, (int *) &cgm_color);  /* line color */
+    CGM_write_int_record(5, 14, 2, (int *) &cgm_color); /* text color */
+}
+
+TERM_PUBLIC void
+CGM_fillbox(
+     int style,
+     unsigned int x1, unsigned int y1,
+     unsigned int width, unsigned int height)
+{
+    gpiPoint corner[5];
+
+    corner[0].x = x1;        corner[0].y = y1;
+    corner[1].x = x1+width;  corner[1].y = y1;
+    corner[2].x = x1+width;  corner[2].y = y1+height;
+    corner[3].x = x1;        corner[3].y = y1+height;
+    corner[4].x = x1;        corner[4].y = y1;
+
+    corner->style = style;
+    CGM_filled_polygon(5, corner);
+}
+
+
+TERM_PUBLIC void
+CGM_linewidth(double width)
+{
+    int new_linewidth;
+
+    if (width <= 0)
+	width = 0.5;
+
+    new_linewidth = width * cgm_linewidth_pt * CGM_PT;
+    if (new_linewidth == cgm_linewidth)
+	return;
+
+    CGM_flush_polyline();
+
+    cgm_linewidth = new_linewidth;
+    CGM_write_int_record(5, 3, sizeof(cgm_linewidth) / CGM_ADJ,
+			 (int *) &cgm_linewidth);
+    CGM_dashtype(cgm_dashtype);	/* have dash lengths recalculated */
+}
+
+TERM_PUBLIC void
+CGM_dashtype(int dashtype)
+{
+    int i, j;
+    /* Each group of 8 entries in dot_length[] defines a dash
+       pattern.  Entries in each group are alternately length of
+       whitespace and length of line, in units of 2/3 of the
+       linewidth. */
+    static int dot_length[CGM_LINE_TYPES * 8] =
+    {				/* 0 - solid             */
+	5, 8, 5, 8, 5, 8, 5, 8,	/* 1 - dashes            */
+	5, 3, 5, 3, 5, 3, 5, 3,	/* 2 - short dashes      */
+	4, 1, 4, 1, 4, 1, 4, 1,	/* 3 - dotted            */
+	4, 8, 4, 1, 4, 8, 4, 1,	/* 4 - dash-dot          */
+	4, 9, 4, 1, 4, 1, 0, 0,	/* 5 - dash-dot-dot      */
+	4, 10, 4, 1, 4, 1, 4, 1,	/* 6 - dash-dot-dot-dot  */
+	4, 10, 4, 10, 4, 1, 0, 0,	/* 7 - dash-dash-dot     */
+	4, 10, 4, 10, 4, 1, 4, 1};	/* 8 - dash-dash-dot-dot */
+
+
+    if (dashtype == cgm_dashtype)
+	return;
+    cgm_dashtype = dashtype;
+
+    CGM_flush_polyline();
+
+    if (dashtype >= CGM_LINE_TYPES)
+	dashtype = dashtype % CGM_LINE_TYPES;
+    if (dashtype < 1) {
+	term->vector = CGM_solid_vector;
+	return;
+    }
+    term->vector = CGM_dashed_vector;
+
+    /* set up dash dimensions */
+    j = (dashtype - 1) * 8;
+    for (i = 0; i < 8; i++, j++) {
+	if (dot_length[j])
+	    cgm_step_sizes[i] = (dot_length[j] * cgm_linewidth) * 2 / 3;
+	else
+	    cgm_step_sizes[i] = 0;
+    }
+    /* first thing drawn will be a line */
+    cgm_step = cgm_step_sizes[1];
+    cgm_step_index = 1;
+}
+
+TERM_PUBLIC void
+CGM_move(unsigned int x, unsigned int y)
+{
+    if (x >= term->xmax)
+	x = term->xmax;
+    if (y >= term->ymax)
+	y = term->ymax;
+
+    if (x == cgm_posx && y == cgm_posy)
+	return;
+    CGM_flush_polyline();
+    cgm_posx = x;
+    cgm_posy = y;
+}
+
+TERM_PUBLIC int
+CGM_make_palette(t_sm_palette *palette)
+{
+    if (palette) {
+	 int i, k;
+
+	 cgm_smooth_colors = palette->colors;
+	 if (CGM_COLORS + cgm_smooth_colors > cgm_user_color_max) {
+	      cgm_user_color_max = CGM_COLORS + cgm_smooth_colors;
+	      cgm_user_color_table =
+		   gp_realloc(cgm_user_color_table,
+			      (cgm_user_color_max*3+1)*sizeof(int),
+			      "CGM color table");
+	 }
+	 k = 1 + (CGM_COLORS)*3;
+	 for (i = 0; i < cgm_smooth_colors; i++) {
+	      cgm_user_color_table[k++] = palette->color[i].r*255.9;
+	      cgm_user_color_table[k++] = palette->color[i].g*255.9;
+	      cgm_user_color_table[k++] = palette->color[i].b*255.9;
+	 }
+	 cgm_user_color_count = CGM_COLORS + cgm_smooth_colors;
+	 CGM_write_int_record(5, 34, (cgm_user_color_count*3+1)*
+			      sizeof(cgm_user_color_table[0])/CGM_ADJ,
+			      cgm_user_color_table);
+	 return 0;
+    } else {
+      return (cgm_maximum_color_index - CGM_COLORS);
+    }
+}
+
+TERM_PUBLIC void
+CGM_set_color(t_colorspec *colorspec)
+{
+    if (colorspec->type == TC_LT) {
+	 CGM_linecolor(colorspec->lt);
+	 cgm_linetype = colorspec->lt;
+	 return;
+
+    } else if (colorspec->type == TC_FRAC) {
+	 double gray = colorspec->value;
+	 /* map [0...1] to interval [0...cgm_smooth_colors-1], then add
+	    offset to get past the default colors */
+	 cgm_next.fill_color = (gray <= 0) ? 0 : (int)(gray * cgm_smooth_colors);
+	 if (cgm_next.fill_color >= cgm_smooth_colors)
+	     cgm_next.fill_color = cgm_smooth_colors - 1;
+	 cgm_next.fill_color += CGM_COLORS;
+
+    } else if (colorspec->type == TC_RGB) {
+	/* To truly support RGB we would have to write a new color table to the */
+	/* output file every time the RGB matched no previous color. That seems */
+	/* prohibitive, so instead we just look for the closest match.          */
+	 cgm_next.fill_color = CGM_find_nearest_color(colorspec);
+
+    } else
+	/* Should not happen! */
+	return;
+
+     /* EAM - force color immediately so that lines and text can use it */
+     if (cgm_color != cgm_next.fill_color) {
+	    cgm_color = cgm_next.fill_color;
+	    cgm_linetype = cgm_color;
+	    CGM_flush_polyline();
+	    CGM_write_int_record(5,  4, 2, (int *) &cgm_color); /* line color */
+	    CGM_write_int_record(5, 14, 2, (int *) &cgm_color); /* text color */
+     }
+}
+
+TERM_PUBLIC void
+CGM_filled_polygon(int points, gpiPoint *corner)
+{
+    /* Note: This implementation cannot handle polygons with more than
+     * about 8190 edges.  The best fix is to implement continuation
+     * blocks.  If the high order bit of the "length" field of a block
+     * is set, then it is followed by another block with more data.
+     * This allows an arbitrary amount of data in a record.  However,
+     * we implement a big enough block that problems should be rare.
+     */
+
+    /* We will use solid fill for patterns 0 and 3 */
+    int hatch_index[]={0, 6, 5, 0, 4, 3};
+    int style = corner->style;
+    int pattern = (style >> 4) % 6;
+    int i;
+
+    switch( style & 0xf ) {
+
+    case FS_SOLID:
+    case FS_TRANSPARENT_SOLID:
+	cgm_next.interior_style = 1;
+        break;
+
+    case FS_PATTERN:
+    case FS_TRANSPARENT_PATTERN:
+	if (pattern == 0) {
+	    /* FIXME - for unknown reasons, solid fill messes up the subsequent */
+	    /* color state.  Just leave it empty and let the background show */
+	    cgm_next.interior_style = 0; /* empty */
+	    break;
+	}
+	if (pattern == 3) {
+	    /* Fill with solid color */
+	    cgm_next.interior_style = 1;
+	    break;
+	}
+
+	/* The rest of the patterns are hatch-filled */
+	cgm_next.interior_style = 3; /* hatched */
+	cgm_next.hatch_index = hatch_index[pattern];
+        break;
+
+    default: /* style == 0 or unknown --> fill with background color */
+	cgm_next.fill_color = 0;
+	cgm_next.interior_style = 1; /* solid */
+        break;
+    }
+
+    if (cgm_current.interior_style != cgm_next.interior_style){
+      cgm_current.interior_style = cgm_next.interior_style;
+      CGM_write_int_record(5, 22, 2, &cgm_next.interior_style);
+    }
+
+    if (cgm_current.fill_color != cgm_next.fill_color){
+      cgm_current.fill_color = cgm_next.fill_color;
+      CGM_write_int_record(5, 23, 2, &cgm_next.fill_color);  /* fill color */
+    }
+
+    if (cgm_current.hatch_index != cgm_next.hatch_index &&
+	cgm_next.interior_style == 3){
+      cgm_current.hatch_index = cgm_next.hatch_index;
+      CGM_write_int_record(5, 24, 2, &cgm_next.hatch_index);
+    }
+
+    cgm_next.edge_visibility = 0;	/* We draw the borders elsewhere */
+    if (cgm_current.edge_visibility != cgm_next.edge_visibility){
+      cgm_current.edge_visibility = cgm_next.edge_visibility;
+      CGM_write_int_record(5, 30, 2, &cgm_current.edge_visibility);
+    }
+
+    CGM_move(corner[0].x, corner[0].y);
+    cgm_doing_polygon = 1;
+    for (i = 1; i < points; i++)
+	 CGM_solid_vector(corner[i].x, corner[i].y);
+    CGM_flush_polygon();
+    cgm_doing_polygon = 0;
+}
+
+static void
+CGM_flush_polyline()
+{
+    if (cgm_coords == 0)
+	return;
+    CGM_write_int_record(4, 1, cgm_coords * 2, cgm_polyline);
+    cgm_coords = 0;
+}
+
+static void
+CGM_write_char_record(int class, int cgm_id, int numbytes, char *data)
+{
+    int i, pad, length;
+    static unsigned char flag = 0xff;
+    static unsigned char paddata = 0;
+    char short_len;
+
+    pad = 0;
+    length = numbytes + 1;
+    if (numbytes >= 255)
+	length += 2;	/* long string */
+    if (length & 1)
+	pad = 1;	/* needs pad */
+    CGM_write_code(class, cgm_id, length);
+    if (numbytes < 255)
+    {
+        short_len = (char)numbytes;
+	fwrite(&short_len, 1, 1, gpoutfile);	/* write true length */
+    } else {
+        fwrite(&flag, 1, 1, gpoutfile);
+	CGM_write_int(numbytes);
+    }
+
+    if (data)
+        fwrite(data, 1, numbytes, gpoutfile);		/* write string */
+    else
+	for (i=0; i<numbytes+pad; i++)
+	    fputc('\0', gpoutfile);			/* write null bytes */
+
+    if(pad)
+      fwrite(&paddata, 1, 1, gpoutfile);
+}
+
+static void
+CGM_write_byte_record(int class, int cgm_id, int numbytes, char *data)
+{
+    int pad;
+    static unsigned char paddata = 0;
+
+    pad = numbytes & 1;
+    CGM_write_code(class, cgm_id, numbytes);
+    fwrite(data, 1, numbytes, gpoutfile);		/* write string */
+    if(pad)
+      fwrite(&paddata, 1, 1, gpoutfile);
+}
+
+static void
+CGM_write_int_record(int class, int cgm_id, int numbytes, int *data)
+{
+    int i;
+    assert((numbytes & 1) == 0);
+    CGM_write_code(class, cgm_id, numbytes);
+    numbytes >>= 1;
+    for (i = 0; i < numbytes; i++)
+	CGM_write_int(data[i]);
+}
+
+static void
+CGM_write_mixed_record(
+     int class, int cgm_id,
+     int numint, int *int_data,
+     int numchar, const char *char_data)
+{
+    int i, pad, length;
+    static unsigned char paddata = 0;
+    static unsigned char flag = 0xff;
+    char short_len;
+
+    pad = 0;
+    length = numchar + 1;
+    if (numchar >= 255)
+	length += 2;	/* long string */
+    if (length & 1)
+	pad = 1;	/* needs pad */
+
+    CGM_write_code(class, cgm_id, numint * 2 + length);
+
+    for (i = 0; i < numint; i++)
+	CGM_write_int(int_data[i]);	/* write integers */
+
+    if (numchar < 255) {
+        short_len = (char)numchar;
+	fwrite(&short_len, 1, 1, gpoutfile);	/* write string length */
+    } else {
+	fwrite(&flag, 1, 1, gpoutfile);
+	CGM_write_int(numchar);
+    }
+    fwrite(char_data, 1, numchar, gpoutfile);	/* write string */
+    if(pad)
+      fwrite(&paddata, 1, 1, gpoutfile);
+}
+
+/*
+   Write the code word that starts a CGM record.
+   bits in code word are as follows...
+   cccciiiiiiilllll
+   where
+   cccc is a 4-bit class number
+   iiiiiii is a 7-bit ID number
+   lllll is a 5-bit length (# bytes following the code word, or
+            31 followed by a word with the actual number)
+   */
+static void
+CGM_write_code(int class, int cgm_id, int length)
+{
+    unsigned int code;
+
+    assert((0 <= class) &&(class <16));
+    assert((0 <= cgm_id) && (cgm_id < 128));
+    assert(0 <= length);
+    if (length < 31) {
+	code = ((class &0x0f) <<12) |
+	    ((cgm_id & 0x7f) << 5) |
+	    ((length & 0x1f));
+	CGM_write_int(code);
+    } else {
+	code = ((class &0x0f) <<12) |
+	    ((cgm_id & 0x7f) << 5) |
+	    0x1f;
+	CGM_write_int(code);
+	CGM_write_int(length);
+    }
+}
+
+static void
+CGM_write_int(int value)
+{
+    union {
+	short s;
+	char c[2];
+    } u;
+
+#if !defined(DOS16) && !defined(WIN16)
+    assert( -32768 <= value );
+    assert( value <= 32767 );
+#endif
+
+    u.c[0] = (value >> 8) & 255;	/* convert to network order */
+    u.c[1] = value & 255;
+
+    fwrite(&u.s, 1, 2, gpoutfile);
+}
+
+/* Draw a dashed line to (ux,uy).  CGM has linestyles, but they are
+ * not usable -- at least with the Word for Windows 6.0 filter, where
+ * lines of significant width (even 1 pt) always come out solid.
+ * Therefore, we implement dashed lines here instead. */
+TERM_PUBLIC void
+CGM_dashed_vector(unsigned int ux, unsigned int uy)
+{
+    int xa, ya;
+    int dx, dy, adx, ady;
+    int dist;			/* approximate distance in plot units
+				   from starting point to specified end
+				   point. */
+    long remain;		/* approximate distance in plot units
+				   remaining to specified end point. */
+
+    if (ux >= term->xmax)
+	ux = term->xmax;
+    if (uy >= term->ymax)
+	uy = term->ymax;
+
+    dx = (ux - cgm_posx);
+    dy = (uy - cgm_posy);
+    adx = abs(dx);
+    ady = abs(dy * 10);
+
+    /* using the approximation
+       sqrt(x**2 + y**2)  ~  x + (5*x*x)/(12*y)   when x > y.
+       Note ordering of calculations to avoid overflow on 16 bit
+       architectures */
+    if (10 * adx < ady)
+	dist = (ady / 2 + 25 * adx / ady * adx / 6 * 5) / 5;
+    else {
+	if (adx == 0)
+	    return;
+	dist = (adx * 10 + (ady / 24) * (ady / adx)) / 10;
+    }
+    remain = dist;
+    xa = cgm_posx;
+    ya = cgm_posy;
+    while (remain > cgm_step) {
+	remain -= cgm_step;
+	if (cgm_step_index & 1)
+	    CGM_solid_vector((int) (ux - (remain * dx) / dist),
+			     (int) (uy - (remain * dy) / dist));
+	else {
+	    xa = (int) (ux - (remain * dx) / dist);
+	    ya = (int) (uy - (remain * dy) / dist);
+	    CGM_move(xa, ya);
+	}
+	if (++cgm_step_index >= 8)
+	    cgm_step_index = 0;
+	cgm_step = cgm_step_sizes[cgm_step_index];
+    }
+    if (cgm_step_index & 1)
+	CGM_solid_vector(ux, uy);
+    else
+	CGM_move(ux, uy);
+    cgm_step -= (int) remain;
+}
+
+TERM_PUBLIC void
+CGM_solid_vector(unsigned int ux, unsigned int uy)
+{
+    if (ux >= term->xmax)
+	ux = term->xmax;
+    if (uy >= term->ymax)
+	uy = term->ymax;
+
+    if (ux == cgm_posx && uy == cgm_posy)
+	return;
+    if (cgm_coords > CGM_MAX_SEGMENTS - 2) {
+	if (cgm_doing_polygon)
+	      CGM_flush_polygon();
+	else
+	      CGM_flush_polyline();
+	cgm_polyline[cgm_coords++] = cgm_posx;
+	cgm_polyline[cgm_coords++] = cgm_posy + CGM_MARGIN;
+    } else if (cgm_coords == 0) {
+	cgm_polyline[cgm_coords++] = cgm_posx;
+	cgm_polyline[cgm_coords++] = cgm_posy + CGM_MARGIN;
+    }
+    cgm_polyline[cgm_coords++] = ux;
+    cgm_polyline[cgm_coords++] = uy + CGM_MARGIN;
+    cgm_posx = ux;
+    cgm_posy = uy;
+}
+
+TERM_PUBLIC void
+CGM_put_text(unsigned int x, unsigned int y, const char str[])
+{
+    static int where[3] = { 0, 0, 1 }; /* the final "1" signals that
+					  this is the last text in the
+					  string */
+    const char *s = str;
+
+    /* sanity check - labels are not clipped */
+    if ((x > 32767) || (y > 32767))
+      return;
+
+    while (*s)
+	if (!isspace((unsigned char) *s++))
+	    goto showit;
+    return;
+
+  showit:
+
+    CGM_flush_polyline();
+
+    /* update the text characteristics if they have changed since the
+       last text string was output */
+    if (cgm_current.font_index != cgm_next.font_index) {
+      cgm_current.font_index = cgm_next.font_index;
+      CGM_write_int_record(5, 10, 2, &cgm_next.font_index);
+    }
+    if (cgm_current.justify_mode != cgm_next.justify_mode) {
+      static int data[6] = { 1, 3, 0, 0, 0, 0 };
+      cgm_current.justify_mode = cgm_next.justify_mode;
+
+      switch (cgm_current.justify_mode) {
+      case LEFT:
+	data[0] = 1;
+	break;
+      case CENTRE:
+	data[0] = 2;
+	break;
+      case RIGHT:
+	data[0] = 3;
+	break;
+      default:
+	assert(0);
+      }
+      CGM_write_int_record(5, 18, 12, data);
+    }
+
+    if (cgm_current.char_height != cgm_next.char_height) {
+      int h = cgm_next.char_height;
+      cgm_current.char_height = h;
+      h = h*2/3;		/* gnuplot measures fonts by the
+                                   baseline-to-baseline distance,
+                                   while the CGM file needs the actual
+                                   height of the upper case
+                                   characters. */
+      CGM_write_int_record(5, 15, 2, &h);
+    }
+
+    /* "angle" is the angle of the text baseline (counter-clockwise in
+       radians from horizontal).  This is a bit more general than
+       gnuplot needs right now. */
+    if (cgm_current.angle != cgm_next.angle) {
+      /* The first two elements of orient are components of a vector
+	 "upward" with respect to the text.  The next two elements are
+	 components of a vector along the baseline of the text. The
+	 lengths of both vectors are equal to the baseline-to-baseline
+	 distance in plot units. */
+      static int orient[4];
+      cgm_current.angle = cgm_next.angle;
+
+      orient[0] = (int)cgm_next.char_height*cos(cgm_next.angle+M_PI_2);
+      orient[1] = (int)cgm_next.char_height*sin(cgm_next.angle+M_PI_2);
+      orient[2] = (int)cgm_next.char_height*cos(cgm_next.angle);
+      orient[3] = (int)cgm_next.char_height*sin(cgm_next.angle);
+      CGM_write_int_record(5, 16, 8, orient);
+    }
+
+    where[0] = x;
+    where[1] = y + CGM_MARGIN;
+    CGM_write_mixed_record(4, 4, 3, where, strlen(str), str);
+
+    cgm_posx = cgm_posy = -2000;
+}
+
+TERM_PUBLIC int
+CGM_text_angle(int ang)
+{
+    if (cgm_rotate) {
+	cgm_next.angle = ang * M_PI_2 / 90.;
+	return TRUE;
+    }
+    return ang ? FALSE : TRUE;
+}
+
+TERM_PUBLIC int
+CGM_justify_text(enum JUSTIFY mode)
+{
+  cgm_next.justify_mode = mode;
+  return (TRUE);
+}
+
+TERM_PUBLIC void
+CGM_reset()
+{
+    cgm_posx = cgm_posy = 0;
+    free(cgm_polyline);
+}
+
+TERM_PUBLIC void
+CGM_point(unsigned int x, unsigned int y, int number)
+{
+    int old_dashtype;
+
+    if (number < 0) {		/* draw dot */
+	CGM_move(x, y);
+	CGM_solid_vector(x + 1, y);
+	return;
+    }
+    number %= CGM_POINTS;
+
+    CGM_flush_polyline();
+    old_dashtype = cgm_dashtype;
+    CGM_dashtype(0);
+    if (number >= 3)		/* using a polygon */
+      cgm_next.interior_style = 1; /* solid */
+    if (number == 4 || number == 6 || number == 8
+	    || number == 10 || number == 12) {
+	/* filled */
+      cgm_next.edge_visibility = 0;
+      cgm_next.fill_color = cgm_color;
+    } else {
+	/* NOT filled */
+      cgm_next.edge_visibility = 1;
+      cgm_next.interior_style = 0; /* empty */
+      cgm_next.edge_color = cgm_color;
+    }
+
+    if (cgm_current.interior_style != cgm_next.interior_style){
+      cgm_current.interior_style = cgm_next.interior_style;
+      CGM_write_int_record(5, 22, 2, &cgm_next.interior_style);
+    }
+    if (cgm_current.fill_color != cgm_next.fill_color){
+      cgm_current.fill_color = cgm_next.fill_color;
+      CGM_write_int_record(5, 23, 2, &cgm_next.fill_color);
+    }
+    if (cgm_current.edge_visibility != cgm_next.edge_visibility){
+      cgm_current.edge_visibility = cgm_next.edge_visibility;
+      CGM_write_int_record(5, 30, 2, &cgm_current.edge_visibility);
+    }
+    if (cgm_current.edge_visibility &&
+	cgm_current.edge_color != cgm_next.edge_color){
+      cgm_current.edge_color = cgm_next.edge_color;
+      CGM_write_int_record(5, 29, 2, &cgm_current.edge_color);
+    }
+
+    switch (number) {
+    case 0:			/* draw plus */
+	CGM_move(x - cgm_tic, y);
+	CGM_solid_vector(x + cgm_tic, y);
+	CGM_move(x, y - cgm_tic);
+	CGM_solid_vector(x, y + cgm_tic);
+	break;
+    case 1:			/* draw X */
+	CGM_move(x - cgm_tic707, y - cgm_tic707);
+	CGM_solid_vector(x + cgm_tic707, y + cgm_tic707);
+	CGM_move(x - cgm_tic707, y + cgm_tic707);
+	CGM_solid_vector(x + cgm_tic707, y - cgm_tic707);
+	break;
+    case 2:			/* draw star (asterisk) */
+	CGM_move(x, y - cgm_tic);
+	CGM_solid_vector(x, y + cgm_tic);
+	CGM_move(x + cgm_tic866, y - cgm_tic500);
+	CGM_solid_vector(x - cgm_tic866, y + cgm_tic500);
+	CGM_move(x + cgm_tic866, y + cgm_tic500);
+	CGM_solid_vector(x - cgm_tic866, y - cgm_tic500);
+	break;
+    case 3:			/* draw box */
+    case 4:
+	CGM_move(x - cgm_tic707, y - cgm_tic707);
+	CGM_solid_vector(x + cgm_tic707, y - cgm_tic707);
+	CGM_solid_vector(x + cgm_tic707, y + cgm_tic707);
+	CGM_solid_vector(x - cgm_tic707, y + cgm_tic707);
+	CGM_flush_polygon();
+	break;
+    case 5:
+    case 6:			/* draw circle (actually, dodecagon)
+				   (WinWord 6 accepts the CGM "circle"
+				   element, but the resulting circle
+				   is not correctly centered!) */
+	CGM_move(x, y - cgm_tic);
+	CGM_solid_vector(x + cgm_tic500, y - cgm_tic866);
+	CGM_solid_vector(x + cgm_tic866, y - cgm_tic500);
+	CGM_solid_vector(x + cgm_tic, y);
+	CGM_solid_vector(x + cgm_tic866, y + cgm_tic500);
+	CGM_solid_vector(x + cgm_tic500, y + cgm_tic866);
+	CGM_solid_vector(x, y + cgm_tic);
+	CGM_solid_vector(x - cgm_tic500, y + cgm_tic866);
+	CGM_solid_vector(x - cgm_tic866, y + cgm_tic500);
+	CGM_solid_vector(x - cgm_tic, y);
+	CGM_solid_vector(x - cgm_tic866, y - cgm_tic500);
+	CGM_solid_vector(x - cgm_tic500, y - cgm_tic866);
+	CGM_flush_polygon();
+	break;
+    case 7:			/* draw triangle (point up) */
+    case 8:
+	CGM_move(x, y + cgm_tic1241);
+	CGM_solid_vector(x - cgm_tic1077, y - cgm_tic621);
+	CGM_solid_vector(x + cgm_tic1077, y - cgm_tic621);
+	CGM_flush_polygon();
+	break;
+    case 9:			/* draw triangle (point down) */
+    case 10:
+	CGM_move(x, y - cgm_tic1241);
+	CGM_solid_vector(x - cgm_tic1077, y + cgm_tic621);
+	CGM_solid_vector(x + cgm_tic1077, y + cgm_tic621);
+	CGM_flush_polygon();
+	break;
+    case 11:			/* draw diamond */
+    case 12:
+	CGM_move(x - cgm_tic, y);
+	CGM_solid_vector(x, y - cgm_tic);
+	CGM_solid_vector(x + cgm_tic, y);
+	CGM_solid_vector(x, y + cgm_tic);
+	CGM_flush_polygon();
+	break;
+    }
+    CGM_dashtype(old_dashtype);
+}
+
+
+TERM_PUBLIC void
+CGM_set_pointsize(double size)
+{
+    /* Markers were chosen to have approximately equal
+       areas.  Dimensions are as follows, in units of
+       cgm_tic:
+
+       plus, diamond: half height = 1
+
+       square, cross: half height = sqrt(1/2) ~ 12/17
+
+       triangle: half width = sqrt(sqrt(4/3)) ~ 14/13,
+       height = sqrt(3*sqrt(4/3)) ~ 54/29
+
+       star: half height = 1, half width = sqrt(3/4) ~ 13/15
+
+       dodecagon: coordinates of vertices are 0,
+       sin(30) = 1/2, cos(30) = sqrt(3/4) ~ 13/15, or 1
+
+       The fractions are approximates of the equivalent
+       continued fractions. */
+    if (size < 0)
+	size = 1;
+    cgm_tic = (size * term->h_tic / 2);
+    cgm_tic707 = cgm_tic * 12 / 17;
+    cgm_tic866 = cgm_tic * 13 / 15;
+    cgm_tic500 = cgm_tic / 2;
+    cgm_tic1241 = cgm_tic * 36 / 29;
+    cgm_tic1077 = cgm_tic * 14 / 13;
+    cgm_tic621 = cgm_tic * 18 / 29;
+}
+
+static void
+CGM_flush_polygon()
+{
+    if (cgm_coords == 0)
+	return;
+    CGM_write_int_record(4, 7, cgm_coords * 2, cgm_polyline);
+    cgm_coords = 0;
+}
+
+/*
+ * This terminal driver does not support true RGB color,
+ * but we can at least try to find some reasonable approximation.
+ */
+#define CLOSE_ENOUGH 32		/* 0 would require a perfect match */
+static int
+CGM_find_nearest_color(t_colorspec *colorspec)
+{
+    int red   = (colorspec->lt >> 16) & 0xff;
+    int green = (colorspec->lt >> 8) & 0xff;
+    int blue  = colorspec->lt & 0xff;
+    int closest = 0;
+    int howclose = 1<<16;
+    int i = 0;
+    int k;
+    int dr, dg, db, distance;
+
+    for (k=0; k<cgm_user_color_count; k++) {
+	dr = cgm_user_color_table[++i] - red;
+	dg = cgm_user_color_table[++i] - green;
+	db = cgm_user_color_table[++i] - blue;
+	distance = (dr*dr + dg*dg + db*db);
+	if (distance < howclose) {
+	    closest = k;
+	    howclose = distance;
+	}
+	if (distance < CLOSE_ENOUGH)
+	    break;
+    }
+
+    FPRINTF((stderr,"CGM_find_nearest_color:  asked for %d %d %d\n",red,green,blue));
+    FPRINTF((stderr,"         got index %3d             %d %d %d\n", closest,
+	    cgm_user_color_table[closest*3], cgm_user_color_table[closest*3+1],
+	    cgm_user_color_table[closest*3+2]));
+
+    return closest;
+}
+#undef CLOSE_ENOUGH
+
+#ifdef DEFEAT_ASSERTIONS
+#define NDEBUG
+#include <assert.h>
+#undef DEFEAT_ASSERTIONS
+#endif /* DEFEAT_ASSERTIONS */
+
+#ifdef NEXT
+#undef id
+#undef datum
+#endif
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+TERM_TABLE_START(cgm_driver)
+    "cgm", "Computer Graphics Metafile",
+    CGM_LARGE - CGM_MARGIN, CGM_SMALL - CGM_MARGIN, CGM_VCHAR, CGM_HCHAR,
+    CGM_VTIC, CGM_HTIC, CGM_options, CGM_init, CGM_reset,
+    CGM_text, null_scale, CGM_graphics, CGM_move, CGM_solid_vector,
+    CGM_linetype, CGM_put_text, CGM_text_angle,
+    CGM_justify_text, CGM_point, do_arrow, CGM_set_font,
+    CGM_set_pointsize,
+    TERM_BINARY|TERM_CAN_DASH|TERM_LINEWIDTH,	/* various flags */
+    NULL,			/* after one plot of multiplot */
+    NULL,			/* before subsequent plot of multiplot */
+    CGM_fillbox,
+    CGM_linewidth
+#ifdef USE_MOUSE
+    , NULL, NULL, NULL, NULL, NULL
+/*  , waitforinput, put_tmptext, set_ruler, set_cursor, set_clipboard */
+#endif
+    , CGM_make_palette,
+    NULL /* _previous_palette */,
+    CGM_set_color,
+    CGM_filled_polygon
+TERM_TABLE_END(cgm_driver)
+
+#undef LAST_TERM
+#define LAST_TERM cgm_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(cgm)
+"1 cgm",
+"?commands set terminal cgm",
+"?set terminal cgm",
+"?set term cgm",
+"?terminal cgm",
+"?term cgm",
+"?cgm",
+" The `cgm` terminal generates a Computer Graphics Metafile, Version 1. ",
+" This file format is a subset of the ANSI X3.122-1986 standard entitled",
+" \"Computer Graphics - Metafile for the Storage and Transfer of Picture",
+" Description Information\".",
+"",
+" Syntax:",
+"       set terminal cgm {color | monochrome} {solid | dashed} {{no}rotate}",
+"                        {<mode>} {width <plot_width>} {linewidth <line_width>}",
+"                        {font \"<fontname>,<fontsize>\"}",
+"                        {<color0> <color1> <color2> ...}",
+"",
+" `solid` draws all curves with solid lines, overriding any dashed patterns;",
+" <mode> is `landscape`, `portrait`, or `default`;",
+" <plot_width> is the assumed width of the plot in points; ",
+" <line_width> is the line width in points (default 1); ",
+" <fontname> is the name of a font (see list of fonts below)",
+" <fontsize> is the size of the font in points (default 12).",
+"",
+" The first six options can be in any order.  Selecting `default` sets all",
+" options to their default values.",
+"",
+" Each color must be of the form 'xrrggbb', where x is the literal",
+" character 'x' and 'rrggbb' are the red, green and blue components in",
+" hex.  For example, 'x00ff00' is green.  The background color is set",
+" first, then the plotting colors.",
+"",
+" Examples:",
+"       set terminal cgm landscape color rotate dashed width 432 \\",
+"                      linewidth 1  'Helvetica Bold' 12       # defaults",
+"       set terminal cgm linewidth 2  14  # wider lines & larger font",
+"       set terminal cgm portrait \"Times Italic\" 12",
+"       set terminal cgm color solid      # no pesky dashes!",
+
+"2 cgm font",
+"?commands set terminal cgm font",
+"?set terminal cgm font",
+"?set term cgm font",
+"?cgm font",
+" The first part of a Computer Graphics Metafile, the metafile description,",
+" includes a font table.  In the picture body, a font is designated by an",
+" index into this table.  By default, this terminal generates a table with",
+" the following 35 fonts, plus six more with `italic` replaced by",
+" `oblique`, or vice-versa (since at least the Microsoft Office and Corel",
+" Draw CGM import filters treat `italic` and `oblique` as equivalent):",
+"@start table - first is interactive cleartext form",
+"       Helvetica",
+"       Helvetica Bold",
+"       Helvetica Oblique",
+"       Helvetica Bold Oblique",
+"       Times Roman",
+"       Times Bold",
+"       Times Italic",
+"       Times Bold Italic",
+"       Courier",
+"       Courier Bold",
+"       Courier Oblique",
+"       Courier Bold Oblique",
+"       Symbol",
+"       Hershey/Cartographic_Roman",
+"       Hershey/Cartographic_Greek",
+"       Hershey/Simplex_Roman",
+"       Hershey/Simplex_Greek",
+"       Hershey/Simplex_Script",
+"       Hershey/Complex_Roman",
+"       Hershey/Complex_Greek",
+"       Hershey/Complex_Script",
+"       Hershey/Complex_Italic",
+"       Hershey/Complex_Cyrillic",
+"       Hershey/Duplex_Roman",
+"       Hershey/Triplex_Roman",
+"       Hershey/Triplex_Italic",
+"       Hershey/Gothic_German",
+"       Hershey/Gothic_English",
+"       Hershey/Gothic_Italian",
+"       Hershey/Symbol_Set_1",
+"       Hershey/Symbol_Set_2",
+"       Hershey/Symbol_Math",
+"       ZapfDingbats",
+"       Script",
+"       15",
+"#\\begin{tabular}{|ccl|} \\hline",
+"#\\multicolumn{3}{|c|}{CGM fonts}\\\\",
+"#&Helvetica&\\\\",
+"#&Helvetica Bold&\\\\",
+"#&Helvetica Oblique&\\\\",
+"#&Helvetica Bold Oblique&\\\\",
+"#&Times Roman&\\\\",
+"#&Times Bold&\\\\",
+"#&Times Italic&\\\\",
+"#&Times Bold Italic&\\\\",
+"#&Courier&\\\\",
+"#&Courier Bold&\\\\",
+"#&Courier Oblique&\\\\",
+"#&Courier Bold Oblique&\\\\",
+"#&Symbol&\\\\",
+"#&Hershey/Cartographic\\_Roman&\\\\",
+"#&Hershey/Cartographic\\_Greek&\\\\",
+"#&Hershey/Simplex\\_Roman&\\\\",
+"#&Hershey/Simplex\\_Greek&\\\\",
+"#&Hershey/Simplex\\_Script&\\\\",
+"#&Hershey/Complex\\_Roman&\\\\",
+"#&Hershey/Complex\\_Greek&\\\\",
+"#&Hershey/Complex\\_Script&\\\\",
+"#&Hershey/Complex\\_Italic&\\\\",
+"#&Hershey/Complex\\_Cyrillic&\\\\",
+"#&Hershey/Duplex\\_Roman&\\\\",
+"#&Hershey/Triplex\\_Roman&\\\\",
+"#&Hershey/Triplex\\_Italic&\\\\",
+"#&Hershey/Gothic\\_German&\\\\",
+"#&Hershey/Gothic\\_English&\\\\",
+"#&Hershey/Gothic\\_Italian&\\\\",
+"#&Hershey/Symbol\\_Set\\_1&\\\\",
+"#&Hershey/Symbol\\_Set\\_2&\\\\",
+"#&Hershey/Symbol\\_Math&\\\\",
+"#&ZapfDingbats&\\\\",
+"#&Script&\\\\",
+"#&15&\\\\",
+"%c c l .",
+"%@@CGM fonts",
+"%_",
+"%@@Helvetica",
+"%@@Helvetica Bold",
+"%@@Helvetica Oblique",
+"%@@Helvetica Bold Oblique",
+"%@@Times Roman",
+"%@@Times Bold",
+"%@@Times Italic",
+"%@@Times Bold Italic",
+"%@@Courier",
+"%@@Courier Bold",
+"%@@Courier Oblique",
+"%@@Courier Bold Oblique",
+"%@@Symbol",
+"%@@Hershey/Cartographic_Roman",
+"%@@Hershey/Cartographic_Greek",
+"%@@Hershey/Simplex_Roman",
+"%@@Hershey/Simplex_Greek",
+"%@@Hershey/Simplex_Script",
+"%@@Hershey/Complex_Roman",
+"%@@Hershey/Complex_Greek",
+"%@@Hershey/Complex_Script",
+"%@@Hershey/Complex_Italic",
+"%@@Hershey/Complex_Cyrillic",
+"%@@Hershey/Duplex_Roman",
+"%@@Hershey/Triplex_Roman",
+"%@@Hershey/Triplex_Italic",
+"%@@Hershey/Gothic_German",
+"%@@Hershey/Gothic_English",
+"%@@Hershey/Gothic_Italian",
+"%@@Hershey/Symbol_Set_1",
+"%@@Hershey/Symbol_Set_2",
+"%@@Hershey/Symbol_Math",
+"%@@ZapfDingbats",
+"%@@Script",
+"%@@15",
+"@end table",
+
+" The first thirteen of these fonts are required for WebCGM.  The",
+" Microsoft Office CGM import filter implements the 13 standard fonts",
+" listed above, and also 'ZapfDingbats' and 'Script'.  However, the",
+" script font may only be accessed under the name '15'.  For more on",
+" Microsoft import filter font substitutions, check its help file which",
+" you may find here:",
+"   C:\\Program Files\\Microsoft Office\\Office\\Cgmimp32.hlp",
+" and/or its configuration file, which you may find here:",
+"   C:\\Program Files\\Common Files\\Microsoft Shared\\Grphflt\\Cgmimp32.cfg",
+"",
+" In the `set term` command, you may specify a font name which does not",
+" appear in the default font table.  In that case, a new font table is",
+" constructed with the specified font as its first entry. You must ensure",
+" that the spelling, capitalization, and spacing of the name are",
+" appropriate for the application that will read the CGM file.  (Gnuplot",
+" and any MIL-D-28003A compliant application ignore case in font names.)",
+" If you need to add several new fonts, use several `set term` commands.",
+"",
+" Example:",
+"       set terminal cgm 'Old English'",
+"       set terminal cgm 'Tengwar'",
+"       set terminal cgm 'Arabic'",
+"       set output 'myfile.cgm'",
+"       plot ...",
+"       set output",
+"",
+" You cannot introduce a new font in a `set label` command.",
+
+"2 cgm fontsize",
+"?commands set terminal cgm fontsize",
+"?set terminal cgm fontsize",
+"?set term cgm fontsize",
+"?cgm fontsize",
+" Fonts are scaled assuming the page is 6 inches wide.  If the `size`",
+" command is used to change the aspect ratio of the page or the CGM file",
+" is converted to a different width, the resulting font sizes will be",
+" scaled up or down accordingly.  To change the assumed width, use the",
+" `width` option.",
+
+"2 cgm linewidth",
+"?commands set terminal cgm linewidth",
+"?set terminal cgm linewidth",
+"?set term cgm linewidth",
+"?cgm linewidth",
+" The `linewidth` option sets the width of lines in pt.  The default width",
+" is 1 pt.  Scaling is affected by the actual width of the page, as",
+" discussed under the `fontsize` and `width` options.",
+
+"2 cgm rotate",
+"?commands set terminal cgm rotate",
+"?set terminal cgm rotate",
+"?set term cgm rotate",
+"?cgm rotate",
+" The `norotate` option may be used to disable text rotation.  For",
+" example, the CGM input filter for Word for Windows 6.0c can accept",
+" rotated text, but the DRAW editor within Word cannot.  If you edit a",
+" graph (for example, to label a curve), all rotated text is restored to",
+" horizontal.  The Y axis label will then extend beyond the clip boundary.",
+" With `norotate`, the Y axis label starts in a less attractive location,",
+" but the page can be edited without damage.  The `rotate` option confirms",
+" the default behavior.",
+
+"2 cgm solid",
+"?set terminal cgm solid",
+"?set term cgm solid",
+"?cgm solid",
+" The `solid` option may be used to disable dashed line styles in the",
+" plots.  This is useful when color is enabled and the dashing of the",
+" lines detracts from the appearance of the plot. The `dashed` option",
+" confirms the default behavior, which gives a different dash pattern to",
+" each line type.",
+
+"2 cgm size",
+"?commands set terminal cgm size",
+"?set terminal cgm size",
+"?set term cgm size",
+"?cgm size",
+" Default size of a CGM plot is 32599 units wide and 23457 units high for",
+" landscape, or 23457 units wide by 32599 units high for portrait.",
+
+"2 cgm width",
+"?commands set terminal cgm width",
+"?set terminal cgm width",
+"?set term cgm width",
+"?cgm width",
+" All distances in the CGM file are in abstract units.  The application",
+" that reads the file determines the size of the final plot.  By default,",
+" the width of the final plot is assumed to be 6 inches (15.24 cm).  This",
+" distance is used to calculate the correct font size, and may be changed",
+" with the `width` option.  The keyword should be followed by the width in",
+" points.  (Here, a point is 1/72 inch, as in PostScript.  This unit is",
+" known as a \"big point\" in TeX.)  Gnuplot `expressions` can be used to",
+" convert from other units.",
+"",
+" Example:",
+"       set terminal cgm width 432            # default",
+"       set terminal cgm width 6*72           # same as above",
+"       set terminal cgm width 10/2.54*72     # 10 cm wide",
+
+"2 cgm nofontlist",
+"?commands set terminal cgm nofontlist",
+"?set terminal cgm nofontlist",
+"?set term cgm nofontlist",
+"?cgm nofontlist",
+"?set terminal cgm winword6",
+"?set term cgm winword6",
+"?cgm winword6",
+" The default font table includes the fonts recommended for WebCGM, which",
+" are compatible with the Computer Graphics Metafile input filter for",
+" Microsoft Office and Corel Draw.  Another application might use",
+" different fonts and/or different font names, which may not be",
+" documented.  The `nofontlist` (synonym `winword6`) option deletes the font",
+" table from the CGM file.  In this case, the reading application should",
+" use a default table.  Gnuplot will still use its own default font table",
+" to select font indices.  Thus, 'Helvetica' will give you an index of 1,",
+" which should get you the first entry in your application's default font",
+" table. 'Helvetica Bold' will give you its second entry, etc.",
+""
+
+END_HELP(cgm)
+#endif /* TERM_HELP */
+
+
+/*
+ * Local Variables:
+ * mode:C
+ * eval: (c-set-style "k&r")
+ * End:
+ */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/corel.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/corel.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/corel.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/corel.trm.svn-base	2012-01-03 17:07:26.453579900 -0800
@@ -0,0 +1,452 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: corel.trm,v 1.17 2006/07/21 02:35:45 sfeam Exp $
+ */
+
+/*
+   corel.trm
+
+   A modified ai.trm for CorelDraw import filters
+   by Chris Parks, parks@physics.purdue.edu
+   Import from CorelDraw with the CorelTrace filter
+
+   syntax: set terminal default
+           set terminal mode "fontname" fontsize,xsize,ysize,linewidth
+
+           mode= color or monochrome             (default=mono)
+           "fontname"= postscript font name      (default="SwitzerlandLight")
+           fontsize  = size of font in points    (default=22pt)
+           xsize     = width of page in inches   (default=8.2in)
+           ysize     = height of page in inches  (default=10in)
+           linewidth = width of lines in points  (default=1.2pt)
+
+*/
+
+/*
+ * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(corel)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void COREL_options __PROTO((void));
+TERM_PUBLIC void COREL_init __PROTO((void));
+TERM_PUBLIC void COREL_graphics __PROTO((void));
+TERM_PUBLIC void COREL_text __PROTO((void));
+TERM_PUBLIC void COREL_reset __PROTO((void));
+TERM_PUBLIC void COREL_linetype __PROTO((int linetype));
+TERM_PUBLIC void COREL_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void COREL_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void COREL_put_text __PROTO((unsigned int x, unsigned int y,
+					 const char *str));
+TERM_PUBLIC int COREL_text_angle __PROTO((int ang));
+TERM_PUBLIC int COREL_justify_text __PROTO((enum JUSTIFY mode));
+#define CORELD_XMAX  5960	/* 8.2 inches wide */
+#define CORELD_YMAX  7200	/* 10 inches high  */
+#define CORELD_VTIC  (CORELD_YMAX/80)
+#define CORELD_HTIC  (CORELD_YMAX/80)
+#define CORELD_VCHAR (22*COREL_SC)	/* default is 22 point characters */
+#define CORELD_HCHAR (22*COREL_SC*6/10)
+#endif
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+#define DEFAULT_CORELFONT "SwitzerlandLight"
+
+/* plots for publication should be sans-serif (don't use TimesRoman) */
+static char corel_font[MAX_ID_LEN + 1] = DEFAULT_CORELFONT;	/* name of font */
+static int corel_fontsize = 22;	/* size of font in pts */
+static TBOOLEAN corel_color = FALSE;
+static TBOOLEAN corel_stroke = FALSE;
+static int corel_path_count = 0;	/* count of lines in path */
+static int corel_ang = 0;		/* text angle */
+static enum JUSTIFY corel_justify = LEFT;	/* text is flush left */
+
+
+/* default mode constants */
+#define CORELD_XOFF  0		/* page offset in pts */
+#define CORELD_YOFF  0
+#define COREL_SC     (10.0)	/* scale is 1pt = 10 units */
+#define CORELD_LW    (1.2*COREL_SC)	/* linewidth = 1.2 pts */
+
+static unsigned int corel_xmax = CORELD_XMAX;
+static unsigned int corel_ymax = CORELD_YMAX;
+static float corel_lw = CORELD_LW;
+
+enum COREL_id {COREL_DEFAULT, COREL_MONOCHROME, COREL_COLOR, COREL_OTHER };
+
+static struct gen_table COREL_opts[] =
+{
+    { "def$ault", COREL_DEFAULT},
+    { "mono$chrome", COREL_MONOCHROME },
+    { "color$", COREL_COLOR },
+    { "colour$", COREL_COLOR },
+    { NULL, COREL_OTHER }
+};
+
+TERM_PUBLIC void
+COREL_options()
+{
+    struct value a;
+
+    while (!END_OF_COMMAND) {
+	switch(lookup_table(&COREL_opts[0],c_token)) {
+	case COREL_DEFAULT:
+	    corel_color = FALSE;
+	    strcpy(corel_font, DEFAULT_CORELFONT);
+	    corel_fontsize = 22;
+	    corel_lw = CORELD_LW;
+	    corel_xmax = CORELD_XMAX;
+	    corel_ymax = CORELD_YMAX;
+	    c_token++;
+	    break;
+	case COREL_MONOCHROME:
+	    corel_color = FALSE;
+	    c_token++;
+	    break;
+	case COREL_COLOR:
+	    corel_color = TRUE;
+	    c_token++;
+	    break;
+	case COREL_OTHER:
+	default:
+	    /* font name */
+	    if (isstring(c_token)) {
+		quote_str(corel_font, c_token, MAX_ID_LEN);
+		c_token++;
+	    } else {
+		/* We have font size specified */
+		corel_fontsize = (int) real(const_express(&a));
+		c_token++;
+		term->v_char = (unsigned int) (corel_fontsize * COREL_SC);
+		term->h_char = (unsigned int) (corel_fontsize * COREL_SC * 6 / 10);
+	    }
+	    break;
+	}
+    }
+
+    /* FIXME - argh. Stupid syntax alert here */
+    if (!END_OF_COMMAND) {
+	corel_xmax = (unsigned int) (real(const_express(&a)) * 720);
+	c_token++;
+	if (!END_OF_COMMAND) {
+	    corel_ymax = (unsigned int) (real(const_express(&a)) * 720);
+	    c_token++;
+	}
+	term->xmax = corel_xmax;
+	term->ymax = corel_ymax;
+	term->v_tic = corel_ymax / 80;
+	term->h_tic = corel_ymax / 80;
+    }
+    if (!END_OF_COMMAND) {
+	corel_lw = real(const_express(&a)) * COREL_SC;
+	c_token++;
+    }
+    sprintf(term_options, "%s \"%s\" %d,%0.1f,%0.1f,%0.1f",
+	    corel_color ? "color" : "monochrome", corel_font,
+	    corel_fontsize, corel_xmax / 720.0, corel_ymax / 720.0,
+	    corel_lw / COREL_SC);
+}
+
+TERM_PUBLIC void
+COREL_init()
+{
+    fprintf(gpoutfile, "\
+%%!PS-Adobe-2.0 EPSF-1.2\n\
+%%%%BoundingBox: %d %d %d %d\n\
+%%%%TemplateBox: %d %d %d %d\n\
+%%%%EndComments\n\
+%%%%EndProlog\n\
+%%%%BeginSetup\n%%%%EndSetup\n",
+	    CORELD_XOFF, CORELD_YOFF,
+	    (int) ((corel_xmax) / COREL_SC + 0.5 + CORELD_XOFF),
+	    (int) ((corel_ymax) / COREL_SC + 0.5 + CORELD_YOFF),
+	    CORELD_XOFF, CORELD_YOFF,
+	    (int) ((corel_xmax) / COREL_SC + 0.5 + CORELD_XOFF),
+	    (int) ((corel_ymax) / COREL_SC + 0.5 + CORELD_YOFF));
+}
+
+
+TERM_PUBLIC void
+COREL_graphics()
+{
+    corel_path_count = 0;
+    corel_stroke = FALSE;
+}
+
+
+TERM_PUBLIC void
+COREL_text()
+{
+    if (corel_stroke) {
+	fputs("S\n", gpoutfile);
+	corel_stroke = FALSE;
+    }
+    corel_path_count = 0;
+}
+
+
+TERM_PUBLIC void
+COREL_reset()
+{
+    fputs("%%Trailer\n", gpoutfile);
+}
+
+
+TERM_PUBLIC void
+COREL_linetype(int linetype)
+{
+    if (corel_stroke) {
+	fputs("S\n", gpoutfile);
+	corel_stroke = FALSE;
+    }
+    switch (linetype) {
+    case LT_BLACK:
+	fprintf(gpoutfile, "%.2f w\n", corel_lw / COREL_SC);
+	if (corel_color) {
+	    fputs("0 0 0 1 K\n", gpoutfile);
+	} else {
+	    fputs("\
+[] 0 d\n\
+0 j\n0 G\n", gpoutfile);
+	}
+	break;
+
+    case LT_AXIS:
+	fprintf(gpoutfile, "%.2f w\n", corel_lw / COREL_SC);
+	if (corel_color) {
+	    fputs("0 0 0 1 K\n", gpoutfile);
+	} else {
+	    fputs("\
+[1 2] 0 d\n\
+0 j\n0 G\n", gpoutfile);
+	}
+	break;
+
+    case 0:
+	fprintf(gpoutfile, "%.2f w\n", corel_lw / COREL_SC);
+	if (corel_color) {
+	    fputs("1 0 1 0 K\n", gpoutfile);
+	} else {
+	    fputs("\
+[] 0 d\n\
+2 j\n0 G\n", gpoutfile);
+	}
+	break;
+
+    case 1:
+	fprintf(gpoutfile, "%.2f w\n", corel_lw / COREL_SC);
+	if (corel_color) {
+	    fputs("1 1 0 0 K\n", gpoutfile);
+	} else {
+	    fputs("\
+[4 2] 0 d\n\
+2 j\n0 G\n", gpoutfile);
+	}
+	break;
+
+    case 2:
+	fprintf(gpoutfile, "%.2f w\n", corel_lw / COREL_SC);
+	if (corel_color) {
+	    fputs("0 1 1 0 K\n", gpoutfile);
+	} else {
+	    fputs("\
+[2 3] 0 d\n\
+2 j\n0 G\n", gpoutfile);
+	}
+	break;
+
+    case 3:
+	fprintf(gpoutfile, "%.2f w\n", corel_lw / COREL_SC);
+	if (corel_color) {
+	    fputs("0 1 0 0 K\n", gpoutfile);
+	} else {
+	    fputs("\
+[1 1.5] 0 d\n\
+2 j\n0 G\n", gpoutfile);
+	}
+	break;
+
+    case 4:
+	fprintf(gpoutfile, "%f w\n", corel_lw / COREL_SC);
+	if (corel_color) {
+	    fputs("1 0 0 0 K\n", gpoutfile);
+	} else {
+	    fputs("\
+[5 2 1 2] 0 d\n\
+2 j\n0 G\n", gpoutfile);
+	}
+	break;
+
+    case 5:
+	fprintf(gpoutfile, "%.2f w\n", corel_lw / COREL_SC);
+	if (corel_color) {
+	    fputs("0 0 1 0 K\n", gpoutfile);
+	} else {
+	    fputs("\
+[4 3 1 3] 0 d\n\
+2 j\n0 G\n", gpoutfile);
+	}
+	break;
+
+    case 6:
+	fprintf(gpoutfile, "%.2f w\n", corel_lw / COREL_SC);
+	if (corel_color) {
+	    fputs("0 0 0 1 K\n", gpoutfile);
+	} else {
+	    fputs("\
+[2 2 2 4] 0 d\n\
+2 j\n0 G\n", gpoutfile);
+	}
+	break;
+
+    case 7:
+	fprintf(gpoutfile, "%.2f w\n", corel_lw / COREL_SC);
+	if (corel_color) {
+	    fputs("0 0.7 1 0 K\n", gpoutfile);
+	} else {
+	    fputs("\
+[2 2 2 2 2 4] 0 d\n\
+2 j\n0 G\n", gpoutfile);
+	}
+	break;
+
+    case 8:
+	fprintf(gpoutfile, "%.2f w\n", corel_lw / COREL_SC);
+	if (corel_color) {
+	    fputs("0.5 0.5 0.5 0 K\n", gpoutfile);
+	} else {
+	    fputs("\
+[2 2 2 2 2 2 2 4] 0 d\n\
+2 j\n0 G\n", gpoutfile);
+	}
+	break;
+    }
+    corel_path_count = 0;
+}
+
+
+TERM_PUBLIC void
+COREL_move(unsigned int x, unsigned int y)
+{
+    if (corel_stroke)
+	fputs("S\n", gpoutfile);
+    fprintf(gpoutfile, "%0.2f %0.2f m\n", x / COREL_SC, y / COREL_SC);
+    corel_path_count += 1;
+    corel_stroke = TRUE;
+}
+
+
+TERM_PUBLIC void
+COREL_vector(unsigned int x, unsigned int y)
+{
+    fprintf(gpoutfile, "%.2f %.2f l\n", x / COREL_SC, y / COREL_SC);
+    corel_path_count += 1;
+    corel_stroke = TRUE;
+    if (corel_path_count >= 400) {
+	fprintf(gpoutfile, "S\n%.2f %.2f m\n", x / COREL_SC, y / COREL_SC);
+	corel_path_count = 0;
+    }
+}
+
+
+TERM_PUBLIC void
+COREL_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    char ch;
+    if (corel_stroke) {
+	fputs("S\n", gpoutfile);
+	corel_stroke = FALSE;
+    }
+    switch (corel_justify) {
+    case LEFT:
+	fprintf(gpoutfile, "/_%s %d %d 0 0 z\n",
+		corel_font, corel_fontsize, corel_fontsize);
+	break;
+    case CENTRE:
+	fprintf(gpoutfile, "/_%s %d %d 0 1 z\n",
+		corel_font, corel_fontsize, corel_fontsize);
+	break;
+    case RIGHT:
+	fprintf(gpoutfile, "/_%s %d %d 0 2 z\n",
+		corel_font, corel_fontsize, corel_fontsize);
+	break;
+    }
+    if (corel_ang == 0) {
+	fprintf(gpoutfile, "[1 0 0 1 %.2f %.2f]e\n0 g\n",
+		x / COREL_SC, y / COREL_SC - corel_fontsize / 3.0);
+    } else {
+	fprintf(gpoutfile, "[0 1 -1 0 %.2f %.2f]e\n0 g\n",
+		x / COREL_SC - corel_fontsize / 3.0, y / COREL_SC);
+    }
+
+    putc('(', gpoutfile);
+    ch = *str++;
+    while (ch != NUL) {
+	if ((ch == '(') || (ch == ')') || (ch == '\\'))
+	    putc('\\', gpoutfile);
+	putc(ch, gpoutfile);
+	ch = *str++;
+    }
+    fputs(")t\nT\n", gpoutfile);
+    corel_path_count = 0;
+}
+
+TERM_PUBLIC int
+COREL_text_angle(int ang)
+{
+    corel_ang = ang;
+    return TRUE;
+}
+
+TERM_PUBLIC int
+COREL_justify_text(enum JUSTIFY mode)
+{
+    corel_justify = mode;
+    return TRUE;
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(corel_driver)
+    "corel", "EPS format for CorelDRAW",
+    CORELD_XMAX, CORELD_YMAX, CORELD_VCHAR, CORELD_HCHAR,
+    CORELD_VTIC, CORELD_HTIC, COREL_options, COREL_init, COREL_reset,
+    COREL_text, null_scale, COREL_graphics, COREL_move, COREL_vector,
+    COREL_linetype, COREL_put_text, COREL_text_angle,
+    COREL_justify_text, do_point, do_arrow, set_font_null
+TERM_TABLE_END(corel_driver)
+
+#undef LAST_TERM
+#define LAST_TERM corel_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(corel)
+"1 corel",
+"?commands set terminal corel",
+"?set terminal corel",
+"?set term corel",
+"?terminal corel",
+"?term corel",
+"?corel",
+" The `corel` terminal driver supports CorelDraw.",
+"",
+" Syntax:",
+"       set terminal corel {  default",
+"                           | {monochrome | color",
+"                                {\"<font>\" {<fontsize> ",
+"                                   {<xsize> <ysize> {<linewidth> }}}}}",
+"",
+" where the fontsize and linewidth are specified in points and the sizes in",
+" inches.  The defaults are monochrome, \"SwitzerlandLight\", 22, 8.2, 10 and 1.2."
+END_HELP(corel)
+#endif /* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/debug.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/debug.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/debug.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/debug.trm.svn-base	2012-01-03 17:07:26.676157100 -0800
@@ -0,0 +1,322 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: debug.trm,v 1.17 2006/07/21 02:35:45 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - debug.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004   Thomas Williams, Colin Kelley
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *  DEBUG
+ *
+ * AUTHORS
+ *    luecken@udel.edu
+ *
+ * send your comments or suggestions to (luecken@udel.edu).
+ *
+ */
+
+/*
+ * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
+ * generalised to have *all* defined capabilities by HBB (June 1997)
+ */
+
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(debug)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void DEBUG_init __PROTO((void));
+TERM_PUBLIC void DEBUG_graphics __PROTO((void));
+TERM_PUBLIC void DEBUG_text __PROTO((void));
+TERM_PUBLIC void DEBUG_linetype __PROTO((int linetype));
+TERM_PUBLIC void DEBUG_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void DEBUG_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void DEBUG_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC void DEBUG_reset __PROTO((void));
+TERM_PUBLIC int DEBUG_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC int DEBUG_text_angle __PROTO((int ang));
+TERM_PUBLIC void DEBUG_point __PROTO((unsigned int x, unsigned int y, int pointstyle));
+TERM_PUBLIC void DEBUG_arrow __PROTO((unsigned int sx, unsigned int sy, unsigned int ex, unsigned int ey, int head));
+TERM_PUBLIC int DEBUG_set_font __PROTO((const char *font));
+TERM_PUBLIC void DEBUG_pointsize __PROTO((double pointsize));
+TERM_PUBLIC void DEBUG_suspend __PROTO((void));
+TERM_PUBLIC void DEBUG_resume __PROTO((void));
+TERM_PUBLIC void DEBUG_fillbox __PROTO((int style, unsigned int x1, unsigned int y1, unsigned int width, unsigned int height));
+TERM_PUBLIC void DEBUG_linewidth __PROTO((double linewidth));
+
+#define DEBUG_XMAX 512
+#define DEBUG_YMAX 390
+
+#define DEBUG_XLAST (DEBUG_XMAX - 1)
+#define DEBUG_YLAST (DEBUG_XMAX - 1)
+
+/* Assume a character size of 1, or a 7 x 10 grid. */
+#define DEBUG_VCHAR	10
+#define DEBUG_HCHAR	7
+#define DEBUG_VTIC	(DEBUG_YMAX/70)
+#define DEBUG_HTIC	(DEBUG_XMAX/75)
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+int DEBUG_linetype_last;
+int DEBUG_xlast;
+int DEBUG_ylast;
+
+TERM_PUBLIC void
+DEBUG_init()
+{
+    fputs("init\n", gpoutfile);
+    DEBUG_linetype_last = LT_NODRAW;
+}
+
+
+TERM_PUBLIC void
+DEBUG_graphics()
+{
+    DEBUG_xlast = DEBUG_ylast = 0;
+    fputs("graphics\n", gpoutfile);
+}
+
+
+TERM_PUBLIC void
+DEBUG_text()
+{
+    fputs("text\n", gpoutfile);
+}
+
+
+TERM_PUBLIC void
+DEBUG_linetype(int linetype)
+{
+    /*
+       if (linetype != DEBUG_linetype_last){
+       fprintf(gpoutfile,"l%d",linetype);
+       DEBUG_linetype_last = linetype;
+       }
+     */
+    fprintf(gpoutfile, "line %d\n", linetype);
+}
+
+
+TERM_PUBLIC void
+DEBUG_move(unsigned int x, unsigned int y)
+{
+    /*
+       if (x != DEBUG_xlast || y != DEBUG_ylast){
+       fprintf(gpoutfile,"mm");
+       DEBUG_xlast = x;
+       DEBUG_ylast = y;
+       }
+     */
+    fprintf(gpoutfile, "move %d, %d\t(%d, %d)\n", x, y, x - DEBUG_xlast, y - DEBUG_ylast);
+    DEBUG_xlast = x;
+    DEBUG_ylast = y;
+}
+
+
+TERM_PUBLIC void
+DEBUG_vector(unsigned int x, unsigned int y)
+{
+    /*
+       if (x != DEBUG_xlast || y != DEBUG_ylast){
+       fprintf(gpoutfile,"vv");
+       DEBUG_xlast = x;
+       DEBUG_ylast = y;
+       }
+     */
+    fprintf(gpoutfile, "vect %d, %d\t(%d, %d)\n", x, y, x - DEBUG_xlast, y - DEBUG_ylast);
+    DEBUG_xlast = x;
+    DEBUG_ylast = y;
+}
+
+
+TERM_PUBLIC void
+DEBUG_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    /*
+       DEBUG_move(x,y);
+       fprintf(gpoutfile,"tx%s\r",str);
+     */
+    fputs("put_text calls:", gpoutfile);
+    DEBUG_move(x, y);
+    fprintf(gpoutfile, "put_text '%s'\n", str);
+}
+
+
+
+TERM_PUBLIC void
+DEBUG_reset()
+{
+    fputs("reset", gpoutfile);
+}
+
+TERM_PUBLIC int
+DEBUG_justify_text(enum JUSTIFY mode)
+{
+    fputs("justify ", gpoutfile);
+    switch (mode) {
+    case (CENTRE):
+	fputs("centre", gpoutfile);
+	break;
+    case (RIGHT):
+	fputs("right", gpoutfile);
+	break;
+    default:
+    case (LEFT):
+	fputs("left", gpoutfile);
+	break;
+    }
+    fputs("\n", gpoutfile);
+    return (TRUE);
+}
+
+TERM_PUBLIC int
+DEBUG_text_angle(int ang)
+{
+    fprintf(gpoutfile, "text_angle %d:", ang);
+    switch (ang) {
+    case 0:
+	fputs(": horizontal\n", gpoutfile);
+	break;
+    case 1:
+	fputs(": upwards\n", gpoutfile);
+	break;
+    default:
+	fputs(": \a*undefined*\n", gpoutfile);
+	break;
+    }
+    return TRUE;
+}
+
+TERM_PUBLIC void
+DEBUG_point(unsigned int x, unsigned int y, int pointstyle)
+{
+    fprintf(gpoutfile, "point at (%ud,%ud), pointstyle %d\n", x, y, pointstyle);
+}
+
+TERM_PUBLIC void
+DEBUG_arrow(
+    unsigned int sx, unsigned int sy,
+    unsigned int ex, unsigned int ey,
+    int head)
+{
+    fprintf(gpoutfile, "arrow from (%ud,%ud) to (%ud,%ud), %s head\n",
+	    sx, sy, ex, ey, head ? "with" : "without");
+}
+
+TERM_PUBLIC int
+DEBUG_set_font(const char *font)
+{
+    fprintf(gpoutfile, "set font to \"%s\"\n",
+	    font ? (*font ? font : "\aempty string!") : "\aNULL string!");
+    return TRUE;
+}
+
+TERM_PUBLIC void
+DEBUG_pointsize(double pointsize)
+{
+    fprintf(gpoutfile, "set pointsize to %lf\n", pointsize);
+}
+
+TERM_PUBLIC void
+DEBUG_suspend()
+{
+    fputs("suspended terminal driver\n", gpoutfile);
+}
+
+TERM_PUBLIC void
+DEBUG_resume()
+{
+    fputs("resumed terminal driver\n", gpoutfile);
+}
+
+TERM_PUBLIC void
+DEBUG_fillbox(
+    int style,
+    unsigned int x1, unsigned int y1,
+    unsigned int width, unsigned int height)
+{
+    fprintf(gpoutfile, "fillbox/clear at (%ud,%ud), area (%ud,%ud), style %d)\n",
+	    x1, y1, width, height, style);
+}
+
+TERM_PUBLIC void
+DEBUG_linewidth(double linewidth)
+{
+    fprintf(gpoutfile, "set linewidth %lf\n", linewidth);
+}
+
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(debug_driver)
+    "debug", "debugging driver",
+    DEBUG_XMAX, DEBUG_YMAX, DEBUG_VCHAR, DEBUG_HCHAR,
+    DEBUG_VTIC, DEBUG_HTIC, options_null, DEBUG_init, DEBUG_reset,
+    DEBUG_text, null_scale, DEBUG_graphics, DEBUG_move, DEBUG_vector,
+    DEBUG_linetype, DEBUG_put_text, DEBUG_text_angle,
+    DEBUG_justify_text, DEBUG_point, DEBUG_arrow, DEBUG_set_font,
+    DEBUG_pointsize,
+    TERM_CAN_MULTIPLOT,
+    DEBUG_suspend, DEBUG_resume, DEBUG_fillbox, DEBUG_linewidth
+TERM_TABLE_END(debug_driver)
+
+#undef LAST_TERM
+#define LAST_TERM debug_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(debug)
+"1 debug",
+"?commands set terminal debug",
+"?set terminal debug",
+"?set term debug",
+"?terminal debug",
+"?term debug",
+"?debug",
+" This terminal is provided to allow for the debugging of `gnuplot`.  It is",
+" likely to be of use only for users who are modifying the source code."
+END_HELP(debug)
+#endif
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/djsvga.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/djsvga.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/djsvga.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/djsvga.trm.svn-base	2012-01-03 17:07:26.901742100 -0800
@@ -0,0 +1,487 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: djsvga.trm,v 1.21 2007/06/04 20:54:54 mikulik Exp $
+ */
+
+/* GNUPLOT - djsvga.trm */
+
+/*[
+ * Copyright 1992 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *  svga
+ *
+ * AUTHORS
+ *  Russell Lang
+ *  Edzer Pebesma (gnuplot 3.6: new terminal layout, fonts, grx20)
+ *  Hans-Bernhard Broeker (several improvements)
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+
+/* HBB: A new version, called grx21a was released recently. To
+ * tell gnuplot you have it, add '-DGRX21' to your compilation flags.
+ * Currently, that only enables the drawing of wide lines. Maybe more
+ *  to come.
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(djsvga)		/* no ; */
+#endif
+
+#ifdef TERM_PROTO
+#define DJSVGA_XMAX 640
+#define DJSVGA_YMAX 480
+
+#define DJSVGA_XLAST (DJSVGA_XMAX - 1)
+#define DJSVGA_YLAST (DJSVGA_YMAX - 1)
+
+#define DJSVGA_VCHAR 16
+#define DJSVGA_HCHAR 8
+#define DJSVGA_VTIC 4
+#define DJSVGA_HTIC 4
+
+TERM_PUBLIC void DJSVGA_init __PROTO((void));
+TERM_PUBLIC void DJSVGA_graphics __PROTO((void));
+TERM_PUBLIC void DJSVGA_text __PROTO((void));
+TERM_PUBLIC void DJSVGA_reset __PROTO((void));
+TERM_PUBLIC void DJSVGA_options __PROTO((void));
+TERM_PUBLIC void DJSVGA_linetype __PROTO((int linetype));
+TERM_PUBLIC void DJSVGA_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void DJSVGA_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC int DJSVGA_angle __PROTO((int ang));
+TERM_PUBLIC int DJSVGA_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC void DJSVGA_put_text __PROTO((unsigned int x, unsigned int y,
+					  const char *str));
+TERM_PUBLIC int DJSVGA_set_font __PROTO((const char *fontname));
+TERM_PUBLIC void DJSVGA_suspend __PROTO((void));
+TERM_PUBLIC void DJSVGA_resume __PROTO((void));
+/* clear part of multiplot */
+TERM_PUBLIC void DJSVGA_fillbox __PROTO((int style, unsigned int x1,
+					 unsigned int y1, unsigned int width,
+					 unsigned int height));
+TERM_PUBLIC void DJSVGA_linewidth __PROTO((double linewidth));
+
+#define GOT_DJSVGA_PROTO
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+/* SVGA driver using DJGPP */
+#if (DJGPP==2)
+# define GRX20
+#endif
+#ifdef GRX20
+/* use grx20.h for DJGPP V1 / GRX V2 combo as well */
+# include <grx20.h>
+#else
+# include <grx.h>
+#endif
+#include <pc.h>
+
+static int dj_startx, dj_starty;
+static int dj_xlast, dj_ylast;
+#define DJNUMCOLOR 15
+/* HBB: Let's just use long for GRX1 as well */
+static long dj_color;
+static long svga256color[DJNUMCOLOR] =
+   /* old sequence: {7, 8, 2, 3, 4, 5, 9, 14, 12, 15, 13, 10, 11, 1, 6}; */
+{
+   7 /*black*/, 8 /*grey*/, 
+#if 0 /* prefer dark colors */
+   4 /*dark red*/, 2 /*dark green*/, 1 /*dark blue*/, 5 /*dark magenta*/, 3 /*dark cyan*/,
+   14 /*yellow*/, 15 /*white*/,
+   12 /*red*/, 9 /*blue*/, 13 /*magenta*/, 10 /*green*/, 11 /*cyan*/,
+   6 /*brown*/
+#else /* prefer light colors */
+   12 /*red*/, 10 /*green*/, 9 /*blue*/, 13 /*magenta*/, 11 /*cyan*/,
+   14 /*yellow*/, 15 /*white*/,
+   4 /*dark red*/, 1 /*dark blue*/, 5 /*dark magenta*/, 2 /*dark green*/, 3 /*dark cyan*/,
+   6 /*brown*/
+#endif
+};
+static long dj_colors[DJNUMCOLOR];
+#ifdef GRX20
+/* Save, Restore: for 16 color mode! */
+static void *DJSVGA_colorbuf = NULL;
+#endif
+static GrTextOption DJSVGA_TextOption;
+/* HBB: I think we should use GR_NAMEWIDTH (=16), instead of MAX_ID_LEN,
+ *   which has nothing to do with GRX at all */
+#ifdef GRX20
+char DJSVGA_fontname[MAX_ID_LEN + 1] = "";
+#else
+char DJSVGA_fontname[MAX_ID_LEN + 1] = "@:pc8x14.fnt";	/* EGA bios font */
+#endif
+static GrContext *DJSVGA_context = 0;	/* save screen for suspend/resume */
+static char *dj_textsave = 0;	/* for text-screen-saving */
+static int dj_cursorx, dj_cursory;
+static int dj_width, dj_height;
+#ifdef GRX21
+static double dj_linewidth;	/* store linewidth assignments here */
+#endif
+
+
+TERM_PUBLIC void
+DJSVGA_options()
+{
+    if (!END_OF_COMMAND && isstring(c_token)) {
+	quote_str(DJSVGA_fontname, c_token, MAX_ID_LEN);
+	c_token++;
+    }
+    sprintf(term_options, "\"%s\"", DJSVGA_fontname);
+}
+
+TERM_PUBLIC void
+DJSVGA_init()
+{
+    int i, on, r, g, b, medium = 170, low = 85;
+    GrFont *font = NULL;
+
+#ifdef GRX20
+    font = &GrDefaultFont;
+#endif
+    /* HBB: save textscreen contents and cursor-position */
+    dj_textsave = gp_alloc(ScreenRows() * ScreenCols() * 2, "djsvga term scrbuf");
+    ScreenRetrieve(dj_textsave);
+    dj_width = ScreenCols();
+    dj_height = ScreenRows();
+    ScreenGetCursor(&dj_cursory, &dj_cursorx);
+    GrSetMode(GR_default_graphics);
+    GrSetRGBcolorMode();
+    GrResetColors();
+    /* Allocate colors */
+    for (i = 0; i < DJNUMCOLOR; i++) {
+	on = (svga256color[i] & 8) ? 255 : medium;
+	r = (svga256color[i] & 4) ? on : 0;
+	g = (svga256color[i] & 2) ? on : 0;
+	b = (svga256color[i] & 1) ? on : 0;
+	if (svga256color[i] == 8)
+	    r = g = b = low;
+	dj_colors[i] = GrAllocColor(r, g, b);
+    }
+    /* Get the screen size: */
+    dj_xlast = GrMaxX();
+    term->xmax = dj_xlast + 1;
+    dj_ylast = GrMaxY();
+    term->ymax = dj_ylast + 1;
+    /* if GRX 1.x loads an GRX 2.x save'd file: */
+    if (font == NULL && DJSVGA_fontname[0] == '\0')
+	sprintf(DJSVGA_fontname, "@:pc8x14.fnt");
+
+    if (DJSVGA_fontname[0] != '\0')
+	font = GrLoadFont(DJSVGA_fontname);
+    if (font == NULL)
+	font = GrLoadFont("@:pc8x14.fnt");	/* try EGA bios font */
+    if (font == NULL)
+	font = GrLoadFont("@:pc8x16.fnt");	/* try VGA bios font */
+    /*
+     * HBB: There are cases when we reach this point with font still NULL,
+     *   eg. when the GRXFONT env.variable points to the GRX V1 fonts, but
+     *   GRX V2 is used for this program: some fonts will *fail* to load in
+     *   that setup (e.g. cour20b)! So IMHO, there should be some error
+     *   treatment here..., like int_error("Couldn't load font!");
+     */
+    DJSVGA_TextOption.txo_font = font;
+    DJSVGA_TextOption.txo_direct = GR_TEXT_RIGHT;
+    DJSVGA_TextOption.txo_xalign = GR_ALIGN_LEFT;
+    DJSVGA_TextOption.txo_yalign = GR_ALIGN_CENTER;
+    DJSVGA_TextOption.txo_chrtype = GR_BYTE_TEXT;
+    DJSVGA_TextOption.txo_bgcolor.v = GrNOCOLOR;
+#ifndef GRX20
+    DJSVGA_TextOption.txo_xmag = 1;
+    DJSVGA_TextOption.txo_ymag = 1;
+#endif
+    /* HBB: this version should work in all configurations */
+    term->v_char = font->h.height;
+    term->h_char = font->h.width;
+
+#ifdef GRX20
+    if (DJSVGA_colorbuf == NULL)
+	DJSVGA_colorbuf = (void *) gp_alloc(GrColorSaveBufferSize(), "djsvga term colorbuf");
+    GrSaveColors(DJSVGA_colorbuf);
+#endif
+    GrSetMode(GR_default_text);
+    ScreenUpdate(dj_textsave);
+    ScreenSetCursor(dj_cursory, dj_cursorx);
+}
+
+/*
+ * HBB: make these two inline, as they're called by other routines
+ * inside this module, and -finline-functions (normally switched
+ * on by 'gcc -O3') doesn't work for compiling term.c
+ */
+__inline__
+TERM_PUBLIC void
+DJSVGA_graphics()
+{
+    ScreenRetrieve(dj_textsave);	/* HBB: save text screen contents */
+    ScreenGetCursor(&dj_cursory, &dj_cursorx);
+    GrSetMode(GR_default_graphics);
+#ifdef GRX20
+    GrRestoreColors(DJSVGA_colorbuf);
+#endif
+}
+
+__inline__
+TERM_PUBLIC void
+DJSVGA_text()
+{
+    (void) getkey();
+    GrSetMode(GR_width_height_text, dj_width, dj_height);
+    ScreenUpdate(dj_textsave);	/* HBB: restore text screen */
+    ScreenSetCursor(dj_cursory, dj_cursorx);
+}
+
+TERM_PUBLIC void
+DJSVGA_reset()
+{
+    GrResetColors();
+    free(dj_textsave);
+}
+
+TERM_PUBLIC void
+DJSVGA_linetype(int linetype)
+{
+    if (linetype < -2)
+	linetype = LT_BLACK;
+    if (linetype >= 13)
+	linetype %= 13;
+    /* HBB: set the TextOption color variable right here (faster) */
+    DJSVGA_TextOption.txo_fgcolor.v = dj_color = dj_colors[linetype + 2];
+}
+
+TERM_PUBLIC void
+DJSVGA_move(unsigned int x, unsigned int y)
+{
+    dj_startx = x;
+    dj_starty = y;
+}
+
+
+TERM_PUBLIC void
+DJSVGA_vector(unsigned int x, unsigned int y)
+{
+#ifdef GRX21
+    GrLineOption dj_lineoption =
+    {dj_color, dj_linewidth, 0, ""};
+
+    GrCustomLine(dj_startx, dj_ylast - dj_starty, x, dj_ylast - y, &dj_lineoption);
+#else
+    GrLine(dj_startx, dj_ylast - dj_starty, x, dj_ylast - y, dj_color);
+#endif
+    dj_startx = x;
+    dj_starty = y;
+}
+
+/*
+ * HBB: IMHO, the previous version was seriously flawed. E.g.
+ *   in the termentry, _justify_text was pointing to the
+ *   null_justify_text dummy routine, so DJSVGA_justify wasn't
+ *   ever called at all. I copied the routines from my (now
+ *   otherwise pointless) own private driver, djgrx.trm, to
+ *   cure that.
+ */
+TERM_PUBLIC int
+DJSVGA_angle(int ang)
+{
+    if (ang) {
+	DJSVGA_TextOption.txo_direct = GR_TEXT_UP;
+    } else {
+	DJSVGA_TextOption.txo_direct = GR_TEXT_RIGHT;
+    }
+    return TRUE;
+}
+
+TERM_PUBLIC int
+DJSVGA_justify_text(enum JUSTIFY mode)
+{
+    if (DJSVGA_TextOption.txo_direct == GR_TEXT_RIGHT) {
+	DJSVGA_TextOption.txo_yalign = GR_ALIGN_CENTER;
+	switch (mode) {
+	case LEFT:
+	    DJSVGA_TextOption.txo_xalign = GR_ALIGN_LEFT;
+	    break;
+	case CENTRE:
+	    DJSVGA_TextOption.txo_xalign = GR_ALIGN_CENTER;
+	    break;
+	case RIGHT:
+	    DJSVGA_TextOption.txo_xalign = GR_ALIGN_RIGHT;
+	    break;
+	}
+    } else {
+	DJSVGA_TextOption.txo_xalign = GR_ALIGN_CENTER;
+	switch (mode) {
+	case LEFT:
+	    DJSVGA_TextOption.txo_yalign = GR_ALIGN_BOTTOM;
+	    break;
+	case CENTRE:
+	    DJSVGA_TextOption.txo_yalign = GR_ALIGN_CENTER;
+	    break;
+	case RIGHT:
+	    DJSVGA_TextOption.txo_yalign = GR_ALIGN_TOP;
+	    break;
+	}
+    }
+    return TRUE;
+}
+
+TERM_PUBLIC int
+DJSVGA_set_font(const char *fontname)
+{
+    char *cp;
+    GrFont *font;
+    if (!fontname || !fontname[0])
+	return FALSE;
+    safe_strncpy(DJSVGA_fontname, fontname, sizeof(DJSVGA_fontname));
+    cp = strstr(DJSVGA_fontname, ",");
+    if (cp != NULL)
+	*cp = NUL;
+    font = GrLoadFont(DJSVGA_fontname);
+    /*HBB: if no font found, do *not* report success! */
+    if (font != NULL) {
+	GrUnloadFont(DJSVGA_TextOption.txo_font);
+	DJSVGA_TextOption.txo_font = font;
+	return TRUE;
+    } else {
+	graph_error("Font not found");
+	return FALSE;
+    }
+}
+
+TERM_PUBLIC void
+DJSVGA_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    /* HBB: why isn't font!=NULL ensured elsewhere? Testing it at
+     * this point doesn't really make much sense (we're in graphics
+     * mode, so we can't even print out a useful error message!) */
+    /*if (DJSVGA_TextOption.txo_font != NULL) */
+    GrDrawString(str, strlen(str), x, dj_ylast - y, &DJSVGA_TextOption);
+}
+
+TERM_PUBLIC void
+DJSVGA_suspend()
+{
+    DJSVGA_context = GrCreateContext(GrSizeX(), GrSizeY(), 0, 0);
+    GrBitBltNC(DJSVGA_context, 0, 0, 0, 0, 0, GrMaxX(), GrMaxY(), GrWRITE);
+    DJSVGA_text();
+}
+
+TERM_PUBLIC void
+DJSVGA_resume()
+{
+    DJSVGA_graphics();
+    GrBitBltNC(0, 0, 0, DJSVGA_context, 0, 0, GrMaxX(), GrMaxY(), GrWRITE);
+    GrDestroyContext(DJSVGA_context);
+}
+
+TERM_PUBLIC void
+DJSVGA_fillbox(
+    int style,
+    unsigned int left, unsigned int bottom,
+    unsigned int width, unsigned height)
+{
+    if (style >= 13)
+	style %= 13;
+    /* HBB: prize question: should it be 'width-1' instead? */
+    /* HBB: fill with GRX Color '0', which *should* be black : */
+    /* ULIG: the style parameter is now used for the fillboxes style */
+    /* (not implemented here), see the documentation */
+
+    GrFilledBox(left, dj_ylast - bottom, left + width, dj_ylast - bottom - height, 0);
+}
+
+TERM_PUBLIC void
+DJSVGA_linewidth(double linewidth)
+{
+#ifdef GRX21
+    dj_linewidth = linewidth;
+#endif
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+/* HBB: I think \" is more readable than \042. BTW: why is this
+ *   option 'documented' here, but not in the Help node? */
+TERM_TABLE_START(djsvga_driver)
+    "svga", "IBM PC/Clone with Super VGA graphics board [\"fontname\"]",
+    DJSVGA_XMAX, DJSVGA_YMAX, DJSVGA_VCHAR, DJSVGA_HCHAR,
+    DJSVGA_VTIC, DJSVGA_HTIC,
+    DJSVGA_options,
+    DJSVGA_init, DJSVGA_reset, DJSVGA_text,
+    null_scale, DJSVGA_graphics, DJSVGA_move, DJSVGA_vector,
+    DJSVGA_linetype, DJSVGA_put_text,
+    DJSVGA_angle, DJSVGA_justify_text,
+    do_point, do_arrow, DJSVGA_set_font,
+    0,				/* no pointsize() */
+    TERM_CAN_MULTIPLOT,
+    DJSVGA_suspend, DJSVGA_resume,
+    DJSVGA_fillbox, DJSVGA_linewidth
+TERM_TABLE_END(djsvga_driver)
+
+#undef LAST_TERM
+#define LAST_TERM djsvga_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+/*
+ * HBB: I think this documentation should be at least a *bit* longer
+ *   (E.g., the "fontname" parameter is claimed to be non-existent!)
+ */
+/* RCC: Not any more...
+ *      If you have other ideas about what could be in the help section,
+ *      please let me know (rccrawford@lanl.gov) --- particularly info
+ *      about what fonts are permitted, if there is such a list.
+*/
+#ifdef TERM_HELP
+START_HELP(svga)
+"1 svga",
+"?commands set terminal svga",
+"?set terminal svga",
+"?set term svga",
+"?terminal svga",
+"?term svga",
+"?svga",
+" The `svga` terminal driver supports PCs with SVGA graphics.  It can only be",
+" used if it is compiled with DJGPP.  Its only option is the font.",
+"",
+" Syntax:",
+"       set terminal svga {\"<fontname>\"}"
+END_HELP(svga)
+#endif /* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/driver.h.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/driver.h.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/driver.h.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/driver.h.svn-base	2012-01-03 17:07:27.094241300 -0800
@@ -0,0 +1,81 @@
+/* $Id: driver.h,v 1.22 2006/10/08 21:11:08 sfeam Exp $ */
+
+/* GNUPLOT - driver.h */
+
+/*[
+ * Copyright 1986 - 1993, 1998, 2004   Thomas Williams, Colin Kelley
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+
+#ifndef TERM_DRIVER_H
+#define TERM_DRIVER_H
+
+#include "syscfg.h"
+
+#include <stdio.h>
+
+/* functions provided by term.c */
+
+static void do_point __PROTO((unsigned int x, unsigned int y, int number));
+static void line_and_point __PROTO((unsigned int x, unsigned int y, int number));
+static int null_text_angle __PROTO((int ang));
+static int null_justify_text __PROTO((enum JUSTIFY just));
+static int null_scale __PROTO((double x, double y));
+static void options_null __PROTO((void));
+static void UNKNOWN_null __PROTO((void));
+/* static int set_font_null __PROTO((const char *s));     */ /* unused */
+#define set_font_null NULL
+
+extern FILE *gpoutfile;
+extern struct termentry *term;
+
+/* for use by all drivers */
+#ifndef NEXT
+#define sign(x) ((x) >= 0 ? 1 : -1)
+#else
+/* it seems that sign as macro causes some conflict with precompiled headers */
+static int sign(int x)
+{
+    return x >= 0 ? 1 : -1;
+}
+#endif /* NEXT */
+
+/* abs as macro is now uppercase, there are conflicts with a few C compilers
+   that have abs as macro, even though ANSI defines abs as function
+   (int abs(int)). Most calls to ABS in term/ could be changed to abs if
+   they use only int arguments and others to fabs, but for the time being,
+   all calls are done via the macro */
+#ifndef ABS
+# define ABS(x) ((x) >= 0 ? (x) : -(x))
+#endif /* ABS */
+
+#define NICE_LINE		0
+#define POINT_TYPES		6
+
+#endif /* TERM_DRIVER_H */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/dumb.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/dumb.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/dumb.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/dumb.trm.svn-base	2012-01-03 17:07:27.308797700 -0800
@@ -0,0 +1,590 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: dumb.trm,v 1.30 2009/03/26 00:49:19 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - dumb.trm */
+
+/*[
+ * Copyright 1991 - 1993, 1998, 2004   Thomas Williams, Colin Kelley
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *   DUMB terminals
+ *
+ * AUTHORS
+ *   Francois Pinard, 91-04-03
+ *           INTERNET: pinard@iro.umontreal.ca
+ *
+ *   Ethan A Merritt Nov 2003
+ *	Added support for enhanced text mode.
+ *	Yes, this is frivolous, but it serves as an example for
+ *	adding enhanced text to other terminals.  You can disable
+ *	it by adding a line
+ *	#define NO_DUMB_ENHANCED_SUPPORT
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(dumb_driver)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void DUMB_options __PROTO((void));
+TERM_PUBLIC void DUMB_init __PROTO((void));
+TERM_PUBLIC void DUMB_graphics __PROTO((void));
+TERM_PUBLIC void DUMB_text __PROTO((void));
+TERM_PUBLIC void DUMB_reset __PROTO((void));
+TERM_PUBLIC void DUMB_linetype __PROTO((int linetype));
+TERM_PUBLIC void DUMB_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void DUMB_point __PROTO((unsigned int x, unsigned int y,
+				     int point));
+TERM_PUBLIC void DUMB_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void DUMB_put_text __PROTO((unsigned int x, unsigned int y,
+					const char *str));
+TERM_PUBLIC void DUMB_arrow __PROTO((unsigned int sx, unsigned int sy,
+				     unsigned int ex, unsigned int ey,
+				     int head));
+
+#ifndef NO_DUMB_ENHANCED_SUPPORT
+/* To support "set term dumb enhanced" (don't ask why!) */
+TERM_PUBLIC void ENHdumb_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
+TERM_PUBLIC void ENHdumb_OPEN __PROTO((char * fontname, double fontsize,
+	                            double base, TBOOLEAN widthflag, TBOOLEAN showflag,
+				    int overprint));
+TERM_PUBLIC void ENHdumb_FLUSH __PROTO((void));
+#else
+#define ENHdumb_put_text NULL
+#endif
+
+
+#define DUMB_XMAX 79
+#define DUMB_YMAX 24
+
+#endif /* TERM_PROTO */
+
+#ifdef TERM_BODY
+
+#define DUMB_AXIS_CONST '\1'
+#define DUMB_BORDER_CONST '\2'
+
+/* matrix of characters */
+static char *dumb_matrix = NULL;
+/* matrix of priority at each position */
+static char *dumb_priority = NULL;
+/* current character used to draw */
+static char dumb_pen;
+/* current X position */
+static int dumb_x;
+/* current Y position */
+static int dumb_y;
+static int dumb_xmax = DUMB_XMAX;
+static int dumb_ymax = DUMB_YMAX;
+static int dumb_feed = 1;
+
+#define DUMB_PIXEL(x,y) dumb_matrix[dumb_xmax*(y)+(x)]
+
+static void dumb_set_pixel __PROTO((int x, int y, int v, int p));
+
+enum DUMB_id { DUMB_FEED, DUMB_NOFEED, DUMB_ENH, DUMB_NOENH, DUMB_SIZE, DUMB_OTHER };
+
+static struct gen_table DUMB_opts[] =
+{
+    { "f$eed", DUMB_FEED },
+    { "nof$eed", DUMB_NOFEED },
+    { "enh$anced", DUMB_ENH },
+    { "noe$nhanced", DUMB_NOENH },
+    { "size", DUMB_SIZE },
+    { NULL, DUMB_OTHER }
+};
+
+TERM_PUBLIC void
+DUMB_options()
+{
+    int x, y;
+
+    while (!END_OF_COMMAND) {
+	switch(lookup_table(&DUMB_opts[0],c_token)) {
+	case DUMB_FEED:
+	    c_token++;
+	    dumb_feed = 1;
+	    break;
+	case DUMB_NOFEED:
+	    c_token++;
+	    dumb_feed = 0;
+	    break;
+#ifndef NO_DUMB_ENHANCED_SUPPORT
+	case DUMB_ENH:
+	    c_token++;
+	    term->put_text = ENHdumb_put_text;
+	    term->flags |= TERM_ENHANCED_TEXT;
+	    break;
+	case DUMB_NOENH:
+	    c_token++;
+	    term->put_text = DUMB_put_text;
+	    term->flags &= ~TERM_ENHANCED_TEXT;
+	    break;
+#endif
+	case DUMB_SIZE:
+	    c_token++;
+	    /* Fall through */
+
+	case DUMB_OTHER:
+	default:
+	    x = int_expression();
+	    if (!END_OF_COMMAND) {
+		if (equals(c_token,","))
+		    c_token++;
+		y = int_expression();
+		dumb_xmax = term->xmax = x;
+		dumb_ymax = term->ymax = y;
+	    }
+ 	    break;
+	}
+    }
+
+    sprintf(term_options, "%sfeed %s size %d, %d",
+	    dumb_feed ? "" : "no",
+	    term->put_text == ENHdumb_put_text ? "enhanced" : "",
+	    dumb_xmax, dumb_ymax);
+}
+
+
+static void
+dumb_set_pixel(int x, int y, int v, int p)
+{
+    if ((unsigned int) x <= dumb_xmax &&	/* ie x>=0 && x<=dumb_xmax */
+	(unsigned int) y <= dumb_ymax &&
+	p > dumb_priority[dumb_xmax * y + x]) {
+	dumb_matrix[dumb_xmax * y + x] = v;
+	dumb_priority[dumb_xmax * y + x] = p;
+    }
+}
+
+
+TERM_PUBLIC void
+DUMB_init()
+{
+    if (dumb_matrix)
+	free(dumb_matrix);
+
+    dumb_matrix = gp_alloc((dumb_xmax+1) * (dumb_ymax+1) * 2, "dumb terminal");
+
+    dumb_priority = dumb_matrix + dumb_xmax * dumb_ymax;
+}
+
+
+TERM_PUBLIC void
+DUMB_graphics()
+{
+    int i;
+    char *pm = dumb_matrix, *pp = dumb_priority;
+
+    for (i = dumb_xmax * dumb_ymax; i > 0; i--) {
+	*pm++ = ' ';
+	*pp++ = 0;
+    }
+}
+
+
+TERM_PUBLIC void
+DUMB_text()
+{
+    int x, y, l;
+
+    putc('\f', gpoutfile);
+    for (y = dumb_ymax - 1; y >= 0; y--) {
+	for (l = dumb_xmax; l > 0 && DUMB_PIXEL(l - 1, y) == ' '; l--);
+	for (x = 0; x < l; x++)
+	    putc(DUMB_PIXEL(x, y), gpoutfile);
+	if (dumb_feed || y > 0)
+	    putc('\n', gpoutfile);
+    }
+    fflush(gpoutfile);
+}
+
+
+TERM_PUBLIC void
+DUMB_reset()
+{
+    if (dumb_matrix)
+	free(dumb_matrix);
+    dumb_matrix = NULL;
+}
+
+
+TERM_PUBLIC void
+DUMB_linetype(int linetype)
+{
+    static char pen_type[7] = { '*', '#', '$', '%', '@', '&', '=' };
+
+    if (linetype == LT_BLACK)
+	dumb_pen = DUMB_BORDER_CONST;
+    else if (linetype == LT_AXIS)
+	dumb_pen = DUMB_AXIS_CONST;
+    else if (linetype <= LT_NODRAW)
+	dumb_pen = ' ';
+    else {
+	linetype = linetype % 7;
+	dumb_pen = pen_type[linetype];
+    }
+}
+
+
+TERM_PUBLIC void
+DUMB_move(unsigned int x, unsigned int y)
+{
+    dumb_x = x;
+    dumb_y = y;
+}
+
+
+TERM_PUBLIC void
+DUMB_point(unsigned int x, unsigned int y, int point)
+{
+    dumb_set_pixel(x, y, point == -1 ? '.' : point % 26 + 'A', 4);
+}
+
+
+TERM_PUBLIC void
+DUMB_vector(unsigned int arg_x, unsigned int arg_y)
+{
+    int x = arg_x;		/* we need signed int, since
+				 * unsigned-signed=unsigned and */
+    int y = arg_y;		/* abs and cast to double wouldn't work */
+    char pen, pen1;
+    int priority;
+    int delta;
+
+    if (ABS(y - dumb_y) > ABS(x - dumb_x)) {
+	switch (dumb_pen) {
+	case DUMB_AXIS_CONST:
+	    pen = ':';
+	    pen1 = '+';
+	    priority = 1;
+	    break;
+
+	case DUMB_BORDER_CONST:
+	    pen = '|';
+	    pen1 = '+';
+	    priority = 2;
+	    break;
+
+	default:
+	    pen = dumb_pen;
+	    pen1 = dumb_pen;
+	    priority = 3;
+	    break;
+	}
+	dumb_set_pixel(dumb_x, dumb_y, pen1, priority);
+	for (delta = 1; delta < ABS(y - dumb_y); delta++) {
+	    dumb_set_pixel(dumb_x  + (int) ((double) (x - dumb_x) *
+					    delta / ABS(y - dumb_y) + 0.5),
+			   dumb_y + delta * sign(y - dumb_y), pen, priority);
+	}
+	dumb_set_pixel(x, y, pen1, priority);
+    } else if (ABS(x - dumb_x) > ABS(y - dumb_y)) {
+	switch (dumb_pen) {
+	case DUMB_AXIS_CONST:
+	    pen = '.';
+	    pen1 = '+';
+	    priority = 1;
+	    break;
+
+	case DUMB_BORDER_CONST:
+	    pen = '-';
+	    pen1 = '+';
+	    priority = 2;
+	    break;
+
+	default:
+	    pen = dumb_pen;
+	    pen1 = dumb_pen;
+	    priority = 3;
+	    break;
+	}
+	dumb_set_pixel(dumb_x, dumb_y, pen1, priority);
+	for (delta = 1; delta < ABS(x - dumb_x); delta++)
+	    dumb_set_pixel(dumb_x + delta * sign(x - dumb_x),
+			   dumb_y +
+			   (int) ((double) (y - dumb_y) * delta / ABS(x - dumb_x)
+				  + 0.5),
+			   pen, priority);
+	dumb_set_pixel(x, y, pen1, priority);
+    } else {
+	switch (dumb_pen) {
+	case DUMB_AXIS_CONST:	/* zero length axis */
+	    pen = '+';
+	    priority = 1;
+	    break;
+
+	case DUMB_BORDER_CONST:	/* zero length border */
+	    pen = '+';
+	    priority = 2;
+	    break;
+
+	default:
+	    pen = dumb_pen;
+	    priority = 3;
+	    break;
+	}
+	for (delta = 0; delta <= ABS(x - dumb_x); delta++)
+	    dumb_set_pixel(dumb_x + delta * sign(x - dumb_x),
+			   dumb_y + delta * sign(y - dumb_y),
+			   pen, priority);
+    }
+    dumb_x = x;
+    dumb_y = y;
+}
+
+
+TERM_PUBLIC void
+DUMB_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    int length;
+
+    length = strlen(str);
+    if (x + length > dumb_xmax)
+	x = GPMAX(0, dumb_xmax - length);
+
+    for (; x < dumb_xmax && *str; x++, str++)
+	dumb_set_pixel(x, y, *str, 5);
+}
+
+
+TERM_PUBLIC void
+DUMB_arrow(
+    unsigned int sx, unsigned int sy,
+    unsigned int ex, unsigned int ey,
+    int head)		/* ignored */
+{
+    char saved_pen;
+    char saved_x;
+    char saved_y;
+
+    (void) head;		/* dummy usage avoid compiler warnings */
+    saved_pen = dumb_pen;
+    saved_x = dumb_x;
+    saved_y = dumb_y;
+
+    dumb_pen = '>';
+    dumb_x = sx;
+    dumb_y = sy;
+    DUMB_vector(ex, ey);
+
+    dumb_pen = saved_pen;
+    dumb_x = saved_x;
+    dumb_y = saved_y;
+}
+
+
+#ifndef NO_DUMB_ENHANCED_SUPPORT
+/*
+ * The code from here on serves as an example of how to
+ * add enhanced text mode support to even a dumb driver.
+ */
+
+static TBOOLEAN ENHdumb_opened_string;
+static TBOOLEAN ENHdumb_show = TRUE;
+static int ENHdumb_overprint = 0;
+static TBOOLEAN ENHdumb_widthflag = TRUE;
+static unsigned int ENHdumb_xsave, ENHdumb_ysave;
+#define ENHdumb_fontsize 1
+#define ENHdumb_font ""
+static double ENHdumb_base;
+
+TERM_PUBLIC void
+ENHdumb_OPEN(
+    char *fontname,
+    double fontsize, double base,
+    TBOOLEAN widthflag, TBOOLEAN showflag,
+    int overprint)
+{
+    /* There are two special cases:
+     * overprint = 3 means save current position
+     * overprint = 4 means restore saved position
+     */
+    if (overprint == 3) {
+	ENHdumb_xsave = dumb_x;
+	ENHdumb_ysave = dumb_y;
+	return;
+    } else if (overprint == 4) {
+	DUMB_move(ENHdumb_xsave, ENHdumb_ysave);
+	return;
+    }
+
+
+    if (!ENHdumb_opened_string) {
+	ENHdumb_opened_string = TRUE;
+	/* Start new text fragment */
+	    enhanced_cur_text = &enhanced_text[0];
+	/* Scale fractional font height to vertical units of display */
+	    ENHdumb_base = base * 2;
+	/* Keep track of whether we are supposed to show this string */
+	    ENHdumb_show = showflag;
+	/* 0/1/2  no overprint / 1st pass / 2nd pass */
+	    ENHdumb_overprint = overprint;
+	/* widthflag FALSE means do not update text position after printing */
+	    ENHdumb_widthflag = widthflag;
+	/* Many drivers will need to do something about font selection here */
+	    /* but dumb is dumb */
+    }
+}
+
+TERM_PUBLIC void
+ENHdumb_FLUSH()
+{
+    char *str = enhanced_text;	/* The fragment to print */
+    int x = dumb_x;		/* The current position  */
+    int len;
+
+    if (ENHdumb_opened_string) {
+	*enhanced_cur_text = '\0';
+	len = strlen(str);
+
+	/* print the string fragment, perhaps invisibly */
+	/* NB: base expresses offset from current y pos */
+	for (; x < dumb_xmax && *str; x++, str++)
+	    if (ENHdumb_show)
+        	dumb_set_pixel(x, dumb_y+ENHdumb_base, *str, 5);
+
+	if (!ENHdumb_widthflag)
+	    /* don't update position */
+	    ;
+	else if (ENHdumb_overprint == 1)
+	    /* First pass of overprint, leave position in center of fragment */
+	    dumb_x += len / 2;
+	else
+	    /* Normal case is to update position to end of fragment */
+	    dumb_x += len;
+
+	ENHdumb_opened_string = FALSE;
+    }
+}
+
+TERM_PUBLIC void
+ENHdumb_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    /* If no enhanced text processing is needed, we can use the plain  */
+    /* vanilla put_text() routine instead of this fancy recursive one. */
+    if (ignore_enhanced_text || !strpbrk(str, "{}^_@&~")) {
+	DUMB_put_text(x,y,str);
+	return;
+    }
+
+    /* Set up global variables needed by enhanced_recursion() */
+    enhanced_fontscale = 1.0;
+    ENHdumb_opened_string = FALSE;
+    strncpy(enhanced_escape_format,"%c",sizeof(enhanced_escape_format));
+
+    DUMB_move(x,y);
+
+    /* Set the recursion going. We say to keep going until a
+     * closing brace, but we don't really expect to find one.
+     * If the return value is not the nul-terminator of the
+     * string, that can only mean that we did find an unmatched
+     * closing brace in the string. We increment past it (else
+     * we get stuck in an infinite loop) and try again.
+     */
+    while (*(str = enhanced_recursion((char *)str, TRUE,
+    			ENHdumb_font, ENHdumb_fontsize,
+			0.0, TRUE, TRUE, 0))) {
+	(term->enhanced_flush)();
+
+	/* I think we can only get here if *str == '}' */
+	    enh_err_check(str);
+
+	if (!*++str)
+	    break; /* end of string */
+
+	/* else carry on and process the rest of the string */
+    }
+}
+#endif /* NO_DUMB_ENHANCED_SUPPORT */
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+TERM_TABLE_START(dumb_driver)
+    "dumb", "ascii art for anything that prints text",
+    DUMB_XMAX, DUMB_YMAX, 1, 1,
+    1, 1, DUMB_options, DUMB_init, DUMB_reset,
+    DUMB_text, null_scale, DUMB_graphics, DUMB_move, DUMB_vector,
+    DUMB_linetype, DUMB_put_text, null_text_angle,
+    null_justify_text, DUMB_point, DUMB_arrow, set_font_null,
+    0,				/* pointsize */
+    TERM_CAN_MULTIPLOT,
+    NULL, NULL, NULL, NULL
+#ifdef USE_MOUSE
+    , NULL, NULL, NULL, NULL, NULL
+#endif
+    , NULL, NULL, NULL, NULL
+    , NULL /* image */
+#ifndef NO_DUMB_ENHANCED_SUPPORT
+    , ENHdumb_OPEN, ENHdumb_FLUSH, do_enh_writec
+#endif /* NO_DUMB_ENHANCED_SUPPORT */
+TERM_TABLE_END(dumb_driver)
+
+#undef LAST_TERM
+#define LAST_TERM dumb_driver
+
+#endif /* TERM_TABLE */
+
+#ifdef TERM_HELP
+START_HELP(dumb)
+"1 dumb",
+"?commands set terminal dumb",
+"?set terminal dumb",
+"?set term dumb",
+"?terminal dumb",
+"?term dumb",
+"?dumb",
+" The `dumb` terminal driver has an optional size specification and trailing",
+" linefeed control.",
+"",
+" Syntax:",
+"       set terminal dumb {[no]feed} {<xsize> <ysize>}",
+#ifndef NO_DUMB_ENHANCED_SUPPORT
+"                         {[no]enhanced}",
+#endif
+"",
+" where <xsize> and <ysize> set the size of the dumb terminals. Default is",
+" 79 by 24. The last newline is printed only if `feed` is enabled.",
+"",
+" Examples:",
+"       set term dumb nofeed",
+"       set term dumb 79 49 # VGA screen---why would anyone do that?"
+END_HELP(dumb)
+#endif /* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/dxf.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/dxf.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/dxf.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/dxf.trm.svn-base	2012-01-03 17:07:27.545411300 -0800
@@ -0,0 +1,423 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: dxf.trm,v 1.16 2006/07/21 02:35:45 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - dxf.trm */
+
+/*[
+ * Copyright 1991 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *   AutoCad (Release 10.x) dxf file format (import with AutoCad dxfin command)
+ *
+ *
+ * AUTHOR
+ *   Florian Hiss  (fhis1231@w204zrz.zrz.tu-berlin.de)
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+*/
+
+/*
+ * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(dxf)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void DXF_init __PROTO((void));
+TERM_PUBLIC void DXF_graphics __PROTO((void));
+TERM_PUBLIC void DXF_text __PROTO((void));
+TERM_PUBLIC void DXF_linetype __PROTO((int linetype));
+TERM_PUBLIC void DXF_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void DXF_vector __PROTO((unsigned int ux, unsigned int uy));
+TERM_PUBLIC void DXF_put_text __PROTO((unsigned int x, unsigned int y,
+				       const char str[]));
+TERM_PUBLIC int DXF_text_angle __PROTO((int ang));
+TERM_PUBLIC int DXF_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC void DXF_reset __PROTO((void));
+
+#define DXF_XMAX (120.0 * DXF_UNIT)
+#define DXF_YMAX (80.0 * DXF_UNIT)
+#if 0 /* HBB 20030626: old version */
+#define DXF_HTIC (0.01 * DXF_XMAX)	/* 1.0 percent */
+#define DXF_VTIC (0.01 * DXF_YMAX)	/* 1.0 percent */
+#else
+/* HBB 20030626: make them have the same length in DXF_UNITs ! */
+# define DXF_HTIC (2.0 * DXF_UNIT)
+# define DXF_VTIC (2.0 * DXF_UNIT)
+#endif
+#define DXF_HCHAR (0.014 * DXF_XMAX)	/* 1.4 percent */
+#define DXF_VCHAR (0.026 * DXF_YMAX)	/* 2.6 percent */
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+#define DXF_UNIT 60.0
+#define LINEWIDTH 0.0351	/* default line width is 1 pt */
+
+/* 120 (autocad units) wide by 80 (autocad units) high (default)
+ * use the GNUPLOT 'set size' command to change the defaults */
+/* actual text height */
+#define DXF_TEXTHEIGHT (0.7 * DXF_VCHAR)
+
+/* actual text width, only a guess, we don't know the width of
+ * a character of given height of the AutoCad STANDARD text font,
+ * so change it if you like */
+#define DXF_TEXTWIDTH (0.7 * DXF_HCHAR)
+
+/* number of line types we support. see below  */
+#define DXF_LINE_TYPES 7
+
+/* number of layers used for the drawing. see below */
+#define MAX_LAYER 7
+
+/* line type scaling */
+#define LT_SCALE 1
+
+static unsigned int DXF_posx;
+static unsigned int DXF_posy;
+/* linetype is mapped to a layer. see below. */
+static unsigned int dxf_linetype;
+static enum JUSTIFY dxf_justify = LEFT;
+static float dxf_angle = 0.0;	/* 0 is horizontal, 90.0 is vertical */
+
+/* text style used in the entire drawing */
+static const char *text_style = "STANDARD";
+
+/* text always resides on layer 0 */
+#define TEXT_LAYER 0
+
+/* each linetype resides on its own layer. each layer has its own color.
+ * this avoids difficulties that AutoCad has with proper scaling of
+ * the linetypes.
+ * change the colors according to your needs */
+static const char *layer_name[] ={ "0", "1", "2", "3", "4", "5", "6" };
+
+/* the colours are white, red, yellow, green, cyan, blue, magenta.
+ * change them according to your needs.
+ * when using a black and white plotting device the colours map to different
+ * line thicknesses. see description of AutoCad print / plot command */
+static const char *layer_colour[] = { "7", "1", "2", "3", "4", "5", "6" };
+
+/* support line types AutoCad has to offer by default. */
+static const char *layer_lines[] = {
+    "CONTINUOUS", "DASHED", "HIDDEN", "CENTER", "PHANTOM", "DOT", "DASHDOT"
+};
+
+static TBOOLEAN vector_was_last = FALSE;
+
+TERM_PUBLIC void
+DXF_init()
+{
+    DXF_posx = DXF_posy = 0;
+    dxf_linetype = 0;
+    dxf_angle = 0.0;
+    vector_was_last = FALSE;
+}
+
+TERM_PUBLIC void
+DXF_graphics()
+{
+    register struct termentry *t = term;
+    int i;
+    static char GPFAR dxfi1[] = "\
+999\n\
+%% GNUPLOT: dxf file for AutoCad\n\
+  0\nSECTION\n  2\nHEADER\n\
+  9\n$EXTMIN\n\
+ 10\n0.000\n 20\n0.000\n\
+  9\n$EXTMAX\n\
+ 10\n%-6.3f\n 20\n%-6.3f\n\
+  9\n$LIMMIN\n\
+ 10\n0.000\n 20\n0.000\n\
+  9\n$LIMMAX\n\
+ 10\n%-6.3f\n 20\n%-6.3f\n\
+  9\n$TEXTSTYLE\n  7\n%s\n\
+  9\n$TEXTSIZE\n 40\n%-6.3f\n\
+  9\n$PLINEWID\n 40\n%-6.4f\n\
+  9\n$LTSCALE\n  40\n%-6.3f\n\
+  9\n$COORDS\n 70\n  1\n\
+  9\n$CELTYPE\n 6\nBYLAYER\n\
+  9\n$CLAYER\n  8\n0\n\
+  9\n$CECOLOR\n 62\n   %s\n\
+  9\n$MENU\n  1\nacad\n\
+  0\nENDSEC\n\
+  0\nSECTION\n  2\nTABLES\n";
+    static char GPFAR dxfi2[] = "\
+0\nTABLE\n  2\nLTYPE\n 70\n    %d\n\
+0\nLTYPE\n  2\nCONTINUOUS\n 70\n    64\n\
+  3\nSolid line\n 72\n    65\n 73\n      0\n 40\n0.0\n\
+  0\nLTYPE\n  2\nDASHED\n 70\n    64\n\
+  3\n__ __ __ __ __ __ __ __ __ __ __ __ __ __ __\n\
+ 72\n    65\n 73\n     2\n 40\n0.75\n 49\n0.5\n 49\n-0.25\n\
+  0\nLTYPE\n  2\nHIDDEN\n 70\n    64\n\
+  3\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\
+ 72\n    65\n 73\n     2\n 40\n0.375\n 49\n0.25\n 49\n-0.125\n\
+  0\nLTYPE\n  2\nCENTER\n 70\n    64\n\
+  3\n____ _ ____ _ ____ _ ____ _ ____ _ ____ _ ____\n\
+ 72\n    65\n 73\n     4\n 40\n2.0\n 49\n1.25\n 49\n-0.25\n\
+ 49\n0.25\n 49\n-0.25\n\
+  0\nLTYPE\n  2\nPHANTOM\n 70\n    64\n\
+  3\n_____ _ _ _____ _ _ _____ _ _ _____ _ _ ____\n\
+ 72\n    65\n 73\n     6\n 40\n2.5\n 49\n1.25\n\
+ 49\n-0.25\n 49\n0.25\n 49\n-0.25\n 49\n0.25\n 49\n-0.25\n\
+  0\nLTYPE\n  2\nDOT\n 70\n    64\n\
+  3\n...............................................\n\
+ 72\n    65\n 73\n     2\n 40\n0.25\n 49\n0.0\n 49\n-0.25\n\
+  0\nLTYPE\n  2\nDASHDOT\n 70\n    64\n\
+  3\n__ . __ . __ . __ . __ . __ . __ . __ . __ . __\n\
+ 72\n    65\n 73\n     4\n 40\n1.0\n 49\n0.5\n 49\n-0.25\n\
+ 49\n0.0\n 49\n-0.25\n\
+  0\nENDTAB\n";
+
+    fprintf(gpoutfile, dxfi1,
+	    t->xmax / DXF_UNIT, t->ymax / DXF_UNIT,
+	    t->xmax / DXF_UNIT, t->ymax / DXF_UNIT,
+	    text_style,
+	    DXF_TEXTHEIGHT / DXF_UNIT,
+	    LINEWIDTH,
+	    (double) LT_SCALE,
+	    layer_colour[0]);
+    /* the linetype table */
+    fprintf(gpoutfile, dxfi2, DXF_LINE_TYPES);
+    /* the layer table */
+    fprintf(gpoutfile, "  0\nTABLE\n  2\nLAYER\n 70\n   %-d\n", MAX_LAYER);
+    for (i = 1; i <= MAX_LAYER; i++)
+	fprintf(gpoutfile, "  0\nLAYER\n  2\n%s\n 70\n   64\n62\n   %s\n  6\n%s\n", layer_name[i - 1], layer_colour[i - 1], layer_lines[i - 1]);
+
+    /* no blocks for insertion */
+    /* start the entity section */
+    fputs("  0\nENDTAB\n0\nENDSEC\n\
+  0\nSECTION\n  2\nBLOCKS\n  0\nENDSEC\n\
+  0\nSECTION\n\
+  2\nENTITIES\n",
+	  gpoutfile);
+}
+
+TERM_PUBLIC void
+DXF_text()
+{
+    if (vector_was_last)
+	fputs("  0\nSEQEND\n", gpoutfile);
+    fputs("  0\nENDSEC\n  0\nEOF\n", gpoutfile);
+}
+
+TERM_PUBLIC void
+DXF_linetype(int linetype)
+{
+    linetype = ABS(linetype);
+    linetype = linetype % DXF_LINE_TYPES;
+    dxf_linetype = linetype;
+}
+
+TERM_PUBLIC void
+DXF_move(unsigned int x, unsigned int y)
+{
+    DXF_posx = x;
+    DXF_posy = y;
+    if (vector_was_last)
+	fputs("  0\nSEQEND\n", gpoutfile);
+    vector_was_last = FALSE;
+    fprintf(gpoutfile, "\
+  0\nPOLYLINE\n  8\n%s\n 66\n   1\n\
+  6\n%s\n\
+  0\nVERTEX\n  8\n%s\n\
+  6\n%s\n\
+ 10\n%-6.3f\n 20\n%-6.3f\n 30\n0.000\n",
+	    layer_name[dxf_linetype],
+	    layer_lines[dxf_linetype],
+	    layer_name[dxf_linetype],
+	    layer_lines[dxf_linetype],
+	    DXF_posx / DXF_UNIT, DXF_posy / DXF_UNIT);
+
+}
+
+TERM_PUBLIC void
+DXF_vector(unsigned int ux, unsigned int uy)
+{
+    DXF_posx = ux;
+    DXF_posy = uy;
+    vector_was_last = TRUE;
+
+    fprintf(gpoutfile, "\
+  0\nVERTEX\n  8\n%s\n\
+  6\n%s\n\
+  10\n%-6.3f\n  20\n%-6.3f\n  30\n0.000\n",
+	    layer_name[dxf_linetype],
+	    layer_lines[dxf_linetype],
+	    DXF_posx / DXF_UNIT, DXF_posy / DXF_UNIT);
+}
+
+TERM_PUBLIC void
+DXF_put_text(unsigned int x, unsigned int y, const char str[])
+{
+    int stl;
+    float xleftpos, yleftpos, xrightpos, yrightpos;
+
+    /* shut up gcc warnings  - SB */
+    xleftpos = yleftpos = xrightpos = yrightpos = 1.0;	/* dummy */
+    /* ignore empty strings */
+    if (str[0] == NUL)
+	return;
+
+    stl = 0;
+    while (str[stl] != NUL)
+	++stl;			/* get string length */
+
+    if (vector_was_last)
+	fputs("  0\nSEQEND\n", gpoutfile);
+    vector_was_last = FALSE;
+    fprintf(gpoutfile, "  0\nTEXT\n  8\n%s\n", layer_name[TEXT_LAYER]);
+    if (dxf_angle != 90.0) {
+	switch (dxf_justify) {
+	case LEFT:
+	    xleftpos = (float) x;
+	    yleftpos = (float) (y - DXF_VCHAR / 4.0);
+	    xrightpos = (float) (x + stl * DXF_TEXTWIDTH);
+	    yrightpos = yleftpos;
+	    break;
+	case RIGHT:
+	    xleftpos = (float) (x - stl * DXF_TEXTWIDTH);
+	    yleftpos = (float) (y - DXF_VCHAR / 4.0);
+	    xrightpos = (float) x;
+	    yrightpos = yleftpos;
+	    break;
+	case CENTRE:
+	    xleftpos = (float) (x - stl * DXF_TEXTWIDTH / 2.0);
+	    yleftpos = (float) (y - DXF_VCHAR / 4.0);
+	    xrightpos = (float) x;	/* center point */
+	    yrightpos = yleftpos;
+	    break;
+	}
+    } else {
+	switch (dxf_justify) {
+	case LEFT:
+	    xleftpos = (float) (x + DXF_VCHAR / 4.0);
+	    yleftpos = (float) y;
+	    xrightpos = xleftpos;
+	    yrightpos = (float) (y + stl * DXF_TEXTWIDTH);
+	    break;
+	case RIGHT:
+	    xleftpos = (float) (x + DXF_VCHAR / 4.0);
+	    yleftpos = (float) (y - stl * DXF_HCHAR);
+	    xrightpos = xleftpos;
+	    yrightpos = (float) y;
+	    break;
+	case CENTRE:
+	    xleftpos = (float) (x + DXF_VCHAR / 4.0);
+	    yleftpos = (float) (y - stl * DXF_TEXTWIDTH / 2.0);
+	    xrightpos = xleftpos;
+	    yrightpos = (float) y;	/* center point */
+	    break;
+	}
+    }
+
+    fprintf(gpoutfile, "\
+ 10\n%-6.3f\n 20\n%-6.3f\n 30\n0.000\n\
+ 40\n%-6.3f\n  1\n%s\n 50\n%-6.3f\n\
+  7\n%s\n",
+	    xleftpos / DXF_UNIT, yleftpos / DXF_UNIT,
+	    DXF_TEXTHEIGHT / DXF_UNIT, str, dxf_angle,
+	    text_style);
+
+    if (dxf_justify != LEFT) {
+	fprintf(gpoutfile, " 72\n%d\n\
+ 11\n%-6.3f\n 21\n%-6.3f\n 31\n0.000\n",
+		dxf_justify,
+		xrightpos / DXF_UNIT, yrightpos / DXF_UNIT);
+    }
+}
+
+TERM_PUBLIC int
+DXF_text_angle(int ang)
+{
+    dxf_angle = (ang ? 90.0 : 0.0);
+    return (TRUE);
+}
+
+TERM_PUBLIC int
+DXF_justify_text(enum JUSTIFY mode)
+{
+    dxf_justify = mode;
+    return (TRUE);
+}
+
+TERM_PUBLIC void
+DXF_reset()
+{
+    DXF_posx = DXF_posy = 0;
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+TERM_TABLE_START(dxf_driver)
+  "dxf", "dxf-file for AutoCad (default size 120x80)",
+    DXF_XMAX, DXF_YMAX, DXF_VCHAR, DXF_HCHAR,
+    DXF_VTIC, DXF_HTIC, options_null, DXF_init, DXF_reset,
+    DXF_text, null_scale, DXF_graphics, DXF_move, DXF_vector,
+    DXF_linetype, DXF_put_text, DXF_text_angle,
+    DXF_justify_text, do_point, do_arrow, set_font_null
+TERM_TABLE_END(dxf_driver)
+
+#undef LAST_TERM
+#define LAST_TERM dxf_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(dxf)
+"1 dxf",
+"?commands set terminal dxf",
+"?set terminal dxf",
+"?set term dxf",
+"?terminal dxf",
+"?term dxf",
+"?dxf",
+" The `dxf` terminal driver creates pictures that can be imported into AutoCad",
+" (Release 10.x).  It has no options of its own, but some features of its plots",
+" may be modified by other means.  The default size is 120x80 AutoCad units,",
+" which can be changed by `set size`.  `dxf` uses seven colors (white, red,",
+" yellow, green, cyan, blue and magenta), which can be changed only by",
+" modifying the source file.  If a black-and-white plotting device is used, the",
+" colors are mapped to differing line thicknesses.  See the description of the",
+" AutoCad print/plot command."
+END_HELP(dxf)
+#endif /* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/dxy.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/dxy.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/dxy.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/dxy.trm.svn-base	2012-01-03 17:07:27.753952100 -0800
@@ -0,0 +1,203 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: dxy.trm,v 1.14 2006/07/21 02:35:45 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - dxy.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *  Roland DXY800A plotter
+ *
+ * AUTHORS
+ *  Martin Yii, eln557h@monu3.OZ
+ *  Further modified Jan 1990 by Russell Lang, rjl@monu1.cc.monash.oz
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+
+/*
+ * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(dxy800a)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void DXY_init __PROTO((void));
+TERM_PUBLIC void DXY_graphics __PROTO((void));
+TERM_PUBLIC void DXY_text __PROTO((void));
+TERM_PUBLIC void DXY_linetype __PROTO((int linetype));
+TERM_PUBLIC void DXY_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void DXY_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void DXY_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC int DXY_text_angle __PROTO((int ang));
+TERM_PUBLIC void DXY_reset __PROTO((void));
+
+#define DXY_XMAX 2470
+#define DXY_YMAX 1700
+
+#define DXY_XLAST (DXY_XMAX - 1)
+#define DXY_YLAST (DXY_XMAX - 1)
+
+#define DXY_VCHAR	(56)	/* double actual height of characters */
+#define DXY_HCHAR	(28)	/* actual width including spacing */
+#define DXY_VTIC	(28)
+#define DXY_HTIC	(28)
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+int dxy_angle = 0;
+
+TERM_PUBLIC void
+DXY_init()
+{
+    /* No initialisation sequences for DXY 800A */
+}
+
+
+TERM_PUBLIC void
+DXY_graphics()
+{
+    /* HOME, Character size 3 */
+    fputs("H\nS3\n", gpoutfile);
+}
+
+
+TERM_PUBLIC void
+DXY_text()
+{
+    /* No sequences needed */
+}
+
+
+TERM_PUBLIC void
+DXY_linetype(int linetype)
+{
+    /* select pen */
+    fprintf(gpoutfile, "J%d\n", (linetype + 2) % 8 + 1);
+    switch (linetype) {
+    case LT_AXIS:
+	/* use dotted line for axis */
+	fputs("L1\nB50\n", gpoutfile);
+	break;
+    default:
+	/* use solid line for all others */
+	fputs("L0\n", gpoutfile);
+	break;
+    }
+}
+
+
+TERM_PUBLIC void
+DXY_move(unsigned int x, unsigned int y)
+{
+    fprintf(gpoutfile, "M%d,%d\n", x, y);
+}
+
+
+TERM_PUBLIC void
+DXY_vector(unsigned int x, unsigned int y)
+{
+    fprintf(gpoutfile, "D%d,%d\n", x, y);
+}
+
+
+TERM_PUBLIC void
+DXY_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    if (dxy_angle == 1) {
+	/* vertical */
+	DXY_move(x + DXY_VCHAR / 4, y);
+    } else {
+	/* horiz */
+	DXY_move(x, y - DXY_VCHAR / 4);
+    }
+    fprintf(gpoutfile, "P%s\n", str);
+}
+
+
+TERM_PUBLIC int
+DXY_text_angle(int ang)
+{
+    dxy_angle = (ang ? 1 : 0);
+    fprintf(gpoutfile, "Q%d\n", ang);
+    return TRUE;
+}
+
+
+TERM_PUBLIC void
+DXY_reset()
+{
+    /* Home pen */
+    fputs("H\n", gpoutfile);
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+TERM_TABLE_START(dxy_driver)
+    "dxy800a", "Roland DXY800A plotter",
+    DXY_XMAX, DXY_YMAX, DXY_VCHAR, DXY_HCHAR,
+    DXY_VTIC, DXY_HTIC, options_null, DXY_init, DXY_reset,
+    DXY_text, null_scale, DXY_graphics, DXY_move, DXY_vector,
+    DXY_linetype, DXY_put_text, DXY_text_angle,
+    null_justify_text, do_point, do_arrow, set_font_null
+TERM_TABLE_END(dxy_driver)
+
+#undef LAST_TERM
+#define LAST_TERM dxy_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(dxy800a)
+"1 dxy800a",
+"?commands set terminal dxy800a",
+"?set terminal dxy800a",
+"?set term dxy800a",
+"?terminal dxy800a",
+"?term dxy800a",
+"?dxy800a",
+" This terminal driver supports the Roland DXY800A plotter.  It has no options."
+END_HELP(dxy800a)
+#endif
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/eepic.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/eepic.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/eepic.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/eepic.trm.svn-base	2012-01-03 17:07:27.962492900 -0800
@@ -0,0 +1,640 @@
+/* Hello, Emacs! This is -*-C-*- !*/
+/*
+ * $Id: eepic.trm,v 1.30 2008/02/24 19:49:38 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - eepic.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *   The EEPIC macros for LaTeX.
+ *
+ * AUTHORS
+ *   David Kotz
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+/*
+ *  This file contains the eepic terminal driver, intended for use with the
+ *  eepic.sty macro package for LaTeX. This is an alternative to the
+ *  latex driver. You need eepic.sty, epic.sty, and a printer driver that
+ *  supports the tpic \specials.
+ *
+ * Although dotted and dashed lines are possible with EEPIC, and are
+ * tempting, they do not work well for high-sample-rate curves, mushing
+ * the dashes all together into a solid line. For now anyway, the EEPIC
+ * driver will have only solid lines. Anyone got a solution?
+ *
+ * LATEX must also be defined.
+ */
+/*
+ * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
+ */
+/* Additions by Gabriel Zachmann (Gabriel.Zachmann@gmx.net), Nov 2000:
+ * - little bug fix in stacked (faked rotated) text
+ * - color support
+ * - true rotated text
+ * - augmented line types set with dashed lines
+ * - optionally small or tiny point symbols
+ * - font size
+ */
+
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(eepic)
+#endif
+
+#ifdef TERM_PROTO
+
+#include <ctype.h>
+
+TERM_PUBLIC void EEPIC_init __PROTO((void));
+TERM_PUBLIC void EEPIC_graphics __PROTO((void));
+TERM_PUBLIC void EEPIC_text __PROTO((void));
+TERM_PUBLIC void EEPIC_linetype __PROTO((int linetype));
+TERM_PUBLIC void EEPIC_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void EEPIC_point __PROTO((unsigned int x, unsigned int y,
+				      int number));
+TERM_PUBLIC void EEPIC_vector __PROTO((unsigned int ux, unsigned int uy));
+TERM_PUBLIC void EEPIC_arrow __PROTO((unsigned int sx, unsigned int sy,
+				      unsigned int ex, unsigned int ey,
+				      int head));
+TERM_PUBLIC void EEPIC_put_text __PROTO((unsigned int x, unsigned int y,
+					 const char str[]));
+TERM_PUBLIC int EEPIC_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC int EEPIC_text_angle __PROTO((int ang));
+TERM_PUBLIC void EEPIC_reset __PROTO((void));
+TERM_PUBLIC void EEPIC_options __PROTO((void));
+
+#define EEPIC_PTS_PER_INCH 72.27
+/* resolution of printer we expect to use */
+#define EEPIC_DOTS_PER_INCH 600
+/* dot size in pt */
+#define EEPIC_UNIT (EEPIC_PTS_PER_INCH/EEPIC_DOTS_PER_INCH)
+
+/* 5 inches wide by 3 inches high (default) */
+#define EEPIC_XMAX (EEPIC_PTS_PER_INCH/EEPIC_UNIT*5.0)
+#define EEPIC_YMAX (EEPIC_PTS_PER_INCH/EEPIC_UNIT*3.0)
+
+#define EEPIC_HTIC (5.0/EEPIC_UNIT)
+#define EEPIC_VTIC (5.0/EEPIC_UNIT)
+#define EEPIC_VCHAR (10.0/EEPIC_UNIT)
+#define EEPIC_HCHAR (EEPIC_VCHAR/2.0)
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+static unsigned int EEPIC_posx;
+static unsigned int EEPIC_posy;
+static enum JUSTIFY eepic_justify = LEFT;
+static int eepic_angle = 0;
+static int eepic_color_on = FALSE;		/* use \color */
+static int eepic_true_rotate = FALSE;		/* use \rotatebox */
+static int fontsize_set = FALSE;
+
+/* for DOTS point style */
+#define EEPIC_TINY_DOT "\\rule{.1pt}{.1pt}"
+
+/* POINTS */
+static int eepic_num_point_types[] = { 12, 10, 8 };
+static int eepic_pointsize = 0;
+static const char GPFAR *GPFAR EEPIC_points[][12] =
+{
+	{
+		"\\makebox(0,0){$\\Diamond$}",
+		"\\makebox(0,0){$+$}",
+		"\\makebox(0,0){$\\Box$}",
+		"\\makebox(0,0){$\\times$}",
+		"\\makebox(0,0){$\\triangle$}",
+		"\\makebox(0,0){$\\star$}",
+		"\\circle{12}", "\\circle{18}", "\\circle{24}",
+		"\\circle*{12}", "\\circle*{18}", "\\circle*{24}"
+	},
+	{
+		"\\makebox(0,0){$\\scriptstyle\\Diamond$}",
+		"\\makebox(0,0){$\\scriptstyle +$}",
+		"\\makebox(0,0){$\\scriptstyle\\Box$}",
+		"\\makebox(0,0){$\\scriptstyle\\times$}",
+		"\\makebox(0,0){$\\scriptstyle\\triangle$}",
+		"\\makebox(0,0){$\\scriptstyle\\star$}",
+		"\\circle{12}", "\\circle{18}",
+		"\\circle*{12}", "\\circle*{18}",
+	},
+	{
+		"\\makebox(0,0){$\\scriptscriptstyle\\Diamond$}",
+		"\\makebox(0,0){$\\scriptscriptstyle +$}",
+		"\\makebox(0,0){$\\scriptscriptstyle\\Box$}",
+		"\\makebox(0,0){$\\scriptscriptstyle\\times$}",
+		"\\makebox(0,0){$\\scriptscriptstyle\\triangle$}",
+		"\\makebox(0,0){$\\scriptscriptstyle\\star$}",
+		"\\circle{12}",
+		"\\circle*{12}",
+	}
+};
+
+/* LINES */
+static int eepic_numlines[] = { 5, 7, 8 };	/* number of linetypes below */
+#define EEPIC_MAX_NUMLINES 8				/* max of eepic_numlines[] */
+static int eepic_lineset = 0;
+static char GPFAR *GPFAR EEPIC_lines[][EEPIC_MAX_NUMLINES] =
+{
+	{
+		"\\thicklines \\path",	/* -2 border */
+		"\\thinlines \\drawline[-50]",	/* -1 axes */
+		"\\thinlines \\path",	/*  0 solid thin  */
+		"\\thicklines \\path",	/*  1 solid thick */
+		"\\Thicklines \\path"	/*  2 solid Thick */
+	},
+	{
+		"\\thicklines \\path",	/* -2 border */
+		"\\thinlines \\drawline[-50]",	/* -1 axes */
+		"\\thinlines \\path",	/*  0 solid thin  */
+		"\\thinlines \\dashline[90]{10}",
+		"\\thinlines \\dottedline{10}",
+		"\\thinlines \\dashline[60]{20}",
+		"\\thinlines \\dottedline{20}"
+	},
+	{
+		"\\thicklines \\path",	/* -2 border */
+		"\\thinlines \\drawline[-50]",	/* -1 axes */
+		"\\thinlines \\path",
+		"\\thinlines \\path",
+		"\\thinlines \\path",
+		"\\thinlines \\path",
+		"\\thinlines \\path",
+		"\\thinlines \\path"
+	}
+};
+static int EEPIC_type;		/* current line type */
+static TBOOLEAN EEPIC_inline = FALSE;	/* are we in the middle of a line */
+static void EEPIC_endline __PROTO((void)); /* terminate any line in progress */
+static int EEPIC_linecount = 0;	/* number of points in line so far */
+#define EEPIC_LINEMAX 50	/* max value for linecount */
+
+#define EEPIC_NUM_COLORS 7
+static int eepic_color = 0;
+static char GPFAR *GPFAR eepic_colors[EEPIC_NUM_COLORS] =
+{
+	"\\color{black}\n",	/* border and axes (must be black!) */
+	"\\color{red}\n",
+	"\\color{blue}\n",
+	"\\color{green}\n",
+	"\\color{magenta}\n",
+	"\\color{cyan}\n",
+	"\\color{yellow}\n"
+};
+
+/* ARROWS */
+/* we use the same code as for LATEX */
+/* figure out the best arrow */
+static void best_latex_arrow __PROTO((int sx, int sy, int ex, int ey, int who, int head));
+
+TERM_PUBLIC void
+EEPIC_init()
+{
+    EEPIC_posx = EEPIC_posy = 0;
+	EEPIC_type = 0;
+	EEPIC_linecount = 0;
+	EEPIC_inline = FALSE;
+	eepic_color = 0;
+    fprintf(gpoutfile, "\
+%% GNUPLOT: LaTeX picture using EEPIC macros\n\
+\\setlength{\\unitlength}{%fpt}\n",
+	    EEPIC_UNIT);
+}
+
+
+TERM_PUBLIC void
+EEPIC_graphics()
+{
+    register struct termentry *t = term;
+
+    /* HBB 20001027: respect 'size' and 'offset' settings to modify
+     * picture box size and position */
+    fprintf(gpoutfile, "\\begin{picture}(%d,%d)(%d,%d)\n",
+	    (int) (t->xmax * xsize),
+	    (int) (t->ymax * ysize),
+	    (int) (t->xmax * xoffset),
+	    (int) (t->ymax * xoffset));
+    if (fontsize_set) {
+	float x = t->v_char * EEPIC_UNIT + 0.5;
+
+	fprintf(gpoutfile, "\\fontsize{%d}{%g}\\selectfont\n",
+		(int) x,  1.2 * x );
+    } else
+	fprintf(gpoutfile,"\\footnotesize\n" );
+
+}
+
+
+TERM_PUBLIC void
+EEPIC_text()
+{
+    EEPIC_endline();
+    fputs("\\end{picture}\n", gpoutfile);
+}
+
+
+TERM_PUBLIC void
+EEPIC_linetype(int linetype)
+{
+    EEPIC_endline();
+
+    EEPIC_type = linetype % (eepic_numlines[eepic_lineset] - 2);
+
+	if ( eepic_color_on )
+	{
+		eepic_color = linetype;
+		if ( eepic_color < 0 )
+			eepic_color = 0;
+		else
+		{
+			eepic_color %= EEPIC_NUM_COLORS - 1;
+			eepic_color += 1;
+		}
+		fputs( eepic_colors[eepic_color], gpoutfile );
+	}
+}
+
+
+
+TERM_PUBLIC void
+EEPIC_move(unsigned int x, unsigned int y)
+{
+    EEPIC_endline();
+
+    EEPIC_posx = x;
+    EEPIC_posy = y;
+}
+
+
+TERM_PUBLIC void
+EEPIC_point(unsigned int x, unsigned int y, int number)
+{
+    EEPIC_move(x, y);
+
+    /* Print the character defined by 'number'; number < 0 means
+       to use a dot, otherwise one of the defined points. */
+    fprintf(gpoutfile, "\\put(%d,%d){%s}\n", x, y,
+	    (number < 0 ? EEPIC_TINY_DOT
+	     : EEPIC_points[eepic_pointsize][number % eepic_num_point_types[eepic_pointsize]]));
+}
+
+
+TERM_PUBLIC void
+EEPIC_vector(unsigned int ux, unsigned int uy)
+{
+    if (!EEPIC_inline) {
+	EEPIC_inline = TRUE;
+
+	/* Start a new line. This depends on line type */
+	fprintf(gpoutfile, "%s(%u,%u)",
+		EEPIC_lines[eepic_lineset][EEPIC_type + 2],
+		EEPIC_posx, EEPIC_posy);
+	EEPIC_linecount = 1;
+    } else {
+	/* Even though we are in middle of a path,
+	 * we may want to start a new path command.
+	 * If they are too long then latex will choke.
+	 */
+	if (EEPIC_linecount++ >= EEPIC_LINEMAX) {
+	    fprintf(gpoutfile, "\n%s(%u,%u)",
+		    EEPIC_lines[eepic_lineset][EEPIC_type + 2],
+		    EEPIC_posx, EEPIC_posy);
+	    EEPIC_linecount = 1;
+	}
+    }
+    fprintf(gpoutfile, "(%u,%u)", ux, uy);
+    EEPIC_posx = ux;
+    EEPIC_posy = uy;
+}
+
+static void
+EEPIC_endline()
+{
+    if (EEPIC_inline) {
+	putc('\n', gpoutfile);
+	EEPIC_inline = FALSE;
+    }
+}
+
+
+TERM_PUBLIC void
+EEPIC_arrow(
+    unsigned int sx, unsigned int sy,
+    unsigned int ex, unsigned int ey,
+    int head)
+{
+    best_latex_arrow(sx, sy, ex, ey, 2, head);	/* call latex routine */
+
+    EEPIC_posx = ex;
+    EEPIC_posy = ey;
+}
+
+
+TERM_PUBLIC void
+EEPIC_put_text(unsigned int x, unsigned int y, const char str[])
+{
+    int i, l;
+
+    EEPIC_endline();
+
+    fprintf(gpoutfile, "\\put(%d,%d)", x, y);
+    if ((str[0] == '{') || (str[0] == '[')) {
+	fprintf(gpoutfile, "{\\makebox(0,0)%s}\n", str);
+    }
+    else
+    switch (eepic_angle)
+    {
+	case 0:
+	{
+	   switch (eepic_justify) {
+	       case LEFT:
+		   fputs("{\\makebox(0,0)[l]{",gpoutfile);
+		   break;
+	       case CENTRE:
+		   fputs("{\\makebox(0,0){",gpoutfile);
+		   break;
+	       case RIGHT:
+		   fputs("{\\makebox(0,0)[r]{",gpoutfile);
+		   break;
+	   }
+	   fprintf(gpoutfile,"%s}}\n", str);
+	   break;
+	}
+	case 1:
+	{
+	   if ( eepic_true_rotate )
+	   {
+	       /* use \rotatebox */
+	       switch (eepic_justify) {
+		   case LEFT:
+		       fputs("{\\makebox(0,0)[lb]{\\rotatebox[origin=c]{90}{",
+			     gpoutfile);
+		       break;
+		   case CENTRE:
+		       fputs("{\\makebox(0,0)[l]{\\rotatebox[origin=c]{90}{",
+			     gpoutfile);
+		       break;
+		   case RIGHT:
+		       fputs("{\\makebox(0,0)[lt]{\\rotatebox[origin=c]{90}{",
+			     gpoutfile);
+		       break;
+	       }
+	       fprintf(gpoutfile,"%s}}}\n", str);
+	   }
+	   else
+	   {
+	       /* put text in a short stack */
+	       switch (eepic_justify) {
+		   case LEFT:
+		       fputs("{\\makebox(0,0)[lb]{\\shortstack{",gpoutfile);
+		       break;
+		   case CENTRE:
+		       fputs("{\\makebox(0,0)[l]{\\shortstack{",gpoutfile);
+		       break;
+		   case RIGHT:
+		       fputs("{\\makebox(0,0)[lt]{\\shortstack{",gpoutfile);
+		       break;
+	       }
+	       l = strlen(str)-1;
+	       for ( i = 0; i < l; i ++ )
+		   fprintf(gpoutfile, "%c\\\\", str[i] );
+	       fputc(str[l],gpoutfile);
+	       fputs("}}}\n",gpoutfile);
+	   }
+	   break;
+       }
+    }
+}
+
+
+
+TERM_PUBLIC int
+EEPIC_justify_text(enum JUSTIFY mode)
+{
+    eepic_justify = mode;
+    return (TRUE);
+}
+
+TERM_PUBLIC int
+EEPIC_text_angle(int ang)
+{
+    eepic_angle = (ang ? 1 : 0);
+    return (TRUE);
+}
+
+TERM_PUBLIC void
+EEPIC_reset()
+{
+    EEPIC_endline();
+    EEPIC_posx = EEPIC_posy = 0;
+}
+
+TERM_PUBLIC void
+EEPIC_options()
+{
+    float fontsize = 0;
+
+    eepic_color_on =
+    eepic_true_rotate = FALSE;
+    eepic_lineset = 0;
+    eepic_pointsize = 0;
+
+    while (!END_OF_COMMAND) {
+	if (almost_equals(c_token, "de$fault")) {
+	    fontsize_set = FALSE;
+	    eepic_color_on = FALSE;
+	    eepic_true_rotate = FALSE;
+	    eepic_lineset = 0;
+	    eepic_pointsize = 0;
+	    c_token++;
+	} else if (almost_equals(c_token, "c$olor") ||
+		   almost_equals(c_token, "c$olour")) {
+	    eepic_color_on = TRUE;
+	    eepic_lineset = 2;
+	    c_token++;
+	} else if (almost_equals(c_token, "r$otate")) {
+	    eepic_true_rotate = TRUE;
+	    c_token++;
+	} else if (almost_equals(c_token, "da$shed")) {
+	    if (! eepic_color_on)
+		eepic_lineset = 1;	/* ignore when color is on */
+	    c_token++;
+	} else if (almost_equals(c_token, "s$mall")) {
+	    eepic_pointsize = 1;
+	    c_token++;
+	} else if (almost_equals(c_token, "t$iny")) {
+	    eepic_pointsize = 2;
+	    c_token++;
+	} else if (isdigit((unsigned char)
+			   gp_input_line[token[c_token].start_index])) {
+	    struct value a;
+	    fontsize = real(const_express(&a));
+
+	    if (fontsize < 1 || fontsize > 100)
+		int_error(c_token, "font size out of bounds [1..100]");
+	    else {
+		fontsize_set = TRUE;
+		term->v_char = (unsigned int)(fontsize/EEPIC_UNIT);
+		term->h_char = (unsigned int)((fontsize/EEPIC_UNIT)/2);
+	    }
+	} else
+	    int_error(c_token, "unrecognized option");
+    } /* while(command) */
+
+    sprintf(term_options, "default%s%s%s%s",
+	    eepic_color_on ? " color" : "",
+	    eepic_lineset == 1 ? " dashed" : "",
+	    eepic_true_rotate ? " rotate" : "",
+	    eepic_pointsize == 1 ? " small"
+	    : eepic_pointsize == 2 ? " tiny" : "" );
+    if (fontsize_set)
+	sprintf( term_options+strlen(term_options), " %d", (int) fontsize );
+}
+
+#endif
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(eepic_driver)
+    "eepic", "EEPIC -- extended LaTeX picture environment",
+    EEPIC_XMAX, EEPIC_YMAX, EEPIC_VCHAR, EEPIC_HCHAR,
+    EEPIC_VTIC, EEPIC_HTIC, EEPIC_options, EEPIC_init, EEPIC_reset,
+    EEPIC_text, null_scale, EEPIC_graphics, EEPIC_move, EEPIC_vector,
+    EEPIC_linetype, EEPIC_put_text, EEPIC_text_angle,
+    EEPIC_justify_text, EEPIC_point, EEPIC_arrow, set_font_null,
+    0, /* pointsize */
+    0, /* flags */
+    0, 0, /* suspend, resume */
+    0, /* fillbox */
+    0  /* linewidth */
+TERM_TABLE_END(eepic_driver)
+
+#undef LAST_TERM
+#define LAST_TERM eepic_driver
+
+#endif
+#endif
+
+#ifdef TERM_HELP
+START_HELP(eepic)
+"1 eepic",
+"?commands set terminal eepic",
+"?set terminal eepic",
+"?set term eepic",
+"?terminal eepic",
+"?term eepic",
+"?eepic",
+" The `eepic` terminal driver supports the extended LaTeX picture environment.",
+" It is an alternative to the `latex` driver.",
+"",
+" The output of this terminal is intended for use with the \"eepic.sty\" macro",
+" package for LaTeX.  To use it, you need \"eepic.sty\", \"epic.sty\" and a",
+" printer driver that supports the \"tpic\" \\specials.  If your printer driver",
+" doesn't support those \\specials, \"eepicemu.sty\" will enable you to use some",
+" of them.",
+" dvips and dvipdfm do support the \"tpic\" \\specials.",
+"",
+" Syntax:",
+"    set terminal eepic {color, dashed, rotate, small, tiny, default, <fontsize>}",
+"",
+" Options:",
+" You can give options in any order you wish.",
+" 'color' causes gnuplot to produce \\color{...} commands so that the graphs are",
+" colored. Using this option, you must include \\usepackage{color} in the preambel",
+" of your latex document.",
+" 'dashed' will allow dashed line types; without this option, only solid lines",
+" with varying thickness will be used.",
+" 'dashed' and 'color' are mutually exclusive; if 'color' is specified, then 'dashed'",
+" will be ignored.",
+" 'rotate' will enable true rotated text (by 90 degrees). Otherwise, rotated text",
+" will be typeset with letters stacked above each other. If you use this option",
+" you must include \\usepackage{graphicx} in the preamble.",
+" 'small' will use \\scriptsize symbols as point markers (Probably does not work",
+" with TeX, only LaTeX2e). Default is to use the default math size.",
+" 'tiny' uses \\scriptscriptstyle symbols.",
+" 'default' resets all options to their defaults = no color, no dashed lines,",
+" pseudo-rotated (stacked) text, large point symbols.",
+" <fontsize> is a number which specifies the font size inside the picture",
+" environment; the unit is pt (points), i.e., 10 pt equals approx. 3.5 mm.",
+" If fontsize is not specified, then all text inside the picture will be set",
+" in \\footnotesize.",
+"",
+" Notes:",
+" Remember to escape the # character (or other chars meaningful to (La-)TeX)",
+" by \\\\ (2 backslashes).",
+" It seems that dashed lines become solid lines when the vertices of a plot",
+" are too close. (I do not know if that is a general problem with the tpic specials,",
+" or if it is caused by a bug in eepic.sty or dvips/dvipdfm.)",
+" The default size of an eepic plot is 5x3 inches, which can be scaled ",
+" by 'set size a,b'.",
+" Points, among other things, are drawn using the LaTeX commands \"\\Diamond\",",
+" \"\\Box\", etc.  These commands no longer belong to the LaTeX2e core; they are",
+" included in the latexsym package, which is part of the base distribution and",
+" thus part of any LaTeX implementation. Please do not forget to use this package.",
+" Instead of latexsym, you can also include the amssymb package.",
+" All drivers for LaTeX offer a special way of controlling text positioning:",
+" If any text string begins with '{', you also need to include a '}' at the",
+" end of the text, and the whole text will be centered both horizontally and",
+" vertically.  If the text string begins with '[', you need to follow this with",
+" a position specification (up to two out of t,b,l,r), ']{', the text itself,",
+" and finally '}'.  The text itself may be anything LaTeX can typeset as an",
+" LR-box.  '\\rule{}{}'s may help for best positioning.",
+"",
+" Examples:",
+" set term eepic",
+"   output graphs as eepic macros inside a picture environment;",
+"   \\input the resulting file in your LaTeX document.",
+" set term eepic color tiny rotate 8",
+"   eepic macros with \\color macros, \\scripscriptsize point markers,",
+"   true rotated text, and all text set with 8pt.",
+"",
+" About label positioning:",
+" Use gnuplot defaults (mostly sensible, but sometimes not really best):",
+"        set title '\\LaTeX\\ -- $ \\gamma $'",
+" Force centering both horizontally and vertically:",
+"        set label '{\\LaTeX\\ -- $ \\gamma $}' at 0,0",
+" Specify own positioning (top here):",
+"        set xlabel '[t]{\\LaTeX\\ -- $ \\gamma $}'",
+" The other label -- account for long ticlabels:",
+"        set ylabel '[r]{\\LaTeX\\ -- $ \\gamma $\\rule{7mm}{0pt}}'"
+END_HELP(eepic)
+#endif /* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/emf.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/emf.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/emf.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/emf.trm.svn-base	2012-01-03 17:07:28.181059700 -0800
@@ -0,0 +1,1709 @@
+/* Hey Emacs this is -*- C -*-
+ * $Id: emf.trm,v 1.59.2.5 2010/02/28 04:33:36 sfeam Exp $
+ */
+
+/* GNUPLOT - emf.trm */
+
+/*[
+ * Copyright 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c and ../docs/termdoc.c.
+ *
+ * This terminal driver supports:
+ *   Enhanced Metafile Format
+ *
+ * TODO
+ *
+ * HISTORY
+ *
+ * 4.3.1 12-Sep-2008 Ethan A Merritt
+ * - enhanced text mode
+ * - Two variants are here. One uses the TA_UPDATECP mode to track character position.
+ *   This works great horizontally, but I could not find a way to introduce a vertical
+ *   offset to handle subscripts and superscripts.
+ * - The second variant tracks both x and y by estimating the character width/height.
+ *   This causes visible imperfections in the character spacing.
+ * - Rotated enhanced text not yet supported
+ *
+ * 1.0.11 06-Dec-2004 Ethan A Merritt
+ * - implement term->set_color(), term->filled_polygon(), and term->fillbox()
+ *   RGB colors supported, but not yet PM3D palettes
+ * 1.0.10 08-Jul-2004 Hans-Bernhard Broeker
+ * - cleaned up to match gnuplot CodeStyle conventions (one line per statement,
+ *   even in macro bodies, no meddling with assert()).
+ * - purged K&R definitions
+ * 1.0.9 03-Jun-2004 Stephane Barbaray <stephane.barbaray@compodata.com>, Ethan Merritt <merritt@u.washington.edu>
+ * - fixed linewidth bug
+ * - all is now really assumed as 1024x768@96dpi,
+ *   before it was a mix between 1600x1200@120dpi and 1024x768@96dpi,
+ *   so font may now render differently than before...
+ * - pointsize rework (size twice also now)
+ * - HCHAR and VCHAR are more efficiently computed
+ * 1.0.8 06-May-2004 Stephane Barbaray <stephane.barbaray@compodata.com> 
+ * - fixed to work with MS security patch (kb835732) applied, because MS introduced bugs!!!
+ * - EMR_EXTTEXTOUTW (84) is now EMR_EXTTEXTOUTA (83)
+ * 1.0.7 3-Feb-2003 Ethan A Merritt 
+ * - modify text and point color handling to match other terminal types
+ * - FIXME! alignment of rotated text is not correct.
+ * 1.0.6 25-Jul-2002 Ethan A Merritt <merritt@u.washington.edu> 
+ * - generalized text rotation and justification
+ * 1.0.5 2000/07/20
+ * - Handles were not freed at all, resulting to resource leaks when viewing on Windows 9x (not on NT4/W2000!!!)
+ * 1.0.4 2000/06/28
+ * - Emulated dashed vectors are now looking better
+ * - 15 colors * 8 pointstyles = 120 pointtypes
+ * 1.0.3 2000/03/29
+ * - default font is now Arial 12
+ * - implemented options (color/mono,dashed/solid,font)
+ * - 15 colors * 5 dashtypes = 75 linetypes
+ * 1.0.2 2000/03/22
+ * - Polygon and Polyline structures are not working for Windows 9X, I
+ *   really don't know why, replaced with lineto/moveto couples...
+ * - Texts are now displayed in GM_Compatible mode because GM_Advanced is
+ *   displaying correctly but it does not print correctly with Word97!
+ * - Text centering now works best according to escapement/orientation
+ * - Now there is 8 colors * 5 dashtypes = 40 linetypes
+ * - Successfully Working on Linux Suse 6.1 (x86)
+ *
+ * 1.0.1 2000/03/16
+ * - Unicode text have be to long aligned in EMF files (exttextoutw)
+ * - Problems with text transparence (SetBkMode was not called)
+ * - Null brush created for *not* filling polygon
+ *
+ * 1.0.0 2000/03/15
+ * - Only tested on x86 Win32
+ *
+ * AUTHOR
+ *   Stephane Barbaray <stephane.barbaray@compodata.com>
+ *   Some code based on cgm.trm
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(emf)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void EMF_options __PROTO((void));
+TERM_PUBLIC void EMF_init __PROTO((void));
+TERM_PUBLIC void EMF_reset __PROTO((void));
+TERM_PUBLIC void EMF_text __PROTO((void));
+TERM_PUBLIC void EMF_graphics __PROTO((void));
+TERM_PUBLIC void EMF_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void EMF_dashed_vector __PROTO((unsigned int ux, unsigned int uy));
+TERM_PUBLIC void EMF_solid_vector __PROTO((unsigned int ux, unsigned int uy));
+TERM_PUBLIC void EMF_linetype __PROTO((int linetype));
+TERM_PUBLIC void EMF_linecolor __PROTO((int color));
+TERM_PUBLIC void EMF_dashtype __PROTO((int dashtype));
+TERM_PUBLIC void EMF_linewidth __PROTO((double width));
+TERM_PUBLIC void EMF_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC int EMF_text_angle __PROTO((int ang));
+TERM_PUBLIC int EMF_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC void EMF_point __PROTO((unsigned int x, unsigned int y, int number));
+TERM_PUBLIC void EMF_set_pointsize __PROTO((double size));
+TERM_PUBLIC int EMF_set_font __PROTO((const char *));
+TERM_PUBLIC int EMF_make_palette __PROTO((t_sm_palette *palette));
+TERM_PUBLIC void EMF_previous_palette __PROTO((void));
+TERM_PUBLIC void EMF_set_color __PROTO((t_colorspec *colorspec));
+TERM_PUBLIC void EMF_filled_polygon __PROTO((int, gpiPoint *));
+TERM_PUBLIC void EMF_fillbox __PROTO((int, unsigned int, unsigned int, unsigned int, unsigned int));
+
+/* Enhanced text support */
+TERM_PUBLIC void ENHemf_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC void ENHemf_OPEN __PROTO((char * fontname, double fontsize,
+                        double base, TBOOLEAN widthflag, TBOOLEAN showflag,
+			int overprint));
+TERM_PUBLIC void ENHemf_FLUSH __PROTO((void));
+
+#undef RGB
+#define RGB(r,g,b) ((long)					\
+		    (((unsigned char)(r)			\
+		      | ((short) ((unsigned char) (g)) << 8))	\
+		     | (((long) (unsigned char) (b)) << 16)))
+
+#ifndef GPMIN
+# define GPMIN(a,b) (a < b ? a : b)
+#endif
+
+#ifndef GPMAX
+# define GPMAX(a,b) (a > b ? a : b)
+#endif
+
+#define EMF_PX2HM 26.37
+#define EMF_PT2HM 35.28
+#define EMF_10THDEG2RAD (3.14159265359/1800)
+#define EMF_XMAX (1024 * EMF_PX2HM)
+#define EMF_YMAX (768 * EMF_PX2HM)
+#define EMF_HTIC (EMF_XMAX / 160)
+#define EMF_VTIC EMF_HTIC
+#define EMF_FONTNAME "Arial"
+#define EMF_FONTSIZE 12
+#define EMF_HCHAR ((EMF_FONTSIZE * EMF_PT2HM) * 0.6)
+#define EMF_VCHAR ((EMF_FONTSIZE * EMF_PT2HM) * 1.3)
+#define EMF_LINE_TYPES 5	/* number of line types we support */
+#define EMF_COLORS 15		/* number of colors we support */
+#define EMF_POINTS 13		/* number of markers we support */
+#define EMF_MAX_SEGMENTS 104	/* maximum # polyline coordinates */
+
+#define EMF_HANDLE_PEN		1
+#define EMF_HANDLE_FONT		2
+#define EMF_HANDLE_BRUSH	3
+#define EMF_HANDLE_MAX		4
+
+#define EMF_STOCK_OBJECT_FLAG	((unsigned long)0x1 << 31)
+#define EMF_STOCK_OBJECT_WHITE_BRUSH 	(EMF_STOCK_OBJECT_FLAG + 0x00)
+#define EMF_STOCK_OBJECT_BLACK_PEN   	(EMF_STOCK_OBJECT_FLAG + 0x07)
+#define EMF_STOCK_OBJECT_DEFAULT_FONT	(EMF_STOCK_OBJECT_FLAG + 0x0A)
+
+#define EMF_write_emr(type, size) {		\
+    EMF_write_long(type);			\
+    EMF_write_long(size);			\
+    emf_record_count++;				\
+}
+#define EMF_write_sizel(width, height) {	\
+    EMF_write_long(width);			\
+    EMF_write_long(height);			\
+}
+#define EMF_write_points(x, y) {		\
+    EMF_write_short(x);				\
+    EMF_write_short(y);				\
+}
+#define EMF_write_pointl(x, y) {		\
+    EMF_write_long(x);				\
+    EMF_write_long(y);				\
+}
+#define EMF_write_rectl(left, top, right, bottom) {	\
+    EMF_write_long(left);				\
+    EMF_write_long(top);				\
+    EMF_write_long(right);				\
+    EMF_write_long(bottom);				\
+}
+
+#define EMF_EOF() {				\
+    EMF_write_emr(14, 20);			\
+    EMF_write_long(0);				\
+    EMF_write_long(0x10);			\
+    EMF_write_long(20);				\
+}
+#define EMF_SetMapMode(mode) {			\
+    EMF_write_emr(17, 0x0C);			\
+    EMF_write_long(mode);			\
+}
+#define EMF_SetWindowExtEx(width, height) {	\
+    EMF_write_emr(9, 0x10);			\
+    EMF_write_sizel(width, height);		\
+}
+#define EMF_SetWindowOrgEx(width, height) {	\
+    EMF_write_emr(10, 0x10);			\
+    EMF_write_sizel(width, height);		\
+}
+#define EMF_SetViewportExtEx(width, height) {	\
+    EMF_write_emr(11, 0x10);			\
+    EMF_write_sizel(width, height);		\
+}
+#define EMF_SetViewportOrgEx(width, height) {	\
+    EMF_write_emr(12, 0x10);			\
+    EMF_write_sizel(width, height);		\
+}
+#define EMF_SetTextColor(color) {		\
+    EMF_write_emr(24, 0x0C);			\
+    EMF_write_long(color);			\
+}
+#define EMF_MoveToEx(x,y) {			\
+    EMF_write_emr(27, 0x10);			\
+    EMF_write_pointl(x, y);			\
+}
+#define EMF_LineTo(x,y) {			\
+    EMF_write_emr(54, 0x10);			\
+    EMF_write_pointl(x, y);			\
+}
+#define EMF_CreatePen(handle, type, width, color) {	\
+    EMF_write_emr(38, 0x1C);				\
+    EMF_write_long(handle);				\
+    EMF_write_long(type);				\
+    EMF_write_long(width);				\
+    EMF_write_long(0);					\
+    EMF_write_long(color);				\
+}
+#define EMF_CreateBrush(handle, type, color, hatch) {	\
+    EMF_write_emr(39, 0x18);				\
+    EMF_write_long(handle);				\
+    EMF_write_long(type);				\
+    EMF_write_long(color);				\
+    EMF_write_long(hatch);				\
+}
+#define EMF_SelectObject(handle) {		\
+    EMF_write_emr(37, 0x0C);			\
+    EMF_write_long(handle);			\
+}
+#define EMF_DeleteObject(handle) {		\
+    EMF_write_emr(40, 0x0C);			\
+    EMF_write_long(handle);			\
+}
+#define EMF_SetTextAlign(align) {		\
+    EMF_write_emr(22, 0x0C);			\
+    EMF_write_long(align);			\
+}
+#define EMF_SetBkMode(mode) {			\
+    EMF_write_emr(18, 0x0C);			\
+    EMF_write_long(mode);			\
+}
+#define EMF_SaveDC() {				\
+    EMF_write_emr(33, 0x0C);			\
+    EMF_write_long(0);				\
+}
+#define EMF_RestoreDC() {			\
+    EMF_write_emr(34, 0x0C);			\
+    EMF_write_long(1);				\
+}
+#define EMF_CreatePolygon(nvert) {		\
+    EMF_write_emr(3, (7+2*nvert)*4);		\
+    EMF_write_rectl(0,0,0,0);  /* Bounds */	\
+    EMF_write_long(nvert);			\
+} 
+
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+#include <ctype.h>		/* for isspace() */
+
+static unsigned int emf_posx;
+static unsigned int emf_posy;
+static unsigned int emf_record_count = 0;
+static unsigned int emf_linetype = 1;
+static unsigned int emf_dashtype = 0;
+static unsigned long emf_color = 0L;
+static unsigned long emf_textcolor = LT_UNDEFINED;
+static unsigned int emf_colors = EMF_COLORS;
+static unsigned int emf_polyline[EMF_MAX_SEGMENTS];	/* stored polyline coordinates */
+static unsigned int emf_graphics = FALSE;
+static unsigned int emf_dashed = TRUE;
+static unsigned int emf_monochrome = FALSE;
+static double emf_linewidth;	/* line width in plot units */
+static double emf_linewidth_factor = 1.0;
+static double emf_dashlength = 1.0;
+static int emf_coords = 0;	/* # polyline coordinates saved */
+static char emf_fontname[255] = EMF_FONTNAME;
+static float emf_fontsize = EMF_FONTSIZE;
+static enum JUSTIFY emf_justify = LEFT;
+static char emf_defaultfontname[255] = EMF_FONTNAME;
+static float emf_defaultfontsize = EMF_FONTSIZE;
+static int emf_vert_text = 0;	/* text orientation -- nonzero for vertical */
+static int emf_step_sizes[8];	/* array of currently used dash lengths in plot units */
+static int emf_step_index = 0;	/* index into emf_step_sizes[] */
+static int emf_step = 0;	/* amount of current dash not yet drawn, in plot units */
+static int emf_tic, emf_tic707, emf_tic866, emf_tic500, emf_tic1241, emf_tic1077, emf_tic621;	/* marker dimensions */
+
+static TBOOLEAN emf_tweak = TRUE;	/* Empirical hack to adjust character widths */
+
+static void EMF_flush_polyline __PROTO((void));
+static void EMF_flush_polygon __PROTO((void));
+static void EMF_write_byte __PROTO((int)); 
+static void EMF_write_short __PROTO((int)); 
+static void EMF_write_long __PROTO((unsigned long));
+static void EMF_write_float __PROTO((double)); 
+static void EMF_setfont __PROTO((void));
+
+#define ANSI_CHARSET         0
+#define DEFAULT_CHARSET      1
+#define GREEK_CHARSET      161
+#define TURKISH_CHARSET    162
+#define BALTIC_CHARSET     186
+#define RUSSIAN_CHARSET    204
+#define EASTEUROPE_CHARSET 238
+#define KOI8_CHARSET       242
+
+/* Text alignment */
+#define GP_TA_NOUPDATECP       0x00
+#define GP_TA_UPDATECP         0x01
+#define GP_TA_LEFT             0x00
+#define GP_TA_RIGHT            0x02
+#define GP_TA_CENTER           0x06
+#define GP_TA_TOP              0x00
+#define GP_TA_BOTTOM           0x08
+#define GP_TA_BASELINE         0x18
+
+/* ExtTextOut options */
+#define ETO_NO_RECT	   0x100
+#define ETO_PDY		  0x2000
+
+static void 
+EMF_setfont()
+{
+    int i, count;
+    int bold = 400;
+    char italic = 0, underline = 0, strikeout = 0;
+    char font[32];
+    char *sub;
+
+    if (!emf_graphics)
+	return;
+
+    count = GPMIN (strlen(emf_fontname), 31);
+    if (((sub = strstr(emf_fontname, " bold")) != NULL)
+	|| ((sub = strstr(emf_fontname, " Bold")) != NULL)) {
+	bold = 700;
+	count = GPMIN(sub - emf_fontname, count);
+    }
+    if (((sub = strstr(emf_fontname, " italic")) != NULL)
+	|| ((sub = strstr(emf_fontname, " Italic")) != NULL)) {
+	italic = 1;
+	count = GPMIN(sub - emf_fontname, count);
+    }
+    if (((sub = strstr(emf_fontname, " underline")) != NULL)
+	|| ((sub = strstr(emf_fontname, " Underline")) != NULL)) {
+	underline = 1;
+	count = GPMIN(sub - emf_fontname, count);
+    }
+    if (((sub = strstr(emf_fontname, " strikeout")) != NULL)
+	|| ((sub = strstr(emf_fontname, " Strikeout")) != NULL)
+	|| ((sub = strstr(emf_fontname, " StrikeOut")) != NULL)
+	) {
+	strikeout = 1;
+	count = GPMIN(sub - emf_fontname, count);
+    }
+
+    safe_strncpy(font, emf_fontname, count + 1);
+
+    EMF_SelectObject(EMF_STOCK_OBJECT_DEFAULT_FONT);
+    EMF_DeleteObject(EMF_HANDLE_FONT);
+
+    /* SB 20040506: was not complete size was 104, now it is 332 */
+    EMF_write_emr(82, 332); 
+    EMF_write_long(EMF_HANDLE_FONT);
+    EMF_write_long((long) (-emf_fontsize * EMF_PT2HM));	/* height */
+    EMF_write_long(0);		        /* width */
+    EMF_write_long(emf_vert_text);	/* escapement */
+    EMF_write_long(emf_vert_text);	/* orientation */
+    EMF_write_long(bold);	        /* weight */
+    EMF_write_byte(italic);	        /* italic */
+    EMF_write_byte(underline);	        /* underline */
+    EMF_write_byte(strikeout);	        /* strikeout */
+
+    /* charset: could be extended? */
+    switch (encoding) {
+    case S_ENC_CP1250:
+    case S_ENC_ISO8859_2:
+	EMF_write_byte(EASTEUROPE_CHARSET);
+	break;
+    case S_ENC_KOI8_R:
+    case S_ENC_KOI8_U:
+	EMF_write_byte(KOI8_CHARSET);
+	break;
+    case S_ENC_CP1254:
+    case S_ENC_ISO8859_9:
+	EMF_write_byte(TURKISH_CHARSET);
+	break;
+    default:
+	EMF_write_byte(DEFAULT_CHARSET);
+    }
+
+    EMF_write_byte(0);		        /* out precision */
+    EMF_write_byte(0);		        /* clip precision */
+    EMF_write_byte(0);		        /* quality */
+    EMF_write_byte(0);		        /* pitch and family */
+    for (i = 0; i < 32; i++) {
+	/* face name (max 32) */
+	EMF_write_byte((char) (i < strlen(font) ? font[i] : 0));
+	EMF_write_byte(0);
+    }
+    
+    /* SB 20040506: modification following */
+    for (i = 0; i < 64; i++) {
+	/* FULL face name (max 64) */
+	EMF_write_byte((char) (i < strlen(font) ? font[i] : 0));
+	EMF_write_byte(0);
+    }
+    for (i = 0; i < 32; i++) {
+	/* style name (max 32) */
+	EMF_write_byte(0);
+	EMF_write_byte(0);
+    }
+    EMF_write_long(0);		/* version */
+    EMF_write_long(0);		/* Style size */
+    EMF_write_long(0);		/* Match */
+    EMF_write_long(0);		/* reserved */
+    EMF_write_long(0);		/* VendorId */
+    EMF_write_long(0);		/* Culture */
+    for (i = 0; i < 10; i++)
+	EMF_write_byte(0); /* Panose (ignored) */
+    EMF_write_byte(0);		/* pad (long aligned) */
+    EMF_write_byte(0);		/* pad (long aligned) */
+    /* SB 20040506: End of modification */
+
+    EMF_SelectObject(EMF_HANDLE_FONT);
+}
+
+static void 
+EMF_flush_polygon()
+{
+    int i = 0;
+
+    if (emf_coords == 0)
+	return;
+
+    EMF_MoveToEx(emf_polyline[i++], term->ymax - emf_polyline[i++]);
+    while (i < emf_coords * 2)
+	EMF_LineTo(emf_polyline[i++], term->ymax - emf_polyline[i++]);
+    EMF_LineTo(emf_polyline[0], term->ymax - emf_polyline[1]);
+
+    emf_coords = 0;
+}
+
+static void 
+EMF_flush_polyline()
+{
+    if (emf_coords == 0)
+	return;
+    
+    if (emf_coords <= 2) {
+	EMF_MoveToEx(emf_polyline[0], term->ymax - emf_polyline[1]);
+	EMF_LineTo(emf_polyline[2], term->ymax - emf_polyline[3]);
+    } else {
+	int i = 0;
+	EMF_MoveToEx(emf_polyline[i++], term->ymax - emf_polyline[i++]);
+	while (i < emf_coords * 2)
+	    EMF_LineTo(emf_polyline[i++], term->ymax - emf_polyline[i++]);
+    }
+    emf_coords = 0;
+}
+
+/* HBB 20040708: the following keep K&R argument types for now */
+static void 
+EMF_write_byte(int value)
+{
+    char c = value;
+    fwrite(&c, 1, 1, gpoutfile);
+}
+
+static void 
+EMF_write_short(int value)
+{
+    short actual_value = value;
+    char c[2];
+
+    c[1] = (actual_value >> 8) & 255;	/* convert to x86 order */
+    c[0] = actual_value & 255;
+
+    fwrite(c, 1, 2, gpoutfile);
+}
+
+static void 
+EMF_write_long(unsigned long value)
+{
+    char c[4];
+
+    c[3] = (value >> 24) & 0xFFL;	/* convert to x86 order */
+    c[2] = (value >> 16) & 0xFFL;
+    c[1] = (value >> 8) & 0xFFL;
+    c[0] = value & 0xFFL;
+
+    fwrite(c, 1, 4, gpoutfile);
+}
+
+/* FIXME HBB 20001103: this only works as given iff 'float' is the
+ * same format as on x86's, i.e. IEEE 4-byte floating point format */
+static void 
+EMF_write_float(double value)
+{
+    char c[4];
+
+    union {
+	long l;
+	float f;
+    } u;
+
+    u.f = value;
+
+    c[3] = (u.l >> 24) & 0xFFL;	/* convert to x86 order */
+    c[2] = (u.l >> 16) & 0xFFL;
+    c[1] = (u.l >> 8) & 0xFFL;
+    c[0] = u.l & 0xFFL;
+
+    fwrite(c, 1, 4, gpoutfile);
+}
+
+TERM_PUBLIC void 
+EMF_options()
+{
+    char *s;
+
+    /* Annoying hack to handle the case of 'set termoption' after */
+    /* we have already initialized the terminal.                  */
+    if (c_token != 2) {
+	term->xmax = EMF_XMAX;
+	term->ymax = EMF_YMAX;
+	emf_dashed = TRUE;
+	emf_monochrome = FALSE;
+	emf_tweak = TRUE;
+    }
+
+    while (!END_OF_COMMAND) {
+	if (almost_equals(c_token, "de$fault")) {
+	    strcpy(emf_defaultfontname, EMF_FONTNAME);
+	    emf_defaultfontsize = EMF_FONTSIZE;
+	    emf_monochrome = FALSE;
+	    emf_dashed = TRUE;
+	    term->flags &= ~TERM_MONOCHROME;
+	    c_token++;
+	    continue;
+	}
+	if (almost_equals(c_token, "m$onochrome")) {
+	    emf_monochrome = TRUE;
+	    term->flags |= TERM_MONOCHROME;
+	    c_token++;
+	    continue;
+	}
+	if (almost_equals(c_token, "c$olor") || almost_equals(c_token, "c$olour")) {
+	    emf_monochrome = FALSE;
+	    term->flags &= ~TERM_MONOCHROME;
+	    c_token++;
+	    continue;
+	}
+	if (almost_equals(c_token, "da$shed")) {
+	    emf_dashed = TRUE;
+	    c_token++;
+	    continue;
+	}
+	if (equals(c_token, "dl") || almost_equals(c_token, "dashl$ength")) {
+	    c_token++;
+	    emf_dashlength = real_expression();
+	    if (emf_dashlength < 0.5)
+		emf_dashlength = 1.0;
+	    continue;
+	}
+	if (almost_equals(c_token, "s$olid")) {
+	    emf_dashed = FALSE;
+	    c_token++;
+	    continue;
+	}
+	if (equals(c_token, "lw") || almost_equals(c_token, "linew$idth")) {
+	    c_token++;
+	    emf_linewidth_factor = real_expression();
+	    if (emf_linewidth_factor < 0.1)
+		emf_linewidth_factor = 1.0;
+	    continue;
+	}
+
+	if (almost_equals(c_token,"enh$anced")) {
+	    c_token++;
+	    term->put_text = ENHemf_put_text;
+	    term->flags |= TERM_ENHANCED_TEXT;
+	    continue;
+	} else if (almost_equals(c_token,"noenh$anced")) {
+	    c_token++;
+	    term->put_text = EMF_put_text;
+	    term->flags &= ~TERM_ENHANCED_TEXT;
+	}
+
+	if (almost_equals(c_token,"nopro$portional")) {
+	    c_token++;
+	    emf_tweak = FALSE;
+	}
+
+	if (almost_equals(c_token, "si$ze")) {
+	    int tempxmax = 1024;
+	    int tempymax = 768;
+	    c_token++;
+	    if (!END_OF_COMMAND) {
+		tempxmax = real_expression();
+		if (equals(c_token, ",")) {
+		    c_token++;
+		    tempymax = real_expression();
+		}
+	    }
+	    if (tempxmax > 0)
+		term->xmax = tempxmax * EMF_PX2HM;
+	    if (tempymax > 0)
+		term->ymax = tempymax * EMF_PX2HM;
+	    term->h_tic = term->xmax / 160;
+	    term->v_tic = term->h_tic;
+	    continue;
+	}
+	if (equals(c_token, "font"))
+	    c_token++;
+	/* Fall through to old-style bare font name */
+	if ((s = try_to_get_string())) {
+	    char *comma = strrchr(s,',');
+	    if (comma && (1 == sscanf(comma+1,"%g",&emf_defaultfontsize))) {
+		*comma = '\0';
+	    }
+	    if (*s)
+		strncpy(emf_defaultfontname, s, sizeof(emf_defaultfontname));
+	    free(s);
+	    if (isanumber(c_token)) {
+		emf_defaultfontsize = int_expression();
+	    }
+	    continue;
+	}
+	break;
+    } /* while(!end of command) */
+
+    if (!END_OF_COMMAND) {
+	/* We have old-style bare font size specified */
+	emf_defaultfontsize = int_expression();
+    }
+    EMF_set_font(NULL);		/* set default font */
+    
+    emf_colors = emf_monochrome ? 1 : EMF_COLORS;
+
+    sprintf(term_options, "%s %s \"%s\" %g",
+	    emf_monochrome ? "monochrome" : "color",
+	    emf_dashed ? "dashed" : "solid",
+	    emf_defaultfontname, emf_defaultfontsize);
+
+    if (term->flags & TERM_ENHANCED_TEXT)
+	strcat(term_options, " enhanced ");
+    if (term->xmax != (int)EMF_XMAX || term->ymax != (int)EMF_YMAX)
+	sprintf(&(term_options[strlen(term_options)]), " size %d,%d ",
+	    (int)(0.5+term->xmax/EMF_PX2HM), (int)(0.5+term->ymax/EMF_PX2HM));
+    if (emf_linewidth_factor != 1.0)
+	sprintf(&(term_options[strlen(term_options)]), " lw %.1f",
+		emf_linewidth_factor);
+    if (emf_dashlength != 1.0)
+	sprintf(&(term_options[strlen(term_options)]), " dashlength %.1f",
+		emf_dashlength);
+}
+
+TERM_PUBLIC void 
+EMF_init()
+{
+    emf_posx = emf_posy = 0;
+    emf_linetype = 0;
+    emf_vert_text = 0;
+    emf_graphics = FALSE;
+}
+
+TERM_PUBLIC void 
+EMF_graphics()
+{
+    int width = 0.5 + term->xmax/EMF_PX2HM;
+    int height = 0.5 + term->ymax/EMF_PX2HM;
+    int mmwidth = 0.5 + (term->xmax/EMF_PX2HM) * (270./1024.);
+    int mmheight = 0.5 + (term->ymax/EMF_PX2HM) * (200./768.);
+
+    /* header start */
+    emf_record_count = 0;
+    EMF_write_emr(1, 100);
+    EMF_write_long(0);		/* rclBounds */
+    EMF_write_long(0);
+    EMF_write_long(term->xmax / EMF_PX2HM);
+    EMF_write_long(term->ymax / EMF_PX2HM);
+    EMF_write_long(0);		/* rclFrame */
+    EMF_write_long(0);
+    EMF_write_long(term->xmax);
+    EMF_write_long(term->ymax);
+    EMF_write_long(0x464D4520);	/* signature */
+    EMF_write_long(0x00010000);	/* version */
+    EMF_write_long(0);		/* nBytes */
+    EMF_write_long(0);		/* nRecords */
+    EMF_write_short(EMF_HANDLE_MAX);	/* nHandles, MUST NOT BE 0 */
+    EMF_write_short(0);		/* reserved */
+    EMF_write_long(0);		/* descSize */
+    EMF_write_long(0);		/* descOff */
+    EMF_write_long(0);		/* nPalEntries */
+    EMF_write_long(width);	/* ref dev pixwidth, default 1024 */
+    EMF_write_long(height);	/* ref dev pixheight, default 768 */
+    EMF_write_long(mmwidth);	/* ref dev mwidth, default 270 */
+    EMF_write_long(mmheight);	/* ref dev mheight, default 200 */
+    EMF_write_long(0);		/* cbPixelFormat  */
+    EMF_write_long(0);		/* offPixelFormat  */
+    EMF_write_long(0);		/* bOpenGL */
+    emf_graphics = TRUE;
+    /* header end */
+
+    EMF_SetMapMode(8);		/* forcing anisotropic mode */
+    EMF_SetWindowExtEx(term->xmax, term->ymax);		/* setting logical (himetric) size      */
+    EMF_SetViewportExtEx(term->xmax / EMF_PX2HM, term->ymax / EMF_PX2HM);	/* setting device (pixel) size */
+    EMF_CreatePen(EMF_HANDLE_PEN, 0, 1, 0x000000);	/* init default pen */
+    EMF_SelectObject(EMF_HANDLE_PEN);
+    EMF_SetBkMode(1);		/* transparent background for text */
+    EMF_CreateBrush(EMF_HANDLE_BRUSH, 1, 0, 0);		/* transparent brush for polygons */
+    EMF_SelectObject(EMF_HANDLE_BRUSH);
+    EMF_set_font(NULL);		/* init default font */
+}
+
+TERM_PUBLIC int 
+EMF_set_font(const char *font)
+{
+    static float last_fontsize = -1;
+    static char last_fontname[256] = {'\0'};
+
+    if (font && *font) {
+	float tempsize;
+	int sep = strcspn(font,",");
+	if (sep > 0)
+	    safe_strncpy(emf_fontname, font, GPMIN(sep + 1, 32));
+	if (sep < strlen(font) && sscanf(font+sep+1, "%f", &tempsize))
+	    emf_fontsize = tempsize;
+    } else {
+	strcpy(emf_fontname, emf_defaultfontname);
+	emf_fontsize = emf_defaultfontsize;
+    }
+
+    /* Optimization only */
+    if (!strcmp(last_fontname,emf_fontname) && last_fontsize == emf_fontsize) {
+	return TRUE;
+    }
+
+    term->h_char = (emf_fontsize * EMF_PT2HM)*0.6;
+    term->v_char = (emf_fontsize * EMF_PT2HM)*1.3;
+    EMF_setfont();
+    return TRUE;
+}
+
+TERM_PUBLIC void 
+EMF_text()
+{
+    long pos;
+    EMF_flush_polyline();
+
+    /* writing end of metafile */
+    EMF_SelectObject(EMF_STOCK_OBJECT_DEFAULT_FONT);
+    EMF_DeleteObject(EMF_HANDLE_FONT);
+    EMF_SelectObject(EMF_STOCK_OBJECT_BLACK_PEN);
+    EMF_DeleteObject(EMF_HANDLE_PEN);
+    EMF_SelectObject(EMF_STOCK_OBJECT_WHITE_BRUSH);
+    EMF_DeleteObject(EMF_HANDLE_BRUSH);
+    EMF_EOF();
+
+    /* updating header */
+    pos = ftell(gpoutfile);
+    fseek(gpoutfile, 48, SEEK_SET);
+    EMF_write_long(pos);
+    EMF_write_long(emf_record_count);
+    /* HBB 20010228: have to make known that we're no longer in graphics
+     * status. */
+    emf_graphics = FALSE;
+}
+
+TERM_PUBLIC void 
+EMF_linetype(int linetype)
+{
+    /* Note : separating linetype and color would have not been futile, but anyway... */
+
+#if (0)  /* Not safe because linetype/color/pen are intermixed */
+    if (linetype == emf_linetype)
+	return;
+#endif
+
+    if (linetype == LT_NODRAW)
+	linetype = LT_BACKGROUND;
+	
+    emf_linetype = linetype;
+
+    EMF_linecolor(linetype);
+    EMF_dashtype(linetype);
+}
+
+TERM_PUBLIC void 
+EMF_linecolor(int linecolor)
+{
+    static long GPFAR color_table_data[] =
+    {
+	RGB(255, 0, 0),		/* red */
+	RGB(0, 255, 0),		/* green */
+	RGB(0, 0, 255),		/* blue */
+	RGB(255, 0, 255),	/* magenta */
+	RGB(0, 0, 128),		/* dark blue */
+	RGB(128, 0, 0),		/* dark red */
+	RGB(0, 128, 128),	/* dark cyan */
+	RGB(0, 0, 0),		/* black */
+	RGB(128, 128, 128),	/* grey */
+	RGB(0, 128, 64),	/* very dark cyan */
+	RGB(128, 128, 0),	/* dark yellow */
+	RGB(128, 0, 128),	/* dark magenta */
+	RGB(192, 192, 192),	/* light grey */
+	RGB(0, 255, 255),	/* cyan */
+	RGB(255, 255, 0)	/* yellow */
+    };
+
+    if (linecolor == LT_BACKGROUND)
+	emf_color = RGB(255, 255, 255);	/* white (background) */
+    else {
+	linecolor = (linecolor < 0 || emf_monochrome) ? 7 : (linecolor % EMF_COLORS);
+	emf_color = color_table_data[linecolor];
+    }
+
+    EMF_flush_polyline();
+}
+
+TERM_PUBLIC int EMF_make_palette(t_sm_palette *palette)
+{
+    return 0; /* can do continous colors */
+}
+
+TERM_PUBLIC void EMF_previous_palette()
+{
+    /* do nothing */
+}
+
+TERM_PUBLIC void
+EMF_set_color(t_colorspec *colorspec)
+{
+    rgb255_color rgb255;
+
+    if (colorspec->type == TC_LT) {
+	EMF_linecolor(colorspec->lt);
+    } else if (colorspec->type == TC_FRAC) {
+	rgb255maxcolors_from_gray(colorspec->value, &rgb255);
+	emf_color = RGB(rgb255.r, rgb255.g, rgb255.b);
+    } else if (colorspec->type == TC_RGB) {
+	emf_color = RGB( colorspec->lt >> 16 & 0xff,
+			 colorspec->lt >> 8 & 0xff,
+			 colorspec->lt & 0xff );
+    }
+
+    /*
+    else {
+	fprintf(stderr, "unhandled colorspec type %d\n", colorspec->type);
+    }
+    */
+
+    /* Force reevaluation of dash type */
+    emf_dashtype = LT_UNDEFINED;
+    EMF_dashtype(emf_linetype);
+}
+
+TERM_PUBLIC void
+EMF_filled_polygon(int points, gpiPoint *corners)
+{
+    int i;
+    unsigned long color = emf_color;
+    int fillpar = corners->style >> 4;
+    int style = corners->style & 0xf;
+
+    switch (style) {
+	case FS_EMPTY: /* fill with background color */
+		color = RGB(255,255,255);
+		break;
+	case FS_PATTERN: /* pattern fill implemented as partial density */
+		fillpar *= 12;
+	case FS_SOLID: /* solid fill */
+		if (fillpar >= 0 && fillpar < 100) {
+		    double density = (double)fillpar / 100.;
+		    color = ((int)((double)((emf_color>>16)&0xff)*density) << 16)
+			  + ((int)((double)((emf_color>>8)&0xff)*density) << 8)
+			  + ((int)((double)(emf_color&0xff)*density));
+		    color += ((int)(255.*(1.-density)) << 16)
+		           + ((int)(255.*(1.-density)) << 8)
+			   + ((int)(255.*(1.-density)));
+		}
+		break;
+	default:
+		break;
+    }
+
+    /* Sequence of operations cribbed from Windows example */
+	EMF_CreateBrush(EMF_HANDLE_BRUSH, 0, color, 0);
+	EMF_SelectObject(EMF_HANDLE_BRUSH);
+
+	EMF_CreatePolygon(points);
+	for (i=0; i<points; i++)
+	    EMF_write_pointl(corners[i].x, term->ymax - corners[i].y);
+
+	EMF_DeleteObject(EMF_HANDLE_BRUSH);
+
+    /* Force re-evaluation of linetype next time we draw a line */
+    emf_linetype = LT_UNDEFINED;
+    emf_dashtype = LT_UNDEFINED;
+}
+
+TERM_PUBLIC void
+EMF_fillbox(int style, unsigned int x1, unsigned int y1, unsigned int width, unsigned int height)
+{
+    gpiPoint corner[4];
+
+	corner[0].x = x1;        corner[0].y = y1;
+	corner[1].x = x1+width;  corner[1].y = y1;
+	corner[2].x = x1+width;  corner[2].y = y1+height;
+	corner[3].x = x1;        corner[3].y = y1+height;
+	corner->style = style;
+
+	EMF_filled_polygon(4, corner);
+}
+
+TERM_PUBLIC void 
+EMF_linewidth(double width)
+{
+	int current_dashtype = emf_dashtype;
+    
+    width *= emf_linewidth_factor;
+    if (width == emf_linewidth)
+	return;
+    emf_linewidth = width;
+
+	emf_dashtype = LT_UNDEFINED;      /* Invalidate current dash type     */
+	EMF_dashtype(current_dashtype);    /* Force re-evaluation of dash type */
+}
+
+/*
+ * Resets _both_ line color and dash type!
+ */
+TERM_PUBLIC void 
+EMF_dashtype(int dashtype)
+{
+    int i, j;
+    /* Each group of 8 entries in dot_length[] defines a dash
+       pattern.  Entries in each group are alternately length of
+       whitespace and length of line, in units of 2/3 of the
+       linewidth. */
+    static int dot_length[EMF_LINE_TYPES * 8] =
+    {				/* 0 - solid             */
+	5, 8, 5, 8, 5, 8, 5, 8,	/* 1 - dashes            */
+	4, 2, 4, 2, 4, 2, 4, 2,	/* 2 - dotted            */
+	4, 8, 4, 2, 4, 8, 4, 2,	/* 3 - dash-dot          */
+	4, 9, 4, 2, 4, 2, 0, 0,	/* 4 - dash-dot-dot      */
+    };
+
+    emf_dashtype = dashtype;
+
+    EMF_flush_polyline();
+
+    if (dashtype >= 0)
+	dashtype = (dashtype / emf_colors) % EMF_LINE_TYPES;
+
+    if (dashtype == LT_AXIS)
+	dashtype = 2;
+
+    if (dashtype < 1 || !emf_dashed) {	/* solid mode */
+	EMF_SelectObject(EMF_STOCK_OBJECT_BLACK_PEN);
+	EMF_DeleteObject(EMF_HANDLE_PEN);
+	EMF_CreatePen(EMF_HANDLE_PEN, 0, emf_linewidth * EMF_PX2HM, emf_color);
+	EMF_SelectObject(EMF_HANDLE_PEN);
+
+	term->vector = EMF_solid_vector;
+    } else {			/* Since win32 dashed lines works only with 1 pixel linewith we must emulate */
+	EMF_SelectObject(EMF_STOCK_OBJECT_BLACK_PEN);
+	EMF_DeleteObject(EMF_HANDLE_PEN);
+	EMF_CreatePen(EMF_HANDLE_PEN, 0, emf_linewidth * EMF_PX2HM, emf_color);
+	EMF_SelectObject(EMF_HANDLE_PEN);
+
+	term->vector = EMF_dashed_vector;
+
+	/* set up dash dimensions */
+	j = (dashtype - 1) * 8;
+	for (i = 0; i < 8; i++, j++) {
+	    emf_step_sizes[i] = dot_length[j] * emf_dashlength * EMF_PX2HM;
+	}
+	/* first thing drawn will be a line */
+	emf_step = emf_step_sizes[1];
+	emf_step_index = 1;
+    }
+}
+
+TERM_PUBLIC void 
+EMF_move(unsigned int x, unsigned int y)
+{
+    if (x >= term->xmax || y >= term->ymax) {
+	int_warn(NO_CARET, "emf_move: (%d,%d) out of range",x,y);
+	x = GPMIN(x, term->xmax); y = GPMIN(y, term->ymax);
+    }
+    if (x == emf_posx && y == emf_posy)
+	return;
+    EMF_flush_polyline();
+    emf_posx = x;
+    emf_posy = y;
+}
+
+TERM_PUBLIC void 
+EMF_dashed_vector(unsigned int ux, unsigned int uy)
+{
+    int xa, ya;
+    int dx, dy, adx, ady;
+    int dist;			/* approximate distance in plot units from starting point to specified end point. */
+    long remain;		/* approximate distance in plot units remaining to specified end point. */
+
+    if (ux >= term->xmax || uy >= term->ymax)
+	int_warn(NO_CARET, "emf_dashed_vector: (%d,%d) out of range",ux,uy);
+
+    dx = (ux - emf_posx);
+    dy = (uy - emf_posy);
+    adx = abs(dx);
+    ady = abs(dy * 10);
+
+    /* using the approximation sqrt(x**2 + y**2)  ~  x + (5*x*x)/(12*y)   when x > y.  
+       Note ordering of calculations to avoid overflow on 16 bit architectures */
+    if (10 * adx < ady)
+	dist = (ady / 2 + 25 * adx / ady * adx / 6 * 5) / 5;
+    else {
+	if (adx == 0)
+	    return;
+	dist = (adx * 10 + (ady / 24) * (ady / adx)) / 10;
+    }
+    remain = dist;
+    xa = emf_posx;
+    ya = emf_posy;
+    while (remain > emf_step) {
+	remain -= emf_step;
+	if (emf_step_index & 1)
+	    EMF_solid_vector((int) (ux - (remain * dx) / dist),
+			     (int) (uy - (remain * dy) / dist));
+	else {
+	    xa = (int) (ux - (remain * dx) / dist);
+	    ya = (int) (uy - (remain * dy) / dist);
+	    EMF_move(xa, ya);
+	}
+	if (++emf_step_index >= 8)
+	    emf_step_index = 0;
+	emf_step = emf_step_sizes[emf_step_index];
+    }
+    if (emf_step_index & 1)
+	EMF_solid_vector(ux, uy);
+    else
+	EMF_move(ux, uy);
+    emf_step -= (int) remain;
+}
+
+TERM_PUBLIC void 
+EMF_solid_vector(unsigned int ux, unsigned int uy)
+{
+    if (ux >= term->xmax || uy >= term->ymax)
+	int_warn(NO_CARET, "emf_solid_vector: (%d,%d) out of range",ux,uy);
+    if (ux == emf_posx && uy == emf_posy)
+	return;
+    if (emf_coords * 2 > EMF_MAX_SEGMENTS - 2)
+	EMF_flush_polyline();
+    if (emf_coords == 0) {
+	emf_polyline[0] = emf_posx;
+	emf_polyline[1] = emf_posy;
+	emf_coords++;
+    }
+    emf_posx = emf_polyline[emf_coords * 2] = ux;
+    emf_posy = emf_polyline[emf_coords * 2 + 1] = uy;
+    emf_coords++;
+}
+
+TERM_PUBLIC void 
+EMF_put_text(unsigned int x, unsigned int y, const char str[])
+{
+    int i, len = strlen(str);
+
+    EMF_flush_polyline();
+    if (emf_textcolor != emf_color) {
+	EMF_SetTextColor(emf_color);	/* since text doesn't use pens, we must initialize with this */
+	emf_textcolor = emf_color;
+    }
+
+    /* SB 20040506: offset array now included since it won't work with MS Security patch (kb835732) */
+    /* SB 20040506: also changed function from unicode to ansi version */
+    if (len % 4)
+	len += 4 - (len % 4); /* Structure must be long aligned! */
+    EMF_write_emr(83, 76 + len + strlen(str)*4);/* ExtTextOutA, ANSI char version! */
+    EMF_write_rectl(0, 0, 0, 0); /* bounding, never used */
+    EMF_write_long(1);		/* GM_Compatible mode for advanced scaling */
+    EMF_write_float(EMF_PX2HM);	/* x scale */
+    EMF_write_float(EMF_PX2HM);	/* y scale */
+    /* positioning... y is recentered from bottom reference set in
+     * text align */
+    EMF_write_pointl(
+	x + (long) ((EMF_VCHAR / 2) * sin(emf_vert_text * EMF_10THDEG2RAD)),
+	term->ymax - y + (long) (EMF_VCHAR / 2
+				 * cos(emf_vert_text * EMF_10THDEG2RAD)));
+    EMF_write_long(strlen(str)); /* real char size */
+    EMF_write_long(76);		/* offset to text */
+    EMF_write_long(0);		/* options, none */
+    EMF_write_rectl(0, 0, 0, 0); /* rectangle clipping not used */
+    EMF_write_long(0);		/* offset to intercharacter spacing array, can't be used since really we don't know anything about the face properties used */
+    for (i = 0; i < len; i++) 
+	EMF_write_byte(i<strlen(str)?str[i]:0);	/* writing text */
+    for (i = 0; i < strlen(str); i++)
+	/* writing intercharacter spacing array (but we don't use it) */
+	EMF_write_long(300); 
+    /* SB 20040506: end of modification */
+
+    emf_posx = emf_posy = -2000;
+}
+
+TERM_PUBLIC int 
+EMF_text_angle(int ang)
+{
+    /* Win GDI rotation is scaled in tenth of degrees, so... */
+    switch (ang) {
+    case 0:			/* left right */
+	if (emf_vert_text != 0) {
+	    emf_vert_text = 0;
+	    EMF_setfont();
+	}
+	break;
+    case TEXT_VERTICAL:		/* bottom up */
+	if (emf_vert_text != 900) {
+	    emf_vert_text = 900;
+	    EMF_setfont();
+	}
+	break;
+    default:			/* the general case */
+    	emf_vert_text = 10 * ang;
+	EMF_setfont();
+	break;
+    }
+    return TRUE;
+}
+
+TERM_PUBLIC int 
+EMF_justify_text(enum JUSTIFY mode)
+{
+    int align = GP_TA_BOTTOM;
+
+    emf_justify = mode;
+
+    switch (mode) {
+    case LEFT:
+	align |= GP_TA_LEFT;
+	break;
+    case RIGHT:
+	align |= GP_TA_RIGHT;
+	break;
+    case CENTRE:
+	align |= GP_TA_CENTER;
+	break;
+    }
+    EMF_SetTextAlign(align);
+
+    return (TRUE);
+}
+
+TERM_PUBLIC void 
+EMF_reset()
+{
+    emf_posx = emf_posy = 0;
+    emf_graphics = FALSE;
+}
+
+TERM_PUBLIC void 
+EMF_point(unsigned int x, unsigned int y, int number)
+{
+    int old_dashtype;
+    gpiPoint corners[12];
+    corners->style = FS_OPAQUE;
+
+    EMF_flush_polyline();
+    old_dashtype = emf_dashtype;
+    EMF_dashtype(0);
+
+    /* if (number < 0)*/
+    {
+	/* draw dot */
+	EMF_move(x, y);
+	EMF_solid_vector(x + 1, y);
+	/* goto end_points;*/
+    }
+    number = number % EMF_POINTS;
+
+    switch (number) {
+    case 0:			/* draw plus */
+	EMF_move(x - emf_tic, y);
+	EMF_solid_vector(x + emf_tic, y);
+	EMF_move(x, y - emf_tic);
+	EMF_solid_vector(x, y + emf_tic);
+	break;
+    case 1:			/* draw X */
+	EMF_move(x - emf_tic707, y - emf_tic707);
+	EMF_solid_vector(x + emf_tic707, y + emf_tic707);
+	EMF_move(x - emf_tic707, y + emf_tic707);
+	EMF_solid_vector(x + emf_tic707, y - emf_tic707);
+	break;
+    case 2:			/* draw star (asterisk) */
+	EMF_move(x, y - emf_tic);
+	EMF_solid_vector(x, y + emf_tic);
+	EMF_move(x + emf_tic866, y - emf_tic500);
+	EMF_solid_vector(x - emf_tic866, y + emf_tic500);
+	EMF_move(x + emf_tic866, y + emf_tic500);
+	EMF_solid_vector(x - emf_tic866, y - emf_tic500);
+	break;
+    case 3:			/* draw box */
+	EMF_move(x - emf_tic707, y - emf_tic707);
+	EMF_solid_vector(x + emf_tic707, y - emf_tic707);
+	EMF_solid_vector(x + emf_tic707, y + emf_tic707);
+	EMF_solid_vector(x - emf_tic707, y + emf_tic707);
+	EMF_flush_polygon();
+	break;
+    case 4:			/* draw filled box */
+	corners[0].x = x - emf_tic707; corners[0].y = y - emf_tic707;
+	corners[1].x = x + emf_tic707; corners[1].y = y - emf_tic707;
+	corners[2].x = x + emf_tic707; corners[2].y = y + emf_tic707;
+	corners[3].x = x - emf_tic707; corners[3].y = y + emf_tic707;
+	EMF_filled_polygon(4, corners);
+	break;
+    case 5:
+	/* draw circle (actually, dodecagon) (WinWord 6 accepts the
+	 * CGM "circle" element, but the resulting circle is not
+	 * correctly centered!) */
+	EMF_move(x, y - emf_tic);
+	EMF_solid_vector(x + emf_tic500, y - emf_tic866);
+	EMF_solid_vector(x + emf_tic866, y - emf_tic500);
+	EMF_solid_vector(x + emf_tic, y);
+	EMF_solid_vector(x + emf_tic866, y + emf_tic500);
+	EMF_solid_vector(x + emf_tic500, y + emf_tic866);
+	EMF_solid_vector(x, y + emf_tic);
+	EMF_solid_vector(x - emf_tic500, y + emf_tic866);
+	EMF_solid_vector(x - emf_tic866, y + emf_tic500);
+	EMF_solid_vector(x - emf_tic, y);
+	EMF_solid_vector(x - emf_tic866, y - emf_tic500);
+	EMF_solid_vector(x - emf_tic500, y - emf_tic866);
+	EMF_flush_polygon();
+	break;
+    case 6: /* filled circle */
+	corners [0].x = x             ; corners [0].y = y - emf_tic;
+	corners [1].x = x + emf_tic500; corners [1].y = y - emf_tic866;
+	corners [2].x = x + emf_tic866; corners [2].y = y - emf_tic500;
+	corners [3].x = x + emf_tic   ; corners [3].y = y;
+	corners [4].x = x + emf_tic866; corners [4].y = y + emf_tic500;
+	corners [5].x = x + emf_tic500; corners [5].y = y + emf_tic866;
+	corners [6].x = x             ; corners [6].y = y + emf_tic;
+	corners [7].x = x - emf_tic500; corners [7].y = y + emf_tic866;
+	corners [8].x = x - emf_tic866; corners [8].y = y + emf_tic500;
+	corners [9].x = x - emf_tic   ; corners [9].y = y;
+	corners[10].x = x - emf_tic866; corners[10].y = y - emf_tic500;
+	corners[11].x = x - emf_tic500; corners[11].y = y - emf_tic866;
+	EMF_filled_polygon(12, corners);
+	break;
+    case 7:			/* draw triangle (point up) */
+	EMF_move(x, y + emf_tic1241);
+	EMF_solid_vector(x - emf_tic1077, y - emf_tic621);
+	EMF_solid_vector(x + emf_tic1077, y - emf_tic621);
+	EMF_flush_polygon();
+	break;
+    case 8: /* filled triangle point up */
+	corners[0].x = x               ; corners[0].y = y + emf_tic1241;
+	corners[1].x = x - emf_tic1077 ; corners[1].y = y - emf_tic621;
+	corners[2].x = x + emf_tic1077 ; corners[2].y = y - emf_tic621;
+	EMF_filled_polygon(3, corners);
+	break;
+    case 9:			/* draw triangle (point down) */
+	EMF_move(x, y - emf_tic1241);
+	EMF_solid_vector(x - emf_tic1077, y + emf_tic621);
+	EMF_solid_vector(x + emf_tic1077, y + emf_tic621);
+	EMF_flush_polygon();
+	break;
+    case 10: /* filled triangle point down */
+	corners[0].x = x               ; corners[0].y = y - emf_tic1241;
+	corners[1].x = x - emf_tic1077 ; corners[1].y = y + emf_tic621;
+	corners[2].x = x + emf_tic1077 ; corners[2].y = y + emf_tic621;
+	EMF_filled_polygon(3, corners);
+	break;
+    case 11:			/* draw diamond */
+	EMF_move(x - emf_tic, y);
+	EMF_solid_vector(x, y - emf_tic);
+	EMF_solid_vector(x + emf_tic, y);
+	EMF_solid_vector(x, y + emf_tic);
+	EMF_flush_polygon();
+	break;
+    case 12: /* filled diamond */
+	corners[0].x = x - emf_tic ; corners[0].y = y;
+	corners[1].x = x           ; corners[1].y = y - emf_tic;
+	corners[2].x = x + emf_tic ; corners[2].y = y;
+	corners[3].x = x           ; corners[3].y = y + emf_tic;
+	EMF_filled_polygon(4, corners);
+	break;
+    }
+/* end_points: */
+    EMF_dashtype(old_dashtype);
+}
+
+
+TERM_PUBLIC void 
+EMF_set_pointsize(double size)
+{
+    if (size < 0)
+	size = 1;
+    emf_tic = (size * term->h_tic);
+    emf_tic707 = emf_tic * 12 / 17;
+    emf_tic866 = emf_tic * 13 / 15;
+    emf_tic500 = emf_tic / 2;
+    emf_tic1241 = emf_tic * 36 / 29;
+    emf_tic1077 = emf_tic * 14 / 13;
+    emf_tic621 = emf_tic * 18 / 29;
+}
+
+/*
+ * Ethan A Merritt September 2008
+ *	- Support for enhanced text mode
+ * PROBLEMS:
+ *	- Rotated enhanced text is not handled
+ *	- The proportional spacing hack is really ugly
+ *	  ETO_PDY is supposed to handle this, but pre-Vista Windows
+ *	  doesn't support the flag so it's of no real use.
+ */
+
+static TBOOLEAN ENHemf_opened_string;
+
+/* used in determining height of processed text */
+static float ENHemf_base;
+
+/* use these so that we don't over-write the current font settings */
+static float ENHemf_fontsize;
+static char   *ENHemf_font;
+
+static TBOOLEAN ENHemf_show = TRUE;
+static int ENHemf_overprint = 0;
+
+TERM_PUBLIC void
+ENHemf_OPEN(
+    char *fontname,
+    double fontsize, double base,
+    TBOOLEAN widthflag,
+    TBOOLEAN showflag,
+    int overprint)
+{
+
+    /* If the overprint code requests a save or restore, that's all we do */
+#define EMF_AVG_WID 0.8
+#undef TA_UPDATECP_MODE
+#ifdef TA_UPDATECP_MODE
+    if (overprint == 3) {
+	EMF_SaveDC();
+	return;
+    } else if (overprint == 4) {
+	EMF_RestoreDC();
+	return;
+    }
+#else
+    static int save_x, save_y;
+    if (overprint == 3) {
+	save_x = emf_posx;
+	save_y = emf_posy;
+	return;
+    } else if (overprint == 4) {
+	emf_posx = save_x;
+	emf_posy = save_y;
+	return;
+    }
+#endif
+
+    if (!ENHemf_opened_string) {
+	ENHemf_opened_string = TRUE;
+	enhanced_cur_text = &enhanced_text[0];
+	ENHemf_font = fontname;
+	ENHemf_fontsize = fontsize;
+	ENHemf_base = base;
+	ENHemf_show = showflag;
+	ENHemf_overprint = overprint;
+    }
+}
+
+/* Write a string fragment and update the current position */
+TERM_PUBLIC void
+ENHemf_FLUSH()
+{
+    unsigned int x, y;
+    char *str;
+    int i;
+    int incr_x;
+    double strl;
+
+	if (ENHemf_opened_string) {
+	    *enhanced_cur_text = '\0';
+	    ENHemf_opened_string = FALSE;
+	    x = emf_posx;
+	    y = emf_posy;
+
+	    FPRINTF((stderr,"ENHemf_FLUSH: Write string \"%s\" len %d at %g with font %s,%g\n",
+		    enhanced_text,strlen(enhanced_text),
+		    (double)x/EMF_PX2HM,ENHemf_font,ENHemf_fontsize));
+
+	    if (1) {
+		char save_font[256];
+		float save_fontsize = emf_fontsize;
+		strcpy(save_font,emf_fontname);
+		emf_fontsize = ENHemf_fontsize;
+
+		EMF_set_font(ENHemf_font);
+		
+		emf_fontsize = save_fontsize;
+		strcpy(emf_fontname,save_font);
+	    }
+
+	    /* Don't know how to do a pure move; instead write in white */
+	    if (!ENHemf_show) {
+		EMF_SetTextColor(0xffffff);
+		emf_textcolor = 0xffffff;
+	    } else if (ENHemf_show && emf_textcolor != emf_color) {
+		EMF_SetTextColor(emf_color);
+		emf_textcolor = emf_color;
+	    }
+
+	    str = enhanced_text;
+
+#ifndef GP_TA_UPDATEPC_MODE
+	    /* We are especially bad at guessing the width of whitespace. */
+	    /* Best is to pile up all our errors on top of leading space. */
+	    i = strspn(enhanced_text," ");
+	    if (i > 0) {
+		x += i * term->h_char 
+		   * EMF_AVG_WID * ENHemf_fontsize/emf_defaultfontsize;
+		emf_posx = x;
+		str += i;
+	    }
+#endif
+
+	    /* Copied from put_text(). Is all this really necessary? */
+	    {
+	    int record_length;
+	    int len = strlen(str);
+	    if (len % 4)
+		len += 4 - (len % 4);		/* Structure must be long aligned! */
+	    record_length = 76 + len + strlen(str)*4;
+
+	    EMF_write_emr(83, record_length);/* ExtTextOutA, ANSI char version! */
+	    EMF_write_rectl(0, 0, 0, 0);	/* bounding, never used */
+	    EMF_write_long(1);			/* GM_Compatible mode for advanced scaling */
+	    EMF_write_float(EMF_PX2HM);		/* x scale */
+	    EMF_write_float(EMF_PX2HM);		/* y scale */
+	    if (emf_vert_text == 0) {		/* x,y position (ignored if GP_TA_UPDATECP) */
+		float yo = 1.3 * EMF_PX2HM * ENHemf_base;
+		EMF_write_pointl(
+			x, term->ymax - (y + yo));
+	    } else {
+		float a = emf_vert_text * EMF_10THDEG2RAD;
+		float yo = 1.3 * EMF_PX2HM * ENHemf_base;
+		EMF_write_pointl(
+			x - (long) (yo * sin(a)),
+			term->ymax - (long) (y + (yo * cos(a))) );
+	    }
+	    EMF_write_long(strlen(str)); 	/* true number of characters */
+	    EMF_write_long(76);			/* offset to text */
+	    EMF_write_long(0);			/* ExtTextOut options */
+	    EMF_write_rectl(0, 0, 0, 0);	/* bounding, never used */
+	    EMF_write_long(0);			/* offset to intercharacter spacing array */
+	    for (i = 0; i < len; i++) 
+		EMF_write_byte(i<strlen(str)?str[i]:0);	/* character string */
+	    for (i = 0; i < strlen(str); i++)
+		EMF_write_long(300); 		/* intercharacter spacing array (not used) */
+	    }
+
+	    /* Empirical hack */
+	    strl = strlen(str);
+	    if (emf_vert_text != 0)
+		strl += 1.0;
+
+	    if (emf_tweak) {
+		/* Tweak estimated length of rendered string by counting "thin" characters */
+		/* In principle EMF will accept an array of char widths. But in practice   */
+		/* none of the EMF viewers implement this option (ETO_PDY).                */
+		{
+		int thin = 0, wide = 0;
+		for (i=0; i<strlen(str); i++) {
+		    if (strchr(" ijl.,;:|!()[]I-'",str[i]))
+			thin++;
+		    if (('A' <= str[i] && str[i] <= 'Z') || strchr("mw<>",str[i]))
+			wide++;
+		    if (strchr(" i.,;:|!'",str[i]))  /* really thin */
+			thin++;
+		}
+		incr_x = (strl * EMF_AVG_WID 
+			+ (double)(wide) * 0.3
+			+ (double)(-thin) * 0.2)
+			* term->h_char;
+		}
+	    } else {
+		incr_x = strl * EMF_AVG_WID * term->h_char;
+	    }
+
+	    /* Attempt to handle slanted text. Not entirely successful */
+	    emf_posx += incr_x * cos(emf_vert_text * EMF_10THDEG2RAD);
+	    emf_posy += incr_x * sin(emf_vert_text * EMF_10THDEG2RAD);
+
+	    if (ENHemf_overprint == 1)
+		emf_posx -= strlen(str) * term->h_char 
+	    		  * (0.5) * EMF_AVG_WID * ENHemf_fontsize/emf_defaultfontsize;
+
+	}
+}
+
+TERM_PUBLIC void
+ENHemf_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    int tmp_justify = emf_justify;
+    int len;
+
+    if (ignore_enhanced_text) {
+	EMF_put_text(x,y,str);
+	return;
+    }
+
+    if (!strlen(str))
+	return;
+    len = estimate_strlen((char *)str);
+
+    /* if there are no magic characters, we should just be able
+     * punt the string to EMF_put_text()
+     */
+    if (!strpbrk(str, "{}^_@&~")) {
+	/* FIXME: do something to ensure default font is selected */
+	EMF_put_text(x,y,str);
+	return;
+    }
+
+    if (emf_textcolor != emf_color) {
+	EMF_SetTextColor(emf_color);
+	emf_textcolor = emf_color;
+    }
+
+    /* set up the global variables needed by enhanced_recursion() */
+    enhanced_fontscale = 1.0;
+    strncpy(enhanced_escape_format,"&#x%2.2x;",sizeof(enhanced_escape_format));
+
+    ENHemf_opened_string = FALSE;
+    ENHemf_show = TRUE;
+    ENHemf_overprint = 0;
+    ENHemf_font = emf_fontname;
+    ENHemf_fontsize = emf_fontsize;
+
+    /* EAM -FIXME
+     * To do proper justification requires some way to track the current position
+     * after writing a text fragment.  I don't know how to do that in emf.
+     * So I punt by just estimating the total length.
+     */
+    if (emf_justify == RIGHT) {
+		x -= term->h_char * len * cos(emf_vert_text * EMF_10THDEG2RAD);
+		y -= term->h_char * len * sin(emf_vert_text * EMF_10THDEG2RAD);
+    } else if (emf_justify == CENTRE) {
+		x -= term->h_char * len/2. * cos(emf_vert_text * EMF_10THDEG2RAD);
+		y -= term->h_char * len/2. * sin(emf_vert_text * EMF_10THDEG2RAD);
+    }
+    x += term->v_char/3. * sin(emf_vert_text * EMF_10THDEG2RAD);
+    y -= term->v_char/3. * cos(emf_vert_text * EMF_10THDEG2RAD);
+    EMF_move(x,y);
+
+    emf_justify = LEFT;
+#ifdef UPDATECP_MODE
+    EMF_SetTextAlign(GP_TA_BASELINE|GP_TA_LEFT|GP_TA_UPDATECP);
+#else
+    EMF_SetTextAlign(GP_TA_BASELINE|GP_TA_LEFT|GP_TA_NOUPDATECP);
+#endif
+
+    /* Set the recursion going. We say to keep going until a
+     * closing brace, but we don't really expect to find one.
+     * If the return value is not the nul-terminator of the
+     * string, that can only mean that we did find an unmatched
+     * closing brace in the string. We increment past it (else
+     * we get stuck in an infinite loop) and try again.
+     */
+    while (*(str = enhanced_recursion((char *)str, TRUE,
+			ENHemf_font, ENHemf_fontsize,
+			0.0, TRUE, TRUE, 0))) {
+	(term->enhanced_flush)();
+
+	/* I think we can only get here if *str == '}' */
+	    enh_err_check(str);
+
+	if (!*++str)
+	    break; /* end of string */
+
+	/* else carry on and process the rest of the string */
+    }
+
+    /* Restore everything we messed with */
+    emf_justify = tmp_justify;
+    EMF_setfont(); /* Necessary? */
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+TERM_TABLE_START(emf_driver)
+    "emf", "Enhanced Metafile format",
+    EMF_XMAX, EMF_YMAX, EMF_VCHAR, EMF_HCHAR,
+    EMF_VTIC, EMF_HTIC, EMF_options, EMF_init, EMF_reset,
+    EMF_text, null_scale, EMF_graphics, EMF_move, EMF_solid_vector,
+    EMF_linetype, EMF_put_text, EMF_text_angle,
+    EMF_justify_text, EMF_point, do_arrow, EMF_set_font,
+    EMF_set_pointsize,
+    TERM_BINARY|TERM_CAN_DASH|TERM_LINEWIDTH,		/* various flags */
+    NULL,				/* suspend */
+    NULL,				/* resume  */
+    EMF_fillbox,
+    EMF_linewidth
+#ifdef USE_MOUSE
+   , 0, 0, 0, 0, 0 /* no mouse support for emf */
+#endif
+   , EMF_make_palette,
+   EMF_previous_palette,
+   EMF_set_color,
+   EMF_filled_polygon
+    , NULL /* image */
+    , ENHemf_OPEN, ENHemf_FLUSH, do_enh_writec
+TERM_TABLE_END(emf_driver)
+#undef LAST_TERM
+#define LAST_TERM emf_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(emf)
+"1 emf",
+"?commands set terminal emf",
+"?set terminal emf",
+"?set term emf",
+"?terminal emf",
+"?term emf",
+"?emf",
+" The `emf` terminal generates an Enhanced Metafile Format file.",
+" This file format is recognized by many Windows applications.",
+"",
+" Syntax:",
+"       set terminal emf {color | monochrome} {solid | dashed}",
+"                        {enhanced {noproportional}}",
+"                        {linewidth <LW>} {dashlength <DL>} {size XX,YY}",
+"                        {\"<fontname>\"} {<fontsize>}    #old syntax",
+"                        {font \"<fontname>,<fontsize>\"} #new syntax",
+"",
+" In `monochrome` mode successive line types cycle through dash patterns.",
+" In `color` mode successive line types use successive colors, and only after",
+" all 8 default colors are exhausted is the dash pattern incremented.",
+" `solid` draws all curves with solid lines, overriding any dashed patterns;",
+" `linewidth <factor>` multiplies all line widths by this factor.",
+" `dashlength <factor>` is useful for thick lines.",
+" <fontname> is the name of a font; and ",
+" `<fontsize>` is the size of the font in points.",
+"",
+" The nominal size of the output image defaults to 1024x768 in arbitrary",
+" units. You may specify a different nominal size using the `size` option.",
+"",
+" Enhanced text mode tries to approximate proportional character spacing.",
+" If you are using a monospaced font, or don't like the approximation, you",
+" can turn off this correction using the `noproportional` option.",
+"",
+" The default settings are `color dashed font \"Arial,12\" size 1024,768`",
+" Selecting `default` sets all options to their default values.",
+"",
+" Examples:",
+"       set terminal emf 'Times Roman Italic' 12",
+"       set terminal emf color solid    # no pesky dashes!"
+END_HELP(emf)
+#endif /* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/emxvga.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/emxvga.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/emxvga.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/emxvga.trm.svn-base	2012-01-03 17:07:28.457777300 -0800
@@ -0,0 +1,510 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: emxvga.trm,v 1.15 2006/07/21 02:35:46 sfeam Exp $
+ */
+
+/* GNUPLOT - emxvga.trm */
+
+/*[
+ * Copyright 1994, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *  SVGA 1024x768x256 for PC's running DOS or OS/2
+ *
+ * AUTHOR
+ *   David J. Liu (liudj0@minerva.cis.yale.edu)
+ */
+/*
+ * Compile with GCC (emx) with VESA and SVGAKIT maintained by
+ * Johannes Martin (JMARTIN@GOOFY.ZDV.UNI-MAINZ.DE)
+ * with additions by David J. Liu (liudj0@minerva.cis.yale.edu)
+ * supports VESA, Trident, Cirrus, ET4000, WD and S3.
+ */
+/*
+ * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+#ifdef EMXVESA
+register_term(vesa)
+#endif /* EMXVESA */
+register_term(emxvga)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void EMXVGA_init __PROTO((void));
+TERM_PUBLIC void EMXVGA_reset __PROTO((void));
+TERM_PUBLIC void EMXVGA_text __PROTO((void));
+TERM_PUBLIC void EMXVGA_graphics __PROTO((void));
+TERM_PUBLIC void EMXVGA_linetype __PROTO((int));
+TERM_PUBLIC void EMXVGA_move __PROTO((unsigned int, unsigned int));
+TERM_PUBLIC void EMXVGA_vector __PROTO((unsigned int, unsigned int));
+TERM_PUBLIC int EMXVGA_text_angle __PROTO((int));
+TERM_PUBLIC void EMXVGA_put_text __PROTO((unsigned int, unsigned int, const char *));
+#define EMXVGA_VCHAR 8
+#define EMXVGA_HCHAR 8
+#define EMXVGA_VTIC 4
+#define EMXVGA_HTIC 4
+#define EMXVGA_XMAX 0		/* These two entries are just place holders. */
+#define EMXVGA_YMAX 0		/* The actual values will be filled in init. */
+#ifdef EMXVESA
+TERM_PUBLIC void EMXVESA_options __PROTO((void));
+TERM_PUBLIC void EMXVESA_init __PROTO((void));
+TERM_PUBLIC void EMXVESA_graphics __PROTO((void));
+TERM_PUBLIC void EMXVESA_text __PROTO((void));
+TERM_PUBLIC void EMXVESA_reset __PROTO((void));
+#endif
+#endif /* TERM_PROTO */
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+/* avoid name clash with graph.h - lets hope that no following
+ * driver needs these symbols !
+ */
+#ifdef RIGHT
+#undef RIGHT
+#endif
+#ifdef DOWN
+#undef DOWN
+#endif
+#include <vesa.h>
+#include <jmgraph.h>
+#include <conio.h>		/* for getch()            -SB */
+#include <stdlib.h>
+#include <dos.h>
+/*
+ * Some versions of graph.h (e.g. jmgraph.h) define RIGHT to be 0
+ * colliding with enum JUSTIFY. We don't need this define anyway,
+ * just undef it.			-SB
+ */
+#ifdef RIGHT
+#undef RIGHT
+#endif
+#ifdef DOWN
+#undef DOWN
+#endif
+static int EMXVGA_vmode = G640x480x256;		/* default mode */
+static int vgacolor[] ={ 7, 8, 2, 3, 4, 5, 9, 14, 12, 15, 13, 10, 11, 1, 6 };
+static int graphics_on = FALSE;
+int startx, starty, lasty;
+int EMXVGA_angle, EMXVGA_color;
+char *EMXVGA_buf;
+
+void
+emx_getch()
+{
+    union REGS reg;
+    char c;
+    if (_osmode == OS2_MODE)
+	VesaGetCharacter(&c);
+    else {
+	reg.x.ax = 0x0000;
+	_int86(0x16, &reg, &reg);
+	if (reg.h.al == 0) {
+	    reg.x.ax = 0x0000;
+	    _int86(0x16, &reg, &reg);
+	}
+    }
+}
+
+/* gstring.c (emx+gcc) -- Copyright (c) 1994 by David J. Liu */
+unsigned char font[128][8] =
+{				/* 8x8 font */
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+    {0x7E, 0x81, 0xA5, 0x81, 0xBD, 0x99, 0x81, 0x7E},
+    {0x7E, 0xFF, 0xDB, 0xFF, 0xC3, 0xE7, 0xFF, 0x7E},
+    {0x6C, 0xFE, 0xFE, 0xFE, 0x7C, 0x38, 0x10, 0x00},
+    {0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x10, 0x00},
+    {0x38, 0x7C, 0x38, 0xFE, 0xFE, 0x92, 0x10, 0x7C},
+    {0x00, 0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x7C},
+    {0x00, 0x00, 0x18, 0x3C, 0x3C, 0x18, 0x00, 0x00},
+    {0xFF, 0xFF, 0xE7, 0xC3, 0xC3, 0xE7, 0xFF, 0xFF},
+    {0x00, 0x3C, 0x66, 0x42, 0x42, 0x66, 0x3C, 0x00},
+    {0xFF, 0xC3, 0x99, 0xBD, 0xBD, 0x99, 0xC3, 0xFF},
+    {0x0F, 0x07, 0x0F, 0x7D, 0xCC, 0xCC, 0xCC, 0x78},
+    {0x3C, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x7E, 0x18},
+    {0x3F, 0x33, 0x3F, 0x30, 0x30, 0x70, 0xF0, 0xE0},
+    {0x7F, 0x63, 0x7F, 0x63, 0x63, 0x67, 0xE6, 0xC0},
+    {0x99, 0x5A, 0x3C, 0xE7, 0xE7, 0x3C, 0x5A, 0x99},
+    {0x80, 0xE0, 0xF8, 0xFE, 0xF8, 0xE0, 0x80, 0x00},
+    {0x02, 0x0E, 0x3E, 0xFE, 0x3E, 0x0E, 0x02, 0x00},
+    {0x18, 0x3C, 0x7E, 0x18, 0x18, 0x7E, 0x3C, 0x18},
+    {0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00},
+    {0x7F, 0xDB, 0xDB, 0x7B, 0x1B, 0x1B, 0x1B, 0x00},
+    {0x3E, 0x63, 0x38, 0x6C, 0x6C, 0x38, 0x86, 0xFC},
+    {0x00, 0x00, 0x00, 0x00, 0x7E, 0x7E, 0x7E, 0x00},
+    {0x18, 0x3C, 0x7E, 0x18, 0x7E, 0x3C, 0x18, 0xFF},
+    {0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x00},
+    {0x18, 0x18, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x00},
+    {0x00, 0x18, 0x0C, 0xFE, 0x0C, 0x18, 0x00, 0x00},
+    {0x00, 0x30, 0x60, 0xFE, 0x60, 0x30, 0x00, 0x00},
+    {0x00, 0x00, 0xC0, 0xC0, 0xC0, 0xFE, 0x00, 0x00},
+    {0x00, 0x24, 0x66, 0xFF, 0x66, 0x24, 0x00, 0x00},
+    {0x00, 0x18, 0x3C, 0x7E, 0xFF, 0xFF, 0x00, 0x00},
+    {0x00, 0xFF, 0xFF, 0x7E, 0x3C, 0x18, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+    {0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00},
+    {0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00},
+    {0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00},
+    {0x18, 0x7E, 0xC0, 0x7C, 0x06, 0xFC, 0x18, 0x00},
+    {0x00, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xC6, 0x00},
+    {0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00},
+    {0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00},
+    {0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00},
+    {0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00},
+    {0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00},
+    {0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30},
+    {0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00},
+    {0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00},
+    {0x7C, 0xCE, 0xDE, 0xF6, 0xE6, 0xC6, 0x7C, 0x00},
+    {0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xFC, 0x00},
+    {0x78, 0xCC, 0x0C, 0x38, 0x60, 0xCC, 0xFC, 0x00},
+    {0x78, 0xCC, 0x0C, 0x38, 0x0C, 0xCC, 0x78, 0x00},
+    {0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x1E, 0x00},
+    {0xFC, 0xC0, 0xF8, 0x0C, 0x0C, 0xCC, 0x78, 0x00},
+    {0x38, 0x60, 0xC0, 0xF8, 0xCC, 0xCC, 0x78, 0x00},
+    {0xFC, 0xCC, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00},
+    {0x78, 0xCC, 0xCC, 0x78, 0xCC, 0xCC, 0x78, 0x00},
+    {0x78, 0xCC, 0xCC, 0x7C, 0x0C, 0x18, 0x70, 0x00},
+    {0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00},
+    {0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30},
+    {0x18, 0x30, 0x60, 0xC0, 0x60, 0x30, 0x18, 0x00},
+    {0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00},
+    {0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60, 0x00},
+    {0x3C, 0x66, 0x0C, 0x18, 0x18, 0x00, 0x18, 0x00},
+    {0x7C, 0xC6, 0xDE, 0xDE, 0xDC, 0xC0, 0x7C, 0x00},
+    {0x30, 0x78, 0xCC, 0xCC, 0xFC, 0xCC, 0xCC, 0x00},
+    {0xFC, 0x66, 0x66, 0x7C, 0x66, 0x66, 0xFC, 0x00},
+    {0x3C, 0x66, 0xC0, 0xC0, 0xC0, 0x66, 0x3C, 0x00},
+    {0xF8, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00},
+    {0xFE, 0x62, 0x68, 0x78, 0x68, 0x62, 0xFE, 0x00},
+    {0xFE, 0x62, 0x68, 0x78, 0x68, 0x60, 0xF0, 0x00},
+    {0x3C, 0x66, 0xC0, 0xC0, 0xCE, 0x66, 0x3A, 0x00},
+    {0xCC, 0xCC, 0xCC, 0xFC, 0xCC, 0xCC, 0xCC, 0x00},
+    {0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00},
+    {0x1E, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0x00},
+    {0xE6, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0xE6, 0x00},
+    {0xF0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00},
+    {0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0x00},
+    {0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0x00},
+    {0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00},
+    {0xFC, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00},
+    {0x7C, 0xC6, 0xC6, 0xC6, 0xD6, 0x7C, 0x0E, 0x00},
+    {0xFC, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0xE6, 0x00},
+    {0x7C, 0xC6, 0xE0, 0x78, 0x0E, 0xC6, 0x7C, 0x00},
+    {0xFC, 0xB4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00},
+    {0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xFC, 0x00},
+    {0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x00},
+    {0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xFE, 0x6C, 0x00},
+    {0xC6, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0xC6, 0x00},
+    {0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x30, 0x78, 0x00},
+    {0xFE, 0xC6, 0x8C, 0x18, 0x32, 0x66, 0xFE, 0x00},
+    {0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00},
+    {0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00},
+    {0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00},
+    {0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF},
+    {0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},
+    {0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00},
+    {0xE0, 0x60, 0x60, 0x7C, 0x66, 0x66, 0xDC, 0x00},
+    {0x00, 0x00, 0x78, 0xCC, 0xC0, 0xCC, 0x78, 0x00},
+    {0x1C, 0x0C, 0x0C, 0x7C, 0xCC, 0xCC, 0x76, 0x00},
+    {0x00, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00},
+    {0x38, 0x6C, 0x64, 0xF0, 0x60, 0x60, 0xF0, 0x00},
+    {0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8},
+    {0xE0, 0x60, 0x6C, 0x76, 0x66, 0x66, 0xE6, 0x00},
+    {0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00},
+    {0x0C, 0x00, 0x1C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78},
+    {0xE0, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0xE6, 0x00},
+    {0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00},
+    {0x00, 0x00, 0xCC, 0xFE, 0xFE, 0xD6, 0xD6, 0x00},
+    {0x00, 0x00, 0xB8, 0xCC, 0xCC, 0xCC, 0xCC, 0x00},
+    {0x00, 0x00, 0x78, 0xCC, 0xCC, 0xCC, 0x78, 0x00},
+    {0x00, 0x00, 0xDC, 0x66, 0x66, 0x7C, 0x60, 0xF0},
+    {0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0x1E},
+    {0x00, 0x00, 0xDC, 0x76, 0x62, 0x60, 0xF0, 0x00},
+    {0x00, 0x00, 0x7C, 0xC0, 0x70, 0x1C, 0xF8, 0x00},
+    {0x10, 0x30, 0xFC, 0x30, 0x30, 0x34, 0x18, 0x00},
+    {0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00},
+    {0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x00},
+    {0x00, 0x00, 0xC6, 0xC6, 0xD6, 0xFE, 0x6C, 0x00},
+    {0x00, 0x00, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0x00},
+    {0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8},
+    {0x00, 0x00, 0xFC, 0x98, 0x30, 0x64, 0xFC, 0x00},
+    {0x1C, 0x30, 0x30, 0xE0, 0x30, 0x30, 0x1C, 0x00},
+    {0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00},
+    {0xE0, 0x30, 0x30, 0x1C, 0x30, 0x30, 0xE0, 0x00},
+    {0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+    {0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0x00}
+};
+
+void g_set(int x, int y, int color);	/* part of SVGA */
+
+void
+g_string(int x0, int y0, int color, int angle, char *s)
+{
+    int i, j, k;
+    float sa, ca, x, y;
+    k = 0;
+    x = 0.5 + x0;
+    y = 0.5 + y0;
+    sa = sin(- DEG2RAD * angle);
+    ca = cos(DEG2RAD * angle);
+    while (s[k]) {
+	for (i = 0; i < 8; i++)
+	    for (j = 0; j < 8; j++)
+		g_set(x + ca * j - sa * i, y + ca * i + sa * j, (font[(int) s[k]][i] & (1 << (7 - j))) ? color : 0);
+	k++;
+	x += ca * 8;
+	y += sa * 8;
+    }
+}
+
+/* end of gstring.c */
+
+TERM_PUBLIC void
+EMXVGA_init()
+{
+    if (!g_mode(EMXVGA_vmode)) {
+	fputs("Unable to initiate graphics.\n", stderr);
+	return;
+    }
+    term->xmax = g_xsize;
+    term->ymax = g_ysize;
+    lasty = g_ysize - 1;
+}
+
+TERM_PUBLIC void
+EMXVGA_reset()
+{
+    g_mode(GTEXT);
+    graphics_on = FALSE;
+}
+
+TERM_PUBLIC void
+EMXVGA_text()
+{
+    if (graphics_on) {
+	emx_getch();
+	g_mode(GTEXT);
+	graphics_on = FALSE;
+    }
+}
+
+TERM_PUBLIC void
+EMXVGA_graphics()
+{
+    if (!graphics_on) {
+	g_mode(EMXVGA_vmode);
+	graphics_on = TRUE;
+    }
+}
+
+TERM_PUBLIC void
+EMXVGA_linetype(int linetype)
+{
+    EMXVGA_color = vgacolor[(linetype % 13) + 2];
+}
+
+TERM_PUBLIC void
+EMXVGA_move(unsigned int x, unsigned int y)
+{
+    startx = x;
+    starty = y;
+}
+
+TERM_PUBLIC void
+EMXVGA_vector(unsigned int x, unsigned int y)
+{
+    g_line(startx, lasty - starty, x, lasty - y, EMXVGA_color);
+    startx = x;
+    starty = y;
+}
+
+TERM_PUBLIC int
+EMXVGA_text_angle(int ang)
+{
+    EMXVGA_angle = (ang ? 90 : 0);
+    return (TRUE);
+}
+
+TERM_PUBLIC void
+EMXVGA_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    g_string(x, lasty - y - 3, EMXVGA_color, EMXVGA_angle, str);
+}
+
+TERM_PUBLIC void
+EMXVGA_suspend()
+{
+    if (EMXVGA_buf)
+	free(EMXVGA_buf);	/* do this just for safety */
+    EMXVGA_buf = (char *) malloc(g_memsize);
+    g_save(EMXVGA_buf);
+    emx_getch();
+    g_mode(GTEXT);
+}
+
+TERM_PUBLIC void
+EMXVGA_resume()
+{
+    g_mode(EMXVGA_vmode);
+    g_restore(EMXVGA_buf);
+    free(EMXVGA_buf);
+}
+
+#ifdef EMXVESA
+int emx_vesamode = G640x480x256;
+int emx_xlast, emx_ylast;
+TERM_PUBLIC void
+EMXVESA_options()
+{
+    if (!END_OF_COMMAND) {
+	if (almost_equals(c_token, "d$efault")) {
+	    emx_vesamode = G640x480x256;
+	    c_token++;
+	}
+    }
+    if (!END_OF_COMMAND) {
+	/* We have a vesa mode specified */
+	struct value a;
+	emx_vesamode = (int) real(const_express(&a));
+    }
+    sprintf(term_options, "%d", emx_vesamode);
+}
+
+TERM_PUBLIC void
+EMXVESA_init()
+{
+    if (!g_mode(emx_vesamode))
+	int_error(NO_CARET, "Couldn't select graphics mode");
+    emx_xlast = g_xsize - 1;
+    term->xmax = emx_xlast + 1;
+    emx_ylast = g_ysize - 1;
+    term->ymax = emx_ylast + 1;
+    g_mode(GTEXT);
+}
+
+TERM_PUBLIC void
+EMXVESA_graphics()
+{
+    g_mode(emx_vesamode);
+}
+
+TERM_PUBLIC void
+EMXVESA_text()
+{
+    int ch;
+    ch = getch();
+    g_mode(GTEXT);
+    if (ch == 3)
+	int_error(NO_CARET, "Interrupt");
+}
+
+TERM_PUBLIC void
+EMXVESA_reset()
+{
+}
+
+#endif /* VESA */
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+#ifdef EMXVESA
+TERM_TABLE_START(vesa_driver)
+    "vesa", "IBM PC/Clone with VESA SVGA graphics board [vesa mode]",
+    EMXVGA_XMAX, EMXVGA_YMAX, EMXVGA_VCHAR, EMXVGA_HCHAR,
+    EMXVGA_VTIC, EMXVGA_HTIC, EMXVESA_options, EMXVESA_init, EMXVESA_reset,
+    EMXVESA_text, null_scale, EMXVESA_graphics, EMXVGA_move, EMXVGA_vector,
+    EMXVGA_linetype, EMXVGA_put_text, EMXVGA_text_angle,
+    null_justify_text, do_point, do_arrow, set_font_null
+TERM_TABLE_END(vesa_driver)
+
+#undef LAST_TERM
+#define LAST_TERM vesa_driver
+
+#endif /* VESA */
+
+TERM_TABLE_START(emxvga_driver)
+    "emxvga", "PC with VGA running DOS or OS/2",
+    EMXVGA_XMAX, EMXVGA_YMAX, EMXVGA_VCHAR, EMXVGA_HCHAR,
+    EMXVGA_VTIC, EMXVGA_HTIC, options_null, EMXVGA_init, EMXVGA_reset,
+    EMXVGA_text, null_scale, EMXVGA_graphics, EMXVGA_move,
+    EMXVGA_vector, EMXVGA_linetype, EMXVGA_put_text, EMXVGA_text_angle,
+    null_justify_text, do_point, do_arrow, set_font_null,
+    0,				/* pointsize */
+    TERM_CAN_MULTIPLOT, EMXVGA_suspend, EMXVGA_resume
+TERM_TABLE_END(emxvga_driver)
+
+#undef LAST_TERM
+#define LAST_TERM emxvga_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+#ifdef TERM_HELP
+START_HELP(emxvga)
+"1 emxvga",
+"?commands set terminal emxvga",
+"?set terminal emxvga",
+"?set term emxvga",
+"?terminal emxvga",
+"?term emxvga",
+"?emxvga",
+"?commands set terminal emxvesa",
+"?set terminal emxvesa",
+"?set term emxvesa",
+"?terminal emxvesa",
+"?term emxvesa",
+"?emxvesa",
+"?commands set terminal vgal",
+"?set terminal vgal",
+"?set term vgal",
+"?terminal vgal",
+"?term vgal",
+"?vgal",
+" The `emxvga`, `emxvesa` and `vgal` terminal drivers support PCs with SVGA,",
+" vesa SVGA and VGA graphics boards, respectively.  They are intended to be",
+" compiled with \"emx-gcc\" under either DOS or OS/2.  They also need VESA and",
+" SVGAKIT maintained by Johannes Martin (JMARTIN@GOOFY.ZDV.UNI-MAINZ.DE) with",
+" additions by David J. Liu (liu@phri.nyu.edu).",
+"",
+" Syntax:",
+"       set terminal emxvga",
+"       set terminal emxvesa {vesa-mode}",
+"       set terminal vgal",
+"",
+" The only option is the vesa mode for `emxvesa`, which defaults to G640x480x256."
+END_HELP(emxvga)
+#endif /* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/epson.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/epson.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/epson.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/epson.trm.svn-base	2012-01-03 17:07:28.670328500 -0800
@@ -0,0 +1,1183 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: epson.trm,v 1.25 2008/05/31 20:23:44 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - epson.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *  epson_lx800, nec_cp6, starc,
+ *  epson_60dpi, tandy_60dpi
+ *  epson_180dpi
+ *  dpu414
+ *
+ * AUTHORS
+ *  Russell Lang
+ *  William Wilson
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+
+/*
+ * adapted to the new terminal layout by Stefan Bodewig (1995)
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+#ifdef EPS180
+register_term(epson_180dpi)
+#endif /* EPS180 */
+#ifdef EPS60
+register_term(epson_60dpi)
+#endif /* EPS60 */
+#ifdef EPSONP
+register_term(epson_lx800)
+#endif /* EPSONP */
+#ifdef NEC
+register_term(nec_cp6)
+#endif /* NEC */
+#ifdef OKIDATA
+register_term(okidata)
+#endif /* OKIDATA */
+#ifdef STARC
+register_term(starc)
+#endif /* STARC */
+#ifdef TANDY60
+register_term(tandy_60dpi)
+#endif /* TANDY60 */
+#ifdef DPU414
+register_term(dpu414)
+#endif /* DPU414 */
+#endif /* TERM_REGISTER */
+
+#ifdef TERM_PROTO
+
+TERM_PUBLIC void EPSON_reset __PROTO((void));
+
+#if defined(EPS180) || defined(EPS60) || defined(EPSONP) || defined(TANDY60) || defined(OKIDATA)
+TERM_PUBLIC void EPSON_init __PROTO((void));
+
+#if defined(EPS60) || defined(EPSONP) || defined(TANDY60) || defined(OKIDATA)
+#define EPSONVCHAR		FNT5X9_VCHAR
+#define EPSONHCHAR		FNT5X9_HCHAR
+#define EPSONVTIC		6
+#define EPSONHTIC		6
+
+#ifdef EPSONP
+#define EPSONXMAX	512
+#define EPSONYMAX	384
+TERM_PUBLIC void EPSON_graphics __PROTO((void));
+TERM_PUBLIC void EPSON_text __PROTO((void));
+#endif /* EPSONP */
+#endif /* four drivers */
+#endif /* all five */
+
+#ifdef EPS180
+TERM_PUBLIC void EPS180_graphics __PROTO((void));
+TERM_PUBLIC void EPS180_text __PROTO((void));
+#define EPSON180VCHAR		FNT13X25_VCHAR
+#define EPSON180HCHAR		FNT13X25_HCHAR
+#define EPSON180VTIC		18
+#define EPSON180HTIC		18
+/* make the total dimensions 8 inches by 6 inches */
+#define EPS180XMAX	1260
+#define EPS180YMAX	1080
+#endif /* EPS180 */
+
+#if defined(EPS60) || defined(TANDY60) || defined(OKIDATA)
+/* make the total dimensions 8 inches by 5 inches */
+#define EPS60XMAX	480
+#define EPS60YMAX	360
+TERM_PUBLIC void EPS60_graphics __PROTO((void));
+#ifdef TANDY60
+TERM_PUBLIC void TANDY60_text __PROTO((void));
+#endif /* TANDY60 */
+#ifdef OKIDATA
+TERM_PUBLIC void OKIDATA_text __PROTO((void));
+#endif /* OKIDATA */
+#ifdef EPS60
+TERM_PUBLIC void EPS60_text __PROTO((void));
+#endif /* EPS60 */
+#endif /* all three */
+
+#ifdef NEC
+TERM_PUBLIC void NEC_options __PROTO((void));
+TERM_PUBLIC void NEC_init __PROTO((void));
+TERM_PUBLIC void NEC_graphics __PROTO((void));
+TERM_PUBLIC void NEC_text __PROTO((void));
+TERM_PUBLIC void NEC_linetype __PROTO((int linetype));
+#define NECXMAX	400
+#define NECYMAX	320
+#define NECVCHAR		FNT5X9_VCHAR
+#define NECHCHAR		FNT5X9_HCHAR
+#define NECVTIC		6
+#define NECHTIC		6
+#endif /* NEC */
+
+#ifdef STARC
+TERM_PUBLIC void STARC_init __PROTO((void));
+TERM_PUBLIC void STARC_graphics __PROTO((void));
+TERM_PUBLIC void STARC_text __PROTO((void));
+TERM_PUBLIC void STARC_linetype __PROTO((int linetype));
+#define STARCXMAX	512
+#define STARCYMAX	384
+#define STARCVCHAR		FNT5X9_VCHAR
+#define STARCHCHAR		FNT5X9_HCHAR
+#define STARCVTIC		6
+#define STARCHTIC		6
+#endif /* STARC */
+
+#ifdef DPU414
+TERM_PUBLIC void DPU414_options __PROTO((void));
+TERM_PUBLIC void DPU414_init __PROTO((void));
+TERM_PUBLIC void DPU414_graphics __PROTO((void));
+TERM_PUBLIC void DPU414_text __PROTO((void));
+TERM_PUBLIC void DPU414_setfont __PROTO((void));
+#define DPU414XMAX	(640)
+#define DPU414YMAX	(480)
+#define DPU414VCHAR	FNT5X9_VCHAR
+#define DPU414HCHAR	FNT5X9_HCHAR
+#define DPU414VTIC	FNT5X9_HBITS
+#define DPU414HTIC	FNT5X9_HBITS
+#endif /* DPU414 */
+
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+
+TERM_PUBLIC void
+EPSON_reset()
+{
+#ifdef VMS
+    fflush_binary();
+#endif
+}
+
+
+#ifdef EPSONP
+
+/* The following epson lx800 driver uses generic bit mapped graphics
+   routines to build up a bit map in memory. */
+/* by Russell Lang, rjl@monu1.cc.monash.edu.au */
+/* On PC, print using 'copy file /b lpt1:', do NOT use 'print' */
+/* EPSON_init changes gpoutfile to binary mode on PC's */
+
+static void epson_dump __PROTO((void));
+
+#define EPSONXLAST (EPSONXMAX - 1)
+#define EPSONYLAST (EPSONYMAX - 1)
+
+TERM_PUBLIC void
+EPSON_init()
+{
+}
+
+TERM_PUBLIC void
+EPSON_graphics()
+{
+    b_charsize(FNT5X9);
+    b_makebitmap((unsigned int) (EPSONXMAX * xsize),
+		 (unsigned int) (EPSONYMAX * ysize), 1);
+}
+
+
+TERM_PUBLIC void
+EPSON_text()
+{
+    epson_dump();
+    b_freebitmap();
+}
+
+
+/* output file must be binary mode for epson_dump */
+static void
+epson_dump()
+{
+    register unsigned int x;
+    int j;
+    for (j = (b_ysize / 8) - 1; j >= 0; j--) {
+	/* select plotter graphics mode (square pixels) */
+	fputs("\033J\030", gpoutfile);	/* line feed 8/72" = 8 dots */
+	fputs("\r\033*\005", gpoutfile);
+	(void) fputc((char) (b_xsize % 256), gpoutfile);
+	(void) fputc((char) (b_xsize / 256), gpoutfile);
+	for (x = 0; x < b_xsize; x++) {
+	    (void) fputc((char) (*((*b_p)[j] + x)), gpoutfile);
+	}
+    }
+#ifdef PC
+    fputs("Print using: COPY /B\n", stderr);
+#endif
+}
+
+#endif /* EPSONP */
+
+
+/* The following NEC CP6 Pinwriter driver uses generic bit mapped graphics
+   routines to build up a bit map in memory. */
+/* by Russell Lang, rjl@monu1.cc.monash.edu.au */
+/* On PC, print using 'copy file /b lpt1:', do NOT use 'print' */
+/* NEC_init changes gpoutfile to binary mode for PC's */
+
+/* Add a Monochrome NEC printer (for faster speed and line types) jdc */
+
+#ifdef NEC
+
+static void nec_dump __PROTO((void));
+static void nec_draft_dump __PROTO((void));
+
+#define NECXLAST (NECXMAX - 1)
+#define NECYLAST (NECYMAX - 1)
+
+
+/* plane 0=black, 1=cyan(blue), 2=magenta(red), 3=yellow */
+static unsigned int neccolor[] = { 1, 8, 4, 2, 10, 12, 6, 14 };
+static unsigned int necpcolor[] = { 0, 2, 1, 4 };
+
+static int NECmode;
+
+enum NEC_id { NEC_MONOCHROME, NEC_COLOR, NEC_DRAFT, NEC_OTHER };
+
+static struct gen_table NEC_opts[] =
+{
+    { "m$onochrome", NEC_MONOCHROME },
+    { "c$olor", NEC_COLOR },
+    { "c$olour", NEC_COLOR },
+    { "d$raft", NEC_DRAFT },
+    { NULL, NEC_OTHER }
+};
+
+TERM_PUBLIC void
+NEC_options()
+{
+    /* default */
+    if (END_OF_COMMAND) {
+	strcpy(term_options, "monochrome");
+	NECmode = 'm';
+    }
+
+    while (!END_OF_COMMAND) {
+	switch(lookup_table(&NEC_opts[0],c_token)) {
+	case NEC_MONOCHROME:
+	    c_token++;
+	    strcpy(term_options, "monochrome");
+	    NECmode = 'm';
+	    break;
+	case NEC_COLOR:
+	    c_token++;
+	    strcpy(term_options, "color");
+	    NECmode = 'c';
+ 	    break;
+	case NEC_DRAFT:
+	    c_token++;
+	    strcpy(term_options, "draft");
+	    NECmode = 'd';
+	    break;
+	case NEC_OTHER:
+	default:
+	    /* FIXME - not the most sensible thing to do */
+	    /* error, but since the terminal is already set, default to mono */
+	    strcpy(term_options, "monochrome");
+	    NECmode = 'm';
+	    int_error(c_token, "modes: color, monochrome, draft");
+	    break;
+	}
+    }
+
+}
+
+TERM_PUBLIC void
+NEC_init()
+{
+}
+
+TERM_PUBLIC void
+NEC_graphics()
+{
+    b_charsize(FNT5X9);
+    b_makebitmap((unsigned int) (NECXMAX * xsize),
+		 (unsigned int) (NECYMAX * ysize), (NECmode == 'c' ? 4 : 1));
+}
+
+TERM_PUBLIC void
+NEC_text()
+{
+    if (NECmode == 'd') {
+	nec_draft_dump();
+    } else {
+	nec_dump();
+    }
+    b_freebitmap();
+}
+
+TERM_PUBLIC void
+NEC_linetype(int linetype)
+{
+    if (NECmode == 'c') {
+	if (linetype >= 6)
+	    linetype %= 6;
+	b_setvalue(neccolor[linetype + 2]);
+    } else {
+	b_setlinetype(linetype);
+    }
+}
+
+
+
+/* output file must be binary mode for nec_dump */
+static void
+nec_dump()
+{
+    unsigned int x;
+    unsigned int plane, offset;
+    int j;
+    unsigned int column8;
+    unsigned long column24;
+    char column3, column2, column1;
+    fputs("\033P\033l\005", gpoutfile);	/* 10cpi, left margin 5 char */
+    for (j = (b_ysize / 8) - 1; j >= 0; j--) {
+	fputs("\033J\030", gpoutfile);	/* 24/180" line feed */
+	for (plane = 0; plane < b_planes; plane++) {
+	    offset = plane * b_psize;
+	    if (b_planes > 1) {
+		/* select colour for plane */
+		fputs("\033r", gpoutfile);
+		(void) fputc((char) necpcolor[plane], gpoutfile);
+	    }
+	    /* select plotter graphics mode (square pixels) */
+	    fputs("\r\033*\047", gpoutfile);
+	    (void) fputc((char) ((b_xsize * 3) % 256), gpoutfile);
+	    (void) fputc((char) ((b_xsize * 3) / 256), gpoutfile);
+	    for (x = 0; x < b_xsize; x++) {
+		column8 = (unsigned int) (*((*b_p)[j + offset] + x));
+		column24 = 0;
+		if (column8 & 0x01)
+		    column24 |= (long) 0x000007;
+		if (column8 & 0x02)
+		    column24 |= (long) 0x000038;
+		if (column8 & 0x04)
+		    column24 |= (long) 0x0001c0;
+		if (column8 & 0x08)
+		    column24 |= (long) 0x000e00;
+		if (column8 & 0x10)
+		    column24 |= (long) 0x007000;
+		if (column8 & 0x20)
+		    column24 |= (long) 0x038000;
+		if (column8 & 0x40)
+		    column24 |= (long) 0x1c0000;
+		if (column8 & 0x80)
+		    column24 |= (long) 0xe00000;
+		column1 = (char) (column24 & (long) 0xff);
+		column2 = (char) ((column24 >> 8) & (long) 0xff);
+		column3 = (char) ((column24 >> 16) & (long) 0xff);
+		(void) fputc(column3, gpoutfile);
+		(void) fputc(column2, gpoutfile);
+		(void) fputc(column1, gpoutfile);
+		(void) fputc(column3, gpoutfile);
+		(void) fputc(column2, gpoutfile);
+		(void) fputc(column1, gpoutfile);
+		(void) fputc(column3, gpoutfile);
+		(void) fputc(column2, gpoutfile);
+		(void) fputc(column1, gpoutfile);
+	    }
+	}
+    }
+    fputs("\r\033l", gpoutfile);
+    (void) fputc('\0', gpoutfile);	/* set left margin to 0 */
+    if (b_planes > 1) {
+	fprintf(gpoutfile, "\033r");
+	(void) fputc('\0', gpoutfile);	/* set color to black */
+    }
+#ifdef PC
+    fputs("Print using: COPY /B\n", stderr);
+#endif
+#ifdef VMS
+    fflush_binary();
+#endif
+}
+
+/* output file must be binary mode for nec_dump */
+static void
+nec_draft_dump()
+{
+    unsigned int x;
+    unsigned int plane, offset;
+    int j;
+    fputs("\033P\033l\005\r", gpoutfile);	/* 10cpi, left margin 5 char */
+    for (j = (b_ysize / 8) - 1; j >= 0; j--) {
+	fputs("\033J\030", gpoutfile);	/* 24/180" line feed */
+	for (plane = 0; plane < b_planes; plane++) {
+	    offset = plane * b_psize;
+	    if (b_planes > 1) {
+		/* select colour for plane */
+		fputs("\033r", gpoutfile);
+		(void) fputc((char) necpcolor[plane], gpoutfile);
+	    }
+	    /* select plotter graphics mode (square pixels) */
+	    fputs("\r\033*", gpoutfile);
+	    (void) fputc('\0', gpoutfile);
+	    (void) fputc((char) (b_xsize % 256), gpoutfile);
+	    (void) fputc((char) (b_xsize / 256), gpoutfile);
+	    for (x = 0; x < b_xsize; x++) {
+		(void) fputc((char) (*((*b_p)[j + offset] + x)), gpoutfile);
+	    }
+	}
+    }
+    fputs("\r\033l", gpoutfile);
+    (void) fputc('\0', gpoutfile);	/* set left margin to 0 */
+    if (b_planes > 1) {
+	fputs("\033r", gpoutfile);
+	(void) fputc('\0', gpoutfile);	/* set color to black */
+    }
+#ifdef PC
+    fputs("Print using: COPY /B\n", gpoutfile);
+#endif
+}
+
+#endif /* NEC */
+
+#ifdef STARC
+/* The following Star color driver uses generic bit mapped graphics
+   routines to build up a bit map in memory. */
+/* Star Color changes made by William Wilson, wew@naucse.cse.nau.edu */
+/* On PC, print using 'copy file /b lpt1:', do NOT use 'print' */
+/* STARC_init changes gpoutfile to binary mode on PC's */
+
+static void STARC_dump __PROTO((void));
+
+#define STARCXLAST (STARCXMAX - 1)
+#define STARCYLAST (STARCYMAX - 1)
+
+
+/* plane 0=black, 1=cyan(blue), 2=magenta(red), 3=yellow */
+static unsigned int STARCcolor[] = { 1, 8, 4, 2, 10, 12, 6, 14 };
+static unsigned int STARCpcolor[] = { 0, 2, 1, 4 };
+
+TERM_PUBLIC void
+STARC_init()
+{
+}
+
+TERM_PUBLIC void
+STARC_graphics()
+{
+    b_charsize(FNT5X9);
+    b_makebitmap((unsigned int) (STARCXMAX * xsize),
+		 (unsigned int) (STARCYMAX * ysize), 4);
+}
+
+
+TERM_PUBLIC void
+STARC_text()
+{
+    STARC_dump();
+    b_freebitmap();
+}
+
+TERM_PUBLIC void
+STARC_linetype(int linetype)
+{
+    if (linetype >= 6)
+	linetype %= 6;
+    b_setvalue(STARCcolor[linetype + 2]);
+}
+
+
+
+/* output file must be binary mode for STARC_dump */
+static void
+STARC_dump()
+{
+    unsigned int x;
+    unsigned int plane, offset;
+    int j;
+    for (j = (b_ysize / 8) - 1; j >= 0; j--) {
+	fputs("\033J\030", gpoutfile);	/* line feed 8/72" = 8 dots */
+	for (plane = 0; plane < b_planes; plane++) {
+	    offset = plane * b_psize;
+	    if (b_planes > 1) {
+		/* select colour for plane */
+		fputs("\033r", gpoutfile);
+		(void) fputc((char) STARCpcolor[plane], gpoutfile);
+	    }
+	    /* select plotter graphics mode (square pixels) */
+	    fputs("\r\033*\005", gpoutfile);
+	    (void) fputc((char) (b_xsize % 256), gpoutfile);
+	    (void) fputc((char) (b_xsize / 256), gpoutfile);
+	    for (x = 0; x < b_xsize; x++) {
+		(void) fputc((char) (*((*b_p)[j + offset] + x)), gpoutfile);
+	    }
+	}
+    }
+    if (b_planes > 1) {
+	fputs("\033r", gpoutfile);
+	(void) fputc('\0', gpoutfile);	/* set color to black */
+    }
+#ifdef PC
+    fputs("Print using: COPY /B\n", stderr);
+#endif
+}
+
+#endif /* STARC */
+
+
+#ifdef EPS180
+
+static void eps180_dump __PROTO((void));
+
+#define EPS180XLAST (EPS180XMAX - 1)
+#define EPS180YLAST (EPS180YMAX - 1)
+
+TERM_PUBLIC void
+EPS180_graphics()
+{
+    b_charsize(FNT13X25);
+    b_makebitmap((unsigned int) (EPS180XMAX * xsize),
+		 (unsigned int) (EPS180YMAX * ysize), 1);
+}
+
+
+TERM_PUBLIC void
+EPS180_text()
+{
+    eps180_dump();
+    b_freebitmap();
+}
+
+
+
+/* output file must be binary mode for eps180_dump */
+static void
+eps180_dump()
+{
+    register unsigned int x;
+    int j;
+
+    /* reset, set line spacing to 24/180", and move left margin */
+    fputs("\033@\033+\060\033l\005", gpoutfile);
+    for (j = (b_ysize / 8) - 1; j >= 0;) {
+	/* select printer graphics mode '39' */
+	fputs("\r\n\033*'", gpoutfile);
+	(void) fputc((char) (b_xsize % 256), gpoutfile);
+	(void) fputc((char) (b_xsize / 256), gpoutfile);
+	for (x = 0; x < b_xsize; x++) {
+	    (void) fputc((char) (*((*b_p)[j] + x)), gpoutfile);
+	    (void) fputc((char) (*((*b_p)[j - 1] + x)), gpoutfile);
+	    (void) fputc((char) (*((*b_p)[j - 2] + x)), gpoutfile);
+	}
+	j -= 3;
+    }
+    fputs("\r\n\033@\r\n", gpoutfile);	/* reset printer */
+#ifdef PC
+    fputs("Print using: COPY /B\n", stderr);
+#endif
+}
+
+#endif /* EPS180 */
+
+#ifdef EPS60
+
+static void eps60_dump __PROTO((void));
+
+#define EPS60XLAST (EPS60XMAX - 1)
+#define EPS60YLAST (EPS60YMAX - 1)
+
+TERM_PUBLIC void
+EPS60_graphics()
+{
+    b_charsize(FNT5X9);
+    b_makebitmap((unsigned int) (EPS60XMAX * xsize),
+		 (unsigned int) (EPS60YMAX * ysize), 1);
+}
+
+
+TERM_PUBLIC void
+EPS60_text()
+{
+    eps60_dump();
+    b_freebitmap();
+}
+
+
+
+/* output file must be binary mode for eps60_dump */
+static void
+eps60_dump()
+{
+    register unsigned int x;
+    int j;
+    fprintf(gpoutfile, "\033%c\030", '3');	/* set line spacing 24/216" = 8 dots */
+    for (j = (b_ysize / 8) - 1; j >= 0; j--) {
+	/* select printer graphics mode 'K' */
+	fputs("\r\n\033K", gpoutfile);
+	(void) fputc((char) (b_xsize % 256), gpoutfile);
+	(void) fputc((char) (b_xsize / 256), gpoutfile);
+	for (x = 0; x < b_xsize; x++) {
+	    (void) fputc((char) (*((*b_p)[j] + x)), gpoutfile);
+	}
+    }
+    fprintf(gpoutfile, "\033%c\044\r\n", '3');	/* set line spacing 36/216" = 1/6" */
+#ifdef PC
+    fputs("Print using: COPY /B\n", stderr);
+#endif
+}
+
+#endif /* EPS60 */
+
+#ifdef TANDY60
+
+/* The only difference between TANDY60 and EPS60 is the inclusion
+   of codes to swap the Tandy printer into IBM mode and back
+   into Tandy mode.  For a Tandy already in IBM mode, use EPS60. */
+
+
+TERM_PUBLIC void
+TANDY60_text()
+{
+#ifdef PC
+    fputs("Inserting Tandy/IBM mode conversion codes\n", stderr);
+#endif
+    /* Switch to IBM mode, and leave 3 inches above the plot so as
+       to get rough vertical centring on the page.  Perform the
+       centring by setting 1" line feeds and issuing 3 of them. */
+    fprintf(gpoutfile, "\033!\033%c%c\n\n\n", '3', 216);
+    eps60_dump();
+    b_freebitmap();
+    /* A form feed must be sent before switching back to Tandy mode,
+       or else the form setting will be messed up. */
+    fputs("\f\033!", gpoutfile);
+}
+
+
+#endif /* TANDY60 */
+
+#ifdef OKIDATA
+
+static void okidata_dump __PROTO((void));
+
+TERM_PUBLIC void
+OKIDATA_text()
+{
+    okidata_dump();
+    b_freebitmap();
+}
+
+static int OKIDATAbitrev_tbl[] =
+{
+    0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
+    0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
+    0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
+    0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
+    0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
+    0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
+    0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
+    0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
+    0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
+    0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
+    0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
+    0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
+    0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
+    0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
+    0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
+    0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
+    0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
+    0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
+    0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
+    0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
+    0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
+    0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
+    0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
+    0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
+    0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
+    0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
+    0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
+    0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
+    0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
+    0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
+    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
+    0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff
+};
+
+/* output file must be binary mode for okidata_dump */
+static void
+okidata_dump()
+{
+    register unsigned int x;
+    int j;
+    char cur_char;
+    int prev_char;
+
+    prev_char = 0;
+    /* set line spacing 16/144" = 8 dots, turn on single density
+     * graphics mode: */
+    fprintf(gpoutfile, "\033%c%c\020\033*eP:\003", '%', '9');
+    for (j = (b_ysize / 8) - 1; j >= 0; j--) {
+	fputs("\003\016", gpoutfile);
+/*		(void) fputc((char)(b_xsize%256),gpoutfile); */
+/*		(void) fputc((char)(b_xsize/256),gpoutfile); */
+	for (x = 0; x < b_xsize; x++) {
+	    if ((cur_char = (char)
+		 (OKIDATAbitrev_tbl[(int) (*((*b_p)[j] + x))])) == '\003') {
+		fputs("\003\003", gpoutfile);
+	    } else {
+		(void) fputc((char) cur_char, gpoutfile);
+	    }
+	}
+    }
+    fprintf(gpoutfile, "\003\002\033%c%c\030\r\n", '%', '9');	/* Turned off graphics mode: set line spacing 24/144" = 1/6" */
+#ifdef PC
+    fputs("Print using: COPY /B\n", stderr);
+#endif
+}
+
+#endif /* OKIDATA */
+
+#ifdef DPU414
+
+static void DPU414_dump __PROTO((void));
+
+static int DPU414_font = 2; /* medium font */
+static int DPU414_quality = 1; /* normal */
+
+enum DPU414_id {
+	DPU414_SMALL, DPU414_MEDIUM, DPU414_LARGE,
+	DPU414_NORMAL, DPU414_DRAFT,
+	DPU414_OTHER
+};
+
+static struct gen_table DPU414_opts[] =
+{
+	{ "s$mall", DPU414_SMALL },
+	{ "m$edium", DPU414_MEDIUM },
+	{ "l$arge", DPU414_LARGE },
+	{ "n$ormal", DPU414_NORMAL },
+	{ "d$raft", DPU414_DRAFT },
+	{ NULL, DPU414_OTHER }
+};
+
+TERM_PUBLIC void
+DPU414_options()
+{
+	DPU414_font = 2;
+	DPU414_quality = 1;
+	term_options[0] = NUL;
+
+	while (!END_OF_COMMAND) {
+		switch(lookup_table(&DPU414_opts[0],c_token)) {
+			case DPU414_SMALL:
+				DPU414_font = 1;
+				c_token++;
+				break;
+			case DPU414_MEDIUM:
+				DPU414_font = 2;
+				c_token++;
+				break;
+			case DPU414_LARGE:
+				DPU414_font = 3;
+				c_token++;
+				break;
+			case DPU414_NORMAL:
+				DPU414_quality = 1;
+				c_token++;
+				break;
+			case DPU414_DRAFT:
+				DPU414_quality = 2;
+				c_token++;
+				break;
+			case DPU414_OTHER:
+			default:
+				/* reset to default, since term is already set */
+				DPU414_font = 2;
+				DPU414_quality = 1;
+				int_error(c_token, "expecting: {small, medium, large} {normal, draft}");
+				break;
+		}
+	}
+
+	term->v_tic = (term->xmax < term->ymax) ? term->xmax/100 : term->ymax/100;
+	if (term->v_tic < 1)
+		term->v_tic = 1;
+	term->h_tic = term->v_tic;
+
+	/* setup options string */
+	switch (DPU414_font) {
+		case 1:
+			strcat(term_options, "small");
+			break;
+		case 2:
+			strcat(term_options, "medium");
+			break;
+		case 3:
+			strcat(term_options, "large");
+			break;
+	}
+	switch (DPU414_quality) {
+		case 1:
+			strcat(term_options, " normal");
+			term->xmax = DPU414XMAX;
+			term->ymax = DPU414YMAX;
+			break;
+		case 2:
+			strcat(term_options, " draft");
+			term->xmax = DPU414XMAX / 2;
+			term->ymax = DPU414YMAX / 2;
+			break;
+	}
+}
+
+TERM_PUBLIC void
+DPU414_init()
+{
+	DPU414_setfont();
+}
+
+TERM_PUBLIC void
+DPU414_setfont()
+{
+	switch (DPU414_font) {
+	case 1:
+		b_charsize(FNT5X9);
+		term->v_char = FNT5X9_VCHAR;
+		term->h_char = FNT5X9_HCHAR;
+		break;
+	case 2:
+		b_charsize(FNT9X17);
+		term->v_char = FNT9X17_VCHAR;
+		term->h_char = FNT9X17_HCHAR;
+		break;
+	case 3:
+		b_charsize(FNT13X25);
+		term->v_char = FNT13X25_VCHAR;
+		term->h_char = FNT13X25_HCHAR;
+		break;
+	}
+}
+
+TERM_PUBLIC void
+DPU414_graphics()
+{
+	switch (DPU414_quality) {
+	case 1:
+		b_makebitmap((unsigned int) (DPU414XMAX * xsize),
+		             (unsigned int) (DPU414YMAX * ysize), 1);
+		break;
+	case 2:
+		term->xmax = DPU414XMAX / 2;
+		term->ymax = DPU414YMAX / 2;
+		b_makebitmap((unsigned int) (DPU414XMAX / 2 * xsize),
+		             (unsigned int) (DPU414YMAX / 2 * ysize), 1);
+		break;
+	}
+}
+
+TERM_PUBLIC void
+DPU414_text()
+{
+	DPU414_dump();
+	b_freebitmap();
+}
+
+static void
+DPU414_dump()
+{
+	register unsigned int x;
+	int j;
+
+	fputs("\r", gpoutfile);	/* carriage return */
+	fprintf(gpoutfile, "\033%c", 'U');	/* unidirectional printing */
+	(void) fputc((char) 0, gpoutfile);
+
+	switch (DPU414_quality) {
+	case 1:
+		for (j = (b_ysize / 8) - 1; j >= 0; j-=2) {
+			/* select 120-dpi, emulated 16-pin printer graphics mode */
+			/* in reality it's 640/(89.6mm/25.4mm) = 181 dpi = appr. 180 dpi */
+			fputs("\033^\001", gpoutfile);
+			(void) fputc((char) (b_xsize % 256), gpoutfile);
+			(void) fputc((char) (b_xsize / 256), gpoutfile);
+			for (x = 0; x < b_xsize; x++) {
+				(void) fputc((char) (*((*b_p)[j] + x)), gpoutfile);
+				(void) fputc((char) (*((*b_p)[j-1] + x)), gpoutfile);
+			}
+			fprintf(gpoutfile, "\033%c\x10\r", 'J');	/* advance 16 halfdots, carriage return */
+		}
+		break;
+	case 2:
+		for (j = (b_ysize / 8) - 1; j >= 0; j--) {
+			/* select 60-dpi, 8-pin printer graphics mode */
+			/* in reality it's 320/(89.6mm/25.4mm) = 91 dpi = appr. 90 dpi */
+			fputs("\033K", gpoutfile);
+			(void) fputc((char) (b_xsize % 256), gpoutfile);
+			(void) fputc((char) (b_xsize / 256), gpoutfile);
+			for (x = 0; x < b_xsize; x++) {
+				(void) fputc((char) (*((*b_p)[j] + x)), gpoutfile);
+			}
+			fprintf(gpoutfile, "\033%c\x10\r", 'J');	/* advance 16 halfdots, carriage return */
+		}
+		break;
+	}
+	fputs("\r\n\033@\r\n", gpoutfile);	/* reset printer */
+#ifdef PC
+	fputs("Print using: COPY /B\n", stderr);
+#endif
+}
+
+#endif /* DPU414 */
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+#ifdef EPS180
+TERM_TABLE_START(epson180_driver)
+    "epson_180dpi", "Epson LQ-style 180-dot per inch (24 pin) printers",
+    EPS180XMAX, EPS180YMAX, EPSON180VCHAR, EPSON180HCHAR,
+    EPSON180VTIC, EPSON180HTIC, options_null, EPSON_init, EPSON_reset,
+    EPS180_text, null_scale, EPS180_graphics, b_move, b_vector,
+    b_setlinetype, b_put_text, b_text_angle,
+    null_justify_text, do_point, do_arrow, set_font_null, 0, TERM_BINARY,
+    0, 0, b_boxfill
+TERM_TABLE_END(epson180_driver)
+
+#undef LAST_TERM
+#define LAST_TERM epson180_driver
+#endif /* EPS180 */
+
+#ifdef EPS60
+TERM_TABLE_START(epson60_driver)
+    "epson_60dpi", "Epson-style 60-dot per inch printers",
+    EPS60XMAX, EPS60YMAX, EPSONVCHAR, EPSONHCHAR,
+    EPSONVTIC, EPSONHTIC, options_null, EPSON_init, EPSON_reset,
+    EPS60_text, null_scale, EPS60_graphics, b_move, b_vector,
+    b_setlinetype, b_put_text, b_text_angle,
+    null_justify_text, do_point, do_arrow, set_font_null, 0, TERM_BINARY,
+    0, 0, b_boxfill
+TERM_TABLE_END(epson60_driver)
+
+#undef LAST_TERM
+#define LAST_TERM epson60_driver
+#endif /* EPS60 */
+
+#ifdef EPSONP
+TERM_TABLE_START(epsonlx_driver)
+    "epson_lx800", "Epson LX-800, Star NL-10, NX-1000, PROPRINTER ...",
+    EPSONXMAX, EPSONYMAX, EPSONVCHAR, EPSONHCHAR,
+    EPSONVTIC, EPSONHTIC, options_null, EPSON_init, EPSON_reset,
+    EPSON_text, null_scale, EPSON_graphics, b_move, b_vector,
+    b_setlinetype, b_put_text, b_text_angle,
+    null_justify_text, line_and_point, do_arrow, set_font_null, 0, TERM_BINARY,
+    0, 0, b_boxfill
+TERM_TABLE_END(epsonlx_driver)
+
+#undef LAST_TERM
+#define LAST_TERM epsonlx_driver
+#endif /* EPSONP */
+
+#ifdef NEC
+    TERM_TABLE_START(nec_driver)
+    "nec_cp6", "NEC printer CP6, Epson LQ-800 [monocrome color draft]",
+    NECXMAX, NECYMAX, NECVCHAR, NECHCHAR,
+    NECVTIC, NECHTIC, NEC_options, NEC_init, EPSON_reset,
+    NEC_text, null_scale, NEC_graphics, b_move, b_vector,
+    NEC_linetype, b_put_text, b_text_angle,
+    null_justify_text, line_and_point, do_arrow, set_font_null, 0, TERM_BINARY,
+    0, 0, b_boxfill
+TERM_TABLE_END(nec_driver)
+
+#undef LAST_TERM
+#define LAST_TERM nec_driver
+#endif /* NEC */
+
+#ifdef OKIDATA
+TERM_TABLE_START(okidata_driver)
+    "okidata", "OKIDATA 320/321 Standard",
+    EPS60XMAX, EPS60YMAX, EPSONVCHAR, EPSONHCHAR,
+    EPSONVTIC, EPSONHTIC, options_null, EPSON_init, EPSON_reset,
+    OKIDATA_text, null_scale, EPS60_graphics, b_move, b_vector,
+    b_setlinetype, b_put_text, b_text_angle,
+    null_justify_text, do_point, do_arrow, set_font_null, 0, TERM_BINARY,
+    0, 0, b_boxfill
+TERM_TABLE_END(okidata_driver)
+
+#undef LAST_TERM
+#define LAST_TERM okidata_driver
+#endif /* OKIDATA */
+
+#ifdef STARC
+TERM_TABLE_START(starc_driver)
+    "starc", "Star Color Printer",
+    STARCXMAX, STARCYMAX, STARCVCHAR, STARCHCHAR,
+    STARCVTIC, STARCHTIC, options_null, STARC_init, EPSON_reset,
+    STARC_text, null_scale, STARC_graphics, b_move, b_vector,
+    STARC_linetype, b_put_text, b_text_angle,
+    null_justify_text, line_and_point, do_arrow, set_font_null, 0, TERM_BINARY,
+    0, 0, b_boxfill
+TERM_TABLE_END(starc_driver)
+
+#undef LAST_TERM
+#define LAST_TERM starc_driver
+#endif /* STARC */
+
+#ifdef TANDY60
+TERM_TABLE_START(tandy60_driver)
+    "tandy_60dpi", "Tandy DMP-130 series 60-dot per inch graphics",
+    EPS60XMAX, EPS60YMAX, EPSONVCHAR, EPSONHCHAR,
+    EPSONVTIC, EPSONHTIC, options_null, EPSON_init, EPSON_reset,
+    TANDY60_text, null_scale, EPS60_graphics, b_move, b_vector,
+    b_setlinetype, b_put_text, b_text_angle,
+    null_justify_text, do_point, do_arrow, set_font_null, 0, TERM_BINARY,
+    0, 0, b_boxfill
+TERM_TABLE_END(tandy60_driver)
+
+#undef LAST_TERM
+#define LAST_TERM tandy60_driver
+#endif /* TANDY60 */
+
+#ifdef DPU414
+TERM_TABLE_START(dpu414_driver)
+    "dpu414", "Seiko DPU-414 thermal printer [small medium large]",
+    DPU414XMAX, DPU414YMAX, DPU414VCHAR, DPU414HCHAR,
+    DPU414VTIC, DPU414HTIC, DPU414_options, DPU414_init, EPSON_reset,
+    DPU414_text, null_scale, DPU414_graphics, b_move, b_vector,
+    b_setlinetype, b_put_text, b_text_angle,
+    null_justify_text, line_and_point, do_arrow, set_font_null, 0, TERM_BINARY,
+    0, 0, b_boxfill
+TERM_TABLE_END(dpu414_driver)
+
+#undef LAST_TERM
+#define LAST_TERM dpu414_driver
+#endif /* DPU414 */
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(epson_180dpi)
+"1 epson_180dpi",
+"?commands set terminal epson_180dpi",
+"?set terminal epson_180dpi",
+"?set term epson_180dpi",
+"?terminal epson_180dpi",
+"?term epson_180dpi",
+"?epson_180dpi",
+"?commands set terminal epson_60dpi",
+"?set terminal epson_60dpi",
+"?set term epson_60dpi",
+"?terminal epson_60dpi",
+"?term epson_60dpi",
+"?epson_60dpi",
+"?commands set terminal epson_lx800",
+"?set terminal epson_lx800",
+"?set term epson_lx800",
+"?terminal epson_lx800",
+"?term epson_lx800",
+"?epson_lx800",
+"?commands set terminal nec_cp6",
+"?set terminal nec_cp6",
+"?set term nec_cp6",
+"?terminal nec_cp6",
+"?term nec_cp6",
+"?nec_cp6",
+"?commands set terminal okidata",
+"?set terminal okidata",
+"?set term okidata",
+"?terminal okidata",
+"?term okidata",
+"?okidata",
+"?commands set terminal starc",
+"?set terminal starc",
+"?set term starc",
+"?terminal starc",
+"?term starc",
+"?starc",
+"?commands set terminal tandy_60dpi",
+"?set terminal tandy_60dpi",
+"?set term tandy_60dpi",
+"?terminal tandy_60dpi",
+"?term tandy_60dpi",
+"?tandy_60dpi",
+"?commands set terminal dpu414",
+"?set terminal dpu414",
+"?set term dpu414",
+"?terminal dpu414",
+"?term dpu414",
+"?dpu414",
+" This driver supports a family of Epson printers and derivatives.",
+"",
+" `epson_180dpi` and `epson_60dpi` are drivers for Epson LQ-style 24-pin",
+" printers with resolutions of 180 and 60 dots per inch, respectively.",
+"",
+" `epson_lx800` is a generic 9-pin driver appropriate for printers like the",
+" Epson LX-800, the Star NL-10 and NX-1000, the PROPRINTER, and so forth.",
+"",
+" `nec_cp6` is generic 24-pin driver that can be used for printers like the",
+" NEC CP6 and the Epson LQ-800.",
+"",
+" The `okidata` driver supports the 9-pin OKIDATA 320/321 Standard printers.",
+"",
+" The `starc` driver is for the Star Color Printer.",
+"",
+" The `tandy_60dpi` driver is for the Tandy DMP-130 series of 9-pin, 60-dpi",
+" printers.",
+"",
+" The `dpu414` driver is for the Seiko DPU-414 thermal printer.",
+"",
+" `nec_cp6` has the options:",
+"",
+" Syntax:",
+"       set terminal nec_cp6 {monochrome | colour | draft}",
+"",
+" which defaults to monochrome.",
+"",
+" `dpu414` has the options:",
+"",
+" Syntax:",
+"       set terminal dpu414 {small | medium | large} {normal | draft}",
+"",
+" which defaults to medium (=font size) and normal.",
+" Preferred combinations are `medium normal` and `small draft`.",
+#ifdef MSDOS
+"",
+" With each of these drivers, a binary copy is required on a PC to print.",
+" Do not use `print`---use instead `copy file /b lpt1:`.",
+#endif
+""
+END_HELP(epson_180dpi)
+#endif /* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/estimate.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/estimate.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/estimate.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/estimate.trm.svn-base	2012-01-03 17:07:28.893908300 -0800
@@ -0,0 +1,182 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: estimate.trm,v 1.8 2009/03/26 00:49:20 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - estimate.trm */
+
+/*
+ * This file is included by ../src/term.c via term.h.
+ *
+ * This terminal driver supports:
+ *   On return from ENHest_put_text()
+ *	(*term)->xmax = estimated string width
+ *	(*term)->ymax = estimated string height (in tenths of a character height)
+ *
+ * AUTHORS
+ *
+ *   Ethan A Merritt - Dec 2004
+ *
+ */
+#include "driver.h"
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void ENHest_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
+TERM_PUBLIC void ENHest_OPEN __PROTO((char * fontname, double fontsize,
+	                            double base, TBOOLEAN widthflag, TBOOLEAN showflag,
+				    int overprint));
+TERM_PUBLIC void ENHest_FLUSH __PROTO((void));
+#endif /* TERM_PROTO */
+
+#ifdef TERM_BODY
+
+static double ENHest_x, ENHest_y;
+static double ENHest_xsave, ENHest_ysave;
+static double ENHest_fragment_width;
+static double ENHest_fontsize;
+static double ENHest_min_height, ENHest_max_height;
+static double ENHest_total_width;
+
+static TBOOLEAN ENHest_opened_string;
+static TBOOLEAN ENHest_show = TRUE;
+static int ENHest_overprint = 0;
+static TBOOLEAN ENHest_widthflag = TRUE;
+#define ENHest_font ""
+static double ENHest_base;
+
+TERM_PUBLIC void
+ENHest_OPEN(
+    char *fontname,
+    double fontsize, double base,
+    TBOOLEAN widthflag, TBOOLEAN showflag,
+    int overprint)
+{
+    /* There are two special cases:
+     * overprint = 3 means save current position
+     * overprint = 4 means restore saved position
+     */
+    if (overprint == 3) {
+	ENHest_xsave = ENHest_x;
+	ENHest_ysave = ENHest_y;
+	return;
+    } else if (overprint == 4) {
+	ENHest_x = ENHest_xsave;
+	ENHest_y = ENHest_ysave;
+	return;
+    }
+
+    if (!ENHest_opened_string) {
+	ENHest_opened_string = TRUE;
+	/* Start new text fragment */
+	    ENHest_fragment_width = 0;
+	/* font size will be used to estimate width of each character */
+	    ENHest_fontsize = fontsize > 2.0 ? 1.0 : fontsize;
+	/* Scale fractional font height */
+	    ENHest_base = base * 1.0;
+	    if (ENHest_max_height < ENHest_base+1.0*fontsize)
+		ENHest_max_height = ENHest_base+1.0*fontsize;
+	    if (ENHest_min_height > ENHest_base)
+		ENHest_min_height = ENHest_base;
+	    FPRINTF((stderr,"ENHest_OPEN: base %g fontsize %g  min %g max %g\n",
+	    	    base,fontsize,ENHest_min_height,ENHest_max_height));
+	/* Keep track of whether we are supposed to show this string */
+	    ENHest_show = showflag;
+	/* 0/1/2  no overprint / 1st pass / 2nd pass */
+	    ENHest_overprint = overprint;
+	/* widthflag FALSE means do not update text position after printing */
+	    ENHest_widthflag = widthflag;
+    }
+}
+
+TERM_PUBLIC void
+ENHest_FLUSH()
+{
+    double len = ENHest_fragment_width;
+
+    if (ENHest_opened_string) {
+	ENHest_fragment_width = 0;
+
+	if (!ENHest_widthflag)
+	    /* don't update position */
+	    ;
+	else if (ENHest_overprint == 1)
+	    /* First pass of overprint, leave position in center of fragment */
+	    ENHest_x += len / 2;
+	else
+	    /* Normal case is to update position to end of fragment */
+	    ENHest_x += len;
+
+	ENHest_total_width = GPMAX(ENHest_total_width, ENHest_x);
+	ENHest_opened_string = FALSE;
+    }
+}
+
+TERM_PUBLIC void
+ENHest_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    /* Set up global variables needed by enhanced_recursion() */
+    ENHest_fontsize  = 1.0;
+    ENHest_opened_string = FALSE;
+    ENHest_max_height = 1.0;
+    ENHest_min_height = 0.0;
+    ENHest_total_width = 0.0;
+
+    /* If no enhanced text processing is needed, strlen() is sufficient */
+    if (ignore_enhanced_text || !strpbrk(str, "{}^_@&~\n")) {
+	term->xmax = strlen(str);
+	term->ymax = 10;
+	return;
+    }
+
+    ENHest_x = x;
+    ENHest_y = y;
+
+    while (*(str = enhanced_recursion((char *)str, TRUE,
+    			ENHest_font, ENHest_fontsize,
+			0.0, TRUE, TRUE, 0))) {
+	(term->enhanced_flush)();
+
+	enh_err_check(str);
+	if (!*++str)
+	    break; /* end of string */
+    }
+
+    if (ENHest_x > 0.0 && ENHest_x < 1.0)
+	ENHest_x = 1;
+    term->xmax = ENHest_total_width;
+    term->ymax = 10. * (ENHest_max_height - ENHest_min_height) + 0.5;
+}
+
+TERM_PUBLIC void
+ENHest_writec(int c)
+{
+    if (c == '\n') {
+	ENHest_FLUSH();
+	ENHest_opened_string = TRUE;
+	ENHest_min_height -= 1.0 * ENHest_fontsize;
+	ENHest_base -= 1.0 * ENHest_fontsize;
+	ENHest_x = 0;
+    }
+
+    ENHest_fragment_width += ENHest_fontsize;
+}
+
+
+static struct termentry ENHest = {
+    "estimate", "estimate width of enhanced text string",
+    1, 1, 1, 1, 1, 1,
+    NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL,
+    NULL, ENHest_put_text, NULL,
+    NULL, NULL, NULL, NULL,
+    0, 0,			/* pointsize, flags */
+    NULL, NULL, NULL, NULL
+#ifdef USE_MOUSE
+    , NULL, NULL, NULL, NULL, NULL
+#endif
+    , NULL, NULL, NULL, NULL
+    , NULL
+    , ENHest_OPEN, ENHest_FLUSH, ENHest_writec
+};
+
+#endif /* TERM_BODY */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/excl.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/excl.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/excl.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/excl.trm.svn-base	2012-01-03 17:07:29.093425700 -0800
@@ -0,0 +1,286 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: excl.trm,v 1.16 2006/07/21 02:35:46 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - excl.trm */
+
+/* Copyright 1992, 1998, 2004 by P. Klosowski at NIST.  All Rights Reserved
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+ *
+ * This file is included by ../term.c.
+ *
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+
+/***
+  NAME
+     quic
+   PURPOSE
+     QUIC driver for GNUPLOT
+   NOTES
+
+   HISTORY
+     przemek - Aug 16, 1992: Created.
+     lars - Nov 30, 1998: Updated to new gnuplot copyright by
+                          permission from Przemek
+***/
+/*
+c               *****************************************
+c               *****************************************
+c               ******                              *****
+c               ******   EXCL command definitions   *****
+c               ******                              *****
+c               *****************************************
+c               *****************************************
+*/
+
+/*
+ * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(excl)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void EXCL_init __PROTO((void));
+TERM_PUBLIC void EXCL_graphics __PROTO((void));
+TERM_PUBLIC void EXCL_text __PROTO((void));
+TERM_PUBLIC void EXCL_linetype __PROTO((int linetype));
+TERM_PUBLIC void EXCL_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void EXCL_vector __PROTO((unsigned int x2, unsigned int y2));
+TERM_PUBLIC void EXCL_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
+TERM_PUBLIC void EXCL_reset __PROTO((void));
+
+#define EXCL_XMAX 9000
+#define EXCL_YMAX 6500
+
+#define EXCL_XLAST (EXCL_XMAX - 1)
+#define EXCL_YLAST (EXCL_YMAX - 1)
+
+#define EXCL_VCHAR		120
+#define EXCL_HCHAR		70
+#define EXCL_VTIC		70
+#define EXCL_HTIC		70
+#endif /* TERM_PROTO */
+
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+/*  Define ansi command headers, NUL character */
+#define ESC "\033"
+#define GS  "\035"
+#define CSI "\033["
+#define DCS "\033P"
+#define ST  "\033\\"
+
+/*
+page numbers are given per "Talaris EXCL programmer's reference manual" M292 rev.2
+NOTE: EXCL coordinate system places (0,0) at upper left corner of the page
+
+c EXCL commands for initialization
+
+c     TALAMS: set ANSI                                        (p. 162)
+c     TALMOD: set emulation *** EXCL                          (p. 164)
+c     TALPGO: set page orient *** landscape                   (p.  81)
+c     TALFCTL: set paper format *** 8.5x11                    (p.  85)
+c     TALTBM: set top/bot margins  ** in land mode to full pg (p.  73)
+c     TALLRM: set left/right margins                          (p.  75)
+c     PUM:    set units ** units of measure set by TALPRM     (p.  67)
+c     TALASF: Absorb cr/ff/lf/vt   ** ON                      (p. 182)
+c     TALPOP: pop controller params                           (p. 168)
+c     TALPSH: push controller params                          (p. 167)
+c     TALPRM: set units of measure ** to 1/1000 inch          (p.  64)
+c     TALGLT: set line type ** solid                          (p. 211)
+c     TALORG: set page absolute origin ** (0,0) UL corner     (p.  78)
+c     TALPCW: set page clip window *** for landsc/full page   (p.  84)
+c     TALGLP: line: **pen7x7mil*draw*smear*glyph112*font5279* (p. 208)
+c     TALGLPE: ending for TALGLP command, forcing DRAW mode
+c     TALGBB: bounding box; used only by qdrive               (p. 207)
+c     TALFPO: Force page out  ** clear bitmap                 (p.  95)
+c     TALGDW: graphical draw to hor,vert ** abs  coords       (p. 212)
+c     TALGMV: graphical move to hor,vert ** abs  coords       (p. 213)
+*/
+#define TALAMS  "\033[0*s"
+#define TALMOD  "\033[1;0r"
+#define TALPGO  "\033[1;0p"
+#define TALFCTL "\033[0;3x"
+#define TALTBM  "\033[0;8500 v"
+#define TALLRM  "\033[0;11000v"
+#define PUM     "\033[11h"
+#define TALASF  "\033[1 z"
+#define TALPOP  "\033[*]"
+#define TALPSH  "\033[*["
+#define TALPRM  "\033[3y"
+#define TALGLT  "\033[%s*t"
+#define TALORG  "\033[0;0o"
+#define TALCCNT "\033[1;0u"
+#define TALPCW  "\033[0;8500;11000;0*c"
+#define TALGLP_init  "\033[7;7;8;1;112;5279*w"
+#define TALGLP  "\033[%d;%d;8*w"
+#define TALFPO  "\033[0*F"
+#define TALGDW "\033[0;%d;%d*d"
+#define TALGMV "\033[0;%d;%d*m"
+
+/*  TALPYL: polyline                                        (p. 222)
+**        5;0} list of 16-bit signed integers, encoded, mostly relative
+**        5,1} list of ASCII  absolute coords (if w/o +- signs)(e.g. 315:1222;)
+*/
+
+#define TALPYL  "\033P5;1}"
+
+TERM_PUBLIC void
+EXCL_init()
+{
+    fprintf(gpoutfile, "%s%s%s%s%s%s",
+	    TALPSH, TALAMS, TALMOD, TALCCNT, TALFCTL, TALASF);
+/*                ^save state   ^setEXCL       ^PaperSize8.5x11       */
+/*                       ^setANSI      ^copyCount1     ^absorbCtlChar */
+    fprintf(gpoutfile, "%s%s%s%s%s%s",
+	    PUM, TALPRM, TALPGO, TALPCW, TALORG, TALGLP_init);
+    fprintf(gpoutfile, TALGLT, "");
+/*                ^setUnits  ^landscape    ^OriginZero        ^SolidLine   */
+/*                    ^Units1/1000" ^pageClip     ^SetLine            */
+}
+
+TERM_PUBLIC void
+EXCL_graphics()
+{
+}
+
+TERM_PUBLIC void
+EXCL_text()
+{
+    fputs(TALFPO, gpoutfile);
+    /*    ^pageout  */
+}
+
+
+TERM_PUBLIC void
+EXCL_linetype(int linetype)
+{
+/* excl line widths in mils: 4 is mimimum, but too thin; then
+   7,10,14,17,20,24,27...
+   exclpen=MOD(NPEN,8)*7
+   CSI  exclpen; exclpen; TALGLPE
+*/
+    static char *type[2 + 9] =
+    {
+	"", "40;40", "", "42;42", "14;21",
+    /*   ....   ----  -- -- --   . . .   */
+	"", "49;30", "14;21", "", "49;30", "14;21"
+    /*  same pattern, but thicker..  and thicker       */
+    };
+    static int width[2+9] = { 14, 7, 7, 7, 7, 10, 10, 10, 17, 17, 17 };
+
+    if (linetype >= 9)
+	linetype %= 9;
+
+    if (linetype < -2)
+	linetype = LT_BLACK;
+
+    fprintf(gpoutfile, TALGLP, width[linetype + 2], width[linetype + 2]);
+    /*                 ^width in dots */
+    fprintf(gpoutfile, TALGLT, type[linetype + 2]);
+    /*                 ^line type     */
+}
+
+
+TERM_PUBLIC void
+EXCL_move(unsigned int x, unsigned int y)
+{
+    fprintf(gpoutfile, TALGMV, 1000 + x, EXCL_YLAST + 1000 - y);
+    /*                 ^pen up vector */
+}
+
+
+TERM_PUBLIC void
+EXCL_vector(unsigned int x2, unsigned int y2)
+{
+    fprintf(gpoutfile, TALGDW, 1000 + x2, EXCL_YLAST + 1000 - y2);
+    /*                 ^pen down vector */
+}
+
+
+TERM_PUBLIC void
+EXCL_put_text(unsigned int x, unsigned int y, const char str[])
+{
+    char ch;
+    EXCL_move(x, y - EXCL_VCHAR / 3);
+    ch = *str++;
+    while (ch != NUL) {
+	putc(ch, gpoutfile);
+	ch = *str++;
+    }
+}
+
+TERM_PUBLIC void
+EXCL_reset()
+{
+    fprintf(gpoutfile, "%s%s", TALFPO, TALPOP);
+    /*                         ^pageout ^pop  */
+}
+
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(excl_driver)
+    "excl", "Talaris EXCL Laser printer (also Talaris 1590 and others)",
+    EXCL_XMAX, EXCL_YMAX, EXCL_VCHAR, EXCL_HCHAR,
+    EXCL_VTIC, EXCL_HTIC, options_null, EXCL_init, EXCL_reset,
+    EXCL_text, null_scale, EXCL_graphics, EXCL_move, EXCL_vector,
+    EXCL_linetype, EXCL_put_text, null_text_angle,
+    null_justify_text, line_and_point, do_arrow, set_font_null
+TERM_TABLE_END(excl_driver)
+#undef LAST_TERM
+#define LAST_TERM excl_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(excl)
+"1 excl",
+"?commands set terminal excl",
+"?set terminal excl",
+"?set term excl",
+"?terminal excl",
+"?term excl",
+"?excl",
+" The `excl` terminal driver supports Talaris printers such as the EXCL Laser",
+" printer and the 1590.  It has no options."
+END_HELP(excl)
+#endif
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/fg.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/fg.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/fg.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/fg.trm.svn-base	2012-01-03 17:07:29.284922300 -0800
@@ -0,0 +1,463 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: fg.trm,v 1.13 2006/07/21 02:35:46 sfeam Exp $
+ */
+
+/* GNUPLOT - fg.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *	Under Zortech C
+ *      egalib, vgalib, vgamono, svga, mcga, cga, hercules, att
+ *
+ * AUTHORS
+ *		  Gnuplot for DOS 386/flash graphics
+ *				  Clifton T. Liu
+ *
+ */
+
+/* The modifications to allow Gnuplot to compile with Zortech C/C++   */
+/* 3.1 /Flash Graphics	were made by Clifton T. Liu		  */
+/* (cliu@merlin.appmath.columbia.edu)		 20 Feb 1993	  */
+
+/*
+ * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(hercules)
+register_term(egamono)
+register_term(egalib)
+register_term(vgalib)
+register_term(vgamono)
+register_term(svgalib)
+register_term(ssvgalib)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void PC_text __PROTO((void));
+TERM_PUBLIC void PC_reset __PROTO((void));
+TERM_PUBLIC int VGA_text_angle __PROTO((int ang));
+TERM_PUBLIC int VGA_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC void VGA_init __PROTO((void));
+TERM_PUBLIC void HERC_graphics __PROTO((void));
+TERM_PUBLIC void EGAMONO_graphics __PROTO((void));
+TERM_PUBLIC void EGA_graphics __PROTO((void));
+TERM_PUBLIC void VGA_graphics __PROTO((void));
+TERM_PUBLIC void VGAMONO_graphics __PROTO((void));
+TERM_PUBLIC void SVGA_graphics __PROTO((void));
+TERM_PUBLIC void SSVGA_graphics __PROTO((void));
+TERM_PUBLIC void VGA_linetype __PROTO((int linetype));
+TERM_PUBLIC void VGA_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC void VGA_move __PROTO((int x, int y));
+TERM_PUBLIC void VGA_vector __PROTO((int x, int y));
+TERM_PUBLIC void VGA_text __PROTO((void));
+TERM_PUBLIC void VGA_reset __PROTO((void));
+#define HERC_XMAX 720
+#define HERC_YMAX 348
+
+#define HERC_XLAST (HERC_XMAX - 1)
+#define HERC_YLAST (HERC_YMAX - 1)
+
+#define HERC_VCHAR 10
+#define HERC_HCHAR 8
+#define HERC_VTIC 5
+#define HERC_HTIC 5
+
+
+
+#define EGA_XMAX 640
+#define EGA_YMAX 350
+
+#define EGA_XLAST (EGA_XMAX - 1)
+#define EGA_YLAST (EGA_YMAX - 1)
+
+#define EGA_VCHAR 18
+#define EGA_HCHAR 8
+#define EGA_VTIC 5
+#define EGA_HTIC 5
+
+
+#define VGA_XMAX 640
+#define VGA_YMAX 480
+
+#define VGA_XLAST (VGA_XMAX - 1)
+#define VGA_YLAST (VGA_YMAX - 1)
+
+#define VGA_VCHAR 24
+#define VGA_HCHAR 8
+#define VGA_VTIC 5
+#define VGA_HTIC 5
+
+
+#define SVGA_XMAX 800
+#define SVGA_YMAX 600
+
+#define SVGA_XLAST (SVGA_XMAX - 1)
+#define SVGA_YLAST (SVGA_YMAX - 1)
+
+#define SVGA_VCHAR 24
+#define SVGA_HCHAR 8
+#define SVGA_VTIC 5
+#define SVGA_HTIC 5
+
+#define SSVGA_XMAX 1024
+#define SSVGA_YMAX 768
+
+#define SSVGA_XLAST (SSVGA_XMAX - 1)
+#define SSVGA_YLAST (SSVGA_YMAX - 1)
+
+#define SSVGA_VCHAR 24
+#define SSVGA_HCHAR 8
+#define SSVGA_VTIC 5
+#define SSVGA_HTIC 5
+
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+void pause __PROTO((void));
+
+#include <fg.h>
+
+static int pattern[] ={ 0xffff, 0x0f0f, 0xffff, 0xaaaa, 0x3333, 0x3f3f, 0x0f0f };
+
+static int graphics_on = FALSE;
+int startx, starty;
+/*
+int pc_angle;
+#define PC_VCHAR FNT5X9_VCHAR
+#define PC_HCHAR FNT5X9_HCHAR
+*/
+void
+pause()
+{				/* press any key to continue... */
+    (void) getch();
+}
+
+
+TERM_PUBLIC void
+PC_text()
+{
+    if (graphics_on) {
+	graphics_on = FALSE;
+	pause();
+    }
+    fg_term();
+}
+
+TERM_PUBLIC void
+PC_reset()
+{
+}
+
+
+
+/* all of the FlashGraphics C routines for the different graphics devices
+ * go here */
+
+
+
+static int vga256color[] ={ 7, 8, 2, 3, 4, 5, 9, 14, 12, 15, 13, 10, 11, 1, 6 };
+static int *vgacolor = vga256color;
+static fg_color_t vga_color;
+static int text_angle;
+static fg_line_t line_to_draw;
+
+TERM_PUBLIC int
+VGA_text_angle(int ang)
+{
+    text_angle = (ang ? 1 : 0);
+    return TRUE;
+}
+
+TERM_PUBLIC int
+VGA_justify_text(enum JUSTIFY mode)
+{
+    return FALSE;
+}
+
+TERM_PUBLIC void
+VGA_init()
+{
+    if (fg_init() == FG_NULL) {
+	fputs("Graphics card not detected.\n", stderr);
+	exit(EXIT_FAILURE);
+    }
+}
+
+TERM_PUBLIC void
+HERC_graphics()
+{
+    fg_init_herc();
+    graphics_on = TRUE;
+}
+
+TERM_PUBLIC void
+EGAMONO_graphics()
+{
+    fg_init_egamono();
+    graphics_on = TRUE;
+}
+
+TERM_PUBLIC void
+EGA_graphics()
+{
+    fg_init_egaecd();
+    graphics_on = TRUE;
+}
+
+TERM_PUBLIC void
+VGA_graphics()
+{
+    fg_init_vga12();
+    graphics_on = TRUE;
+}
+
+TERM_PUBLIC void
+VGAMONO_graphics()
+{
+    fg_init_vga11();
+    graphics_on = TRUE;
+}
+
+TERM_PUBLIC void
+SVGA_graphics()
+{
+    fg_init_vesa6a();
+    graphics_on = TRUE;
+}
+
+TERM_PUBLIC void
+SSVGA_graphics()
+{
+    fg_init_vesa5();
+    graphics_on = TRUE;
+}
+
+TERM_PUBLIC void
+VGA_linetype(int linetype)
+{
+    if (linetype >= 13)
+	linetype %= 13;
+    if (linetype < -2)
+	linetype = LT_BLACK;
+    vga_color = fg.color[vgacolor[linetype + 2]];
+}
+
+TERM_PUBLIC void
+VGA_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    fg_puts(vga_color, FG_MODE_SET, ~0, text_angle, x, y, str, fg.displaybox);
+}
+
+TERM_PUBLIC void
+VGA_move(unsigned int x, unsigned int y)
+{
+    line_to_draw[FG_X1] = x;
+    line_to_draw[FG_Y1] = y;
+}
+
+
+TERM_PUBLIC void
+VGA_vector(unsigned int x, unsigned int y);
+{
+    line_to_draw[FG_X2] = x;
+    line_to_draw[FG_Y2] = y;
+    fg_drawline(vga_color, FG_MODE_SET, ~0, FG_LINE_SOLID, line_to_draw);
+    line_to_draw[FG_X1] = x;
+    line_to_draw[FG_Y1] = y;
+}
+
+TERM_PUBLIC void
+VGA_text()
+{
+    if (graphics_on) {
+	graphics_on = FALSE;
+	fg_flush();
+	pause();
+    }
+    fg_term();
+}
+
+TERM_PUBLIC void
+VGA_reset()
+{
+    fg_term();
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(hercules_driver)
+    "hercules", "IBM PC/Clone with Hercules graphics board",
+    HERC_XMAX, HERC_YMAX, HERC_VCHAR, HERC_HCHAR,
+    HERC_VTIC, HERC_HTIC, options_null, VGA_init, VGA_reset,
+    VGA_text, null_scale, HERC_graphics, VGA_move, VGA_vector,
+    VGA_linetype, VGA_put_text, VGA_text_angle,
+    VGA_justify_text, do_point, do_arrow, set_font_null
+TERM_TABLE_END(hercules_driver)
+
+#undef LAST_TERM
+#define LAST_TERM hercules_driver
+
+TERM_TABLE_START(egamono_driver)
+    "egamono", "IBM PC/Clone with monochrome EGA graphics board",
+    EGA_XMAX, EGA_YMAX, EGA_VCHAR, EGA_HCHAR,
+    EGA_VTIC, EGA_HTIC, options_null, VGA_init, VGA_reset,
+    VGA_text, null_scale, EGAMONO_graphics, VGA_move, VGA_vector,
+    VGA_linetype, VGA_put_text, VGA_text_angle,
+    VGA_justify_text, do_point, do_arrow, set_font_null
+TERM_TABLE_END(egamono_driver)
+
+#undef LAST_TERM
+#define LAST_TERM egamono_driver
+
+TERM_TABLE_START(egalib_driver)
+    "egalib", "IBM PC/Clone with color EGA graphics board",
+    EGA_XMAX, EGA_YMAX, EGA_VCHAR, EGA_HCHAR,
+    EGA_VTIC, EGA_HTIC, options_null, VGA_init, VGA_reset,
+    VGA_text, null_scale, EGA_graphics, VGA_move, VGA_vector,
+    VGA_linetype, VGA_put_text, VGA_text_angle,
+    VGA_justify_text, do_point, do_arrow, set_font_null
+TERM_TABLE_END(egalib_driver)
+
+#undef LAST_TERM
+#define LAST_TERM egalib_driver
+
+TERM_TABLE_START(vgalib_driver)
+    "vgalib", "IBM PC/Clone with VGA graphics board",
+    VGA_XMAX, VGA_YMAX, VGA_VCHAR, VGA_HCHAR,
+    VGA_VTIC, VGA_HTIC, options_null, VGA_init, VGA_reset,
+    VGA_text, null_scale, VGA_graphics, VGA_move, VGA_vector,
+    VGA_linetype, VGA_put_text, VGA_text_angle,
+    VGA_justify_text, do_point, do_arrow, set_font_null
+TERM_TABLE_END(vgalib_driver)
+
+#undef LAST_TERM
+#define LAST_TERM vgalib_driver
+
+TERM_TABLE_START(vgamono_driver)
+    "vgamono", "IBM PC/Clone with monochrome VGA graphics board",
+    VGA_XMAX, VGA_YMAX, VGA_VCHAR, VGA_HCHAR,
+    VGA_VTIC, VGA_HTIC, options_null, VGA_init, VGA_reset,
+    VGA_text, null_scale, VGAMONO_graphics, VGA_move, VGA_vector,
+    VGA_linetype, VGA_put_text, VGA_text_angle,
+    VGA_justify_text, do_point, do_arrow, set_font_null
+TERM_TABLE_END(vgamono_driver)
+
+#undef LAST_TERM
+#define LAST_TERM vgamono_driver
+
+TERM_TABLE_START(svgalib_driver)
+    "svgalib", "IBM PC/Clone with VESA Super VGA graphics board",
+    SVGA_XMAX, SVGA_YMAX, SVGA_VCHAR, SVGA_HCHAR,
+    SVGA_VTIC, SVGA_HTIC, options_null, VGA_init, VGA_reset,
+    VGA_text, null_scale, SVGA_graphics, VGA_move, VGA_vector,
+    VGA_linetype, VGA_put_text, VGA_text_angle,
+    VGA_justify_text, do_point, do_arrow, set_font_null
+TERM_TABLE_END(svgalib_driver)
+
+#undef LAST_TERM
+#define LAST_TERM svgalib_driver
+
+TERM_TABLE_START(ssvgalib_driver)
+    "ssvgalib", "IBM PC/Clone with VESA 256 color 1024 by 768 super VGA",
+    SSVGA_XMAX, SSVGA_YMAX, SSVGA_VCHAR, SSVGA_HCHAR,
+    SSVGA_VTIC, SSVGA_HTIC, options_null, VGA_init, VGA_reset,
+    VGA_text, null_scale, SSVGA_graphics, VGA_move, VGA_vector,
+    VGA_linetype, VGA_put_text, VGA_text_angle,
+    VGA_justify_text, do_point, do_arrow, set_font_null
+TERM_TABLE_END(ssvgalib_driver)
+
+#undef LAST_TERM
+#define LAST_TERM ssvgalib_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+
+#ifdef TERM_HELP
+START_HELP(hercules)
+"1 hercules",
+"?commands set terminal hercules",
+"?set terminal hercules",
+"?set term hercules",
+"?terminal hercules",
+"?term hercules",
+"?hercules",
+"?commands set terminal egalib",
+"?set terminal egalib",
+"?set term egalib",
+"?terminal egalib",
+"?term egalib",
+"?egalib",
+"?commands set terminal egamono",
+"?set terminal egamono",
+"?set term egamono",
+"?terminal egamono",
+"?term egamono",
+"?egamono",
+"?commands set terminal vgalib",
+"?set terminal vgalib",
+"?set term vgalib",
+"?terminal vgalib",
+"?term vgalib",
+"?vgalib",
+"?commands set terminal vgamono",
+"?set terminal vgamono",
+"?set term vgamono",
+"?terminal vgamono",
+"?term vgamono",
+"?vgamono",
+"?commands set terminal svgalib",
+"?set terminal svgalib",
+"?set term svgalib",
+"?terminal svgalib",
+"?term svgalib",
+"?svgalib",
+"?commands set terminal ssvgalib",
+"?set terminal ssvgalib",
+"?set term ssvgalib",
+"?terminal ssvgalib",
+"?term ssvgalib",
+"?ssvgalib",
+" These drivers supports PC monitors with autodetected graphics boards.  They",
+" can be used only when compiled with Zortech C/C++.  None have options."
+END_HELP(hercules)
+#endif /* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/fig.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/fig.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/fig.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/fig.trm.svn-base	2012-01-03 17:07:29.496470900 -0800
@@ -0,0 +1,1922 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: fig.trm,v 1.67 2009/03/26 00:49:20 sfeam Exp $
+ */
+
+/* GNUPLOT - fig.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *  Fig graphics language
+ *
+ * AUTHORS
+ *  Micah Beck, David Kotz
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+
+/*
+ * Original for Fig code output by Micah Beck, 1989
+ * Department of Computer Science, Cornell University
+ * Updated by David Kotz for gnuplot 2.0
+ * More efficient output by Ian Dall
+ * Updated to FIG 2.1 (with color) format by Vivek Khera
+ * Updated to FIG 3.1 (higher resolution) format by Ian MacPhedran, Jan 1995
+ * Updated to conform to newterm format Ian MacPhedran, Apr 1995
+ * Point-count option joachim.selinger@ins.uni-stuttgart.de (JFS) Feb  9 1996
+ * More options (portrait/landscape, metric/inches, size, fontsize, thickness)
+ * plus symbols and depth/thickness by bernlohr@eu1.mpi-hd.mpg.de (KB) Aug 15 1996
+ * Added PM3D functionality Ian MacPhedran, April 15 1999
+ * Take into account 'set palette maxcolors' Petr Mikulik, June 11 2002
+ * Don't reset options when 'set term fig <new options>', Petr Mikulik, Aug 24 2002
+ * Ethan A Merritt - May 2008:
+ *   Bring into line with other terminals for point types, size syntax, font spec
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(fig)
+#endif /* TERM_REGISTER */
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void FIG_options __PROTO((void));
+TERM_PUBLIC void FIG_init __PROTO((void));
+TERM_PUBLIC void FIG_graphics __PROTO((void));
+TERM_PUBLIC void FIG_text __PROTO((void));
+TERM_PUBLIC void FIG_linetype __PROTO((int linetype));
+TERM_PUBLIC void FIG_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void FIG_vector __PROTO((unsigned int ux, unsigned int uy));
+TERM_PUBLIC void FIG_arrow __PROTO((unsigned int sx, unsigned int sy, unsigned int ex, unsigned int ey, int head));
+TERM_PUBLIC void FIG_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC int FIG_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC int FIG_text_angle __PROTO((int ang));
+TERM_PUBLIC void FIG_pointsize __PROTO((double arg_pointsize));
+TERM_PUBLIC void FIG_linewidth __PROTO((double linewidth));
+TERM_PUBLIC void FIG_reset __PROTO((void));
+TERM_PUBLIC void FIG_lpoint __PROTO((unsigned int x, unsigned int y, int number));
+TERM_PUBLIC void FIG_boxfill __PROTO((int style, unsigned int x, unsigned int y, unsigned int w, unsigned int h));
+TERM_PUBLIC int FIG_make_palette (t_sm_palette *);
+/* TERM_PUBLIC void FIG_previous_palette (void); */
+TERM_PUBLIC void FIG_set_color (t_colorspec *);
+TERM_PUBLIC void FIG_filled_polygon (int, gpiPoint *);
+TERM_PUBLIC void FIG_layer __PROTO((t_termlayer syncpoint));
+
+#define GOT_FIG_PROTO
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+#include "object.h"		/* modified from the XFig distribution */
+#define FIG_DEFAULT DEFAULT
+#define FIG_ROMAN_FONT (0)	/* actually, the default font */
+
+#if METRIC
+# define INCH FALSE
+#else
+# define INCH TRUE
+#endif
+
+/* These should not be defined elsewhere - ACZ */
+/* This is now 1200 per inch */
+#define FIG_IRES        (1200)
+/* This is now 450 per cm */
+#define FIG_MRES        (450)
+
+#define FIG_COORD_SYS   2
+#define FIG_ORIENT (FIG_portrait?"Portrait":"Landscape")
+/* Could be "Portrait" */
+#define FIG_JUST        "Center"
+/* Could be "Flush Left" */
+#define FIG_UNIT (FIG_inches?"Inches":"Metric")
+/* Could be "Inches" */
+#define FIG_PAPER       (FIG_inches ? "Letter" : "A4")
+#define FIG_MAGNIFICATION  100.0
+#define FIG_MULTIPAGE   "Single"
+/* Could be "Multiple" */
+#define FIG_TRANSCOLOR  -2
+/* none: -2; background: -1; 0..31: foreground colors */
+/* This could probably be dropped with the support of GIFs. */
+#define FIG_TRUERES (FIG_inches ? FIG_IRES : FIG_MRES) /* ACZ */
+#define FIG_DEFAULTVERSION "3.2"
+
+#define FIG_HTIC(inch)  ((inch) ? (5*FIG_IRES)/80 : (15*FIG_MRES)/100)
+#define FIG_VTIC(inch)  ((inch) ? (5*FIG_IRES)/80 : (15*FIG_MRES)/100)
+#define FIG_FONT_S      (10)	/* size in points */
+#define FIG_MAX_POINTS  99999L	/* almost infinite ;-) */
+
+/* height of font in pixels: */
+#define FIG_to_pixel_v(inch,s) (((inch) ? (s)*FIG_IRES : (s)*FIG_MRES*2.54) / 72 * 3/4)
+/* This is fudged to enlarge the drawing area, but gives fairly good results */
+/* this is a guess at the width: */
+#define FIG_to_pixel_h(inch,s) (FIG_to_pixel_v(inch,s)*6/10)
+
+#define FIG_VCHAR       FIG_to_pixel_v(INCH,FIG_FONT_S)	/* just for default, */
+#define FIG_HCHAR       FIG_to_pixel_h(INCH,FIG_FONT_S)	/* not really used   */
+
+/* Text flags (ULIG) */
+enum FIG_TEXT_STYLEBITS {
+    FIG_TEXT_RIGID      = 1<<0,
+    FIG_TEXT_SPECIAL    = 1<<1,
+    FIG_TEXT_POSTSCRIPT = 1<<2,
+    FIG_TEXT_HIDDEN     = 1<<3
+};
+#define FIG_TEXT_NORMAL      FIG_TEXT_POSTSCRIPT
+
+enum FIG_poly_stat {
+    FIG_poly_new, FIG_poly_part
+};
+
+static int FIG_posx;
+static int FIG_posy;
+static long FIG_poly_vec_cnt;
+static int FIG_depth = 10;
+static int FIG_linedepth = 10;
+static int FIG_thickness = 1;
+static int FIG_default_thickness = 1;
+static double FIG_current_pointsize = 1.;
+static double FIG_current_linewidth = 1.;
+
+/* Maximum number of points per POLYLINE.
+   Default 1000 (hardcoded in help section as well) */
+static int FIG_poly_vec_max = 999;	/* JFS */
+
+static enum FIG_poly_stat FIG_polyvec_stat;
+
+/* 5 inches wide by 3 inches high */
+#define FIG_XMAX(inch) ((inch) ? 5*FIG_IRES : 12*FIG_MRES)
+#define FIG_YMAX(inch) ((inch) ? 3*FIG_IRES :  8*FIG_MRES)
+
+#define FIG_XOFF(inch) ((inch) ? FIG_IRES : 2*FIG_MRES)
+#define FIG_YOFF(inch) ((inch) ? FIG_IRES : 2*FIG_MRES)
+
+
+#define BFIG_HTIC(inch) ((inch) ? (7*FIG_IRES)/80 : (20*FIG_MRES)/100)
+#define BFIG_VTIC(inch) ((inch) ? (7*FIG_IRES)/80 : (20*FIG_MRES)/100)
+#define BFIG_FONT_S     (16)	/* size in points */
+#define BFIG_VCHAR      FIG_to_pixel_v(INCH,BFIG_FONT_S)  /* height in pixels of font */
+#define BFIG_HCHAR      FIG_to_pixel_h(INCH,BFIG_FONT_S)  /* this is a guess at the width */
+
+static F_point *FIG_points = NULL;	/* Array for the collection of points for
+					   POLYLINE, allocated on demand. */
+static F_line FIG_line;
+
+/* 8 inches wide by 5 inches high */
+#define BFIG_XMAX(inch) ((inch) ? 8*FIG_IRES : 20*FIG_MRES)
+#define BFIG_YMAX(inch) ((inch) ? 5*FIG_IRES : 15*FIG_MRES)
+
+#define BFIG_XOFF(inch) ((inch) ? FIG_IRES : 2*FIG_MRES)
+#define BFIG_YOFF(inch) ((inch) ? FIG_IRES : 2*FIG_MRES)
+
+
+static int FIG_type;		/* negative types use real lines */
+static float FIG_spacing;	/* length of dash or dot spacing */
+static int FIG_justify;		/* Fig justification T_*_JUSTIFIED */
+static float FIG_angle;		/* Fig text angle (in radians) */
+static int FIG_use_color = FALSE;	/* do we use color or not? */
+static int FIG_is_big = FALSE;	/* big plot ? */
+static int FIG_color = DEFAULT;	/* which color to use */
+static int FIG_xoff = FIG_XOFF(INCH);
+static int FIG_yoff = FIG_YOFF(INCH);
+static int FIG_font_id = FIG_ROMAN_FONT;
+static int FIG_font_s = FIG_FONT_S;
+static int FIG_portrait = FALSE;
+static int FIG_inches = INCH;
+static int FIG_text_flags = FIG_TEXT_NORMAL;    /* whether text is special or hidden etc. */
+static char FIG_version[MAX_ID_LEN+1] = FIG_DEFAULTVERSION;  /* file format version */
+static int FIG_solid = FALSE;                   /* dashed lines or not */
+static int FIG_palette_set = FALSE;	/* PM3D Palette Set ? */
+static int FIG_palette_size = 128;	/* Number of colours in palette */
+static int FIG_palette_offst = 32;	/* Offset from zero for user colours */
+static int FIG_fill_style = 20;		/* Full saturation */
+
+static void FIG_poly_clean __PROTO((enum FIG_poly_stat fig_stat));
+
+enum FIG_id {
+    FIG_MONOCHROME, FIG_COLOR,
+    FIG_SMALL, FIG_BIG,
+    FIG_INCHES, FIG_METRIC,
+    FIG_PORTRAIT, FIG_LANDSCAPE,
+    FIG_SIZE, FIG_FONT, FIG_FONTSIZE,
+    FIG_THICKNESS, FIG_DEPTH, FIG_POINTSMAX,
+    FIG_SOLID, FIG_DASHED,
+    FIG_NORMALTEXT, FIG_SPECIALTEXT, FIG_HIDDENTEXT, FIG_RIGIDTEXT,
+    FIG_VERSION, FIG_OTHER
+};
+
+static struct gen_table FIG_opts[] =
+{
+    { "b$ig", FIG_BIG },
+    { "c$olor", FIG_COLOR },
+    { "c$olour", FIG_COLOR },
+    { "da$shed", FIG_DASHED },
+    { "de$pth", FIG_DEPTH },
+    { "font", FIG_FONT },
+    { "f$ontsize", FIG_FONTSIZE },
+    { "in$ches", FIG_INCHES },
+    { "l$andscape", FIG_LANDSCAPE },
+    { "me$tric", FIG_METRIC },
+    { "mo$nochrome", FIG_MONOCHROME },
+    { "poi$ntsmax", FIG_POINTSMAX },
+    { "por$trait", FIG_PORTRAIT },
+    { "si$ze", FIG_SIZE },
+    { "sm$all", FIG_SMALL },
+    { "so$lid", FIG_SOLID },
+    { "linew$idth", FIG_THICKNESS },
+    { "t$hickness", FIG_THICKNESS },
+    { "texth$idden", FIG_HIDDENTEXT },
+    { "textn$ormal", FIG_NORMALTEXT },
+    { "textr$igid", FIG_RIGIDTEXT },
+    { "texts$pecial", FIG_SPECIALTEXT },
+    { "v$ersion", FIG_VERSION },
+    { NULL, FIG_OTHER }
+};
+
+const struct gen_table FIG_fonts[] =
+{
+    { "Times Roman",  0 },
+    { "Times Italic",  1 },
+    { "Times Bold",  2 },
+    { "Times Bold Italic",  3 },
+    { "AvantGarde Book",  4 },
+    { "AvantGarde Book Oblique",  5 },
+    { "AvantGarde Demi",  6 },
+    { "AvantGarde Demi Oblique",  7 },
+    { "Bookman Light",  8 },
+    { "Bookman Light Italic",  9 },
+    { "Bookman Demi", 10 },
+    { "Bookman Demi Italic", 11 },
+    { "Courier", 12 },
+    { "Courier Oblique", 13 },
+    { "Courier Bold", 14 },
+    { "Courier Bold Oblique", 15 },
+    { "Helvetica", 16 },
+    { "Helvetica Oblique", 17 },
+    { "Helvetica Bold", 18 },
+    { "Helvetica Bold Oblique", 19 },
+    { "Helvetica Narrow", 20 },
+    { "Helvetica Narrow Oblique", 21 },
+    { "Helvetica Narrow Bold", 22 },
+    { "Helvetica Narrow Bold Oblique", 23 },
+    { "New Century Schoolbook Roman", 24 },
+    { "New Century Schoolbook Italic", 25 },
+    { "New Century Schoolbook Bold", 26 },
+    { "New Century Schoolbook Bold Italic", 27 },
+    { "Palatino Roman", 28 },
+    { "Palatino Italic", 29 },
+    { "Palatino Bold", 30 },
+    { "Palatino Bold Italic", 31 },
+    { "Symbol", 32 },
+    { "Zapf Chancery Medium Italic", 33 },
+    { "Zapf Dingbats", 34 },
+    { NULL, -1}
+};
+
+TERM_PUBLIC void
+FIG_options()
+{
+    int parse_error = FALSE;
+    long temp_max;
+    unsigned int tmax_t;
+    double xsize_t = 0, ysize_t = 0;
+    char text_flags[256]; /* for description only */
+
+#if 0
+    /* Terminals should not reset options to defaults. */
+    FIG_use_color = FALSE;	/* default */
+    FIG_is_big = FALSE;		/* default */
+    FIG_portrait = FALSE;
+    FIG_font_id = FIG_ROMAN_FONT;
+    FIG_font_s = 0;
+    FIG_default_thickness = 1;
+    xsize_t = ysize_t = 0.;
+    FIG_inches = INCH;
+    FIG_text_flags = FIG_TEXT_NORMAL;
+    FIG_solid = FALSE;
+    strcpy( FIG_version, FIG_DEFAULTVERSION );
+#endif
+
+    while (!END_OF_COMMAND) {
+	switch(lookup_table(&FIG_opts[0],c_token)) {
+	case FIG_MONOCHROME:
+	    FIG_use_color = FALSE;
+	    c_token++;
+	    break;
+	case FIG_COLOR:
+	    FIG_use_color = TRUE;
+	    c_token++;
+	    break;
+	case FIG_SMALL:
+	    FIG_is_big = FALSE;
+	    c_token++;
+	    break;
+	case FIG_BIG:
+	    FIG_is_big = TRUE;
+	    c_token++;
+	    break;
+	case FIG_INCHES:
+	    FIG_inches = TRUE;
+	    c_token++;
+	    break;
+	case FIG_METRIC:
+	    FIG_inches = FALSE;
+	    c_token++;
+	    break;
+	case FIG_SOLID:
+	    FIG_solid = TRUE;
+	    c_token++;
+	    break;
+	case FIG_DASHED:
+	    FIG_solid = FALSE;
+	    c_token++;
+	    break;
+	case FIG_NORMALTEXT:
+	    FIG_text_flags = FIG_TEXT_NORMAL;
+	    c_token++;
+	    break;
+	case FIG_SPECIALTEXT:
+	    FIG_text_flags |= FIG_TEXT_SPECIAL;
+            FIG_text_flags &= ~FIG_TEXT_POSTSCRIPT;
+	    FIG_font_id = 0;
+	    c_token++;
+	    break;
+	case FIG_HIDDENTEXT:
+	    FIG_text_flags |= FIG_TEXT_HIDDEN;
+	    c_token++;
+	    break;
+	case FIG_RIGIDTEXT:
+	    FIG_text_flags |= FIG_TEXT_RIGID;
+	    c_token++;
+	    break;
+	case FIG_PORTRAIT:
+	    FIG_portrait = TRUE;
+	    c_token++;
+	    break;
+	case FIG_LANDSCAPE:
+	    FIG_portrait = FALSE;
+	    c_token++;
+	    break;
+	case FIG_SIZE:
+	    c_token++;
+	    if (END_OF_COMMAND) {
+		int_error(c_token, "size: 2 numbers expected");
+	    } else {
+		xsize_t = real_expression();
+		if (equals(c_token,","))
+		    c_token++;
+		if (END_OF_COMMAND) {
+		    int_error(c_token, "size: 2 numbers expected");
+		    xsize_t = 0.;
+		} else {
+		    ysize_t = real_expression();
+		}
+		if (xsize_t < 2. || ysize_t < 2. || xsize_t > 99. || ysize_t > 99.) {
+		    if (xsize_t != 0. || ysize_t != 0.)
+			int_error(c_token, "size: out of range");
+		    xsize_t = ysize_t = 0.;
+		}
+	    }
+	    break;
+	case FIG_FONT:
+	    {
+	    char *fontname;
+	    int sep;
+	    c_token++;
+	    if (END_OF_COMMAND || !((fontname = try_to_get_string())))
+		int_error(c_token, "expecting font name");
+	    sep = strcspn(fontname,",");
+	    sscanf (&(fontname[sep+1]),"%d",&FIG_font_s);
+	    fontname[sep] = '\0';
+	    FIG_font_id = lookup_table_entry(FIG_fonts, fontname);
+	    if (FIG_font_id < 0)
+		FIG_font_id = FIG_ROMAN_FONT;
+	    free(fontname);
+	    break;
+	    }
+	case FIG_FONTSIZE:
+	    c_token++;
+	    FIG_font_s = int_expression();
+	    break;
+	case FIG_THICKNESS:
+	    c_token++;
+	    if (END_OF_COMMAND) {
+		int_error(c_token, "thickness: number expected");
+	    } else {
+		FIG_default_thickness = int_expression();
+		if (FIG_default_thickness < 1 || FIG_default_thickness > 10) {
+		    int_error(c_token - 1, "thickness out of range");
+		    FIG_default_thickness = 1;
+		}
+	    }
+	    break;
+	case FIG_DEPTH:
+	    c_token++;
+	    if (END_OF_COMMAND) {
+		int_error(c_token, "depth: number expected");
+	    } else {
+		FIG_depth = int_expression();
+		if (FIG_depth < 0 || FIG_depth > 99) {
+		    int_error(c_token - 1, "depth out of range");
+		    FIG_depth = 10;
+		}
+		FIG_linedepth = FIG_depth;
+	    }
+	    break;
+	case FIG_POINTSMAX:
+	    /* Skip the word and then expect the number ! */
+	    c_token++;
+	    if (END_OF_COMMAND) {
+		int_error(c_token,
+			  "max. points per polyline: number expected");
+	    } else {
+		temp_max = (long) real_expression();
+		/* Now check the range for the number */
+		if ((temp_max > 1) && (temp_max < (FIG_MAX_POINTS + 2))) {
+		    /* OK. subtract one to the right number! See other numbers... */
+		    FIG_poly_vec_max = temp_max - 1;
+		} else {
+		    int_error(c_token,
+			      "pointsmax: number out of range (2,%ld)",
+			      (FIG_MAX_POINTS + 1));
+		}
+	    }
+	    break;
+	case FIG_VERSION:
+	    c_token++;
+	    if (END_OF_COMMAND) {
+		int_error(c_token, "version: 3.1 or 3.2 expected");
+	    } else {
+                copy_str( FIG_version, c_token, MAX_ID_LEN );
+                c_token++;
+                if( strcmp( FIG_version, "3.1" ) != 0 &&
+                    strcmp( FIG_version, "3.2" ) != 0 ) {
+                    int_error(c_token, "wrong version number, must be 3.1 or 3.2");
+                }
+	    }
+	    break;
+	case FIG_OTHER:
+	default:
+	    parse_error = TRUE;
+	    int_error(c_token, "unrecognized option");
+	    break;
+	}
+    }
+
+    if( FIG_text_flags == FIG_TEXT_NORMAL ) {
+        strcpy( text_flags, " textnormal" );
+    } else {
+        sprintf( text_flags, "%s%s%s",
+                 (FIG_text_flags & FIG_TEXT_SPECIAL) ? " textspecial" : "",
+                 (FIG_text_flags & FIG_TEXT_HIDDEN) ? " texthidden" : "",
+                 (FIG_text_flags & FIG_TEXT_RIGID) ? " textrigid" : ""
+               );
+    }
+
+    sprintf(term_options, "%s %s %s %d %s %s %s%s %s \"%s\" %s %d %s %d %s %d %s %s",
+	    FIG_use_color ? "color" : "monochrome",
+	    FIG_is_big ? "big" : "small",
+	    "pointsmax",
+	    FIG_poly_vec_max + 1,
+	    FIG_portrait ? "portrait" : "landscape",
+	    FIG_inches ? "inches" : "metric",
+            FIG_solid ? "solid" : "dashed",
+	    text_flags,
+	    "font", FIG_fonts[FIG_font_id].key,
+	    "fontsize", (FIG_font_s > 0 ? FIG_font_s :
+			 (FIG_is_big ? BFIG_FONT_S : FIG_FONT_S)),
+	    "linewidth", FIG_default_thickness, "depth", FIG_depth,
+            "version", FIG_version );	/* JFS, KB, ULIG */
+    if (xsize_t > 0. && ysize_t > 0.) {
+	if (xsize_t - (int) xsize_t == 0. && ysize_t - (int) ysize_t == 0.)
+	    sprintf(term_options + strlen(term_options),
+		    " size %d %d", (int) xsize_t, (int) ysize_t);
+	else
+	    sprintf(term_options + strlen(term_options),
+		    " size %f %f", xsize_t, ysize_t);
+    }
+    if (!FIG_is_big) {
+	if (FIG_font_s <= 0)	/* KB */
+	    FIG_font_s = FIG_FONT_S;
+	term->xmax = FIG_XMAX(FIG_inches);
+	term->ymax = FIG_YMAX(FIG_inches);
+	term->v_tic = FIG_VTIC(FIG_inches);
+	term->h_tic = FIG_HTIC(FIG_inches);
+	FIG_xoff = FIG_XOFF(FIG_inches);
+	FIG_yoff = FIG_YOFF(FIG_inches);
+    } else {
+	if (FIG_font_s <= 0)	/* KB */
+	    FIG_font_s = BFIG_FONT_S;
+	term->xmax = BFIG_XMAX(FIG_inches);
+	term->ymax = BFIG_YMAX(FIG_inches);
+	term->v_tic = BFIG_VTIC(FIG_inches);
+	term->h_tic = BFIG_HTIC(FIG_inches);
+	FIG_xoff = BFIG_XOFF(FIG_inches);
+	FIG_yoff = BFIG_YOFF(FIG_inches);
+    }
+    if (FIG_portrait) {		/* KB */
+	tmax_t = term->xmax;
+	term->xmax = term->ymax;
+	term->ymax = tmax_t;
+    }
+    if (xsize_t > 0. && ysize_t > 0.) {
+	term->xmax = (unsigned int) (xsize_t * FIG_TRUERES);
+	term->ymax = (unsigned int) (ysize_t * FIG_TRUERES);
+    }
+    term->v_char = FIG_to_pixel_v(FIG_inches, FIG_font_s);
+    term->h_char = FIG_to_pixel_h(FIG_inches, FIG_font_s);
+    FIG_thickness = FIG_default_thickness;
+    if (parse_error) {		/* JFS, KB */
+	int_error(c_token, "unrecognized option");
+    }
+}
+
+
+static void
+FIG_poly_clean(enum FIG_poly_stat fig_stat)
+{
+    int i, j;
+    int cap_style;
+
+    if (fig_stat == FIG_poly_part) {
+	cap_style = (FIG_line.style==DOTTED_LINE)
+	    ? CAP_ROUND : FIG_line.cap_style;
+	fprintf(gpoutfile,
+		"%d %d %d %d %d %d %d %d %d %9.3f %d %d %d %d %d %ld\n\t",
+		O_POLYLINE, FIG_line.type, FIG_line.style, FIG_line.thickness,
+		FIG_line.pen_color, FIG_line.fill_color, FIG_line.depth,
+		FIG_line.pen_style, FIG_line.fill_style, FIG_line.style_val,
+		FIG_line.join_style, cap_style, FIG_line.radius,
+		0, 0, FIG_poly_vec_cnt);
+
+	j = 0;
+	for (i = 0; i < FIG_poly_vec_cnt; i++) {
+	    fprintf(gpoutfile, " %d %d", FIG_points[i].x, FIG_points[i].y);
+	    if (j++ > 4 && i != FIG_poly_vec_cnt - 1) {
+		fputs("\n\t", gpoutfile);
+		j = 0;		/* JFS */
+	    }
+	}
+	if (j != 0) {
+	    putc('\n', gpoutfile);
+	}
+	/* Give the memory back to the system because we are done with this
+	 * polyline. Make sure FIG_points contains NULL afterwards!
+	 */
+	free(FIG_points);
+	FIG_points = NULL;
+    }
+    FIG_polyvec_stat = FIG_poly_new;
+}
+
+
+TERM_PUBLIC void
+FIG_init()
+{
+    FIG_posx = FIG_posy = 0;
+    FIG_polyvec_stat = FIG_poly_new;
+    FIG_linetype(-1);
+    FIG_justify_text(LEFT);
+    FIG_text_angle(0);
+
+    FIG_palette_set = FALSE;    /* PM3D Palette Set ? */
+    FIG_line.tagged = FIG_DEFAULT;
+    FIG_line.distrib = FIG_DEFAULT;
+    FIG_line.type = T_POLYLINE;
+    FIG_line.style = 0;
+    FIG_line.thickness = FIG_thickness;
+    FIG_line.fill_style = -1;
+    FIG_line.depth = FIG_linedepth;
+    FIG_line.pen_style = 0;
+    FIG_line.for_arrow = NULL;
+    FIG_line.back_arrow = NULL;
+    FIG_line.cap_style = 0;
+    FIG_line.join_style = 0;
+    FIG_line.style_val = 0.0;
+    FIG_line.radius = 0;
+    FIG_line.pic = NULL;
+    FIG_line.next = NULL;
+
+    /* Add further versions headers below (ULIG). There is probably more work to be done */
+    /* than only changing the header in future xfig versions */
+
+    if( strcmp(FIG_version, "3.1") == 0 ) {
+        fprintf( gpoutfile,
+                 "#FIG 3.1\n%s\n%s\n%s\n%d %d\n",
+                 FIG_ORIENT,
+                 FIG_JUST,
+                 FIG_UNIT,
+                 FIG_IRES, FIG_COORD_SYS
+               );
+    } else if( strcmp(FIG_version, "3.2") == 0 ) {
+        fprintf( gpoutfile,
+                 "#FIG 3.2\n%s\n%s\n%s\n%s\n%6.2f\n%s\n%d\n%d %d\n",
+                 FIG_ORIENT,
+                 FIG_JUST,
+                 FIG_UNIT,
+                 FIG_PAPER,
+                 FIG_MAGNIFICATION,
+                 FIG_MULTIPAGE,
+                 FIG_TRANSCOLOR,
+                 FIG_IRES, FIG_COORD_SYS
+               );
+    }
+}
+
+
+TERM_PUBLIC void
+FIG_graphics()
+{
+    FIG_posx = FIG_posy = 0;
+    FIG_polyvec_stat = FIG_poly_new;
+    /* there is no way to have separate pictures in a FIG file */
+}
+
+
+TERM_PUBLIC void
+FIG_text()
+{
+    /* there is no way to have separate pictures in a FIG file */
+    FIG_poly_clean(FIG_polyvec_stat);
+    FIG_posx = FIG_posy = 0;
+    fflush(gpoutfile);
+}
+
+
+/* Line types for FIG work like this:
+ *  for monochrome:
+ *  -2 : solid (border)
+ *  -1 : dotted 4 (axes)
+ *   0 : solid (first curve)
+ *   1 : dotted 3
+ *   2 : dashed 3
+ *   3 : dotted 6
+ *   4 : dashed 6
+ *   ... ...
+ *  for color, cycle through colors. once colors are used up, repeat colors
+ *   but start using dashed lines of different dash length. don't use white
+ *   as a color.
+ */
+
+TERM_PUBLIC void
+FIG_linetype(int linetype)		/* expect linetype >= -2 */
+{
+    int last_FIG_type = FIG_type;
+    int last_FIG_spacing = FIG_spacing;
+    int last_FIG_color = FIG_color;
+    int last_FIG_depth = FIG_linedepth;
+    int last_FIG_thickness = FIG_thickness;
+
+    /* mapping of fig color codes to color sequence as in the postscript terminal */
+#define npscolors 9
+    int fig2pscolors[npscolors] = {
+	4 /*red*/, 2 /*green*/, 1 /*blue*/,
+	5 /*magenta*/, 3 /*cyan*/, 6 /*yellow*/,
+	0 /*black*/, 26 /*brown*/,
+	11 /*use LtBlue instead of light gray*/
+	/* note: black=1, white=8 */
+    };
+
+    FIG_linedepth = FIG_depth;
+    FIG_thickness = FIG_current_linewidth * FIG_default_thickness;
+    if (FIG_thickness < 1)
+	FIG_thickness = 1;
+    FIG_color = DEFAULT;
+
+    if (linetype <= LT_NODRAW)
+	linetype = LT_BLACK;
+
+    switch (linetype) {
+    case 0:
+    case LT_BLACK:{
+	    FIG_type = SOLID_LINE;
+	    FIG_spacing = 0.0;
+	    if (FIG_use_color)
+#if 0 /* fig's old color sequence */
+		FIG_color = BLACK;
+#else /* color sequence compatible to the postscript terminal */
+		if (linetype==0) FIG_color = fig2pscolors[0]; /* red */
+#endif
+	    break;
+	}
+    case LT_AXIS:{
+	    FIG_type = DOTTED_LINE;
+            if( FIG_solid )
+                FIG_type = SOLID_LINE;
+	    FIG_spacing = 4.0;	/* gap */
+	    if (FIG_use_color)
+		FIG_color = BLACK;
+	    break;
+	}
+    default:{
+	    /* now linetype >= 1 --- shouldn't be negative anyway */
+	    FIG_linedepth = FIG_depth + linetype / 1000;
+	    linetype %= 1000;
+	    /* Thickness of lines is either included in the linetype */
+	    /* (in Fig units) or the default is scaled with the */
+	    /* current 'linewidth'. */
+	    if ((FIG_thickness = linetype / 100) == 0)
+		FIG_thickness = FIG_current_linewidth * FIG_default_thickness;
+	    if (FIG_thickness < 1)	/* Less than 1 would be invisible */
+		FIG_thickness = 1;
+	    linetype %= 100;
+	    if (FIG_use_color) {
+#if 0 /* fig's old color sequence */
+		FIG_type = (linetype >= WHITE);		/* dashed line */
+		FIG_color = linetype % WHITE;
+		FIG_spacing = (linetype / WHITE) * 3;
+#else /* color sequence compatible to the postscript terminal */
+		FIG_type = (linetype >= npscolors);		/* dashed line */
+		FIG_color = fig2pscolors[linetype % npscolors];
+		FIG_spacing = (linetype / npscolors) * 3;
+#endif
+	    } else {		/* monochrome */
+		FIG_type = (linetype)? linetype%2 + 1 : SOLID_LINE; /* dotted, dashed, ... */
+		FIG_spacing = (linetype + 1) / 2 * 3;
+	    }
+            if( FIG_solid )
+                FIG_type = SOLID_LINE;
+	    break;
+	}
+    }
+    if (FIG_type != last_FIG_type || FIG_spacing != last_FIG_spacing ||
+	FIG_color != last_FIG_color || FIG_linedepth != last_FIG_depth ||
+	FIG_thickness != last_FIG_thickness)
+	FIG_poly_clean(FIG_polyvec_stat);
+}
+
+TERM_PUBLIC void
+FIG_move(unsigned int x, unsigned int y)
+{
+    int last_FIG_posx = FIG_posx;
+    int last_FIG_posy = FIG_posy;
+
+    FIG_posx = x;
+    FIG_posy = y;
+    if (FIG_posx != last_FIG_posx || FIG_posy != last_FIG_posy)
+	FIG_poly_clean(FIG_polyvec_stat);
+}
+
+
+TERM_PUBLIC void
+FIG_vector(unsigned int ux, unsigned int uy)
+{
+    int x = ux, y = uy;
+
+    if (FIG_polyvec_stat != FIG_poly_part) {
+	FIG_line.pen_color = FIG_color;
+	FIG_line.fill_color = FIG_color;
+	FIG_line.style = FIG_type;
+	FIG_line.style_val = FIG_spacing;
+	FIG_line.depth = FIG_linedepth;
+	FIG_line.thickness = FIG_thickness;
+	FIG_poly_vec_cnt = 0;
+	/* allocate memory for the first point */
+	FIG_points = (F_point *) gp_realloc(FIG_points, sizeof(F_point), "FIG_points");		/* JFS */
+	FIG_points[FIG_poly_vec_cnt].x = FIG_xoff + FIG_posx;
+	FIG_points[FIG_poly_vec_cnt].y = term->ymax + FIG_yoff - FIG_posy;
+
+	FIG_poly_vec_cnt = 1;
+	FIG_polyvec_stat = FIG_poly_part;
+    }
+    /* allocate memory for the next point */
+    FIG_points = (F_point *) gp_realloc(FIG_points, (FIG_poly_vec_cnt + 1) *
+					sizeof(F_point), "FIG_points");		/* JFS */
+    FIG_points[FIG_poly_vec_cnt].x = FIG_xoff + x;
+    FIG_points[FIG_poly_vec_cnt].y = term->ymax + FIG_yoff - y;
+
+    FIG_poly_vec_cnt++;
+    if (FIG_poly_vec_cnt > FIG_poly_vec_max)
+	FIG_poly_clean(FIG_polyvec_stat);
+
+    FIG_posx = x;
+    FIG_posy = y;
+}
+
+
+TERM_PUBLIC void
+FIG_arrow(
+    unsigned int sx, unsigned int sy, /* start coord */
+    unsigned int ex, unsigned int ey, /* end coord */
+    int head)
+{
+    int cap_style;
+    double awidth, aheight;	/* arrow head sizes */
+
+    FIG_poly_clean(FIG_polyvec_stat);
+    cap_style = (FIG_line.style==DOTTED_LINE)? CAP_ROUND : FIG_line.cap_style;
+    fprintf(gpoutfile, "%d %d %d %d %d %d %d %d %d %9.3f %d %d %d %d %d %d\n",
+	    O_POLYLINE, FIG_line.type, FIG_type, FIG_thickness,
+	    FIG_color, FIG_color, FIG_linedepth,
+	    FIG_line.pen_style, FIG_line.fill_style, FIG_spacing,
+	    FIG_line.join_style, cap_style, FIG_line.radius,
+	    head ? 1 : 0, head==2 ? 1 : 0, 2);
+
+    /* arrow head(s) */
+    if (head) {
+	unsigned int headbackangleparameter = 0;
+	unsigned int headfillparameter = 0;
+
+	/* arrow head size */
+	if (curr_arrow_headlength==0) {
+	    awidth  = (double) (term->h_tic / 2 + 1);
+	    aheight = (double) term->h_tic;
+	} else {
+	    awidth  = (double) curr_arrow_headlength * 2*sin(curr_arrow_headangle*M_PI/180);
+	    aheight = (double) curr_arrow_headlength * cos(curr_arrow_headangle*M_PI/180);
+	}
+
+	/* arrow head geometry */
+	if ( curr_arrow_headbackangle < 70 )
+	    headbackangleparameter = 2;
+	else if ( curr_arrow_headbackangle > 110 )
+	    headbackangleparameter = 3;
+	else
+	    headbackangleparameter = 1;
+
+	if (curr_arrow_headfilled==2)
+	    headfillparameter = 1;
+	else
+	    headfillparameter = 0;
+
+	/* forward head */
+	fprintf(gpoutfile, "%d %d %.3f %.3f %.3f\n",
+		headbackangleparameter, headfillparameter,
+		1.0, awidth, aheight);
+	/* backward head */
+	if (head==2)
+	    fprintf(gpoutfile, "%d %d %.3f %.3f %.3f\n",
+		    headbackangleparameter,  headfillparameter,
+		    1.0, awidth, aheight);
+    }
+
+    /* arrow line */
+    fprintf(gpoutfile, "%d %d %d %d\n",
+	    FIG_xoff + sx, FIG_yoff + term->ymax - sy,
+	    FIG_yoff + ex, FIG_yoff + term->ymax - ey);
+
+    FIG_posx = ex;
+    FIG_posy = ey;
+}
+
+
+TERM_PUBLIC void
+FIG_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    char *s1, *s2, *output_string;
+
+    if (strlen(str) == 0)
+	return;
+
+    output_string = (char *) gp_alloc(2*strlen(str)+1, "FIG text");
+    s1 = (char *)str;
+    s2 = output_string;
+    do {
+	if (*s1 == '\\') *(s2++) = *s1;
+	*(s2++) = *s1;
+    } while ( *(s1++) );
+    FIG_poly_clean(FIG_polyvec_stat);
+    if (FIG_angle == 0.)
+	y -= term->v_char / 2;	/* assuming vertical center justified */
+    else {
+	x += (int)(term->v_char*sin(FIG_angle)/4.);
+	y -= (int)(term->v_char*cos(FIG_angle)/4.);
+    }
+
+    fprintf(gpoutfile, "%d %d %d %d %d %d %6.3f %6.3f %d %6.3f %6.3f %d %d %s\\001\n",
+	    OBJ_TEXT, FIG_justify, FIG_color, 0, FIG_DEFAULT,
+	    FIG_font_id, (float) FIG_font_s,
+	    FIG_angle, FIG_text_flags, (float) term->v_char,
+	    (float) term->h_char * strlen(str),
+	    FIG_xoff + x, term->ymax + FIG_yoff - y, output_string);
+
+    free(output_string);
+}
+
+TERM_PUBLIC int
+FIG_justify_text(enum JUSTIFY mode)
+{
+    switch (mode) {
+    case LEFT:
+	FIG_justify = T_LEFT_JUSTIFIED;
+	break;
+    case CENTRE:
+	FIG_justify = T_CENTER_JUSTIFIED;
+	break;
+    case RIGHT:
+	FIG_justify = T_RIGHT_JUSTIFIED;
+	break;
+	/* shouldn't happen */
+    default:
+	FIG_justify = T_LEFT_JUSTIFIED;
+	return (FALSE);
+	break;
+    }
+    return (TRUE);
+}
+
+TERM_PUBLIC int
+FIG_text_angle(int ang)
+{
+    FIG_angle = ang * M_PI_2 / 90. ;
+    return (TRUE);
+}
+
+TERM_PUBLIC void
+FIG_lpoint(unsigned int x, unsigned int y, int number)
+{
+    FIG_type = 0;		/* Solid lines for marker outline */
+    if (number % 100 >= 49 && number % 100 < 99) {	/* circles, squares, triangles */
+	int r, d, h, xpc, ypc;
+	int line_color, fill_color, fill_style;
+	int cnum, tnum, color, depth;
+
+	FIG_poly_clean(FIG_polyvec_stat);
+	depth = FIG_linedepth - 1;	/* Above error bars */
+	if (number > 1000)
+	    depth = FIG_depth + number / 1000 - 1;
+	number %= 1000;
+	if (depth < 0)
+	    depth = 0;
+	if (number < 100)
+	    color = FIG_color;
+	else if (FIG_use_color)
+	    color = number / 100 - 1;
+	else if (number / 100 >= WHITE)
+	    color = WHITE;
+	else
+	    color = DEFAULT;
+	number %= 100;
+	cnum = (number + 1) % 10;
+	tnum = (number - 49) / 10;
+	if (cnum < 5)
+	    line_color = (FIG_use_color ? BLACK : DEFAULT);
+	else
+	    line_color = FIG_color;
+	fill_color = color;
+	if (cnum == 0 || cnum == 5)
+	    fill_style = -1;
+	else
+	    fill_style = (cnum % 5) * 5;
+
+	xpc = FIG_xoff + x;
+	ypc = term->ymax + FIG_yoff - y;
+
+	if (tnum == 0) {	/* circle */
+	    r = FIG_current_pointsize * term->v_char / 4 + 1;
+	    fprintf(gpoutfile,
+		    "1 3 %d %d %d %d %d %d %d %6.3f 1 0.000 %d %d %d %d %d %d %d %d\n",
+		    FIG_type, FIG_thickness, line_color,
+		    fill_color, depth, 0, fill_style, FIG_spacing,
+		    xpc, ypc, r, r, xpc, ypc, xpc, ypc - r);
+	} else {
+	    fprintf(gpoutfile, "2 3 %d %d %d %d %d %d %d %6.3f 0 0 0 0 0 ",
+		    FIG_type, FIG_thickness, line_color,
+		    fill_color, depth, 0, fill_style, FIG_spacing);
+
+	    if (tnum == 1) {	/* square */
+		d = FIG_current_pointsize * term->v_char / 4 + 1;
+		fprintf(gpoutfile, "5\n\t%d %d %d %d %d %d %d %d %d %d\n",
+			xpc - d, ypc - d, xpc - d, ypc + d, xpc + d, ypc + d, xpc + d, ypc - d,
+			xpc - d, ypc - d);
+	    } else if (tnum == 2) {	/* diamond */
+		d = FIG_current_pointsize * term->v_char / 3 + 1;
+		fprintf(gpoutfile, "5\n\t%d %d %d %d %d %d %d %d %d %d\n",
+			xpc - d, ypc, xpc, ypc + d, xpc + d, ypc, xpc, ypc - d, xpc - d, ypc);
+	    } else if (tnum == 3) {	/* triangle up */
+		d = FIG_current_pointsize * term->v_char / 3 + 1;
+		h = d * 4 / 7;	/* About d times one 3rd of sqrt(3) */
+		fprintf(gpoutfile, "4\n\t%d %d %d %d %d %d %d %d\n",
+			xpc - d, ypc + h, xpc, ypc - 2 * h, xpc + d, ypc + h, xpc - d, ypc + h);
+	    } else if (tnum == 4) {	/* triangle down */
+		d = FIG_current_pointsize * term->v_char / 3 + 1;
+		h = d * 4 / 7;
+		fprintf(gpoutfile, "4\n\t%d %d %d %d %d %d %d %d\n",
+			xpc - d, ypc - h, xpc, ypc + 2 * h, xpc + d, ypc - h, xpc - d, ypc - h);
+	    }
+	}
+    } else {
+	int pt = number % 13;
+	switch (pt) {
+	default:	do_point(x, y, pt); break;
+	case 3: 	FIG_lpoint(x, y, 64); break;
+	case 4: 	FIG_lpoint(x, y, 68); break;
+	case 5: 	FIG_lpoint(x, y, 54); break;
+	case 6: 	FIG_lpoint(x, y, 58); break;
+	case 7: 	FIG_lpoint(x, y, 84); break;
+	case 8: 	FIG_lpoint(x, y, 88); break;
+	case 9: 	FIG_lpoint(x, y, 94); break;
+	case 10:	FIG_lpoint(x, y, 98); break;
+	case 11: 	FIG_lpoint(x, y, 74); break;
+	case 12:	FIG_lpoint(x, y, 78); break;
+	}
+    }
+}
+
+TERM_PUBLIC void
+FIG_pointsize(double arg_pointsize)
+{
+    FIG_current_pointsize = arg_pointsize < 0. ? 1. : arg_pointsize;
+    /* Bug-fix by hkeller@gwdg.de and K.B.: set pointsize for do_point() */
+    do_pointsize(arg_pointsize * FIG_font_s / (double) FIG_FONT_S);
+}
+
+TERM_PUBLIC void
+FIG_linewidth(double linewidth)
+{
+    FIG_current_linewidth = linewidth;
+}
+
+TERM_PUBLIC void
+FIG_reset()
+{
+    FIG_poly_clean(FIG_polyvec_stat);
+    FIG_posx = FIG_posy = 0;
+    fflush(gpoutfile);
+}
+
+TERM_PUBLIC void
+FIG_boxfill(
+    int style,
+    unsigned int x, unsigned int y,
+    unsigned int w, unsigned int h)
+{
+    int pen_color, fill_color, fill_style, fill_dens;
+
+    FIG_poly_clean(FIG_polyvec_stat);
+
+    FIG_line.pen_color = FIG_color;
+
+    switch( style & 0xf ) {
+    case FS_SOLID:
+    case FS_TRANSPARENT_SOLID:
+	/* style == 1 --> filled with intensity according to filldensity */
+        pen_color = FIG_line.pen_color;
+        fill_color = FIG_line.pen_color;
+        fill_dens = style >> 4;
+        if( fill_dens < 0 ) fill_dens = 0;
+        if( fill_dens > 100 ) fill_dens = 100;
+        if( FIG_color == -1 || FIG_color == 0 )
+            /* default color or black: solid 0%...100% -> 0...20 */
+            fill_style = fill_dens / 5;
+        else
+            /* all other colors: solid 0%...100% -> 40...20 */
+            fill_style = 40 - fill_dens / 5;
+        break;
+    case FS_PATTERN:
+    case FS_TRANSPARENT_PATTERN:
+	/* style == 2 --> filled with pattern according to fillpattern */
+        pen_color = FIG_line.pen_color;
+        fill_color = WHITE;
+        fill_style = 41 + ( ( (style>>4) < 0 ) ? 0 : style>>4 );
+        break;
+    case FS_EMPTY:
+    default:
+	/* style == 0 or unknown --> filled with background color */
+        pen_color = FIG_line.pen_color;
+        fill_color = WHITE;
+        fill_style = 20;
+    }
+
+    x = FIG_xoff + x;
+    y = term->ymax + FIG_yoff - y;
+
+    fprintf(gpoutfile, "%d %d %d %d %d %d %d %d %d %6.3f %d %d %d %d %d %d\n"
+            "  %d %d %d %d %d %d %d %d %d %d\n",
+            O_POLYLINE, FIG_line.type, FIG_line.style, FIG_line.thickness,
+            pen_color, fill_color, FIG_line.depth, FIG_line.pen_style,
+            fill_style, FIG_line.style_val, FIG_line.join_style,
+            FIG_line.cap_style, FIG_line.radius, 0, 0, 5,
+            x, y, x+w, y, x+w, y-h, x, y-h, x, y );
+}
+
+TERM_PUBLIC int FIG_make_palette(t_sm_palette *palette)
+{
+    int i;
+
+    /* Query to determine palette size */
+    if (palette==NULL) {
+	return FIG_palette_size; /* How big is palette ? */
+    }
+
+    FIG_poly_clean(FIG_polyvec_stat); /* Clean up current data */
+
+    if (FIG_palette_set == FALSE) {
+	/* Create new palette */
+	FIG_palette_set = TRUE;
+	if (FIG_use_color == FALSE || sm_palette.colorMode == SMPAL_COLOR_MODE_GRAY) {
+	    /* Gray palette */
+	    if (FIG_use_color == FALSE && sm_palette.colorMode == SMPAL_COLOR_MODE_RGB)
+		fprintf(stderr,	"Monochrome fig file: using gray palette instead of color\n");
+	    for (i = 0; i < sm_palette.colors; i++) {
+		int j = (int)(i * 255.0 / (sm_palette.colors-1) + 0.5);
+		fprintf(gpoutfile, "%d %d #%2.2x%2.2x%2.2x\n",
+		O_COLOR_DEF, (i + FIG_palette_offst), j, j, j);
+	    }
+	} else {
+	    /* Create colour/normal palette */
+	    for (i = 0; i < sm_palette.colors; i++) {
+		fprintf(gpoutfile, "%d %d #%2.2x%2.2x%2.2x\n",
+		O_COLOR_DEF, (i + FIG_palette_offst),
+		(int)( palette->color[i].r * 255 + 0.5 ),
+		(int)( palette->color[i].g * 255 + 0.5 ),
+		(int)( palette->color[i].b * 255 + 0.5 ) );
+	    }
+	}
+    } else {
+	fprintf(stderr, "fig: Attempt to set palette twice\n");
+    }
+    return 0;
+}
+
+/* This doesn't apply for FIG format files
+TERM_PUBLIC void FIG_previous_palette()
+{
+}
+*/
+
+TERM_PUBLIC void FIG_set_color(t_colorspec *colorspec)
+{
+    double gray = colorspec->value;
+    int new_color;
+
+    if (colorspec->type == TC_LT) {
+    	FIG_linetype(colorspec->lt);
+	return;
+    }
+
+    if (colorspec->type != TC_FRAC)
+	return;
+
+    new_color = (gray <= 0) ? 0 : (int)(gray * sm_palette.colors);
+    if (new_color >= FIG_palette_size)
+	new_color = FIG_palette_size - 1;
+    if (FIG_palette_set == FALSE) {
+	fprintf(stderr,"fig: Palette used before set\n"); /* Error condition */
+    }
+    new_color += FIG_palette_offst;
+    if (FIG_color != new_color) {
+	FIG_poly_clean(FIG_polyvec_stat);
+	FIG_color = new_color;
+    }
+}
+
+TERM_PUBLIC void FIG_filled_polygon(int points, gpiPoint *corners)
+{
+    int i,j;
+
+    FIG_poly_clean(FIG_polyvec_stat); /* Clean up current data */
+
+    fprintf(gpoutfile, "%d %d %d %d %d %d %d %d %d %9.3f %d %d %d %d %d %ld\n\t",
+	O_POLYLINE, T_POLYGON, FIG_line.style, 0,
+	FIG_color, FIG_color, FIG_line.depth,
+	FIG_line.pen_style, FIG_fill_style, FIG_line.style_val,
+	FIG_line.join_style, FIG_line.cap_style, FIG_line.radius,
+	0, 0, (long)(points+1));
+/* set thickness (arg 4) to 0 */
+
+    j = 0;
+    for (i = 0; i < points; i++) {
+	fprintf(gpoutfile, " %d %d", FIG_xoff + corners[i].x,
+	    term->ymax + FIG_yoff - corners[i].y);
+	if (j++ > 4 && i != points - 1) {
+		fputs("\n\t", gpoutfile);
+		j = 0;		/* JFS */
+	}
+    }
+    fprintf(gpoutfile, " %d %d", FIG_xoff + corners[0].x,
+	term->ymax + FIG_yoff - corners[0].y);
+    j++;
+    if (j != 0) {
+	putc('\n', gpoutfile);
+    }
+}
+
+TERM_PUBLIC void
+FIG_layer(t_termlayer syncpoint)
+{
+    static int plotno = 0;
+
+    /* We must ignore all syncpoints that we don't recognize */
+    switch (syncpoint) {
+
+	default:
+		break;
+	
+	case TERM_LAYER_BEFORE_PLOT:
+		FIG_poly_clean(FIG_polyvec_stat);
+		fputs("6", gpoutfile);
+		/* Bounding box?  Give it the entire plot area */
+		fprintf(gpoutfile, " %d %d %d %d\n",
+			FIG_xoff + plot_bounds.xleft, 
+			term->ymax + FIG_yoff - plot_bounds.ytop,
+			FIG_xoff + plot_bounds.xright, 
+			term->ymax + FIG_yoff - plot_bounds.ybot);
+		fprintf(gpoutfile, "# Begin plot #%d\n", ++plotno);
+		break;
+	
+	case TERM_LAYER_AFTER_PLOT:
+		FIG_poly_clean(FIG_polyvec_stat);
+		fprintf(gpoutfile, "# End plot #%d\n", plotno);
+		fputs("-6\n", gpoutfile);
+		break;
+	
+	case TERM_LAYER_RESET:
+		plotno = 0;
+		break;
+
+    }
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(fig_driver)
+    "fig", "FIG graphics language for XFIG graphics editor",
+    FIG_XMAX(INCH), FIG_YMAX(INCH), FIG_VCHAR, FIG_HCHAR,
+    FIG_VTIC(INCH), FIG_HTIC(INCH), FIG_options, FIG_init, FIG_reset,
+    FIG_text, null_scale, FIG_graphics, FIG_move, FIG_vector,
+    FIG_linetype, FIG_put_text, FIG_text_angle, FIG_justify_text,
+    FIG_lpoint, FIG_arrow, set_font_null, FIG_pointsize,
+    TERM_BINARY|TERM_CAN_DASH /*flags */ ,
+    0 /*suspend */ , 0 /*resume */ ,
+    FIG_boxfill, FIG_linewidth
+#ifdef USE_MOUSE
+    ,0, 0, 0, 0, 0 /* no mouse support for the fig terminal */
+#endif
+    , FIG_make_palette, 0 /*previous_palette*/, FIG_set_color, FIG_filled_polygon
+    , 0
+    , 0, 0, 0	/* no enhanced text support */
+    , FIG_layer
+TERM_TABLE_END(fig_driver)
+
+#undef LAST_TERM
+#define LAST_TERM fig_driver
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(fig)
+"1 fig",
+"?commands set terminal fig",
+"?set terminal fig",
+"?set term fig",
+"?terminal fig",
+"?term fig",
+"?fig",
+"?xfig",
+" The `fig` terminal device generates output in the Fig graphics language.",
+"",
+" Syntax:",
+"       set terminal fig {monochrome | color}",
+"                        {landscape | portrait}",
+"                        {small | big | size <xsize> <ysize>}",
+"                        {metric | inches}",
+"                        {pointsmax <max_points>}",
+"                        {solid | dashed}",
+"                        {font <fontname>} {fontsize <fsize>}",
+"                        {textnormal | {textspecial texthidden textrigid}}",
+"                        {{thickness|linewidth} <units>}",
+"                        {depth <layer>}",
+"                        {version <number>}",
+"",
+" `monochrome` and `color` determine whether the picture is black-and-white or",
+" `color`.  `small` and `big` produce a 5x3 or 8x5 inch graph in the default",
+" `landscape` mode and 3x5 or 5x8 inches in `portrait` mode.",
+" `size` sets (overrides) the size of the drawing",
+" area to <xsize>*<ysize> in units of inches or centimeters depending on the",
+" `inches` or `metric` setting in effect.",
+" The latter settings is also used as default units for editing with \"xfig\".",
+"",
+" `pointsmax <max_points>` sets the maximum number of points per polyline.",
+"",
+" `solid` inhibits automatic usage of `dash`ed lines when solid linestyles are",
+" used up, which otherwise occurs.",
+"",
+" `fontsize` sets the size of the text font to <fsize> points.  `textnormal`",
+" resets the text flags and selects postscript fonts, `textspecial` sets the",
+" text flags for LaTeX specials, `texthidden` sets the hidden flag and",
+" `textrigid` the rigid flag. ",
+"",
+" `depth` sets the default depth layer for all lines and text.  The default",
+" depth is 10 to leave room for adding material with \"xfig\" on top of the",
+" plot.",
+"",
+" `version` sets the format version of the generated fig output. Currently",
+" only versions 3.1 and 3.2 are supported.",
+"",
+" `thickness` sets the default line thickness, which is 1 if not specified.",
+" Overriding the thickness can be achieved by adding a multiple of 100 to the",
+" `linetype` value for a `plot` command.  In a similar way the `depth`",
+" of plot elements (with respect to the default depth) can be controlled by",
+" adding a multiple of 1000 to <linetype>.  The depth is then <layer> +",
+" <linetype>/1000 and the thickness is (<linetype>%1000)/100 or, if that is",
+" zero, the default line thickness. `linewidth` is a synonym for `thickness`.",
+"",
+" Additional point-plot symbols are also available with the `fig` driver. The",
+" symbols can be used through `pointtype` values % 100 above 50, with different",
+" fill intensities controlled by <pointtype> % 5 and outlines in black (for",
+" <pointtype> % 10 < 5) or in the current color.  Available symbols are",
+"         50 - 59:  circles",
+"         60 - 69:  squares",
+"         70 - 79:  diamonds",
+"         80 - 89:  upwards triangles",
+"         90 - 99:  downwards triangles",
+" The size of these symbols is linked to the font size.  The depth of symbols",
+" is by default one less than the depth for lines to achieve nice error bars.",
+" If <pointtype> is above 1000, the depth is <layer> + <pointtype>/1000-1.  If",
+" <pointtype>%1000 is above 100, the fill color is (<pointtype>%1000)/100-1.",
+"",
+" Available fill colors are (from 1 to 9): black, blue, green, cyan, red,",
+" magenta, yellow, white and dark blue (in monochrome mode: black for 1 to 6",
+" and white for 7 to 9).",
+"",
+" See `plot with` for details of <linetype> and <pointtype>.",
+"",
+" The `big` option is a substitute for the `bfig` terminal in earlier versions,",
+" which is no longer supported.",
+"",
+" Examples:",
+"       set terminal fig monochrome small pointsmax 1000  # defaults",
+"",
+"       plot 'file.dat' with points linetype 102 pointtype 759",
+" would produce circles with a blue outline of width 1 and yellow fill color.",
+"",
+"       plot 'file.dat' using 1:2:3 with err linetype 1 pointtype 554",
+" would produce errorbars with black lines and circles filled red.  These",
+" circles are one layer above the lines (at depth 9 by default).",
+"",
+" To plot the error bars on top of the circles use",
+"       plot 'file.dat' using 1:2:3 with err linetype 1 pointtype 2554"
+END_HELP(fig)
+#endif /* TERM_HELP */
+
+
+
+
+#if 0
+
+/* I hope this is enough to stop compilers looking in here
+ * (I think that anything inside #if 0 is still strictly
+ *  required to be valid C, rather than just any old junk
+ *  like this.)
+ */
+
+/*
+ * FIG : Facility for Interactive Generation of figures
+ * Copyright (c) 1985 by Supoj Sutanthavibul
+ * Parts Copyright (c) 1994 by Brian V. Smith
+ * Parts Copyright (c) 1991 by Paul King
+ *
+ * The X Consortium, and any party obtaining a copy of these files from
+ * the X Consortium, directly or indirectly, is granted, free of charge, a
+ * full and unrestricted irrevocable, world-wide, paid up, royalty-free,
+ * nonexclusive right and license to deal in this software and
+ * documentation files (the "Software"), including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons who receive
+ * copies from any such party to do so, with the only requirement being
+ * that this copyright notice remain intact.  This license includes without
+ * limitation a license to do the foregoing actions under any patents of
+ * the party supplying this software to the X Consortium.
+ */
+
+/*
+The only difference from version 3.0 to version 3.1 is that the position
+of the "magnet" has been shifted by 14 Fig units.
+In the 2.1 and older versions of xfig the grid was in multiples of 5 Fig
+units, but they were on intervals 4, 9, 14, 19, etc.
+When version 3.0 was created, coordinates were simply multiplied by the
+ratio of the resolutions (1200/80 = 15) so values like 4 became 60 instead
+of 74 ((4+1)*15 - 1).
+
+This means that figures converted from 2.1 and older files are offset by
+14 Fig units but new objects entered with version 3.0 are correct.
+
+In version 3.1 the magnet grid is at intervals 0, 75, 150, etc instead of
+-1, 74, 149, etc.
+Figures from 2.1 and older are correctly converted now and a warning is popped
+up when you read in a version 3.0 file that says you may have to offset the
+figure when you load it, using the x and y offsets in the file panel.
+
+--------------------------------------------------------------------------------
+Description of the Fig Format Follows
+--------------------------------------------------------------------------------
+
+ (1) The very first line is a comment line containing the name and version:
+	#FIG 3.1
+
+    The character # at the first column of a line indicates that the line
+    is a comment line which will be ignored.
+
+ (2) The first non-comment line consists of two numbers and two strings:
+
+	int	fig_resolution		(Fig units/inch)
+	string	orientation		("Landscape" or "Portrait")
+	string	justification		("Center" or "Flush Left")
+	string	units			("Metric" or "Inches")
+	int	coordinate_system	(1: origin is the lower left corner (NOT USED)
+					 2: upper left)
+
+    Fig_resolution is the resolution of the figure in the file.
+    Xfig will always write the file with a resolution of 1200ppi so it
+    will scale the figure upon reading it in if its resolution is different
+    from 1200ppi.  Pixels are assumed to be square.
+
+    Xfig will read the orientation string and change the canvas to match
+    either the Landscape or Portrait mode of the figure file.
+
+    The units specification is self-explanatory.
+
+    The coordinate_system variable is ignored - the origin is ALWAYS the
+    upper-left corner.
+
+    ** Coordinates are given in "fig_resolution" units.
+    ** Line thicknesses are given in 1/80 of an inch ("display units").  The
+       minimum line thickness is 0 (no line is drawn) and the maximum is 500.
+    ** dash-lengths/dot-gaps are given in 1/80 of an inch.
+
+
+ (3) The rest of the file contains various objects.  An object can be one
+    of six classes (or types).
+
+	0)	Color pseudo-object.
+	1)	Arc.
+	2)	Ellipse which is a generalization of circle.
+	3)	Polyline which includes polygon and box.
+	4)	Spline which includes closed/open control/interpolated spline.
+	5)	Text.
+	6)	Compound object which is composed of one or more objects.
+
+    In the following elaboration on object formats, every value of Fig
+    output are separated by blank characters or new line ('\n').  The
+    value of the unused parameters will be -1.
+
+    Some fields are described as "enumeration type" or "bit vector"; the
+    values which these fields can take are defined in the header file object.h.
+    The pen_style field is unused.
+    These values may be defined in some future version of Fig.
+
+    The two color fields (pen and fill; pen only, for texts) are
+    defined as follows:
+
+	    -1 = Default
+	     0 = Black
+	     1 = Blue
+	     2 = Green
+	     3 = Cyan
+	     4 = Red
+	     5 = Magenta
+	     6 = Yellow
+	     7 = White
+	  8-11 = four shades of blue (dark to lighter)
+	 12-14 = three shades of green (dark to lighter)
+	 15-17 = three shades of cyan (dark to lighter)
+	 18-20 = three shades of red (dark to lighter)
+	 21-23 = three shades of magenta (dark to lighter)
+	 24-26 = three shades of brown (dark to lighter)
+	 27-30 = four shades of pink (dark to lighter)
+	    31 = Gold
+
+	 values from 32 to 543 (512 total) are user colors and
+	 are defined in color pseudo-objects (type 0)
+
+    For WHITE color, the area fill field is defined as follows:
+
+	-1 = not filled
+	 0 = black
+	...  values from 1 to 19 are shades of grey, from darker to lighter
+	20 = white
+	21-40 not used
+	41-56 see patterns for colors, below
+
+    For BLACK or DEFAULT color, the area fill field is defined as follows:
+
+	-1 = not filled
+	 0 = white
+	...  values from 1 to 19 are shades of grey, from lighter to darker
+	20 = black
+	21-40 not used
+	41-56 see patterns for colors, below
+
+    For all other colors, the area fill field is defined as follows:
+
+	-1 = not filled
+	 0 = black
+	...  values from 1 to 19 are "shades" of the color, from darker to lighter.
+		A shade is defined as the color mixed with black
+	20 = full saturation of the color
+	...  values from 21 to 39 are "tints" of the color from the color to white.
+		A tint is defined as the color mixed with white
+	40 = white
+	41 = 30 degree left diagonal pattern
+	42 = 30 degree right diagonal pattern
+	43 = 30 degree crosshatch
+	44 = 45 degree left diagonal pattern
+	45 = 45 degree right diagonal pattern
+	46 = 45 degree crosshatch
+	47 = bricks
+	48 = circles
+	49 = horizontal lines
+	50 = vertical lines
+	51 = crosshatch
+	52 = fish scales
+	53 = small fish scales
+	54 = octagons
+	55 = horizontal "tire treads"
+	56 = vertical "tire treads"
+
+    The depth field is defined as follows:
+
+	 0 ... 999 where larger value means object is deeper than (under)
+		   objects with smaller depth
+
+    The line_style field is defined as follows:
+
+	-1 = Default
+	 0 = Solid
+	 1 = Dashed
+	 2 = Dotted
+
+    The style_val field is defined as the length, in 1/80 inches, of the on/off
+    dashes for dashed lines, and the distance between the dots, in 1/80 inches,
+    for dotted lines.
+
+    The join_style field is defined FOR LINES only as follows:
+
+	 0 = Miter (the default in xfig 2.1 and earlier)
+	 1 = Bevel
+	 2 = Round
+
+    The cap_style field is defined FOR LINES, OPEN SPLINES and ARCS only as follows:
+
+	 0 = Butt (the default in xfig 2.1 and earlier)
+	 1 = Round
+	 2 = Projecting
+
+    The arrow_type field is defined for LINES, ARCS and OPEN SPLINES
+    only as follows:
+
+	 0 = Stick-type (the default in xfig 2.1 and earlier)
+	 1 = Closed triangle:
+		|\
+		|  \
+		|    \
+		|    /
+		|  /
+		|/
+	 2 = Closed with "indented" butt:
+		|\
+		\  \
+		 \   \
+		  \    \
+		  /    /
+		 /   /
+		/  /
+		|/
+	 3 = Closed with "pointed" butt:
+		   |\
+		  /   \
+		 /      \
+		/         \
+		\         /
+		 \      /
+		  \   /
+		   |/
+
+    The arrow_style field is defined for LINES, ARCS and OPEN SPLINES
+    only as follows:
+
+	 0 = Hollow (actually filled with white)
+	 1 = Filled with pen_color
+
+ (3.0) OBJECT DEFINITION:
+
+    (3.1) Color Pseudo-objects (user-defined colors)
+	  This is used to define arbitrary colors beyond the 32 standard colors.
+	  The color objects must be defined before any other Fig objects.
+
+    First line:
+	type	name			(brief description)
+	----	----			-------------------
+	int	object_code		(always 0)
+	int	color_number		(color number, from 32-543 (512 total))
+     hex string	rgb values		(hexadecimal string describing red,
+					 green and blue values (e.g. #330099) )
+
+    (3.2) ARC
+
+    First line:
+	type	name			(brief description)
+	----	----			-------------------
+	int	object_code		(always 5)
+	int	sub_type		(0: pie-wedge (closed)
+					 1: open ended arc)
+	int	line_style		(enumeration type)
+	int	line_thickness		(1/80 inch)
+	int	pen_color		(enumeration type, pen color)
+	int	fill_color		(enumeration type, fill color)
+	int	depth			(enumeration type)
+	int	pen_style		(pen style, not used)
+	int	area_fill		(enumeration type, -1 = no fill)
+	float	style_val		(1/80 inch)
+	int	cap_style		(enumeration type)
+	int	direction		(0: clockwise, 1: counterclockwise)
+	int	forward_arrow		(0: no forward arrow, 1: on)
+	int	backward_arrow		(0: no forward arrow, 1: on)
+	float	center_x, center_y	(center of the arc)
+	int	x1, y1			(Fig units, the 1st point the user entered)
+	int	x2, y2			(Fig units, the 2nd point)
+	int	x3, y3			(Fig units, the last point)
+
+    Forward arrow line (Optional; absent if forward_arrow is 0):
+	type	name			(brief description)
+	----	----			-------------------
+	int	arrow_type		(enumeration type)
+	int	arrow_style		(enumeration type)
+	float	arrow_thickness		(1/80 inch)
+	float 	arrow_width		(Fig units)
+	float	arrow_height		(Fig units)
+
+    Backward arrow line (Optional; absent if backward_arrow is 0):
+	type	name			(brief description)
+	----	----			-------------------
+	int	arrow_type		(enumeration type)
+	int	arrow_style		(enumeration type)
+	float	arrow_thickness		(1/80 inch)
+	float	arrow_width		(Fig units)
+	float	arrow_height		(Fig units)
+
+    (3.3) COMPOUND
+
+    A line with object code 6 signifies the start of a compound.
+    There are four more numbers on this line which indicate the
+    upper right corner and the lower left corner of the bounding
+    box of this compound.  A line with object code -6 signifies
+    the end of the compound.  Compound may be nested.
+
+    First line:
+	type	name			(brief description)
+	----	----			-------------------
+	int	object_code		(always 6)
+	int	upperright_corner_x	(Fig units)
+	int	upperright_corner_y	(Fig units)
+	int	lowerleft_corner_x	(Fig units)
+	int	lowerleft_corner_y	(Fig units)
+
+    Subsequent lines:
+	objects
+	.
+	.
+
+    Last line:
+	-6
+
+    (3.4) ELLIPSE
+
+    First line:
+	type	name			(brief description)
+	----	----			-------------------
+	int	object_code		(always 1)
+	int	sub_type		(1: ellipse defined by radiuses
+					 2: ellipse defined by diameters
+					 3: circle defined by radius
+					 4: circle defined by diameter)
+	int	line_style		(enumeration type)
+	int	thickness		(1/80 inch)
+	int	pen_color		(enumeration type, pen color)
+	int	fill_color		(enumeration type, fill color)
+	int	depth			(enumeration type)
+	int	pen_style		(pen style, not used)
+	int	area_fill		(enumeration type, -1 = no fill)
+	float	style_val		(1/80 inch)
+	int	direction		(always 1)
+	float	angle			(radians, the angle of the x-axis)
+	int	center_x, center_y	(Fig units)
+	int	radius_x, radius_y	(Fig units)
+	int	start_x, start_y	(Fig units; the 1st point entered)
+	int	end_x, end_y		(Fig units; the last point entered)
+
+    (3.5) POLYLINE
+
+    First line:
+	type	name			(brief description)
+	----	----			-------------------
+	int	object_code		(always 2)
+	int	sub_type		(1: polyline
+					 2: box
+					 3: polygon
+					 4: arc-box)
+					 5: imported-picture bounding-box)
+	int	line_style		(enumeration type)
+	int	thickness		(1/80 inch)
+	int	pen_color		(enumeration type, pen color)
+	int	fill_color		(enumeration type, fill color)
+	int	depth			(enumeration type)
+	int	pen_style		(pen style, not used)
+	int	area_fill		(enumeration type, -1 = no fill)
+	float	style_val		(1/80 inch)
+	int	join_style		(enumeration type)
+	int	cap_style		(enumeration type, only used for POLYLINE)
+	int	radius			(1/80 inch, radius of arc-boxes)
+	int	forward_arrow		(0: off, 1: on)
+	int	backward_arrow		(0: off, 1: on)
+	int	npoints			(number of points in line)
+
+    Forward arrow line: same as ARC object
+
+    Backward arrow line: same as ARC object
+
+    Points line:
+	type	name			(brief description)
+	----	----			-------------------
+	int	x1, y1			(Fig units)
+	int	x2, y2			(Fig units)
+	  .
+	  .
+	int	xnpoints ynpoints	(this will be the same as the 1st
+					point for polygon and box)
+
+    PIC line:
+	type	name			(brief description)
+	----	----			-------------------
+	boolean	flipped			orientation = normal (0) or flipped (1)
+	char	file[]			name of picture file to import
+
+    (3.6) SPLINE
+
+    First line:
+	type	name			(brief description)
+	----	----			-------------------
+	int	object_code		(always 3)
+	int	sub_type		(0: open spline
+					 1: closed spline
+					 2: open interpolated spline
+					 3: closed interpolated spline)
+	int	line_style		(See the end of this section)
+	int	thickness		(1/80 inch)
+	int	pen_color		(enumeration type, pen color)
+	int	fill_color		(enumeration type, fill color)
+	int	depth			(enumeration type)
+	int	pen_style		(pen style, not used)
+	int	area_fill		(enumeration type, -1 = no fill)
+	float	style_val		(1/80 inch)
+	int	cap_style		(enumeration type, only used for open splines)
+	int	forward_arrow		(0: off, 1: on)
+	int	backward_arrow		(0: off, 1: on)
+	int	npoints			(number of control points in spline)
+
+    Forward arrow line: same as ARC object
+
+    Backward arrow line: same as ARC object
+
+    Points line: same as POLYLINE object
+
+    Control points line (absent if sub_type is 0 or 1):
+	Control points of interpolated spline.  There are two control
+	points for each knots.  A section i, of the spline is drawn
+	using Bezier cubic with the following four points:
+		(x ,y ), (rx ,ry ), (lx	  , ly   ), (x   , y   ).
+		  i  i	    i	i      i+1    i+1     i+1   i+1
+	For closed interpolated spline the last pair of control points,
+	(lxnpoints,lynpoints) and (rxnpoints,rynpoints) (which can be ignored),
+	are the same as (lx1,ly1) and (rx1,ry1) respectively.
+
+	type	name			(brief description)
+	----	----			-------------------
+	float	lx1, ly1		(Fig units)
+	float	rx1, ry1		(Fig units)
+	float	lx2, ly2		(Fig units)
+	float	rx2, ry2		(Fig units)
+	  .
+	  .
+	float	lxnpoints, lynpoints	(Fig units)
+	float	rxnpoints, rynpoints	(Fig units)
+
+    (3.7) TEXT
+	type	name			(brief description)
+	----	----			-------------------
+	int	object 			(always 4)
+	int	sub_type		(0: Left justified
+					 1: Center justified
+					 2: Right justified)
+	int	color			(enumeration type)
+	int	depth			(enumeration type)
+	int	pen_style		(enumeration , not used)
+	int	font 			(enumeration type)
+	float	font_size 		(font size in points)
+	float	angle			(radians, the angle of the text)
+	int	font_flags		(bit vector)
+	float	height			(Fig units)
+	float	length			(Fig units)
+	int	x, y			(Fig units, coordinate of the origin
+					 of the string.  If sub_type = 0, it is
+					 the lower left corner of the string.
+					 If sub_type = 1, it is the lower
+					 center.  Otherwise it is the lower
+					 right corner of the string.)
+	char	string[]		(ASCII characters; starts after a blank
+					 character following the last number and
+					 ends before the sequence '\001'.  This
+					 sequence is not part of the string.
+					 Characters above octal 177 are
+					 represented by \xxx where xxx is the
+					 octal value.  This permits Fig files to
+					 be edited with 7-bit editors and sent
+					 by e-mail without data loss.
+					 Note that the string may contain '\n'.)
+
+    The font_flags field is defined as follows:
+
+	 Bit	Description
+
+	  0	Rigid text (text doesn't scale when scaling compound objects)
+	  1	Special text (for LaTeX)
+	  2	PostScript font (otherwise LaTeX font is used)
+	  3	Hidden text
+
+    The font field is defined as follows:
+
+	For font_flags bit 2 = 0 (LaTeX fonts):
+
+	 0	Default font
+	 1	Roman
+	 2	Bold
+	 3	Italic
+	 4	Sans Serif
+	 5	Typewriter
+
+	For font_flags bit 3 = 1 (PostScript fonts):
+
+	-1	Default font
+	 0	Times Roman
+	 1	Times Italic
+	 2	Times Bold
+	 3	Times Bold Italic
+	 4	AvantGarde Book
+	 5	AvantGarde Book Oblique
+	 6	AvantGarde Demi
+	 7	AvantGarde Demi Oblique
+	 8	Bookman Light
+	 9	Bookman Light Italic
+	10	Bookman Demi
+	11	Bookman Demi Italic
+	12	Courier
+	13	Courier Oblique
+	14	Courier Bold
+	15	Courier Bold Oblique
+	16	Helvetica
+	17	Helvetica Oblique
+	18	Helvetica Bold
+	19	Helvetica Bold Oblique
+	20	Helvetica Narrow
+	21	Helvetica Narrow Oblique
+	22	Helvetica Narrow Bold
+	23	Helvetica Narrow Bold Oblique
+	24	New Century Schoolbook Roman
+	25	New Century Schoolbook Italic
+	26	New Century Schoolbook Bold
+	27	New Century Schoolbook Bold Italic
+	28	Palatino Roman
+	29	Palatino Italic
+	30	Palatino Bold
+	31	Palatino Bold Italic
+	32	Symbol
+	33	Zapf Chancery Medium Italic
+	34	Zapf Dingbats
+*/
+
+#endif
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/gd.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/gd.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/gd.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/gd.trm.svn-base	2012-01-03 17:07:29.763162500 -0800
@@ -0,0 +1,2655 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: gd.trm,v 1.136.2.10 2010/02/24 20:33:57 sfeam Exp $
+ * based on gif.trm,v 1.26.2.1 2000/05/01 00:17:20 joze
+ */
+
+/* GNUPLOT -- gd.trm */
+
+/*[
+ * Copyright 1998, 2001, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports PNG and JPEG output using
+ *  GD library 1.8, 2.0
+ *
+ * To Use:
+ *
+ * set terminal png ?options ...?
+ *
+ * Where an option is:
+ *
+ * transparent - generate transparent PNGs.  The first color will
+ * be the transparent one.
+ *
+ * interlace - generate interlaced PNGs.
+ *
+ * image size (in pixels)
+ *
+ * font size (tiny,small,medium,large,giant)
+ *
+ * font name (TrueType or Adobe Type 1 font name is passed to libgd)
+ *
+ * xrrggbb - sets the next color.  x is the literal character 'x',
+ * rrggbb are the red green and blue components in hex.  For example
+ * x00ff00 is green.  The background color is set first, then the
+ * color borders, then the X & Y axis, then the plotting colors.
+ * (The wierd color spec is in order to get around limitations
+ * in gnuplot's scanner.)
+ * EAM Feb 2010: This mechanism is totally obsolete except for setting the
+ * background color.  Revise the documentation accordingly.
+ *
+ * This driver is modeled after the PBM driver pbm.trm.
+ *
+ * AUTHORS
+ *  Sam Shen <sls@mh1.lbl.gov>
+ *  Alex Woo <woo@playfair.stanford.edu>
+ *  Ethan A Merritt <merritt@u.washington.edu>
+ *
+ * CONTRIBUTORS
+ *  Alfred Reibenschuh <alfred.reibenschuh@it-austria.com> or <fredo@blackbox.at>
+ *  Ben Laurie <ben@algroup.co.uk>
+ *
+ * This version outputs either indexed or truecolor (24-bit RGB) images
+ * The default size is 640x480 pixels.
+ *
+ ******************************************************************************
+ * PLEASE READ                                                                *
+ * This driver uses the gd library, available from http://www.libgd.org       *
+ * This driver allows you to use TrueType, OpenType, or Adobe Type 1 fonts.   *
+ * If you have libgd version 2.0.36 or later, you may also be able to access  *
+ * any fonts that are managed by the fontconfig utility.                      *
+ * You can use this driver without having any TrueType fonts installed,       *
+ * but the default fonts are comparatively limited.                           *
+ ******************************************************************************
+ *
+ * Petr Mikulik, Jan 1999: terminal entries for PM3D functionality
+ * Ethan Merritt, May 2001: modified gd/gif driver to produce png instead;
+ *                          added support for line width and TrueType fonts
+ */
+
+/* Approximate "fillstyle solid FRAC " for indexed palettes */
+#define PASTEL_PALETTE
+
+#define GD_DEFINED_COLORS	96	/* Must not exceed size of pm3d_color_names_tbl[] */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(png)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void PNG_options __PROTO((void));
+TERM_PUBLIC void PNG_init __PROTO((void));
+TERM_PUBLIC void PNG_graphics __PROTO((void));
+TERM_PUBLIC void PNG_text __PROTO((void));
+TERM_PUBLIC void PNG_linetype __PROTO((int linetype));
+TERM_PUBLIC void PNG_linewidth __PROTO((double linewidth));
+TERM_PUBLIC void PNG_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void PNG_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void PNG_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
+TERM_PUBLIC int PNG_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC void PNG_point __PROTO((unsigned int x, unsigned int y, int number));
+TERM_PUBLIC int PNG_text_angle __PROTO((int ang));
+TERM_PUBLIC void PNG_reset __PROTO((void));
+TERM_PUBLIC int PNG_set_font __PROTO((const char *fontname));
+TERM_PUBLIC void PNG_pointsize __PROTO((double ptsize));
+TERM_PUBLIC void PNG_boxfill(int, unsigned int, unsigned int, unsigned int, unsigned int);
+TERM_PUBLIC int PNG_make_palette (t_sm_palette *);
+/* TERM_PUBLIC void PNG_previous_palette (void); */
+TERM_PUBLIC void PNG_set_color (t_colorspec *);
+TERM_PUBLIC void PNG_filled_polygon (int, gpiPoint *);
+TERM_PUBLIC void PNG_image __PROTO((unsigned int, unsigned int, coordval *, gpiPoint *, t_imagecolor));
+
+/* To support "set term png enhanced" */
+TERM_PUBLIC void ENHGD_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
+TERM_PUBLIC void ENHGD_OPEN __PROTO((char * fontname, double fontsize,
+			double base, TBOOLEAN widthflag, TBOOLEAN showflag,
+			int overprint));
+TERM_PUBLIC void ENHGD_FLUSH __PROTO((void));
+
+
+#include "gd.h"
+
+/* Before version 2.0.36, the libgd function gdFTUseFontConfig() didn't */
+/* do what we need.  Test for earlier versions and ignore it.           */
+#ifdef GD_MAJOR_VERSION
+#  if (GD_MINOR_VERSION > 0  ||  GD_RELEASE_VERSION > 35)
+#    define gdUseFontConfig(x) gdFTUseFontConfig(x)
+#  endif
+#endif
+#ifndef gdUseFontConfig
+#define gdUseFontConfig(x) 0
+#endif
+
+#if defined(WIN32) && !defined(NONDLL)
+  /* static font pointers are recommended when using bgd.dll */
+# ifndef GD_NEED_LOCAL_FONT_POINTERS
+#  define GD_NEED_LOCAL_FONT_POINTERS
+# endif
+#endif
+
+#ifdef GD_NEED_LOCAL_FONT_POINTERS
+# include "gdfonts.h"
+# include "gdfontl.h"
+# include "gdfontmb.h"
+# include "gdfontt.h"
+# include "gdfontg.h"
+#endif
+
+/* This is required for the shared library version of libgd on Windows.
+   Newer versions of libgd (>=2.0.24 ?) already define it. */
+#ifndef BGD_EXPORT_DATA_PROT 
+# define BGD_EXPORT_DATA_PROT extern
+#endif
+
+/* These intermediate functions are necessary on Windows since 
+   the shared version of libgd uses a different calling convention
+   and there is no proper macro defined.
+*/
+#if defined(WIN32) && !defined(NONDLL)
+static void gp_gdImagePolygon(gdImagePtr, gdPointPtr, int, int);
+static void gp_gdImageFilledPolygon(gdImagePtr, gdPointPtr, int, int);
+#else
+# define gp_gdImagePolygon gdImagePolygon
+# define gp_gdImageFilledPolygon gdImageFilledPolygon 
+#endif
+
+static void PNG_PointX __PROTO((unsigned int, unsigned int));
+static void PNG_PointPlus __PROTO((unsigned int, unsigned int));
+static void PNG_Triangle(unsigned int x, unsigned int y, int direction,
+	void (*draw_func)(gdImagePtr, gdPointPtr, int, int));
+static void PNG_Diamond(unsigned int x, unsigned int y,
+	void (*draw_func)(gdImagePtr, gdPointPtr, int, int));
+static void PNG_init_brush __PROTO((int));
+
+#ifndef GD_NEED_LOCAL_FONT_POINTERS
+BGD_EXPORT_DATA_PROT gdFontPtr gdFontSmall;	/* 6x12 */
+BGD_EXPORT_DATA_PROT gdFontPtr gdFontLarge;	/* 8x16 */
+BGD_EXPORT_DATA_PROT gdFontPtr gdFontMediumBold;	/* 7x13 */
+BGD_EXPORT_DATA_PROT gdFontPtr gdFontGiant;  /* 9x15 */
+BGD_EXPORT_DATA_PROT gdFontPtr gdFontTiny;  /* 5x8 */
+#else
+static gdFontPtr gdFontSmall;	/* 6x12 */
+static gdFontPtr gdFontLarge;	/* 8x16 */
+static gdFontPtr gdFontMediumBold;	/* 7x13 */
+static gdFontPtr gdFontGiant;  /* 9x15 */
+static gdFontPtr gdFontTiny;  /* 5x8 */
+#endif
+
+#define GREG_XMAX 640
+#define GREG_YMAX 480
+
+/* This will be the default font */
+# define gdfont gdFontMediumBold
+# define PNG_VCHAR 13
+# define PNG_HCHAR 7
+
+#define PNG_TICSIZE (GREG_YMAX/100)
+
+#define PNG_MAX_COLORS 256
+#define GOT_NEXT_PROTO
+#endif
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+static TBOOLEAN PNG_initialized = FALSE;	/* Set when terminal first initialized */
+
+static struct {
+    gdImagePtr image;
+    gdFontPtr font;
+    unsigned int x, y;
+    int height;
+    int charh, charw;
+    int color;             /* Magic index returned by libgd */
+    int rgb;               /* Our guess at the corresponding rgb */
+    int n_colors;
+    int color_table[PNG_MAX_COLORS];
+    int rgb_table[PNG_MAX_COLORS];
+    int angle;
+    enum JUSTIFY justify;
+    int flags;
+    int linetype;
+    int linewidth;
+    TBOOLEAN capbutt;  /* use capbutt on lines with GD2, 20051205 MWS*/
+    TBOOLEAN use_builtin;
+    int ttfsize;
+    char *ttffont;
+    gdFontPtr default_font;
+    char *    default_ttffont;
+    int       default_ttfsize;
+    TBOOLEAN  TrueColor;
+    /* Variables for animated gif support: */
+    TBOOLEAN  animate;		/* Only gif supports animation */
+    int       loop_count;	/* Number of times to repeat sequence */
+    int       frame_count;	/* Number of frames in animation */
+    int       frame_delay;	/* Time between frames in .01 seconds */
+    TBOOLEAN  frame_optimization;
+    gdImagePtr previous_image;	/* Needed to encode animation as a series of deltas */
+} png_state;
+
+#define PNG_USE_TRANSPARENT 1
+#define PNG_USE_INTERLACE   2
+#define PNG_USE_CROP        4
+
+enum PNG_id {
+    PNG_TRANSPARENT, PNG_NOTRANSPARENT,
+    PNG_INTERLACE, PNG_NOINTERLACE,
+    PNG_CROP, PNG_NOCROP,
+    /* Font size */
+    PNG_TINY, PNG_SMALL, PNG_MEDIUM, PNG_LARGE, PNG_GIANT,
+    PNG_FONT,
+    PNG_SIZE,
+    PNG_ENHANCED, PNG_NOENHANCED,
+    PNG_TRUECOLOR, PNG_NOTRUECOLOR,
+    PNG_LINEWIDTH, PNG_BUTT, PNG_ROUNDED, PNG_DASHLENGTH,
+    GIF_ANIMATE, GIF_DELAY, GIF_LOOP, GIF_NOOPT, GIF_OPT,
+    PNG_OTHER
+};
+
+#ifdef Y
+#   undef Y
+#endif
+#define Y(y) (png_state.height - (y))
+
+static int PNG_XMAX = GREG_XMAX;
+static int PNG_YMAX = GREG_YMAX;
+static const int PNG_POINT_SCALE = 3;
+static int PNG_ps = 3;
+
+static struct gen_table PNG_opts[] =
+{
+    { "trans$parent", PNG_TRANSPARENT },
+    { "notran$sparent", PNG_NOTRANSPARENT },
+    { "inter$lace", PNG_INTERLACE },
+    { "nointer$lace", PNG_NOINTERLACE },
+    { "crop", PNG_CROP },
+    { "nocrop", PNG_NOCROP },
+    { "ti$ny", PNG_TINY },
+    { "s$mall", PNG_SMALL },
+    { "m$edium", PNG_MEDIUM },
+    { "l$arge", PNG_LARGE },
+    { "g$iant", PNG_GIANT },
+    { "fo$nt", PNG_FONT },
+    { "si$ze", PNG_SIZE },
+    { "enh$anced", PNG_ENHANCED },
+    { "noenh$anced", PNG_NOENHANCED },
+    { "true$color", PNG_TRUECOLOR },
+    { "notrue$color", PNG_NOTRUECOLOR },
+    { "linew$idth", PNG_LINEWIDTH },
+    { "anim$ate", GIF_ANIMATE }, /* gif animation options */
+    { "delay", GIF_DELAY },
+    { "loop", GIF_LOOP },
+    { "noopt$imize", GIF_NOOPT },
+    { "opt$imize", GIF_OPT }, /* end of gif animation options */
+    { "lw", PNG_LINEWIDTH },
+    { "butt", PNG_BUTT},
+    { "round$ed", PNG_ROUNDED},
+    { "dashl$ength", PNG_DASHLENGTH},
+    { "dl", PNG_DASHLENGTH},
+    { NULL, PNG_OTHER }
+};
+
+#undef MAXLINEWIDTH
+#define MAXLINEWIDTH 100
+static double PNG_linewidth_factor = 1.0;
+static double PNG_dashlength_factor = 1.0;
+
+/* EAM - gdImage structure to hold brushes for linewidth */
+/* We will allocate and initialize these on demand */
+typedef struct {
+    gdImagePtr im;
+    unsigned int last_rgb;
+    int bgnd;
+    int fgnd;
+}   PNG_BRUSH;
+
+static PNG_BRUSH *PNG_brush[MAXLINEWIDTH+1];
+
+typedef struct {
+    gdImagePtr im;
+    unsigned int last_rgb;
+    int fillpar;
+}   PNG_FILL_TILE;
+
+static PNG_FILL_TILE PNG_fill_tile = { (gdImagePtr)0, 0, 0 };
+
+/* To be used with libgd 2.0.34 to request Symbol encoding */
+#ifdef gdFTEX_Adobe_Custom
+static gdFTStringExtra PNG_FONT_INFO = {0,0,0,0,0,NULL,NULL};
+#endif
+
+#if defined(WIN32) && !defined(NONDLL)
+static void 
+gp_gdImagePolygon(gdImagePtr im, gdPointPtr p, int n, int c)
+{
+    gdImagePolygon(im, p, n, c);
+}
+
+static void 
+gp_gdImageFilledPolygon(gdImagePtr im, gdPointPtr p, int n, int c)
+{
+    gdImageFilledPolygon(im, p, n, c);
+}
+#endif
+
+
+/* Common code to crop the image around its bounding box, just before writing
+   down the file.
+*/
+static void
+image_do_crop ()
+{
+    if (png_state.flags & PNG_USE_CROP) {
+	int x, y, x1, y1, x2, y2, flag;
+	int bg = png_state.color_table[0]; /* index of the background color */
+	gdImagePtr im_crop;
+	for (flag=0, x1=0; x1 < gdImageSX(png_state.image)-1; x1++) {
+	    for (y=0; y < gdImageSY(png_state.image); y++)
+		if (gdImageGetPixel(png_state.image, x1, y) != bg) { flag = 1; break; }
+	    if (flag) break;
+	}
+	for (flag=0, x2=gdImageSX(png_state.image)-1; x2 >= x1; x2--) {
+	    for (y=0; y < gdImageSY(png_state.image); y++)
+		if (gdImageGetPixel(png_state.image, x2, y) != bg) { flag = 1; break; }
+	    if (flag) break;
+	}
+	for (flag=0, y1=0; y1 < gdImageSY(png_state.image)-1; y1++) {
+	    for (x=x1; x <= x2; x++)
+		if (gdImageGetPixel(png_state.image, x, y1) != bg) { flag = 1; break; };
+	    if (flag) break;
+	}
+	for (flag=0, y2=gdImageSY(png_state.image)-1; y2 >= y1; y2--) {
+	    for (x=x1; x <= x2; x++)
+		if (gdImageGetPixel(png_state.image, x, y2) != bg) { flag = 1; break; };
+	    if (flag) break;
+	}
+	x = x2 - x1 + 1; /* width */
+	y = y2 - y1 + 1; /* height */
+#if (GD2_VERS >= 2)
+	if (png_state.TrueColor)
+	    im_crop = gdImageCreateTrueColor(x,y);
+	else
+	    im_crop = gdImageCreate(x,y);
+	if (!im_crop) {
+	    int_warn(NO_CARET,"libgd: failed to create cropped image structure");
+	    return;
+	}
+	bg = gdImageColorAllocateAlpha(im_crop,255,255,255,127);
+#else
+	im_crop = gdImageCreate(x,y);
+#endif
+
+	gdImagePaletteCopy(im_crop, png_state.image);
+	if (png_state.flags & PNG_USE_TRANSPARENT) {
+	    gdImageColorTransparent(im_crop, bg);
+	    /* WARNING: This is a work-around for strangeness in libgd,  */
+	    /* which doesn't copy transparent pixels in TrueColor images. */
+	    if (png_state.TrueColor)
+		gdImageColorTransparent(png_state.image, -1);
+	} else
+	    gdImageColorTransparent(im_crop, -1);
+
+	gdImageCopy(im_crop, png_state.image, 0, 0, x1, y1, x, y);
+	gdImageDestroy(png_state.image);
+	png_state.image = im_crop;
+    }
+}
+
+
+static int PNG_FillSolid __PROTO((int fillpar));
+static int PNG_FillPattern __PROTO((int fillpar));
+static int PNG_FillTransparent __PROTO((int fillpar));
+
+static int
+PNG_FillSolid(int fillpar)
+{
+    int red   = (png_state.rgb >> 16) & 0xff;
+    int green = (png_state.rgb >> 8) & 0xff;
+    int blue  = png_state.rgb & 0xff;
+
+    double fact = (double)(100 - fillpar) * 0.01;
+
+    int color;
+
+    if (fact <= 0 || fact >= 1.0)
+	return png_state.color;
+
+    red   += (0xff - red) * fact;
+    green += (0xff - green) * fact;
+    blue  += (0xff - blue) * fact;
+
+    color = gdImageColorExact(png_state.image, red, green, blue);
+    if (color < 0) {
+	color = gdImageColorAllocate(png_state.image, red, green, blue);
+    }
+    if (color < 0) {
+	color = gdImageColorClosest(png_state.image, red, green, blue);
+    }
+
+    return color;
+}
+
+static int
+PNG_FillTransparent(int fillpar)
+{
+    int red   = (png_state.rgb >> 16) & 0xff;
+    int green = (png_state.rgb >> 8) & 0xff;
+    int blue  = png_state.rgb & 0xff;
+    int alpha = 127 * (float)(100-fillpar) / 100.;
+
+    return  gdImageColorExactAlpha(png_state.image, red, green, blue, alpha);
+}
+
+static int
+PNG_FillPattern(int style)
+{
+    int rgb = png_state.rgb;
+    int brgb = png_state.rgb_table[0];
+    int fillpar = (style >> 4) % 8;
+    style = style & 0xf;
+
+    if (!PNG_fill_tile.im || rgb != PNG_fill_tile.last_rgb || PNG_fill_tile.fillpar != fillpar) {
+
+	int foreground, background;
+
+	if (PNG_fill_tile.im) {
+	    gdImageDestroy(PNG_fill_tile.im);
+	    PNG_fill_tile.im = (gdImagePtr)0;
+	}
+
+	/* save new values */
+	PNG_fill_tile.fillpar = fillpar;
+	PNG_fill_tile.last_rgb = rgb;
+
+	/* create new tile */
+	if (!((PNG_fill_tile.im = gdImageCreate(8, 8))))
+	    int_error(NO_CARET,"libgd: failed to create pattern-fill tile");
+
+	background = gdImageColorAllocate(PNG_fill_tile.im,
+		(brgb >> 16) & 0xff, (brgb >> 8) & 0xff, brgb & 0xff);
+	if (style == FS_TRANSPARENT_PATTERN)
+	    gdImageColorTransparent(PNG_fill_tile.im, background);
+	gdImageFilledRectangle(PNG_fill_tile.im, 0, 0, 7, 7, background);
+
+	/* foreground */
+	foreground = gdImageColorAllocate(PNG_fill_tile.im,
+		(rgb >> 16) & 0xff, (rgb >> 8) & 0xff, rgb & 0xff);
+
+	switch (fillpar) {
+	    case 0: /* no fill */
+	    default:
+		break;
+	    case 1: /* cross-hatch */
+		gdImageLine(PNG_fill_tile.im, 0, 0, 7, 7, foreground);
+		gdImageLine(PNG_fill_tile.im, 0, 6, 6, 0, foreground);
+		break;
+	    case 2: /* double cross-hatch */
+		gdImageLine(PNG_fill_tile.im, 0, 0, 7, 7, foreground);
+		gdImageLine(PNG_fill_tile.im, 0, 6, 6, 0, foreground);
+		gdImageLine(PNG_fill_tile.im, 0, 2, 2, 0, foreground);
+		gdImageLine(PNG_fill_tile.im, 7, 3, 3, 7, foreground);
+		gdImageLine(PNG_fill_tile.im, 4, 0, 7, 3, foreground);
+		gdImageLine(PNG_fill_tile.im, 0, 4, 3, 7, foreground);
+		break;
+	    case 3: /* solid */
+		gdImageFilledRectangle(PNG_fill_tile.im, 0, 0, 7, 7, foreground);
+		break;
+	    case 4:
+		gdImageLine(PNG_fill_tile.im, 0, 0, 7, 7, foreground);
+		break;
+	    case 5:
+		gdImageLine(PNG_fill_tile.im, 0, 7, 7, 0, foreground);
+		break;
+	    case 6:
+		gdImageLine(PNG_fill_tile.im, 0, 0, 3, 7, foreground);
+		gdImageLine(PNG_fill_tile.im, 4, 0, 7, 7, foreground);
+		break;
+	    case 7:
+		gdImageLine(PNG_fill_tile.im, 0, 7, 3, 0, foreground);
+		gdImageLine(PNG_fill_tile.im, 4, 7, 7, 0, foreground);
+		break;
+	    case 8:
+		gdImageLine(PNG_fill_tile.im, 0, 0, 7, 3, foreground);
+		gdImageLine(PNG_fill_tile.im, 0, 4, 7, 7, foreground);
+		break;
+	    case 9:
+		gdImageLine(PNG_fill_tile.im, 0, 3, 7, 0, foreground);
+		gdImageLine(PNG_fill_tile.im, 0, 7, 7, 4, foreground);
+		break;
+	}
+    }
+
+    gdImageSetTile(png_state.image, PNG_fill_tile.im);
+    return (int)gdTiled;
+}
+
+static void
+PNG_PointX(unsigned int x, unsigned int y)
+{
+    gdImageLine(png_state.image, x - PNG_ps, y - PNG_ps,
+	    x + PNG_ps, y + PNG_ps, png_state.color);
+    gdImageLine(png_state.image, x + PNG_ps, y - PNG_ps,
+	    x - PNG_ps, y + PNG_ps, png_state.color);
+}
+
+static void
+PNG_PointPlus(unsigned int x, unsigned int y)
+{
+    gdImageLine(png_state.image, x - PNG_ps, y,
+	    x + PNG_ps, y, png_state.color);
+    gdImageLine(png_state.image, x, y - PNG_ps,
+	    x, y + PNG_ps, png_state.color);
+}
+
+static void
+PNG_Triangle(
+    unsigned int x, unsigned int y,
+    int direction,
+    void (*draw_func)(gdImagePtr, gdPointPtr, int, int))
+{
+    int delta  = (int)((1.33 * (double)PNG_ps) + 0.5);
+    int delta_ = (int)((0.67 * (double)PNG_ps) + 0.5);
+
+    gdPoint points[4];
+    points[0].x = x;
+    points[0].y = y - direction * delta;
+    points[1].x = x - delta;
+    points[1].y = y + direction * delta_;
+    points[2].x = x + delta;
+    points[2].y = y + direction * delta_;
+    points[3].x = points[0].x;
+    points[3].y = points[0].y;
+    draw_func(png_state.image, points, 4, png_state.color);
+}
+
+static void
+PNG_Diamond(
+    unsigned int x, unsigned int y,
+    void (*draw_func)(gdImagePtr, gdPointPtr, int, int))
+{
+    gdPoint points[5];
+    points[0].x = x;
+    points[0].y = y - PNG_ps;
+    points[1].x = x + PNG_ps;
+    points[1].y = y;
+    points[2].x = x;
+    points[2].y = y + PNG_ps;
+    points[3].x = x - PNG_ps;
+    points[3].y = y;
+    points[4].x = points[0].x;
+    points[4].y = points[0].y;
+    draw_func(png_state.image, points, 5, png_state.color);
+}
+
+/*
+ * _options()  Called when terminal type is selected.
+ * This procedure should parse options on the command line.  A list of the
+ * currently selected options should be stored in term_options[] in a form
+ * suitable for use with the set term command.  term_options[] is used by
+ * the save command.  Use options_null() if no options are available.
+ */
+TERM_PUBLIC void
+PNG_options()
+{
+    int i;
+    char *string;
+    unsigned long color;
+    TBOOLEAN new_colors = FALSE;
+    TBOOLEAN gif_anim_option = FALSE; /* set to TRUE if an animated gif option given */
+
+    if (!PNG_initialized) {
+	PNG_initialized = TRUE;
+	term_options[0] = '\0';
+	term->h_char = PNG_HCHAR; /* Default to medium font */
+	png_state.default_font = gdfont;
+	png_state.n_colors = 0;
+	png_state.flags = 0;
+	png_state.use_builtin = FALSE;
+	png_state.ttffont = NULL;
+	png_state.default_ttffont = NULL;
+	png_state.default_ttfsize = 0;
+	png_state.justify = CENTRE;
+	png_state.TrueColor = FALSE;
+	PNG_linewidth_factor = 1.0;
+	PNG_dashlength_factor = 1.0;
+	png_state.capbutt = FALSE; /* to preserve previous default behavior */
+#ifdef GD_NEED_LOCAL_FONT_POINTERS
+	gdFontSmall = gdFontGetSmall();
+	gdFontLarge = gdFontGetLarge();
+	gdFontMediumBold = gdFontGetMediumBold();
+	gdFontGiant = gdFontGetGiant();
+	gdFontTiny = gdFontGetTiny();
+#endif
+    } else {
+	/* FIXME EAM - these should never happen! */
+	if (!png_state.default_font) {
+	    fprintf(stderr,"gd.trm: caught initialization error\n");
+	    png_state.default_font = gdfont;
+	}
+    }
+
+    /* Annoying hack to handle the case of 'set termoption' after */
+    /* we are already in animation mode.                          */
+    if (c_token == 2)
+	FPRINTF((stderr,"gif: Maintaining animation state\n"));
+    else {
+	/* Otherwise reset animation parameters */
+	if (png_state.previous_image)
+	    gdImageDestroy(png_state.previous_image);
+	png_state.animate = FALSE;
+	png_state.previous_image = NULL;
+	png_state.frame_optimization = FALSE;
+	png_state.loop_count = 0;
+	/* And default font size */
+	term->h_char = PNG_HCHAR;
+	png_state.default_ttfsize = 0;
+	PNG_linewidth_factor = 1.0;
+	PNG_dashlength_factor = 1.0;
+    }
+
+    while (!END_OF_COMMAND) {
+	switch(lookup_table(&PNG_opts[0],c_token)) {
+	case PNG_TRANSPARENT:
+	    png_state.flags |= PNG_USE_TRANSPARENT;
+	    ++c_token;
+	    break;
+	case PNG_NOTRANSPARENT:
+	    png_state.flags &= ~PNG_USE_TRANSPARENT;
+	    ++c_token;
+	    break;
+	case PNG_INTERLACE:
+	    png_state.flags |= PNG_USE_INTERLACE;
+	    ++c_token;
+	    break;
+	case PNG_NOINTERLACE:
+	    png_state.flags &= ~PNG_USE_INTERLACE;
+	    ++c_token;
+	    break;
+	case PNG_CROP:
+	    png_state.flags |= PNG_USE_CROP;
+	    ++c_token;
+	    break;
+	case PNG_NOCROP:
+	    png_state.flags &= ~PNG_USE_CROP;
+	    ++c_token;
+	    break;
+
+#ifdef HAVE_GD_TTF
+# define UNSET_TTF_FONT \
+	    free(png_state.ttffont); \
+	    png_state.ttffont = NULL; \
+	    png_state.default_ttfsize = 2 * term->h_char - 2; \
+	    png_state.use_builtin = TRUE;
+#else
+# define UNSET_TTF_FONT \
+	    ; /* nothing to do */
+#endif
+
+	case PNG_TINY:
+	    png_state.default_font=gdFontTiny;
+	    term->v_char = png_state.default_font->h;
+	    term->h_char = png_state.default_font->w;
+	    ++c_token;
+	    UNSET_TTF_FONT;
+	    break;
+	case PNG_SMALL:
+	    png_state.default_font = gdFontSmall;
+	    term->v_char = png_state.default_font->h;
+	    term->h_char = png_state.default_font->w;
+	    ++c_token;
+	    UNSET_TTF_FONT;
+	    break;
+	case PNG_MEDIUM:
+	    png_state.default_font = gdFontMediumBold;
+	    term->v_char = png_state.default_font->h;
+	    term->h_char = png_state.default_font->w;
+	    ++c_token;
+	    UNSET_TTF_FONT;
+	    break;
+	case PNG_LARGE:
+	    png_state.default_font = gdFontLarge;
+	    term->v_char = png_state.default_font->h;
+	    term->h_char = png_state.default_font->w;
+	    ++c_token;
+	    UNSET_TTF_FONT;
+	    break;
+	case PNG_GIANT:
+	    png_state.default_font=gdFontGiant;
+	    term->v_char = png_state.default_font->h;
+	    term->h_char = png_state.default_font->w;
+	    ++c_token;
+	    UNSET_TTF_FONT;
+	    break;
+
+	case PNG_FONT:
+	    c_token++;
+#ifdef HAVE_GD_TTF
+	    if (END_OF_COMMAND) {
+		free(png_state.ttffont);
+		png_state.ttffont = NULL;
+		png_state.default_ttfsize = 0;
+	    } else {
+		int brect[8];
+		char *err;
+
+		if (isstringvalue(c_token)) {
+		    char *s = try_to_get_string();
+		    char *comma = strrchr(s,',');
+		    double fontsize;
+		    if (comma && (1 == sscanf(comma+1,"%lf",&fontsize))) {
+			png_state.default_ttfsize = (int)(fontsize+0.5);
+			png_state.ttfsize = png_state.default_ttfsize;
+			*comma = '\0';
+		    }
+		    if (*s) {
+			free(png_state.ttffont);
+			png_state.ttffont = s;
+		    } else {
+			continue;
+		    }
+		} else {
+		    free(png_state.ttffont);
+		    png_state.ttffont = gp_alloc(token_len(c_token)+1,"new font");
+		    copy_str(png_state.ttffont, c_token, token_len(c_token)+1);
+		    c_token++;
+		}
+		free(png_state.default_ttffont);
+		png_state.default_ttffont = gp_strdup(png_state.ttffont);
+
+		/* First try the old GDFONTPATH mechanism for locating fonts */
+		(void)gdUseFontConfig(0);
+		err = gdImageStringFT(NULL, &brect[0], 0,
+			png_state.ttffont, (double)png_state.default_ttfsize,
+			0.0, 0, 0, "test");
+	
+		/* If that didn't work, try again using the fontconfig mechanism */
+		if (err && gdUseFontConfig(1)) {
+		    err = gdImageStringFT(NULL, &brect[0], 0,
+			png_state.ttffont, (double)png_state.default_ttfsize,
+			0.0, 0, 0, "test");
+		}
+
+		/* If we still haven't found the font, punt to the internal non-TTF default set */
+		if (err) {
+		    fprintf(stderr, "%s when opening font %s, trying default\n",
+				err, png_state.ttffont);
+		    free(png_state.ttffont);
+		    free(png_state.default_ttffont);
+		    png_state.ttffont = NULL;
+		    png_state.default_ttffont = NULL;
+		}
+
+	    }
+#else
+	    c_token++;
+	    fprintf(stderr,"No TTF font support, using internal non-scalable font\n");
+#endif
+	    break;
+# undef UNSET_TTF_FONT
+
+	case PNG_SIZE:
+	    c_token++;
+	    if (END_OF_COMMAND) {
+		PNG_XMAX = GREG_XMAX;
+		PNG_YMAX = GREG_YMAX;
+	    } else {
+		PNG_XMAX = real_expression();
+		if (equals(c_token, ",")) {
+		    c_token++;
+		    PNG_YMAX = real_expression();
+		}
+		if (PNG_XMAX < 0)
+		    PNG_XMAX = GREG_XMAX;
+		if (PNG_YMAX < 0)
+		    PNG_YMAX = GREG_YMAX;
+	    }
+	    term->ymax = PNG_YMAX;
+	    term->xmax = PNG_XMAX;
+	    /* EAM Apr 2003 - same tic size on both x and y axes */
+	    term->v_tic = (PNG_XMAX < PNG_YMAX) ? PNG_XMAX/100 : PNG_YMAX/100;
+	    if (term->v_tic < 1)
+		term->v_tic = 1;
+	    term->h_tic = term->v_tic;
+	    break;
+	case PNG_ENHANCED:
+	    term->flags |= TERM_ENHANCED_TEXT;
+	    term->put_text = ENHGD_put_text;
+	    ++c_token;
+	    break;
+	case PNG_NOENHANCED:
+	    term->flags &= ~TERM_ENHANCED_TEXT;
+	    term->put_text = PNG_put_text;
+	    ++c_token;
+	    break;
+	case PNG_TRUECOLOR:
+	    png_state.TrueColor = TRUE;
+	    term->flags |= TERM_ALPHA_CHANNEL;
+	    c_token++;
+	    break;
+	case PNG_NOTRUECOLOR:
+	    png_state.TrueColor = FALSE;
+	    term->flags &= ~TERM_ALPHA_CHANNEL;
+	    c_token++;
+	    break;
+	case PNG_LINEWIDTH:
+	    c_token++;
+	    PNG_linewidth_factor = real_expression();
+	    if (PNG_linewidth_factor < 0)
+		PNG_linewidth_factor = 1.0;
+	    break;
+	case PNG_DASHLENGTH:
+	    c_token++;
+	    PNG_dashlength_factor = real_expression();
+	    if (PNG_dashlength_factor <= 0.2)
+		PNG_dashlength_factor = 1.0;
+	    break;
+
+	/* parse gif animation options */
+	case GIF_ANIMATE:
+	    if (strncmp("gif",term->name,3))
+		int_error(c_token,"Only the gif terminal supports animation");
+	    c_token++;
+	    png_state.animate = TRUE;
+	    png_state.frame_count = 0;
+	    png_state.frame_delay = 10;
+	    png_state.frame_optimization = FALSE;
+	    gif_anim_option = 1;
+	    break;
+	case GIF_DELAY:
+	    if (strncmp("gif",term->name,3))
+		int_error(c_token,"Only the gif terminal supports animation");
+	    c_token++;
+	    png_state.frame_delay = int_expression();
+	    if (png_state.frame_delay <= 0)
+		png_state.frame_delay = 10;
+	    gif_anim_option = 1;
+	    break;
+	case GIF_LOOP:
+	    if (strncmp("gif",term->name,3))
+		int_error(c_token,"Only the gif terminal supports animation");
+	    c_token++;
+	    png_state.loop_count = int_expression();
+	    gif_anim_option = 1;
+	    break;
+	case GIF_NOOPT:
+	    if (strncmp("gif",term->name,3))
+		int_error(c_token,"Only the gif terminal supports animation");
+	    c_token++;
+	    png_state.frame_optimization = FALSE;
+	    gif_anim_option = 1;
+	    break;
+	case GIF_OPT:
+	    if (strncmp("gif",term->name,3))
+		int_error(c_token,"Only the gif terminal supports animation");
+	    c_token++;
+	    png_state.frame_optimization = TRUE;
+	    gif_anim_option = 1;
+	    break;
+
+	case PNG_BUTT:
+	    png_state.capbutt = TRUE;
+	    c_token++;
+	    break;
+
+	case PNG_ROUNDED:
+	    png_state.capbutt = FALSE;
+	    c_token++;
+	    break;
+
+	case PNG_OTHER:
+	default:
+	    /* not "size" */
+	    string = gp_input_line + token[c_token].start_index;
+
+#ifdef HAVE_GD_TTF
+	    /* Check for explicit TTF font size */
+	    if (sscanf(string, "%d", &i) == 1) {
+		if (i > 0 && i < 999)
+		    png_state.default_ttfsize = i;
+		else
+		    int_warn(c_token,"illegal font size");
+		++c_token;
+	        break;
+	    }
+#endif
+
+	    if (sscanf(string, "x%lx", &color) != 1) {
+		int_error(c_token, "invalid color spec, must be xRRGGBB");
+	    } else if (png_state.n_colors == PNG_MAX_COLORS && new_colors) {
+		int_warn(c_token, "too many colors, ignoring");
+		++c_token;
+	    } else {
+	        if (!new_colors) {
+		    new_colors = TRUE;
+		    png_state.n_colors = 0;
+		}
+		png_state.rgb_table[png_state.n_colors++] = color;
+		++c_token;
+	    }
+	    break;
+	}
+    }
+
+#ifndef GIF_ANIMATION /* animated gifs not supported by the current GD library */
+    if (gif_anim_option) {
+	png_state.animate = FALSE;
+	int_warn(NO_CARET, "gif animation options ignored (not compiled into this binary)");
+    }
+#endif
+
+#ifdef HAVE_GD_TTF
+    /* If no font has been chosen but there is a default, use it */
+    if (!png_state.ttffont && !png_state.use_builtin) {
+	char *external_default = getenv("GNUPLOT_DEFAULT_GDFONT");
+	int brect[8];
+	char *err;
+
+	if (external_default)
+		png_state.ttffont = gp_strdup(external_default);
+	else	/* Might as well try some plausible font; it's no worse than failing immediately */
+		png_state.ttffont = gp_strdup("arial");
+
+	free(png_state.default_ttffont);
+	png_state.default_ttffont = gp_strdup(png_state.ttffont);
+	if (png_state.default_ttfsize == 0)
+		png_state.default_ttfsize = 2 * term->h_char - 2;
+
+	/* First try the old GDFONTPATH mechanism for locating fonts */
+	(void)gdUseFontConfig(0);
+	err = gdImageStringFT(NULL, &brect[0], 0,
+		png_state.ttffont, (double)png_state.default_ttfsize,
+		0.0, 0, 0, "test");
+
+	/* If that didn't work, try again using fontconfig mechanism */
+	if (err && gdUseFontConfig(1)) {
+	    err = gdImageStringFT(NULL, &brect[0], 0,
+		png_state.ttffont, (double)png_state.default_ttfsize,
+		0.0, 0, 0, "test");
+	}
+
+	/* If we still haven't found the font, punt to the internal non-TTF default set */
+	if (err) {
+		fprintf(stderr,"%s when opening font \"%s\", using internal non-scalable font\n",
+			err, png_state.ttffont);
+		free(png_state.ttffont);
+		free(png_state.default_ttffont);
+		png_state.ttffont = NULL;
+		png_state.default_ttffont = NULL;
+	}
+
+    }
+
+    /* If no explicit TTF font size found, generate default */
+    if (png_state.default_ttfsize == 0)
+	png_state.default_ttfsize = 2 * term->h_char - 2;
+    png_state.ttfsize = png_state.default_ttfsize;
+
+    /* Find approximate character width of selected TTF font   */
+    /* This is needed in order to set appropriate border width */
+    if (png_state.default_ttffont) {
+	int brect[8];
+	char *err;
+	err = gdImageStringFT(NULL, &brect[0], 0,
+		png_state.default_ttffont, (double)png_state.default_ttfsize,
+		0.0, 0, 0, "f00000000g");
+	if (!err) {
+	    term->h_char = .11 * (float)(brect[2] - brect[0]) + 0.5;
+	    term->v_char = 1.1 * (float)(brect[1] - brect[7]) + 0.5;
+	}
+    }
+#endif
+
+    /* This code is shared by png, gif, and jpeg terminal types */
+    if (!strcmp(term->name,"jpeg"))
+	png_state.flags &= ~PNG_USE_TRANSPARENT;
+
+    /* now generate options string */
+
+    if (png_state.flags & PNG_USE_TRANSPARENT) {
+	strcat(term_options, "transparent ");
+    }
+    if (png_state.flags & PNG_USE_INTERLACE) {
+	strcat(term_options, "interlace ");
+    }
+    /* JPEG files are always 24-bit color */
+    if (strcmp(term->name, "jpeg") == 0) {
+	png_state.TrueColor = TRUE;
+	term->flags |= TERM_ALPHA_CHANNEL;
+    } else if (png_state.TrueColor) {
+	strcat(term_options, "truecolor ");
+    }
+    if (!(png_state.flags & PNG_USE_CROP)) {
+	strcat(term_options, "no");
+    }
+    strcat(term_options, "crop ");
+
+    if (term->flags & TERM_ENHANCED_TEXT) {
+	strcat(term_options, "enhanced ");
+    }
+
+    if (png_state.ttffont) {
+	sprintf(term_options + strlen(term_options),
+		"font %s %d ", png_state.ttffont, png_state.ttfsize);
+    } else switch (term->h_char) {
+    case 5:
+	strcat(term_options,"tiny ");
+	break;
+    case 6:
+	strcat(term_options, "small ");
+	break;
+    case 7:
+    default:
+	strcat(term_options, "medium ");
+	break;
+    case 8:
+	strcat(term_options, "large ");
+	break;
+    case 9:
+	strcat(term_options,"giant ");
+	break;
+    }
+
+    if (PNG_linewidth_factor != 1.0)
+	sprintf(term_options + strlen(term_options),
+	    "linewidth %3.1f ", PNG_linewidth_factor);
+
+    if (PNG_dashlength_factor != 1.0)
+	sprintf(term_options + strlen(term_options),
+	    "dashlength %3.1f ", PNG_dashlength_factor);
+
+    if (png_state.capbutt) {
+	sprintf(term_options + strlen(term_options),
+	    "butt ");
+    }
+
+    if (png_state.animate) {
+	sprintf(term_options + strlen(term_options),
+	    "animate delay %d loop %d %soptimize ", 
+	    png_state.frame_delay, png_state.loop_count,
+	    png_state.frame_optimization ? "" : "no");
+    }
+
+    sprintf(term_options + strlen(term_options),
+	    "size %d,%d ", PNG_XMAX, PNG_YMAX);
+
+    if (new_colors)
+	for (i = 0; strlen(term_options) + 9 < MAX_LINE_LEN &&
+	     i < png_state.n_colors; i++) {
+	    sprintf(term_options + strlen(term_options),
+		"x%06x ", png_state.rgb_table[i]);
+	}
+}
+
+
+/*
+ * _init()  Called once, when the device is first selected.  This procedure
+ * should set up things that only need to be set once, like handshaking and
+ * character sets etc...
+ */
+TERM_PUBLIC void
+PNG_init()
+{
+int i;
+
+    png_state.linetype = 0;
+    png_state.linewidth = 1;
+
+    /* Clear brush array, then initialize a few small ones */
+    for (i=2; i<=MAXLINEWIDTH; i++)
+	PNG_brush[i] = NULL;
+}
+
+/*
+ * Internal helper routine to initialize brushes used for stroking linewidth > 1
+ */
+static void
+PNG_init_brush(int width)
+{
+    PNG_BRUSH *brush = PNG_brush[width];
+
+    if (!brush) {
+	brush = gp_alloc(sizeof(PNG_BRUSH),"gd brush");
+	PNG_brush[width] = brush;
+	brush->last_rgb = -99;  /* Something invalid */
+	if (!((brush->im = gdImageCreate(width,width))))
+	    int_error(NO_CARET,"libgd: failed to create brush structure");
+	brush->bgnd = gdImageColorAllocate( brush->im, 255, 255, 255 );
+	gdImageFill(brush->im, 0, 0, brush->bgnd);
+	gdImageColorTransparent(brush->im, brush->bgnd);
+    }
+
+    if (png_state.color != brush->last_rgb) {
+	brush->fgnd = gdImageColorResolve(brush->im,
+	    gdImageRed(png_state.image,png_state.color),
+	    gdImageGreen(png_state.image,png_state.color),
+	    gdImageBlue(png_state.image,png_state.color) );
+	brush->last_rgb = png_state.color;
+
+	/* EAM - quick and dirty is to fill the entire brush (square nib)  */
+	/* It might be better to approximate a circular nib by selectively */
+	/* coloring the individual pixels of the brush image.          	   */
+	gdImageFilledRectangle(brush->im, 0, 0, width-1, width-1, brush->fgnd);
+    }
+}
+
+/*
+ * _reset()  Called when gnuplot is exited, the output device changed or
+ * the terminal type changed.  This procedure should reset the device,
+ * possibly flushing a buffer somewhere or generating a form feed.
+ */
+TERM_PUBLIC void
+PNG_reset()
+{
+    int i;
+    /* EAM - Clean up the brushes used for linewidth */
+    for (i=2; i<=MAXLINEWIDTH; i++) {
+	if (PNG_brush[i]) {
+	    if (PNG_brush[i]->im)
+		gdImageDestroy(PNG_brush[i]->im);
+	    PNG_brush[i] = NULL;
+	}
+    }
+    if (PNG_fill_tile.im) {
+	gdImageDestroy(PNG_fill_tile.im);
+	PNG_fill_tile.im = (gdImagePtr)0;
+    }
+#ifdef GIF_ANIMATION
+    if (png_state.animate) {
+	gdImageGifAnimEnd(gpoutfile);
+	png_state.frame_count = 0;
+	png_state.animate = FALSE;
+	fprintf(stderr,"End of animation sequence\n");
+    }
+#endif
+}
+
+#if 0
+/* use  #if 1  that's just for debugging */
+void
+PNG_show_current_palette()
+{
+    int i;
+
+    fprintf(stderr, "*****\n SHOW THE PALETTE! total=%i\n",
+	    gdImageColorsTotal(png_state.image));
+    for (i=0; i < gdImageColorsTotal(png_state.image); i++) {
+	/* Use access macros to learn colors. */
+	fprintf(stderr, "%i\tr=%d\t g=%d\tb=%d\n",
+		i,
+		gdImageRed(png_state.image,i),
+		gdImageGreen(png_state.image,i),
+		gdImageBlue(png_state.image,i));
+    }
+}
+#endif
+
+/*
+How this works: Gray interval [0;1] will be mapped to interval
+[0;sm_palette.colors-1] those r,g,b components are mapped by the array
+below palette.offset equals 0 since png_smooth_color[0..colors] are
+from ColorAllocate
+*/
+static int png_smooth_color[gdMaxColors];
+
+#ifdef PASTEL_PALETTE
+/*
+ * This is only needed in order to maintain png_state_rgb for fillstyle variants,
+ * and only for palette-based coloring. It doesn't seem worth the space or effort.
+ * EAM November 2004
+ */
+static int png_smooth_rgb[gdMaxColors];
+#endif
+
+  /* TODO: how to recover from a multiplot with two colour pm3d maps?
+     They must use the same palette! Or palette size must be
+     restricted to certain number of colours---a new user's option
+  */
+
+TERM_PUBLIC int PNG_make_palette (t_sm_palette *palette)
+{
+    int i;
+    if (palette == NULL) {
+	/* If the output format is TrueColor there in no color limit */
+	if (png_state.TrueColor)
+	    return(0);
+
+	/* return maximal number of colours in a PNG palette */
+	i = gdMaxColors /*256*/ - gdImageColorsTotal(png_state.image);
+	/* the latter is the number of currently allocated colours. We want
+	   to allocate the rest */
+	/*BACK PLEASE  fprintf(stderr,"colors in PNG palette=%i\n",(int)gdMaxColors); */
+	if (i == 0) {
+	    i = (sm_palette.colors <= 0) ? -1 : sm_palette.colors;
+	        /* (no more colorus) : (previous palette (obviously multiplot mode)) */
+#if 0
+	    if (i > 0) fprintf(stderr,"reusing it again\n");
+#endif
+	}
+	return i;
+    }
+    if (0 == gdMaxColors /*256*/ - gdImageColorsTotal(png_state.image))
+	return 0; /* reuse previous palette (without warning) */
+    for (i = 0; i < sm_palette.colors; i++) {
+	png_smooth_color[i] = gdImageColorAllocate(png_state.image,
+	    (int)( palette->color[i].r * 255 + 0.5 ), /* r,g,b values for png */
+	    (int)( palette->color[i].g * 255 + 0.5 ), /* terminal are [0;255] */
+	    (int)( palette->color[i].b * 255 + 0.5 ) );
+#ifdef PASTEL_PALETTE
+	png_smooth_rgb[i] = (((int)(palette->color[i].r * 255.) & 0xff) << 16)
+	                  + (((int)(palette->color[i].g * 255.) & 0xff) << 8)
+			  +  ((int)(palette->color[i].b * 255.) & 0xff);
+#endif
+	if (png_smooth_color[i] < 0) { /* this should never happen! take away? */
+	    FPRINTF((stderr,"png_smooth_color[i]<0 cannot happen"));
+	    exit(1);
+	}
+#if 0
+	fprintf(stderr,"ALLOCATED: i=%i\t=> pal_index=%i\tr=%g g=%g b=%g\n",
+	    i, png_smooth_color[i],
+	    palette->color[i].r, palette->color[i].g, palette->color[i].b );
+#endif
+    }
+    return 0;
+}
+
+
+TERM_PUBLIC
+void PNG_set_color (t_colorspec *colorspec)
+{
+    double gray = colorspec->value;
+
+    if (colorspec->type == TC_LT) {
+	int savetype = png_state.linetype;
+	PNG_linetype(colorspec->lt);
+	/* Harmless now; will be needed if we ever support dot/dash */
+	png_state.linetype = savetype;
+    }
+
+    if (colorspec->type == TC_RGB) {
+	png_state.rgb = colorspec->lt;
+	png_state.color = gdImageColorResolve(png_state.image,
+	    colorspec->lt >> 16, (colorspec->lt >> 8) & 0xff, colorspec->lt & 0xff);
+    }
+
+    if (colorspec->type != TC_FRAC)
+	return;
+
+    if (png_state.TrueColor) {
+	rgb255_color color;
+	rgb255maxcolors_from_gray(gray, &color);
+	png_state.color = gdImageColorResolve(png_state.image,
+	    (int)color.r, (int)color.g, (int)color.b);
+	png_state.rgb = (color.r << 16) + (color.g << 8) +color.b;
+	return;
+    } else {
+	int png_color = (gray <= 0) ? 0 : (int)(gray * sm_palette.colors);
+	if (png_color >= sm_palette.colors)
+	    png_color = sm_palette.colors - 1;
+	/* map [0;1] to interval [0;png_smooth_colors-1] */
+	png_state.color = png_smooth_color[ png_color ];
+#ifdef PASTEL_PALETTE
+	png_state.rgb = png_smooth_rgb[ png_color ];
+#endif
+    }
+}
+
+TERM_PUBLIC
+void PNG_filled_polygon(int points, gpiPoint *corners)
+{
+    int i;
+    int fillpar = corners->style >> 4;
+    int color = png_state.color;
+    
+    /* since gpiPoint carries more than just x and y if
+     * we have EXTENDED_COLOR_SPECS defined, we need to
+     * copy it to the gdPointPtr struct; make it static
+     * so that is faster (joze) */
+    static gdPointPtr gd_corners = (gdPointPtr) 0;
+    static unsigned int size = 0;
+    if (points > size) {
+	size = points;
+	gd_corners = gp_realloc(gd_corners, sizeof(gdPoint) * size,
+	    "PNG_filled_polygon->gd_corners");
+    }
+    for (i = 0; i < points; i++) {
+	gd_corners[i].x = corners[i].x;
+	gd_corners[i].y = Y(corners[i].y);
+    }
+
+    switch (corners->style & 0xf) {
+	case FS_EMPTY: /* fill with background color */
+	    color = png_state.color_table[0];
+	    break;
+	case FS_SOLID: /* solid fill */
+	    color = PNG_FillSolid(fillpar);
+	    break;
+	case FS_TRANSPARENT_SOLID:
+	    if (png_state.TrueColor)
+		color = PNG_FillTransparent(fillpar);
+	    else
+		color = PNG_FillSolid(fillpar);
+	    break;
+	case FS_PATTERN: /* pattern fill */
+	case FS_TRANSPARENT_PATTERN:
+	    color = PNG_FillPattern(corners->style);
+	    break;
+	default:
+	    color = png_state.color;
+	    break;
+    }
+
+    gdImageFilledPolygon(png_state.image, gd_corners, points, color);
+}
+
+/*
+ * This function is used for filledboxes
+ * style parameter is some garbled hash combining fillstyle and filldensity
+ */
+TERM_PUBLIC void
+PNG_boxfill(
+    int style,
+    unsigned int x, unsigned int y,
+    unsigned int width, unsigned int height)
+{
+    unsigned int x1, y1, x2, y2;
+    int          color;
+
+    /* fillpar:
+     * - solid   : 0 - 100
+     * - pattern : 0 - 100
+     */
+    int fillpar = style >> 4;
+
+    switch (style & 0xf) {
+	case FS_EMPTY: /* fill with background color */
+	    color = png_state.color_table[0];
+	    break;
+	case FS_SOLID: /* solid fill */
+	    color = PNG_FillSolid(fillpar);
+	    break;
+	case FS_TRANSPARENT_SOLID:
+	    if (png_state.TrueColor)
+		color = PNG_FillTransparent(fillpar);
+	    else
+		color = PNG_FillSolid(fillpar);
+	    break;
+	case FS_PATTERN: /* pattern fill */
+	case FS_TRANSPARENT_PATTERN:
+	    color = PNG_FillPattern(style);
+	    break;
+	default:
+	    /* should never happen */
+	    color = png_state.color;
+	    break;
+    }
+
+    x1 = x;
+    x2 = x + width - 1;
+    y2 = Y(y);
+    y1 = y2 - height + 1;
+    gdImageFilledRectangle(png_state.image, x1, y1, x2, y2, color);
+}
+
+/*
+ * _graphics()  Called just before a plot is going to be displayed.  This
+ * procedure should set the device into graphics mode.  Devices which can't
+ * be used as terminals (like plotters) will probably be in graphics mode
+ * always and therefore won't need this.
+ */
+TERM_PUBLIC void
+PNG_graphics()
+{
+    int i;
+    unsigned int rgb;
+ 
+    for (i = png_state.n_colors; i < GD_DEFINED_COLORS; i++)
+	png_state.rgb_table[i] = pm3d_color_names_tbl[i].value;
+    if (png_state.n_colors < GD_DEFINED_COLORS)
+	png_state.n_colors = GD_DEFINED_COLORS;
+
+#if (GD2_VERS >= 2)
+    /* TrueColor images default to a black background; load white instead.	*/
+    /* If PNG_USE_TRANSPARENT, store the background alpha in the output file	*/
+    /* but apply alpha for the rest of the image internally. Otherwise you	*/
+    /* see only background through the topmost transparent layer.		*/
+    if (png_state.TrueColor) {
+        unsigned int brgb = png_state.rgb_table[0];
+	png_state.image = gdImageCreateTrueColor(PNG_XMAX, PNG_YMAX);
+	if (!png_state.image)
+	    int_error(NO_CARET,"libgd: failed to create output image structure");
+	if (png_state.flags & PNG_USE_TRANSPARENT) {
+	    rgb = gdImageColorAllocateAlpha(png_state.image,
+		(brgb >> 16) & 0xff, (brgb >> 8) & 0xff, brgb & 0xff, 127);
+	    gdImageSaveAlpha(png_state.image, 1);
+	    gdImageAlphaBlending(png_state.image, 0);
+	} else {
+	    rgb = gdImageColorAllocate(png_state.image,
+		(brgb >> 16) & 0xff, (brgb >> 8) & 0xff, brgb & 0xff);
+	}
+	gdImageFill(png_state.image, 1, 1, rgb);
+	gdImageAlphaBlending(png_state.image, 1);
+    } else
+#endif
+	png_state.image = gdImageCreate(PNG_XMAX, PNG_YMAX);
+    if (!png_state.image)
+	int_error(NO_CARET,"libgd: failed to create output image structure");
+
+    png_state.height = PNG_YMAX - 1;
+    png_state.charw = term->h_char;	/* png_state.font->w; */
+    png_state.charh = term->v_char;	/* png_state.font->h; */
+    png_state.font = png_state.default_font;
+    png_state.color = 0;
+
+    for (i = 0; i < png_state.n_colors; i++) {
+	rgb = png_state.rgb_table[i];
+	png_state.color_table[i] =
+	    gdImageColorAllocate(png_state.image, (rgb >> 16) & 0xff,
+				 (rgb >> 8) & 0xff, rgb & 0xff);
+    }
+    if (png_state.flags & PNG_USE_TRANSPARENT)
+	gdImageColorTransparent(png_state.image, png_state.color_table[0]);
+    else
+	gdImageColorTransparent(png_state.image, -1);
+
+}
+
+/*
+ * _text()  Called immediately after a plot is displayed.  This procedure
+ * should set the device back into text mode if it is also a terminal, so
+ * that commands can be seen as they're typed.  Again, this will probably
+ * do nothing if the device can't be used as a terminal.
+ */
+TERM_PUBLIC void
+PNG_text()
+{
+    image_do_crop();
+    if (png_state.flags & PNG_USE_INTERLACE)
+	gdImageInterlace(png_state.image, 1);
+    gdImagePng(png_state.image, gpoutfile);
+    gdImageDestroy(png_state.image);
+}
+
+/* _move(x,y)  Called at the start of a line.  The cursor should move to the
+ * (x,y) position without drawing.
+ */
+TERM_PUBLIC void
+PNG_move(unsigned int x, unsigned int y)
+{
+    png_state.x = x;
+    png_state.y = y;
+}
+
+/* _vector(x,y)  Called when a line is to be drawn.  This should display a line
+ * from the last (x,y) position given by _move() or _vector() to this new (x,y)
+ * position.
+ */
+TERM_PUBLIC void
+PNG_vector(unsigned int x, unsigned int y)
+{
+    int lw = png_state.linewidth;
+
+    /* Dashed line style; used only for the x/y grid */
+    if (png_state.linetype == -1) {
+	static int last_lw = -1;
+	static double last_dl = -1;
+	static int last_color = -1;
+	static int *png_linetype_dotted = NULL;
+	static int ssize;
+
+	/* Adjust the style when linewidth or dashlength has changed. */
+	if (lw != last_lw || PNG_dashlength_factor != last_dl || last_color != png_state.color) {
+	    int i;
+	    int dashlength = 2 * PNG_dashlength_factor;
+	    int spacelength = 3 * PNG_dashlength_factor;
+	    int psize = lw*lw*dashlength;
+	    
+	    ssize = lw*lw*(spacelength + dashlength);
+	    png_linetype_dotted = gp_realloc( png_linetype_dotted, ssize*sizeof(int), "dashes");
+
+	    /* Fill style with with color then transparent.
+	     * The style is 2 on / 3 off and scales with linewidth and dashlength.
+	     */
+	    for(i = 0;i < psize; i++)
+		png_linetype_dotted[i] = png_state.color;
+	    for (;i < ssize; i++)
+		png_linetype_dotted[i] = gdTransparent;
+	    last_lw = lw;
+	    last_dl = PNG_dashlength_factor;
+	    last_color = png_state.color;
+	}
+	/* This driver does not in general use gd's built-in SetThickness command,
+	 * because it only works right for purely horizontal or vertical lines.
+	 * But that's OK for a 2D grid.
+	 */
+	gdImageSetStyle(png_state.image, png_linetype_dotted, ssize);
+	gdImageSetThickness(png_state.image,lw);
+	gdImageLine(png_state.image, png_state.x, Y(png_state.y), x, Y(y), gdStyled);
+	gdImageSetThickness(png_state.image,1);
+
+    /* All other (not dashed) vectors */
+    } else {
+	if (png_state.linewidth == 1) {
+#if (GD2_VERS >= 2) && defined(gdAntiAliased) 
+	    gdImageSetThickness(png_state.image,1);
+	    gdImageSetAntiAliased(png_state.image, png_state.color);
+	    gdImageLine(png_state.image, png_state.x, Y(png_state.y),
+			x, Y(y), gdAntiAliased);
+#else
+	    gdImageLine(png_state.image, png_state.x, Y(png_state.y),
+			x, Y(y), png_state.color);
+#endif
+#if (GD2_VERS >= 2)
+	} else if (png_state.capbutt){
+
+	    gdImageSetThickness(png_state.image,png_state.linewidth);
+	    gdImageLine(png_state.image, png_state.x, Y(png_state.y),
+			x, Y(y), png_state.color);
+#endif
+	} else {
+	    /* EAM - Implement linewidth by using a brush */
+	    PNG_init_brush(lw);
+	    gdImageSetBrush(png_state.image, PNG_brush[lw]->im);
+	    gdImageLine(png_state.image, png_state.x, Y(png_state.y),
+			x, Y(y), gdBrushed );
+	}
+    }
+
+    png_state.x = x;
+    png_state.y = y;
+}
+
+/* _linetype(lt)  Called to set the line type before text is displayed or
+ * line(s) plotted.
+ * Negative linetypes are defined in gadgets.h
+ * lt 0 and upwards are used for plots 0 and upwards.
+ * If _linetype() is called with lt greater than the available line types,
+ * it should map it to one of the available line types.
+ */
+TERM_PUBLIC void
+PNG_linetype(int type)
+{
+    if (type >= (png_state.n_colors - 3))
+	type %= (png_state.n_colors - 3);
+    if (type <= LT_BACKGROUND) /* LT_NODRAW, LT_BACKGROUND, LT_UNDEFINED */
+	type = -3;	/* Draw in background color */
+
+    png_state.color = png_state.color_table[type + 3];
+    png_state.rgb = png_state.rgb_table[type + 3];
+    png_state.linetype = type;
+}
+
+/* Use the "brush" tools in the gd library to control line width.
+ * Pre-define brushes for linewidths 2, 3, 4, 5, 6 (1 doesn't need a brush!).
+ * Here we just remember the state.
+ */
+TERM_PUBLIC void
+PNG_linewidth(double linewidth)
+{
+    png_state.linewidth = (int)(PNG_linewidth_factor * linewidth+0.49);
+    if (png_state.linewidth > MAXLINEWIDTH) png_state.linewidth = MAXLINEWIDTH;
+    if (png_state.linewidth < 1) png_state.linewidth = 1;
+}
+
+/* _put_text(x,y,str)  Called to display text at the (x,y) position,
+ * while in graphics mode.   The text should be vertically (with respect
+ * to the text) justified about (x,y).  The text is rotated according
+ * to _text_angle and then horizontally (with respect to the text)
+ * justified according to _justify_text.
+ */
+#ifdef HAVE_GD_TTF
+TERM_PUBLIC void
+PNG_put_text(unsigned int x, unsigned int y, const char *string)
+{
+    if (png_state.ttffont) {
+	int brect[8]; char *err;
+	/* Draw once with a NULL image to get the bounding rectangle */
+	/* then draw it again, centered.                             */
+	err = gdImageStringFT(NULL, brect, png_state.color,
+			png_state.ttffont, (double)png_state.ttfsize,
+			(double)png_state.angle * M_PI_2 / 90. ,
+			x, Y(y), (char *)string);
+	if (err) {
+	    fprintf(stderr,"gdImageStringFT: %s while printing string %s with font %s\n",
+		err,string,png_state.ttffont);
+	} else {
+	    x += sin((double)png_state.angle * M_PI_2/90.) * (double)png_state.charh/4.;
+	    y -= cos((double)png_state.angle * M_PI_2/90.) * (double)png_state.charh/4.;
+	    switch (png_state.justify) {
+		case RIGHT:
+				x -= (brect[2]-brect[0]);
+				y += (brect[3]-brect[1]);
+				break;
+		case CENTRE:
+				x -= (brect[2]-brect[0]) / 2.;
+				y += (brect[3]-brect[1]) / 2.;
+				break;
+		case LEFT:
+		default:	break;
+	    }
+	    err = gdImageStringFT(png_state.image, brect, png_state.color,
+			png_state.ttffont, (double)png_state.ttfsize,
+			(double)png_state.angle * M_PI_2 / 90.,
+			x, Y(y), (char *)string);
+	    if (err)
+		fprintf(stderr,"gdImageStringFT: %s while printing string %s with font %s\n",
+		    err,string,png_state.ttffont);
+	}
+    } else if (png_state.angle != 0) {
+	x -= png_state.charh / 2;
+	switch (png_state.justify) {
+	    case RIGHT:	y -= png_state.charw * strlen(string);
+			break;
+	    case CENTRE:y -= png_state.charw * strlen(string) / 2;
+			break;
+	    case LEFT:
+	    default:	break;
+	}
+	gdImageStringUp(png_state.image, png_state.font,
+			x, Y(y),
+			(unsigned char *)string, png_state.color);
+    } else {
+	y += png_state.charh / 2;
+	switch (png_state.justify) {
+	    case RIGHT:	x -= png_state.charw * strlen(string);
+			break;
+	    case CENTRE:x -= png_state.charw * strlen(string) / 2;
+			break;
+	    case LEFT:
+	    default:	break;
+	}
+	gdImageString(png_state.image, png_state.font,
+		      x, Y(y),
+		      (unsigned char *)string, png_state.color);
+    }
+}
+
+#else  /* not HAVE_GD_TTF */
+
+TERM_PUBLIC void
+PNG_put_text(unsigned int x, unsigned int y, const char *string)
+{
+    if (png_state.angle == 0) {
+	y += png_state.charh / 2;
+	gdImageString(png_state.image, png_state.font,
+		      x, Y(y),
+		      (unsigned char *)string, png_state.color);
+    } else {
+	x -= png_state.charh / 2;
+	gdImageStringUp(png_state.image, png_state.font,
+			x, Y(y),
+			(unsigned char *)string, png_state.color);
+    }
+}
+
+#endif /* HAVE_GD_TTF */
+
+
+TERM_PUBLIC int
+PNG_text_angle(int ang)
+{
+    while (ang < -180) ang += 360;	/* Should not be needed, but reported to */
+    while (ang > 180) ang -= 360;	/* avoid a bug in some libgd versions    */
+    png_state.angle = ang;
+    return TRUE;
+}
+
+TERM_PUBLIC int
+PNG_justify_text(enum JUSTIFY mode)
+{
+#ifdef HAVE_GD_TTF
+    png_state.justify = mode;
+    return TRUE;
+#else
+    return null_justify_text(mode);
+#endif
+}
+
+TERM_PUBLIC void
+PNG_point(unsigned int x, unsigned int y, int number)
+{
+    int save_color = png_state.color;
+
+    if (number < 0) { /* Dot */
+	gdImageSetPixel(png_state.image, x, Y(y), png_state.color);
+	return;
+    }
+    /* Use current linewidth to draw the point symbol */
+    if (png_state.linewidth > 1) {
+	/* EAM - Implement linewidth by using a brush */
+	int lw   = png_state.linewidth;
+	PNG_init_brush(lw);
+	gdImageSetBrush(png_state.image, PNG_brush[lw]->im);
+	png_state.color = gdBrushed;
+    }
+
+    y = Y(y);
+
+    switch (number % 13) {
+    case 0: /* plus */
+    default:
+	PNG_PointPlus(x, y);
+	break;
+    case 1: /* X */
+	PNG_PointX(x, y);
+	break;
+    case 2: /* star */
+	PNG_PointPlus(x, y);
+	PNG_PointX(x, y);
+	break;
+    case 3: /* box */
+	gdImageRectangle(png_state.image, x - PNG_ps, y - PNG_ps,
+			 x + PNG_ps, y + PNG_ps, png_state.color);
+	break;
+    case 4: /* box                   filled */
+	gdImageFilledRectangle(png_state.image, x - PNG_ps, y - PNG_ps,
+			       x + PNG_ps, y + PNG_ps, png_state.color);
+	break;
+    case 5: /* circle */
+	gdImageArc(png_state.image, x, y, 2 * PNG_ps, 2 * PNG_ps,
+		   0, 360, png_state.color);
+	break;
+    case 6: /* circle (disk)         filled */
+#if (GD2_VERS >= 2)
+	gdImageFilledArc(png_state.image, x, y, 2 * PNG_ps, 2 * PNG_ps,
+		   0, 360, png_state.color, gdArc);
+#else
+	gdImageArc(png_state.image, x, y, 2 * PNG_ps, 2 * PNG_ps,
+		   0, 360, png_state.color);
+	gdImageFillToBorder(png_state.image, x, y,
+			    png_state.color, png_state.color);
+#endif
+	break;
+    case 7: /* triangle */
+	PNG_Triangle(x, y, 1, gp_gdImagePolygon);
+	break;
+    case 8: /* triangle              filled */
+	PNG_Triangle(x, y, 1, gp_gdImageFilledPolygon);
+	break;
+    case 9: /* upside down triangle */
+	PNG_Triangle(x, y, -1, gp_gdImagePolygon);
+	break;
+    case 10: /* upside down triangle  filled */
+	PNG_Triangle(x, y, -1, gp_gdImageFilledPolygon);
+	break;
+    case 11: /* diamond */
+	PNG_Diamond(x, y, gp_gdImagePolygon);
+	break;
+    case 12: /* diamond               filled */
+	PNG_Diamond(x, y, gp_gdImageFilledPolygon);
+	break;
+    }
+
+    png_state.color = save_color;
+}
+
+TERM_PUBLIC int
+PNG_set_font(const char *fontname)
+{
+    int  sep;
+    int  size;
+    gdFontPtr font = png_state.default_font;
+    char *name = gp_strdup(fontname);
+
+    sep = strcspn(fontname,",");
+    strncpy(name,fontname,sep);
+    name[sep] = '\0';
+    size = png_state.default_ttfsize;
+    sscanf (&(fontname[sep+1]),"%d",&size);
+
+    if (!strcmp(name,"small"))
+	font = gdFontSmall;
+    else if (!strcmp(name,"medium"))
+	font = gdFontMediumBold;
+    else if (!strcmp(name,"large"))
+	font = gdFontLarge;
+    else if (!strcmp(name,"giant"))
+	font = gdFontGiant;
+    else if (!strcmp(name,"tiny"))
+	font = gdFontTiny;
+    else if (*name) {
+	/* New ttf font */
+	free(png_state.ttffont);
+	png_state.ttffont = gp_strdup(name);
+	png_state.ttfsize = size;
+    } else {
+	/* Restore initial default font */
+	free(png_state.ttffont);
+	png_state.ttffont = gp_strdup(png_state.default_ttffont);
+	png_state.ttfsize = png_state.default_ttfsize;
+    }
+    free(name);
+
+    png_state.font  = font;
+    png_state.charw = font->w;
+    png_state.charh = font->h;
+
+/* EAM 9-Feb-2003 Make new font size visible to higher level routines like write_multiline */
+    term->h_char = font->w;
+    term->v_char = font->h;
+#ifdef HAVE_GD_TTF
+    /* Find approximate character width and height of selected TTF font */
+    if (png_state.ttffont) {
+	int brect[8];
+	char *err;
+	err = gdImageStringFT(NULL, &brect[0], 0,
+		png_state.ttffont, (double)png_state.ttfsize,
+		0.0, 0, 0, "f00000000g");
+	if (!err) {
+	    term->h_char = .11 * (float)(brect[2] - brect[0]) + 0.5;
+	    term->v_char = 1.1 * (float)(brect[1] - brect[7]) + 0.5;
+	}
+    }
+#endif
+
+    return TRUE;
+}
+
+TERM_PUBLIC void
+PNG_pointsize(double ptsize)
+{
+    if (ptsize < 0)
+	ptsize = 1;
+    PNG_ps = (int)(((double)PNG_POINT_SCALE * ptsize) + 0.5);
+}
+
+/*
+ * Ethan A Merritt November 2003
+ *	- Support for enhanced text mode
+ * BUGS:
+ *	- placement of overprinted characters is not correct;
+ *	  the overprinted text (pass 2) should be centered, not left-justified
+ * PROBLEMS:
+ *	- the Symbol font encoding didn't work in libgd until 2.0.21
+ * 	- Placement of superscripts and subscripts relies on information
+ * 	  in the font description that is not always reliable
+ *	- the TTF character encoding for non-keyboard characters does
+ *	  not always match the PostScript standard.
+ *	- Spacing of rotated text is incorrect; I believe this is a due
+ *	  to a problem in the text rotation code (aspect ratio??).
+ */
+
+static TBOOLEAN ENHgd_opened_string;
+
+/* used in determining height of processed text */
+static float ENHgd_base;
+
+/* use these so that we don't over-write the current font settings in png_state */
+static double  ENHgd_fontsize;
+static char   *ENHgd_font;
+
+static TBOOLEAN ENHgd_show = TRUE;
+static TBOOLEAN ENHgd_sizeonly = FALSE;
+static int ENHgd_overprint = 0;
+static TBOOLEAN ENHgd_widthflag = TRUE;
+static unsigned int ENHgd_xsave, ENHgd_ysave;
+
+TERM_PUBLIC void
+ENHGD_OPEN(
+    char *fontname,
+    double fontsize, double base,
+    TBOOLEAN widthflag,
+    TBOOLEAN showflag,
+    int overprint)
+{
+    /* If the overprint code requests a save or restore, that's all we do */
+    if (overprint == 3) {
+	ENHgd_xsave = png_state.x;
+	ENHgd_ysave = png_state.y;
+	return;
+    } else if (overprint == 4) {
+	PNG_move(ENHgd_xsave, ENHgd_ysave);
+	return;
+    }
+
+    if (!ENHgd_opened_string) {
+	ENHgd_opened_string = TRUE;
+	enhanced_cur_text = &enhanced_text[0];
+	ENHgd_font = fontname;
+	ENHgd_fontsize = fontsize;
+	ENHgd_base = base;
+	ENHgd_show = showflag;
+	ENHgd_overprint = overprint;
+	ENHgd_widthflag = widthflag;
+    }
+}
+
+/* Write a string fragment and update the current position */
+TERM_PUBLIC void
+ENHGD_FLUSH()
+{
+    int brect[8]; char *err;
+    unsigned int x, y;
+
+	if (ENHgd_opened_string) {
+	    ENHgd_opened_string = FALSE;
+	    *enhanced_cur_text = '\0';
+	    x = png_state.x;
+	    y = png_state.y;
+	    x -= sin((double)png_state.angle * M_PI_2/90.) * ENHgd_base;
+	    y += cos((double)png_state.angle * M_PI_2/90.) * ENHgd_base;
+	    x += sin((double)png_state.angle * M_PI_2/90.) * (double)png_state.charh/4.;
+	    y -= cos((double)png_state.angle * M_PI_2/90.) * (double)png_state.charh/4.;
+
+#ifdef gdFTEX_Adobe_Custom
+	    /* libgd defaults to UTF-8 encodings. We have limited options for	*/
+	    /* over-riding this, but we can try					*/
+	    if (encoding != S_ENC_UTF8 && ENHgd_font && !strcmp(ENHgd_font,"Symbol")) {
+		PNG_FONT_INFO.flags |= gdFTEX_CHARMAP;
+		PNG_FONT_INFO.charmap = gdFTEX_Adobe_Custom;
+	    } else {
+		PNG_FONT_INFO.flags &= ~gdFTEX_CHARMAP;
+		PNG_FONT_INFO.charmap = 0;   /* gdFTEX_Adobe_Custom */
+	    }
+	    err = gdImageStringFTEx(
+			(ENHgd_show && !ENHgd_sizeonly) ? png_state.image : NULL,
+			brect, png_state.color,
+			ENHgd_font, ENHgd_fontsize,
+			(double)png_state.angle * M_PI_2/90.,
+			x, Y(y), enhanced_text, &PNG_FONT_INFO);
+#else
+	    err = gdImageStringFT(
+			(ENHgd_show && !ENHgd_sizeonly) ? png_state.image : NULL,
+			brect, png_state.color,
+			ENHgd_font, ENHgd_fontsize,
+			(double)png_state.angle * M_PI_2/90.,
+			x, Y(y), enhanced_text);
+#endif
+	    if (err) 
+		fprintf(stderr,"gdImageStringFT: %s while printing string %s with font %s\n",
+		    err,enhanced_text,ENHgd_font);
+
+	    FPRINTF((stderr,"outputstring: %s boundingbox: %d %d %d %d\n",
+			enhanced_text, brect[6], brect[7], brect[2], brect[3]));
+	    if (ENHgd_overprint == 1) {
+		png_state.x += ((brect[2] - brect[0]))/2;
+		png_state.y -= (brect[3] - brect[1]);
+	    } else if (ENHgd_widthflag) {
+		png_state.x += (brect[2] - brect[0]);
+		png_state.y -= (brect[3] - brect[1]);
+	    }
+	}
+}
+
+TERM_PUBLIC void
+ENHGD_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    char *original_string = (char *)str;
+
+    if (ignore_enhanced_text || !png_state.ttffont) {
+	PNG_put_text(x,y,str);
+	return;
+    }
+
+    if (!strlen(str))
+	return;
+
+    /* if there are no magic characters, we should just be able
+     * punt the string to PNG_put_text()
+     */
+    if (!strpbrk(str, "{}^_@&~")) {
+	/* FIXME: do something to ensure default font is selected */
+	PNG_put_text(x,y,str);
+	return;
+    }
+
+    PNG_move(x,y);
+
+    /* set up the global variables needed by enhanced_recursion() */
+    enhanced_fontscale = 1.0;
+    strncpy(enhanced_escape_format,"&#x%2.2x;",sizeof(enhanced_escape_format));
+
+    ENHgd_opened_string = FALSE;
+    ENHgd_show = TRUE;
+    ENHgd_overprint = 0;
+
+    /* EAM - post.trm wasn't doing this, but how else do they get initialized? */
+	ENHgd_font = png_state.ttffont;
+	ENHgd_fontsize = png_state.ttfsize;
+
+    /* EAM - Software text justification requires two passes */
+    if (png_state.justify == RIGHT || png_state.justify == CENTRE)
+	ENHgd_sizeonly = TRUE;
+
+    /* Set the recursion going. We say to keep going until a
+     * closing brace, but we don't really expect to find one.
+     * If the return value is not the nul-terminator of the
+     * string, that can only mean that we did find an unmatched
+     * closing brace in the string. We increment past it (else
+     * we get stuck in an infinite loop) and try again.
+     */
+    while (*(str = enhanced_recursion((char *)str, TRUE,
+			ENHgd_font, ENHgd_fontsize,
+			0.0, TRUE, TRUE, 0))) {
+	(term->enhanced_flush)();
+
+	/* I think we can only get here if *str == '}' */
+	    enh_err_check(str);
+
+	if (!*++str)
+	    break; /* end of string */
+
+	/* else carry on and process the rest of the string */
+    }
+
+    /* We can do text justification by running the entire top level string */
+    /* through 2 times, with the ENHgd_sizeonly flag set the first time.   */
+    /* After seeing where the final position is, we then offset the start  */
+    /* point accordingly and run it again without the flag set.            */
+    if (png_state.justify == RIGHT || png_state.justify == CENTRE) {
+	int justification = png_state.justify;
+	int x_offset = png_state.x - x;
+	int y_offset = 0;
+
+	if (png_state.angle != 0)
+	    y_offset = png_state.y - y;
+	png_state.justify = LEFT;
+	ENHgd_sizeonly = FALSE;
+
+	if (justification == RIGHT) {
+	    ENHGD_put_text(x - x_offset, y - y_offset, original_string);
+	} else if (justification == CENTRE) {
+	    ENHGD_put_text(x - x_offset/2, y - y_offset/2, original_string);
+	}
+	png_state.justify = justification;
+    }
+
+}
+
+#undef gdfont
+
+TERM_PUBLIC void
+PNG_image (unsigned int M, unsigned int N, coordval * image, gpiPoint * corner, t_imagecolor color_mode)
+{
+    int m, n, mout, nout;
+    int x1,y1,x2,y2;
+    int xclip1, xclip2, yclip1, yclip2;
+    int pixel;
+    gdImagePtr im;
+
+#if (GD2_VERS >= 2)
+    if (png_state.TrueColor) {
+	im = gdImageCreateTrueColor(M, N);
+	if (!im)
+	    int_error(NO_CARET,"libgd: failed to create image structure");
+    } else
+#endif
+    {
+	im = gdImageCreate(M, N);
+	if (!im)
+	    int_error(NO_CARET,"libgd: failed to create image structure");
+	gdImagePaletteCopy(im, png_state.image);
+    }
+
+#if (GD2_VERS >= 2)
+    /* Set clipping bound for area into which we will copy */
+    xclip1 = GPMIN(corner[2].x, corner[3].x);
+    xclip2 = GPMAX(corner[2].x, corner[3].x);
+    yclip1 = GPMIN(Y(corner[2].y), Y(corner[3].y));
+    yclip2 = GPMAX(Y(corner[2].y), Y(corner[3].y));
+    gdImageGetClip(png_state.image, &x1, &y1, &x2, &y2);
+    gdImageSetClip(png_state.image, xclip1, yclip1, xclip2, yclip2);
+#endif
+
+    /* Initialize image area with current contents of plot. */
+    mout = abs( (int)corner[1].x - (int)corner[0].x );
+    nout = abs( (int)corner[1].y - (int)corner[0].y );
+
+    if (color_mode == IC_RGBA) {
+	/* RGB + Alpha channel
+	 * Resize explicitly in a loop rather than calling a library
+	 * routine in order not to apply the alpha correction more than
+	 * once when building up any given output pixel.
+	 */
+	for (n=0; n<nout; n++) {
+	for (m=0; m<mout; m++) {
+	    rgb_color rgb1;
+	    rgb255_color rgb255;
+	    int alpha;
+	    int msrc = (m*(long)(M-1))/(mout-1);
+	    int nsrc = (n*(long)(N-1))/(nout-1);
+	    coordval *cval = image + 4*(M*nsrc + msrc);
+	    rgb1.r = *cval++;
+	    rgb1.g = *cval++;
+	    rgb1.b = *cval++;
+	    alpha  = *cval++;
+	    alpha  = 127 - (alpha>>1);	/* input is [0:255] but gd wants [127:0] */
+	    rgb255_from_rgb1( rgb1, &rgb255 );
+	    pixel = gdImageColorResolveAlpha( png_state.image,
+		(int)rgb255.r, (int)rgb255.g, (int)rgb255.b, alpha);
+	    gdImageSetPixel( png_state.image, m + corner[0].x, n + Y(corner[0].y), pixel );
+	}
+	}
+
+    } else if (color_mode == IC_RGB) {
+	/* TrueColor 24-bit color mode */
+	for (n=0; n<N; n++) {
+	for (m=0; m<M; m++) {
+	    rgb_color rgb1;
+	    rgb255_color rgb255;
+	    rgb1.r = *image++;
+	    rgb1.g = *image++;
+	    rgb1.b = *image++;
+	    rgb255_from_rgb1( rgb1, &rgb255 );
+	    pixel = gdImageColorResolve( im, 
+		(int)rgb255.r, (int)rgb255.g, (int)rgb255.b );
+	    gdImageSetPixel( im, m, n, pixel );
+	}
+	}
+
+    } else if (color_mode == IC_PALETTE) {
+	/* Palette color lookup from gray value */
+	for (n=0; n<N; n++) {
+	for (m=0; m<M; m++) {
+	    rgb255_color rgb;
+	    if (isnan(*image)) {
+		/* Transparent would be even better */
+		pixel = png_state.color_table[0];
+		image++;
+	    } else {
+		rgb255maxcolors_from_gray( *image++, &rgb );
+		pixel = gdImageColorResolve( im,
+		    (int)rgb.r, (int)rgb.g, (int)rgb.b );
+	    }
+	    gdImageSetPixel( im, m, n, pixel );
+	}
+	}
+    }
+
+    /* Copy and resize onto requested region of plot */
+    if (color_mode != IC_RGBA)
+	gdImageCopyResized(png_state.image, im,
+		(corner[0].x), Y(corner[0].y),	/* Destination X, Y */
+		0, 0, 				/* Source X, Y */
+		mout, nout,			/* Destination Width, Height */
+		M, N				/* Source Width, Height */
+		);
+    gdImageDestroy(im);
+
+#if (GD2_VERS >= 2)
+    /* Restore previous clipping, if any */
+    gdImageSetClip(png_state.image, x1, y1, x2, y2);
+#endif
+
+}
+
+#undef MAXLINEWIDTH
+#undef Y
+
+#endif /* TERM_BODY */
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(png_driver)
+    "png", "PNG images using libgd and TrueType fonts",
+    GREG_XMAX, GREG_YMAX, PNG_VCHAR, PNG_HCHAR,
+    PNG_TICSIZE, PNG_TICSIZE, PNG_options, PNG_init, PNG_reset,
+    PNG_text, null_scale, PNG_graphics, PNG_move, PNG_vector,
+    PNG_linetype, PNG_put_text, PNG_text_angle,
+    PNG_justify_text, PNG_point, do_arrow, PNG_set_font,
+    PNG_pointsize,
+    TERM_CAN_MULTIPLOT|TERM_BINARY|TERM_LINEWIDTH, /* TERM_ALPHA_CHANNEL only if truecolor */
+    0 /*suspend*/, 0 /*resume*/,
+    PNG_boxfill /*EAM - fillbox*/,
+    PNG_linewidth /*EAM - linewidth*/
+#ifdef USE_MOUSE
+    , 0, 0, 0, 0, 0 /* no mouse support */
+#endif
+    , PNG_make_palette,
+    0, /* previous_palette() ... no, single array of 256 colours for PNG */
+    PNG_set_color,
+    PNG_filled_polygon
+    , PNG_image
+    , ENHGD_OPEN, ENHGD_FLUSH, do_enh_writec
+TERM_TABLE_END(png_driver)
+
+#undef LAST_TERM
+#define LAST_TERM png_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifndef JPEG_HELP_ONLY
+#ifdef TERM_HELP
+START_HELP(png)
+"1 png",
+"?commands set terminal png",
+"?set terminal png",
+"?set term png",
+"?terminal png",
+"?term png",
+"?png",
+" Syntax:",
+"       set terminal png ",
+"              {{no}transparent} {{no}interlace}",
+"              {{no}truecolor} {rounded|butt}",
+"              {linewidth <lw>} {dashlength <dl>}",
+"              {tiny | small | medium | large | giant}",
+"              {font \"<face> {,<pointsize>}\"} {{no}enhanced}",
+"              {size <x>,<y>} {{no}crop}",
+"              {<background_color>}",
+"",
+" PNG, JPEG and GIF images are created using the external library libgd.",
+" PNG plots may be viewed interactively by piping the output to the",
+" 'display' program from the ImageMagick package as follows:",
+"                set term png",
+"                set output '| display png:-'",
+" You can view the output from successive plot commands interactively by typing",
+" <space> in the display window.  To save the current plot to a file,",
+" left click in the display window and choose `save`.",
+"",
+" `transparent` instructs the driver to make the background color transparent.",
+" Default is `notransparent`.",
+"",
+" `interlace` instructs the driver to generate interlaced PNGs.",
+" Default is `nointerlace`.",
+"",
+" The `linewidth` and `dashlength` options are scaling factors that affect all",
+" lines drawn, i.e. they are multiplied by values requested in various drawing",
+" commands.",
+"",
+" By default output png images use 256 indexed colors. The `truecolor` option",
+" instead creates TrueColor images with 24 bits of color information per pixel.",
+" Transparent fill styles require the `truecolor` option. See `fillstyle`.",
+" A transparent background is possible in either indexed or TrueColor images.",
+"",
+" `butt` instructs the driver to use a line drawing method that does",
+" not overshoot the desired end point of a line.  This setting is only",
+" applicable for line widths greater than 1.  This setting is most useful when",
+" drawing horizontal or vertical lines.  Default is `rounded`.",
+"",
+" The details of font selection are complicated.",
+" Two equivalent simple examples are given below:",
+"      set term png font arial 11",
+"      set term png font \"arial,11\"",
+" For more information please see the separate section under `fonts`.",
+"",
+" The output plot size <x,y> is given in pixels---it defaults to 640x480.",
+" Please see additional information under `canvas` and `set size`.",
+" Blank space at the edges of the finished plot may be trimmed using the `crop`",
+" option, resulting in a smaller final image size. Default is `nocrop`.",
+"",
+" The background color must be given in the form 'xrrggbb', where x is the",
+" literal character 'x' and 'rrggbb' are the red, green and blue components",
+" in hexadecimal.  For example, 'x00ff00' is green.  The specification of",
+" additional colors other than the background is deprecated.",
+"",
+"2 examples",
+"?set term png examples",
+"       set terminal png medium size 640,480 xffffff",
+"",
+" Use the medium size built-in non-scaleable, non-rotatable font.",
+" Use white (xffffff) for the non-transparent background.",
+"",
+"       set terminal png font arial 14 size 800,600",
+"",
+" Searches for a scalable font with face name 'arial' and sets the font",
+" size to 14pt.  Please see `fonts` for details of how the font search",
+" is done.",
+"",
+"       set terminal png transparent truecolor enhanced",
+"",
+" Use 24 bits of color information per pixel, with a transparent background.",
+" Use the `enhanced text` mode to control the layout of strings to be printed.",
+""
+END_HELP(png)
+#endif /* TERM_HELP */
+#endif /* JPEG_HELP_ONLY */
+
+/*
+ * JPEG support comes almost for free.
+ * We just piggy-back on the PNG routines, since they both go via libgd
+ */
+#ifdef HAVE_GD_JPEG
+
+#ifdef TERM_REGISTER
+register_term(jpeg)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void JPEG_text __PROTO((void));
+#define GOT_NEXT_PROTO
+#endif
+
+#ifndef TERM_PROTO_ONLY
+
+#ifdef TERM_BODY
+
+#include "gd.h"
+/*
+ * All functions except the final write to file
+ * are actually performed by the PNG driver code
+ */
+TERM_PUBLIC void
+JPEG_text()
+{
+int quality = 90;
+
+    image_do_crop();
+    if (png_state.flags & PNG_USE_INTERLACE)
+	gdImageInterlace(png_state.image, 1);
+    gdImageJpeg(png_state.image, gpoutfile, quality);
+    gdImageDestroy(png_state.image);
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(jpeg_driver)
+    "jpeg", "JPEG images using libgd and TrueType fonts",
+    GREG_XMAX, GREG_YMAX, PNG_VCHAR, PNG_HCHAR,
+    PNG_TICSIZE, PNG_TICSIZE, PNG_options, PNG_init, PNG_reset,
+    JPEG_text, null_scale, PNG_graphics, PNG_move, PNG_vector,
+    PNG_linetype, PNG_put_text, PNG_text_angle,
+    PNG_justify_text, PNG_point, do_arrow, PNG_set_font,
+    PNG_pointsize,
+    TERM_CAN_MULTIPLOT|TERM_BINARY|TERM_ALPHA_CHANNEL|TERM_LINEWIDTH,
+    0 /*suspend*/, 0 /*resume*/,
+    PNG_boxfill /*EAM - fillbox*/,
+    PNG_linewidth /*EAM - linewidth*/
+#ifdef USE_MOUSE
+    , 0, 0, 0, 0, 0 /* no mouse support */
+#endif
+    , PNG_make_palette,
+    0, /* previous_palette() ... no, single array of 256 colours for PNG */
+    PNG_set_color,
+    PNG_filled_polygon
+    , PNG_image
+    , ENHGD_OPEN, ENHGD_FLUSH, do_enh_writec
+TERM_TABLE_END(jpeg_driver)
+
+#undef LAST_TERM
+#define LAST_TERM jpeg_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(jpeg)
+"1 jpeg",
+"?commands set terminal jpeg",
+"?set terminal jpeg",
+"?set term jpeg",
+"?terminal jpeg",
+"?term jpeg",
+"?jpeg",
+" Syntax:",
+"       set terminal jpeg ",
+"              {{no}interlace}",
+"              {linewidth <lw>} {dashlength <dl>} {rounded|butt}",
+"              {tiny | small | medium | large | giant}",
+"              {font \"<face> {,<pointsize>}\"} {{no}enhanced}",
+"              {size <x>,<y>} {{no}crop}",
+"              {<background_color>}",
+"",
+" PNG, JPEG and GIF images are created using the external library libgd.",
+" In most cases, PNG is to be preferred for single plots, and GIF for",
+" animations.  Both are loss-less image formats, and produce better image",
+" quality than the lossy JPEG format. This is in particular noticeable",
+" for solid color lines against a solid background, i.e. exactly the sort",
+" of image typically created by gnuplot.",
+"",
+" The `interlace` option creates a progressive JPEG image.",
+" Default is `nointerlace`.",
+"",
+" The `linewidth` and `dashlength` options are scaling factors that affect all",
+" lines drawn, i.e. they are multiplied by values requested in various drawing",
+" commands.",
+"",
+" `butt` instructs the driver to use a line drawing method that does",
+" not overshoot the desired end point of a line.  This setting is only",
+" applicable for line widths greater than 1.  This setting is most useful when",
+" drawing horizontal or vertical lines.  Default is `rounded`.",
+"",
+" The details of font selection are complicated.",
+" Two equivalent simple examples are given below:",
+"      set term jpeg font arial 11",
+"      set term jpeg font \"arial,11\"",
+" For more information please see the separate section under `fonts`.",
+"",
+" The output plot size <x,y> is given in pixels---it defaults to 640x480.",
+" Please see additional information under `canvas` and `set size`.",
+" Blank space at the edges of the finished plot may be trimmed using the `crop`",
+" option, resulting in a smaller final image size. Default is `nocrop`.",
+"",
+" The background color must be given in the form 'xrrggbb', where x is the",
+" literal character 'x' and 'rrggbb' are the red, green and blue components",
+" in hexadecimal.  For example, 'x00ff00' is green.  The specification of",
+" additional colors other than the background is deprecated.",
+""
+END_HELP(jpeg)
+#endif /* TERM_HELP */
+#endif /* HAVE_GD_JPEG */
+
+#ifdef HAVE_GD_GIF
+/*
+ * GIF support comes almost for free.
+ * We just piggy-back on the PNG routines, since they both go via libgd.
+ * Required libgd version is 2.0.28 or newer.
+ */
+#ifdef HAVE_GD_GIF
+
+#ifdef TERM_REGISTER
+register_term(gif)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void GIF_text __PROTO((void));
+#define GOT_NEXT_PROTO
+#endif
+
+#ifndef TERM_PROTO_ONLY
+
+#ifdef TERM_BODY
+
+#include "gd.h"
+/*
+ * All functions except the final write to file
+ * are actually performed by the PNG driver code
+ */
+TERM_PUBLIC void
+GIF_text()
+{
+    image_do_crop();
+
+#ifdef GIF_ANIMATION
+    if (png_state.animate) {
+	/* Note - using a global colormap saves space, but it breaks	*/
+	/* if later frames add new colors to the palette.		*/
+	if (png_state.frame_count == 0) {
+	    gdImageGifAnimBegin(png_state.image, gpoutfile, 
+		1, /* Load Global Colormap even if it isn't used */ 
+		png_state.loop_count );
+	}
+	gdImageGifAnimAdd(png_state.image, gpoutfile,
+	    png_state.frame_optimization ? 0  /* use global map  */
+	                                 : 1, /* use private map */
+	    0, 0 /* No offset */,
+	    png_state.frame_delay,
+	    (png_state.flags & PNG_USE_TRANSPARENT)
+			? gdDisposalRestorePrevious 
+			: gdDisposalNone, 
+	    (png_state.frame_optimization && !(png_state.flags & PNG_USE_TRANSPARENT))
+	    ? png_state.previous_image : NULL);
+	png_state.frame_count++;
+	if (png_state.previous_image)
+	    gdImageDestroy(png_state.previous_image);
+	png_state.previous_image = png_state.image;
+	return;
+    }
+#endif
+
+    gdImageGif(png_state.image, gpoutfile);
+    gdImageDestroy(png_state.image);
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(gif_driver)
+    "gif", "GIF images using libgd and TrueType fonts",
+    GREG_XMAX, GREG_YMAX, PNG_VCHAR, PNG_HCHAR,
+    PNG_TICSIZE, PNG_TICSIZE, PNG_options, PNG_init, PNG_reset,
+    GIF_text, null_scale, PNG_graphics, PNG_move, PNG_vector,
+    PNG_linetype, PNG_put_text, PNG_text_angle,
+    PNG_justify_text, PNG_point, do_arrow, PNG_set_font,
+    PNG_pointsize,
+    TERM_CAN_MULTIPLOT|TERM_BINARY|TERM_LINEWIDTH,
+    0 /*suspend*/, 0 /*resume*/,
+    PNG_boxfill /*EAM - fillbox*/,
+    PNG_linewidth /*EAM - linewidth*/
+#ifdef USE_MOUSE
+    , 0, 0, 0, 0, 0 /* no mouse support */
+#endif
+    , PNG_make_palette,
+    0, /* previous_palette() ... no, single array of 256 colours for PNG */
+    PNG_set_color,
+    PNG_filled_polygon
+    , PNG_image
+    , ENHGD_OPEN, ENHGD_FLUSH, do_enh_writec
+TERM_TABLE_END(gif_driver)
+
+#undef LAST_TERM
+#define LAST_TERM gif_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+
+#ifdef TERM_HELP
+START_HELP(gif)
+"1 gif",
+"?commands set terminal gif",
+"?set terminal gif",
+"?set term gif",
+"?terminal gif",
+"?term gif",
+"?gif",
+" Syntax:",
+"       set terminal gif ",
+"              {{no}transparent} {rounded|butt}",
+"              {linewidth <lw>} {dashlength <dl>}",
+"              {tiny | small | medium | large | giant}",
+"              {font \"<face> {,<pointsize>}\"} {{no}enhanced}",
+"              {size <x>,<y>} {{no}crop}",
+"              {animate {delay <d>} {loop <n>} {{no}optimize}}",
+"              {<background_color>}",
+"",
+" PNG, JPEG and GIF images are created using the external library libgd.",
+" GIF plots may be viewed interactively by piping the output to the",
+" 'display' program from the ImageMagick package as follows:",
+"                set term gif",
+"                set output '| display gif:-'",
+" You can view the output from successive plot commands interactively by typing",
+" <space> in the display window.  To save the current plot to a file,",
+" left click in the display window and choose `save`.",
+"",
+" `transparent` instructs the driver to make the background color transparent.",
+" Default is `notransparent`.",
+"",
+" The `linewidth` and `dashlength` options are scaling factors that affect all",
+" lines drawn, i.e. they are multiplied by values requested in various drawing",
+" commands.",
+"",
+" `butt` instructs the driver to use a line drawing method that does",
+" not overshoot the desired end point of a line.  This setting is only",
+" applicable for line widths greater than 1.  This setting is most useful when",
+" drawing horizontal or vertical lines.  Default is `rounded`.",
+"",
+" The details of font selection are complicated.",
+" Two equivalent simple examples are given below:",
+"      set term gif font arial 11",
+"      set term gif font \"arial,11\"",
+" For more information please see the separate section under `fonts`.",
+"",
+" The `animate` option is available only if your local gd library supports",
+" the creation of animated gifs. The default delay between display of",
+" successive images may be specified in units of 1/100 second (default 5).",
+" The actual delay may vary depending on the program used as a viewer.",
+" Number of animation loops can be specified, default 0 means infinity.",
+" An animation sequence is terminated by the next `set output` or `set term`",
+" command.  The `optimize` option has two effects on the animation.",
+"",
+" 1) A single color map is used for the entire animation. This requires",
+" that all colors used in any frame of the animation are already",
+" defined in the first frame.",
+"",
+" 2) If possible, only the portions of a frame that differ from the",
+" previous frame are stored in the animation file.  This space saving",
+" may not be possible if the animation uses transparency.",
+"",
+" Both of these optimizations are intended to produce a smaller output file,",
+" but the decrease in size is probably only significant for long animations",
+" or very small frame sizes.",
+" The `nooptimize` option turns off both of the effects just described.",
+" Each frame is stored in its entirety along with a private color map.",
+" Note that it is possible to post-process a non-optimized animation",
+" using external utilities, and this post-processing can yield a smaller",
+" file than gnuplot's internal optimization mode.",
+" The default is `nooptimize`.",
+"",
+" The output plot size <x,y> is given in pixels---it defaults to 640x480.",
+" Please see additional information under `canvas` and `set size`.",
+" Blank space at the edges of the finished plot may be trimmed using the `crop`",
+" option, resulting in a smaller final image size. Default is `nocrop`.",
+"",
+" The background color must be given in the form 'xrrggbb', where x is the",
+" literal character 'x' and 'rrggbb' are the red, green and blue components",
+" in hexadecimal.  For example, 'x00ff00' is green.  The specification of",
+" additional colors other than the background is deprecated.",
+"",
+"2 examples",
+"?set term gif examples",
+"       set terminal gif medium size 640,480 xffffff",
+"",
+" Use the medium size built-in non-scaleable, non-rotatable font.",
+" Use white (xffffff) for the non-transparent background.",
+"",
+"       set terminal gif font arial 14 enhanced",
+"",
+" Searches for a scalable font with face name 'arial' and sets the font",
+" size to 14pt.  Please see `fonts` for details of how the font search",
+" is done.  Because this is a scalable font, we can use enhanced text mode.",
+"",
+"       set term gif animate transparent opt delay 10 size 200,200 x000000",
+"       load \"animate2.dem\"",
+"",
+" Open the gif terminal for creation of an animated gif file.  The individual",
+" frames of the animation sequence are created by the script file animate2.dem",
+" from the standard collection of demos.",
+""
+END_HELP(gif)
+#endif /* TERM_HELP */
+#endif /* HAVE_GD_GIF */
+#endif
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/ggi.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/ggi.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/ggi.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/ggi.trm.svn-base	2012-01-03 17:07:30.070960700 -0800
@@ -0,0 +1,1541 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: ggi.trm,v 1.27 2008/06/26 23:12:17 sfeam Exp $
+ */
+
+/* GNUPLOT - ggi.trm */
+
+/*[
+ * Copyright 2000, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+ ]*/
+
+/*
+ * AUTHOR:
+ *   Cesar Crusius <crusius@leland.stanford.edu>
+ *   event / mouse processing & double-buffering
+ *   by Johannes Zellner <johannes@zellner.org>
+ *   pm3d support by Johannes Zellner <johannes@zellner.org> (Oct. 2000)
+ *
+ *   TODO:
+ *
+ *   	- reimplement wmh (if it's available)
+ *   	- implement window title using wmh (if it's available)
+ *   	- check for availability of two frames, and if not
+ *   	  do it with one frame. (will eventually not do
+ *   	  with mouse/event reporting)
+ *   	- check if libxmi is available and if so, use
+ *   	  it to draw filled polygons.
+ *   	- enable cursors using blits.
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(ggi)
+#endif
+
+#ifdef TERM_PROTO
+
+#include <ggi/ggi.h>
+#ifdef USE_MOUSE
+#  include <ggi/ggi-unix.h>
+#endif
+
+#ifdef HAVE_GGI_WMH_H
+#   include <ggi/wmh.h>
+static TBOOLEAN GGI_use_whm = 0;
+#endif
+
+#if 1
+#if defined(HAVE_GGI_XMI_H)
+#   define ENABLE_XMI 1
+#endif
+#endif
+
+#ifdef ENABLE_XMI
+#   include <ggi/xmi.h>
+#endif
+
+static void GGI_line_colors __PROTO((void));
+TERM_PUBLIC void GGI_graphics __PROTO((void));
+TERM_PUBLIC void GGI_set_size __PROTO((void));
+TERM_PUBLIC void GGI_init __PROTO((void));
+TERM_PUBLIC void GGI_linetype __PROTO((int));
+TERM_PUBLIC void GGI_move __PROTO((unsigned int,unsigned int));
+TERM_PUBLIC void GGI_options __PROTO((void));
+TERM_PUBLIC void GGI_put_text __PROTO((unsigned int,unsigned int, const char*));
+TERM_PUBLIC void GGI_suspend __PROTO((void));
+TERM_PUBLIC void GGI_resume __PROTO((void));
+TERM_PUBLIC void GGI_fillbox __PROTO((int style, unsigned int x, unsigned int y,
+	unsigned int w, unsigned int h));
+TERM_PUBLIC void GGI_close __PROTO((void));
+TERM_PUBLIC void GGI_reset __PROTO((void));
+TERM_PUBLIC void GGI_text __PROTO((void));
+TERM_PUBLIC void GGI_vector __PROTO((unsigned int,unsigned int));
+
+#ifdef USE_MOUSE
+
+/* zoom box information */
+
+typedef struct  {
+    int x;
+    int y;
+} GGI_point_t;
+
+typedef struct {
+    int x;
+    int y;
+    int width;
+    int height;
+    char str[0xff];
+} GGI_vertex_t;
+
+TERM_PUBLIC long int GGI_SetTime(const struct timeval* current);
+TERM_PUBLIC int GGI_from_keysym __PROTO((uint32_t keysym));
+TERM_PUBLIC int GGI_from_button __PROTO((uint32_t button));
+TERM_PUBLIC int GGI_y __PROTO((int32_t y));
+TERM_PUBLIC int GGI_dispatch_event __PROTO((const ggi_event* event));
+TERM_PUBLIC int GGI_eventually_update_modifiers __PROTO((const ggi_event* event, const int add));
+TERM_PUBLIC int GGI_waitforinput __PROTO((void));
+TERM_PUBLIC void GGI_draw_ruler __PROTO((void));
+TERM_PUBLIC void GGI_clear_zoombox __PROTO((void));
+TERM_PUBLIC void GGI_draw_zoombox __PROTO((void));
+TERM_PUBLIC void GGI_set_ruler __PROTO((int, int));
+TERM_PUBLIC void GGI_set_cursor __PROTO((int, int, int));
+TERM_PUBLIC void GGI_save_frame_canvas __PROTO((void));
+TERM_PUBLIC void GGI_save_frame_stl __PROTO((void));
+TERM_PUBLIC void GGI_replot __PROTO((void));
+TERM_PUBLIC void GGI_clear __PROTO((const GGI_vertex_t* v, const int tag));
+TERM_PUBLIC void GGI_save_puts __PROTO((GGI_vertex_t* v, const int tag));
+TERM_PUBLIC void GGI_set_vertex __PROTO((GGI_vertex_t* v, const int x, const int y, const char* str, const int tag));
+TERM_PUBLIC void GGI_abort_zooming __PROTO((void));
+TERM_PUBLIC void GGI_put_tmptext __PROTO((int, const char str[]));
+TERM_PUBLIC void GGI_relative __PROTO((int r[2]));
+TERM_PUBLIC void GGI_clear_hline __PROTO((int x1, int x2, int y));
+TERM_PUBLIC void GGI_clear_vline __PROTO((int y1, int y2, int x));
+TERM_PUBLIC void GGI_draw_hline __PROTO((int x1, int x2, int y));
+TERM_PUBLIC void GGI_draw_vline __PROTO((int y1, int y2, int x));
+TERM_PUBLIC void GGI_set_clipboard __PROTO((const char[]));
+#endif /* USE_MOUSE */
+
+TERM_PUBLIC int GGI_make_palette __PROTO((t_sm_palette*));
+TERM_PUBLIC void GGI_previous_palette __PROTO((void));
+TERM_PUBLIC void GGI_set_color __PROTO((struct t_colorspec *colorspec));
+#ifdef ENABLE_XMI
+TERM_PUBLIC void GGI_filled_polygon __PROTO((int, gpiPoint*));
+#endif
+
+#define GOT_GGI_PROTO
+#endif
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+#define GGI_XMAX 800
+#define GGI_YMAX 600
+#define GGI_VCHAR 8
+#define GGI_HCHAR 8
+#define GGI_VTIC 8
+#define GGI_HTIC 8
+
+
+#ifdef USE_MOUSE
+static GGI_vertex_t GGI_zoom[2][2];
+static GGI_vertex_t GGI_stl_vertex;
+static GGI_point_t GGI_ruler = {-1, -1};
+static GGI_point_t GGI_zoombox[2] = {{-1, -1}, {-1, -1}};
+
+static struct timeval GGI_timestamp;
+static int GGI_mouse_x = 0;
+static int GGI_mouse_y = 0;
+static int GGI_modifiers = 0;
+static int GGI_use_mouse = 1; /* mouse is on by default */
+static unsigned int GGIcanvas_height = 0;
+static int GGI_font_width = 0;
+static int GGI_font_height = 0;
+static int GGI_saved_canvas = 0;
+static int GGI_saved_stl = 0;
+static int GGI_needs_update = 1;
+#endif
+
+static t_sm_palette GGI_save_pal = {
+    -1, -1, -1, -1, -1, -1, -1, -1,
+    (rgb_color*) 0, -1, -1
+};
+
+/* First to some global variables
+ *
+ * GGIvisual is our 'piece of paper.'
+ * GGIborderColor and axixColor have the obvious meanings.
+ * GGIcolors are the colors for linestyles 0 and up.
+ * GGImap is for initializing colors.
+ * GGIx,GGIy are the current coordinates.
+ * GGIwidth, GGIheight are the extensions in the visual.
+ * GGIymax = term->ymax
+ */
+static ggi_visual_t GGIvisual = (ggi_visual_t)0;
+static ggi_pixel GGIborderColor;
+static ggi_pixel GGIaxisColor;
+static ggi_pixel GGIblack;
+static ggi_pixel GGIcolors[7];
+#define GGI_PM3D_COLORS 240
+static const int ggi_pm3d_colors = GGI_PM3D_COLORS;
+static ggi_pixel GGI_smooth_colors[GGI_PM3D_COLORS];
+static unsigned int GGIx,GGIy;
+static unsigned int GGIwidth, GGIheight, GGIymax;
+#if 0
+static unsigned int Xenv;
+#endif
+static int GGI_frames =
+#ifdef USE_MOUSE
+2
+#else
+1
+#endif
+;
+
+#ifdef ENABLE_XMI
+static miGC* GGI_miGC = (miGC*)0;
+static miPaintedSet* GGI_miPaintedSet = (miPaintedSet*)0;
+static miPixel GGI_miPixels[2]; /* only GGI_miPixels[1] is used */
+static int GGI_numblendstages = 0;
+static miBlendStage GGI_blendstages[4];
+#endif
+
+static TBOOLEAN GGI_mode_changed = 1;
+static char GGI_mode_spec[0xff] = "";
+static int GGI_acceleration = 7; /* arbitrary */
+
+enum GGI_id {
+    GGI_MODE,
+    GGI_ACCELERATION,
+    GGI_OTHER
+};
+
+static struct gen_table GGI_opts[] =
+{
+    { "mo$de", GGI_MODE },
+    { "ac$celeration", GGI_ACCELERATION },
+    { NULL, GGI_OTHER }
+};
+
+static void
+GGI_line_colors()
+{
+    ggi_pixel GGIwhite,GGIred,GGIgreen,GGIblue,GGIcyan,GGImagenta,GGIgray;
+    ggi_pixel GGIyellow;
+    ggi_color color;
+
+    color.r = 0xFFFF; color.g = 0xFFFF; color.b = 0xFFFF; GGIwhite   = ggiMapColor(GGIvisual,&color);
+    color.r = 0x0000; color.g = 0x0000; color.b = 0x0000; GGIblack   = ggiMapColor(GGIvisual,&color);
+    color.r = 0xFFFF; color.g = 0x0000; color.b = 0x0000; GGIred     = ggiMapColor(GGIvisual,&color);
+    color.r = 0x0000; color.g = 0xFFFF; color.b = 0x0000; GGIgreen   = ggiMapColor(GGIvisual,&color);
+    color.r = 0x0000; color.g = 0x0000; color.b = 0xFFFF; GGIblue    = ggiMapColor(GGIvisual,&color);
+    color.r = 0x0000; color.g = 0xFFFF; color.b = 0xFFFF; GGIcyan    = ggiMapColor(GGIvisual,&color);
+    color.r = 0xFFFF; color.g = 0x0000; color.b = 0xFFFF; GGImagenta = ggiMapColor(GGIvisual,&color);
+    color.r = 0xFFFF; color.g = 0xFFFF; color.b = 0x0000; GGIyellow  = ggiMapColor(GGIvisual,&color);
+    color.r = 0x8888; color.g = 0x8888; color.b = 0x8888; GGIgray    = ggiMapColor(GGIvisual,&color);
+
+    GGIborderColor = GGIwhite;
+    GGIaxisColor   = GGIgray;
+    GGIcolors[0]   = GGIred;
+    GGIcolors[1]   = GGIgreen;
+    GGIcolors[2]   = GGIblue;
+    GGIcolors[3]   = GGImagenta;
+    GGIcolors[4]   = GGIcyan;
+    GGIcolors[5]   = GGIyellow;
+    GGIcolors[6]   = GGIgray;
+}
+
+/* Called bevore a graphic is displayed */
+TERM_PUBLIC void GGI_graphics()
+{
+#ifdef USE_MOUSE
+    int i, j;
+    int display_frame = ggiGetDisplayFrame(GGIvisual);
+#endif
+#if 0
+    if(!Xenv)
+    {
+	GGI_line_colors();
+	return;
+    }
+#endif
+    ggiSetGCForeground(GGIvisual,GGIblack);
+#ifdef USE_MOUSE
+    /* write to the currently not displayed buffer */
+    ggiSetWriteFrame(GGIvisual, !display_frame);
+
+    /* mark the contents of the alternate frame as invalid */
+    GGI_saved_canvas = 0;
+    GGI_saved_stl = 0;
+    GGI_needs_update = 1;
+
+    /* reset the stl vertex */
+    GGI_stl_vertex.width = 0;
+
+    /* reset the zoom box coordinates */
+    for (i = 0; i < 2; i++) {
+	for (j = 0; j < 2; j++) {
+	    GGI_zoom[i][j].width = 0;
+	}
+	GGI_zoombox[i].x = -1;
+	GGI_zoombox[i].y = -1;
+    }
+#endif /* USE_MOUSE */
+
+    /* clear *write* buffer. */
+    ggiDrawBox(GGIvisual, 0, 0, GGIwidth, GGIheight);
+
+#ifdef USE_MOUSE
+    if (GGI_use_mouse) {
+	/* copy the contents of the currently
+	 * displayed stl to the write frame.
+	 * This way the stl won't jitter. */
+	ggiSetReadFrame(GGIvisual, display_frame);
+	ggiCopyBox(GGIvisual, 0, GGIcanvas_height,
+	    GGIwidth, GGI_font_height, 0, GGIcanvas_height);
+    }
+#endif
+}
+
+TERM_PUBLIC void
+GGI_set_size()
+{
+    ggi_mode mode;
+    ggiGetMode(GGIvisual,&mode);
+
+    GGIwidth  = mode.virt.x;
+    GGIheight = mode.virt.y;
+
+    term->xmax = mode.virt.x - 1;
+
+#ifdef USE_MOUSE
+    GGIcanvas_height = mode.virt.y - (GGI_use_mouse ? GGI_font_height : 0);
+    term->ymax = GGIcanvas_height - 1;
+#else
+    term->ymax = mode.virt.y - 1;
+#endif
+    GGIymax = term->ymax;
+}
+
+/*
+ * init
+ * -----------------------
+ * Called only once, when the terminal is initialized. We have to open the visual here because it
+ * is during 'init' that we have to change the terminal dimensions (xmax, ymax).
+ */
+TERM_PUBLIC void GGI_init()
+{
+    int success = 0;
+    ggi_mode mode;
+
+#if 0
+    if (0 != giiInit()) {
+	ggiPanic("*** giiInit() failed *** \n");
+    }
+#endif
+
+    if (0 != ggiInit()) {
+	ggiPanic("*** ggiInit() failed *** \n");
+    }
+
+    if (NULL == (GGIvisual = ggiOpen(NULL))) {
+	/* TODO: abort a bit more gracefully */
+	ggiPanic("(GGI_init() unable to open default\n");
+    }
+
+    if (strlen(GGI_mode_spec)) {
+	/* user specified mode */
+	if (!ggiParseMode(GGI_mode_spec, &mode)) {
+	    mode.frames = GGI_frames;
+	    if (!ggiSetMode(GGIvisual, &mode)) {
+		success = 1;
+	    }
+	}
+    }
+
+    if (!success) {
+	/* try the default mode */
+	if(ggiSetSimpleMode(GGIvisual,GGI_AUTO,GGI_AUTO,GGI_frames,GT_AUTO)) {
+	    ggiPanic("(GGI_init() unable to set default mode\n");
+	    GGIvisual = (ggi_visual_t)0;
+	}
+    }
+
+    ggiGetMode(GGIvisual, &mode);
+
+    /* print the mode only once if it has changed */
+    if (GGI_mode_changed) {
+	GGI_mode_changed = 0;
+	ggiFPrintMode(stderr, &mode);
+	fprintf(stderr, "\n");
+    }
+
+#ifdef USE_MOUSE
+    /* must come before GGI_set_size() */
+    ggiGetCharSize(GGIvisual, &GGI_font_width, &GGI_font_height);
+#endif
+
+    GGI_set_size();
+
+
+#ifdef USE_MOUSE
+    ggiSetReadFrame(GGIvisual, 0);
+    ggiSetWriteFrame(GGIvisual, 0);
+    ggiSetDisplayFrame(GGIvisual, 0);
+#endif
+
+#ifdef HAVE_GGI_WMH_H
+    /* Initialize WMH extension */
+    if (ggiWmhInit() != 0 || ggiWmhAttach(GGIvisual) < 0) {
+	GGI_use_whm = 0;
+    } else {
+	GGI_use_whm = 1;
+	ggiWmhAllowResize(GGIvisual, 100, 50, 2000, 2000, 10, 10);
+	ggiWmhSetTitle(GGIvisual, "GGI Gnuplot Driver");
+	ggiWmhSetIconTitle(GGIvisual, "Gnuplot");
+    }
+#endif
+
+    /*
+     * if(!(Xenv=!ggiWmhAttach(GGIvisual))) ggiWmhDetach(GGIvisual);
+     * else Xenv=!ggiWmhSetTitle(GGIvisual,"GGI Gnuplot Driver");
+     */
+#if 0
+    if(!Xenv)
+    {
+	/*
+	 * ggiWmhDetach(GGIvisual);
+	 * ggiWmhExit();
+	 */
+	ggiClose(GGIvisual);
+	ggiExit();
+	GGIvisual=NULL;
+    }
+#endif
+    GGI_line_colors();
+    ggiSetFlags(GGIvisual, GGIFLAG_ASYNC);
+#ifdef USE_MOUSE
+    GGI_mouse_x = 0;
+    GGI_mouse_y = 0;
+    GGI_modifiers = 0;
+    {
+	struct timeval tv;
+	struct timezone tz;
+	gettimeofday(&tv, &tz);
+	GGI_SetTime(&tv); /* initialize time */
+    }
+#endif
+
+#ifdef ENABLE_XMI
+    if (0 != xmiInit()) {
+	/* TODO: abort a bit more gracefully */
+	ggiPanic("(GGI_init() unable to initialize xmi\n");
+    }
+
+    if (xmiAttach(GGIvisual) < 0) {
+	ggiPanic("(GGI_init) Unable to attach XMI extension to visual\n");
+    }
+
+    /* miPaintedSet */
+    if (GGI_miPaintedSet) {
+	miDeletePaintedSet(GGIvisual, GGI_miPaintedSet);
+	GGI_miPaintedSet = (miPaintedSet*)0;
+    }
+    GGI_miPaintedSet = miNewPaintedSet(GGIvisual);
+    miClearPaintedSet(GGIvisual, GGI_miPaintedSet);
+
+    /* miGC */
+    if (GGI_miGC) {
+	miDeleteGC(GGIvisual, GGI_miGC);
+	GGI_miGC = (miGC*)0;
+    }
+    GGI_miGC = miNewGC(GGIvisual, 2,
+	GGI_miPixels, GGI_numblendstages, GGI_blendstages);
+#endif
+    setvbuf(stdin, (char*)0, _IONBF, 0);
+}
+
+TERM_PUBLIC void GGI_linetype(int linetype)
+{
+    if(linetype == LT_BLACK)
+	ggiSetGCForeground(GGIvisual,GGIborderColor);
+    if(linetype == LT_AXIS)
+	ggiSetGCForeground(GGIvisual,GGIaxisColor);
+    if(linetype < 0)
+	return;
+    if(linetype >= 6)
+	linetype%=6;
+    ggiSetGCForeground(GGIvisual,GGIcolors[linetype]);
+}
+
+TERM_PUBLIC void GGI_move(unsigned int x, unsigned int y)
+{
+    GGIx=x;
+    GGIy=GGI_y(y);
+}
+
+TERM_PUBLIC void
+GGI_options()
+{
+    while (!END_OF_COMMAND) {
+	switch(lookup_table(&GGI_opts[0], c_token)) {
+	case GGI_ACCELERATION:
+	{
+	    int itmp;
+	    struct value a;
+
+	    c_token++;
+	    itmp = (int) real(const_express(&a));
+	    if (itmp < 1) {
+		fprintf(stderr, "acceleration must be strictly positive!\n");
+	    } else {
+		GGI_acceleration = itmp;
+	    }
+	    break;
+	}
+	case GGI_MODE:
+	    c_token++;
+	    /* fallthru */
+	default:
+	    if (!END_OF_COMMAND) {
+		copy_str(GGI_mode_spec, c_token, 0xfe);
+		GGI_mode_changed = 1;
+	    }
+	    break;
+	}
+	c_token++;
+    } /* while(command) */
+
+    if (*GGI_mode_spec) {
+	sprintf(term_options, "mode %s acceleration %d",
+		GGI_mode_spec, GGI_acceleration);
+    } else {
+	sprintf(term_options, "acceleration %d", GGI_acceleration);
+    }
+}
+
+TERM_PUBLIC void
+GGI_close()
+{
+    ggiFlush(GGIvisual);
+    /* DETACH EXTENSIONS */
+#if HAVE_WMH_H
+    if(GGI_use_whm) {
+	ggiWmhDetach(GGIvisual);
+    }
+#endif
+#ifdef ENABLE_XMI
+    xmiDetach(GGIvisual);
+#endif
+
+    ggiClose(GGIvisual);
+    GGIvisual = (ggi_visual_t)0;
+
+    /* EXIT EXTENSIONS */
+#if HAVE_WMH_H
+    if(GGI_use_whm) {
+	ggiWmhExit();
+	GGI_use_whm = 0;
+    }
+#endif
+#ifdef ENABLE_XMI
+    xmiExit();
+#endif
+}
+
+/* Called when terminal is terminated i.e.
+ * when switching to another terminal. */
+TERM_PUBLIC void
+GGI_reset()
+{
+    if(GGIvisual!=NULL) {
+	GGI_close();
+    }
+# if 0 /* not needed */
+    GGI_save_pal.colorFormulae = -1; /* force later reallocation of palette */
+# endif
+}
+
+TERM_PUBLIC void
+GGI_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    ggi_pixel current_foreground;
+    ggiGetGCForeground(GGIvisual,&current_foreground);
+    ggiSetGCForeground(GGIvisual,GGIborderColor);
+    ggiPuts(GGIvisual,x,GGI_y(y) - 4 /* ? (joze ? */,str);
+    ggiSetGCForeground(GGIvisual,current_foreground);
+}
+
+TERM_PUBLIC void
+GGI_suspend()
+{
+    /* this fails on the console */
+    GGI_text();
+}
+
+TERM_PUBLIC void
+GGI_resume()
+{
+    /* do nothing */
+}
+
+TERM_PUBLIC void
+GGI_fillbox(
+    int style,
+    unsigned int x, unsigned int y,
+    unsigned int w, unsigned int h)
+{
+    ggiDrawBox(GGIvisual, x, GGI_y((int)(y+h)), w, h);
+}
+
+TERM_PUBLIC void
+GGI_text()
+{
+    ggiFlush(GGIvisual);
+#ifdef USE_MOUSE
+    /* now display the buffer which was just written */
+    ggiSetDisplayFrame(GGIvisual, ggiGetWriteFrame(GGIvisual));
+    return;
+#else
+    /* Wait for a key to be pressed and exit graphics mode if
+     * running in console mode. */
+    /* TODO: return immediately, if in X */
+    ggiGetc(GGIvisual);
+    GGI_close();
+#endif
+}
+
+TERM_PUBLIC void
+GGI_vector(unsigned int x, unsigned int y)
+{
+    y = GGI_y(y);
+    ggiDrawLine(GGIvisual,GGIx,GGIy,x,y);
+    GGIx=x;
+    GGIy=y;
+}
+
+#ifdef USE_MOUSE
+
+/* translate ggi keysym to gnuplot keysym */
+TERM_PUBLIC int
+GGI_from_keysym(uint32_t keysym)
+{
+    switch (keysym) {
+	case GIIUC_BackSpace:
+	    return GP_BackSpace;
+	case GIIUC_Tab:
+	    return GP_Tab;
+	case GIIUC_Linefeed:
+	    return GP_Linefeed;
+	case GIIK_Clear:
+	    return GP_Clear;
+	case GIIUC_Return:
+	    return GP_Return;
+	case GIIK_Pause:
+	    return GP_Pause;
+	case GIIK_ScrollLock:
+	    return GP_Scroll_Lock;
+	case GIIK_SysRq:
+	    return GP_Sys_Req;
+	case GIIUC_Escape:
+	    return GP_Escape;
+	case GIIK_Insert:
+	    return GP_Insert;
+	case GIIUC_Delete:
+	    return GP_Delete;
+	case GIIK_Home:
+	    return GP_Home;
+	case GIIK_Left:
+	    return GP_Left;
+	case GIIK_Up:
+	    return GP_Up;
+	case GIIK_Right:
+	    return GP_Right;
+	case GIIK_Down:
+	    return GP_Down;
+	case GIIK_PageUp:
+	    return GP_PageUp;
+	case GIIK_PageDown:
+	    return GP_PageDown;
+	case GIIK_End:
+	    return GP_End;
+	case GIIK_Begin:
+	    return GP_Begin;
+	case GIIK_PSpace:
+	    return GP_KP_Space;
+	case GIIK_PTab:
+	    return GP_KP_Tab;
+	case GIIK_PEnter:
+	    return GP_KP_Enter;
+
+	case GIIK_PF1:
+	    return GP_KP_F1;
+	case GIIK_PF2:
+	    return GP_KP_F2;
+	case GIIK_PF3:
+	    return GP_KP_F3;
+	case GIIK_PF4:
+	    return GP_KP_F4;
+
+#if 0
+	case 1:
+	    return GP_KP_Insert;    /* ~ KP_0 */
+	case 1:
+	    return GP_KP_End;       /* ~ KP_1 */
+	case 1:
+	    return GP_KP_Down;      /* ~ KP_2 */
+	case 1:
+	    return GP_KP_Page_Down; /* ~ KP_3 */
+	case 1:
+	    return GP_KP_Left;      /* ~ KP_4 */
+	case 1:
+	    return GP_KP_Begin;     /* ~ KP_5 */
+	case 1:
+	    return GP_KP_Right;     /* ~ KP_6 */
+	case 1:
+	    return GP_KP_Home;      /* ~ KP_7 */
+	case 1:
+	    return GP_KP_Up;        /* ~ KP_8 */
+	case 1:
+	    return GP_KP_Page_Up;   /* ~ KP_9 */
+#endif
+
+#if 0
+	case GIIK_PDelete:
+	    return GP_KP_Delete;
+#endif
+	case GIIK_PEqual:
+	    return GP_KP_Equal;
+	case GIIK_PAsterisk:
+	    return GP_KP_Multiply;
+	case GIIK_PPlus:
+	    return GP_KP_Add;
+	case GIIK_PSeparator:
+	    return GP_KP_Separator;
+	case GIIK_PMinus:
+	    return GP_KP_Subtract;
+	case GIIK_PDecimal:
+	    return GP_KP_Decimal;
+	case GIIK_PSlash:
+	    return GP_KP_Divide;
+
+	case GIIK_P0:
+	    return GP_KP_0;
+	case GIIK_P1:
+	    return GP_KP_1;
+	case GIIK_P2:
+	    return GP_KP_2;
+	case GIIK_P3:
+	    return GP_KP_3;
+	case GIIK_P4:
+	    return GP_KP_4;
+	case GIIK_P5:
+	    return GP_KP_5;
+	case GIIK_P6:
+	    return GP_KP_6;
+	case GIIK_P7:
+	    return GP_KP_7;
+	case GIIK_P8:
+	    return GP_KP_8;
+	case GIIK_P9:
+	    return GP_KP_9;
+
+	case GIIK_F1:
+	    return GP_F1;
+	case GIIK_F2:
+	    return GP_F2;
+	case GIIK_F3:
+	    return GP_F3;
+	case GIIK_F4:
+	    return GP_F4;
+	case GIIK_F5:
+	    return GP_F5;
+	case GIIK_F6:
+	    return GP_F6;
+	case GIIK_F7:
+	    return GP_F7;
+	case GIIK_F8:
+	    return GP_F8;
+	case GIIK_F9:
+	    return GP_F9;
+	case GIIK_F10:
+	    return GP_F10;
+	case GIIK_F11:
+	    return GP_F11;
+	case GIIK_F12:
+	    return GP_F12;
+
+	default:
+	    /* return it untranslated */
+	    return keysym;
+    }
+}
+
+TERM_PUBLIC long int
+GGI_SetTime(const struct timeval* current)
+{
+    /* --> dsec in musec */
+    int dsec = (current->tv_sec - GGI_timestamp.tv_sec) * 1000000;
+    /* --> dmu in millisec */
+    int dmu = (current->tv_usec - GGI_timestamp.tv_usec + dsec) / 1000;
+
+    GGI_timestamp = *current;
+    return dmu;
+}
+
+TERM_PUBLIC int
+GGI_from_button(uint32_t button)
+{
+    switch (button) {
+    case GII_PBUTTON_LEFT:
+	return 1;
+    case GII_PBUTTON_MIDDLE:
+	return 2;
+    case GII_PBUTTON_RIGHT:
+	return 3;
+    default:
+	/* should not happen */
+	return 0;
+    }
+}
+
+TERM_PUBLIC int
+GGI_y(int32_t y)
+{
+    return GGIymax - y;
+}
+
+TERM_PUBLIC int
+GGI_eventually_update_modifiers(const ggi_event* event, const int add)
+{
+    int mod = 0;
+    int old_modifiers = GGI_modifiers;
+
+    switch (event->key.sym) {
+    case GIIK_Shift:
+	mod = Mod_Shift;
+	break;
+    case GIIK_Ctrl:
+	mod = Mod_Ctrl;
+	break;
+    case GIIK_Alt:
+    case GIIK_Meta:
+	mod = Mod_Alt;
+	break;
+    default:
+	return 0;
+    }
+
+    if (add) {
+	GGI_modifiers |= mod;
+    } else {
+	GGI_modifiers &= ~mod;
+    }
+
+    if (GGI_modifiers != old_modifiers) {
+
+	struct gp_event_t gp_ev;
+
+	gp_ev.type = GE_modifier;
+	gp_ev.mx   = GGI_mouse_x;
+	gp_ev.my   = GGI_y(GGI_mouse_y);
+	gp_ev.par1 = 0;
+	gp_ev.par2 = 0;
+	gp_ev.par1 = GGI_modifiers;
+
+	do_event(&gp_ev);
+    }
+
+    return 1;
+}
+
+TERM_PUBLIC int
+GGI_dispatch_event(const ggi_event* event)
+{
+    struct gp_event_t gp_ev;
+
+    gp_ev.type = 0;
+    gp_ev.mx   = GGI_mouse_x;
+    gp_ev.my   = GGI_y(GGI_mouse_y);
+    gp_ev.par1 = 0;
+    gp_ev.par2 = 0;
+
+    switch (event->any.type) {
+
+	/* [-- KEY EVENTS --] */
+    case evKeyPress:
+    case evKeyRepeat:
+	if (GGI_eventually_update_modifiers(event, 1)) {
+	    /* was just a modifier pressed */
+	    return 0;
+	}
+	gp_ev.type = GE_keypress;
+	gp_ev.par1 = GGI_from_keysym(event->key.sym);
+	if ('q' == gp_ev.par1) {
+	    return 'q';
+	}
+	break;
+    case evKeyRelease:
+	if (GGI_eventually_update_modifiers(event, 0)) {
+	    /* was just a modifier pressed */
+	    return 0;
+	}
+	break;
+
+	/* [-- POINTER EVENTS --] */
+    case evPtrRelative:
+	/* relative motion is not implemented. Should it ? */
+	/*
+	 * fprintf(stderr, "%s:%d report this to <johannes@zellner.org> %d %d\n",
+	 *     __FILE__, __LINE__, event->pmove.x, event->pmove.y);
+	 */
+	gp_ev.type  = GE_motion;
+	GGI_mouse_x += GGI_acceleration * event->pmove.x;
+	GGI_mouse_y += GGI_acceleration * event->pmove.y;
+	break;
+    case evPtrAbsolute:
+	gp_ev.type  = GE_motion;
+	GGI_mouse_x = event->pmove.x;
+	GGI_mouse_y = event->pmove.y;
+	break;
+    case evPtrButtonPress:
+	gp_ev.type = GE_buttonpress;
+	gp_ev.par1 = GGI_from_button(event->pbutton.button);
+	break;
+    case evPtrButtonRelease:
+	gp_ev.type = GE_buttonrelease;
+	gp_ev.par1 = GGI_from_button(event->pbutton.button);
+	gp_ev.par2 = GGI_SetTime(&(event->pbutton.time));
+	break;
+#ifdef HAVE_GGI_WMH_H
+    case evCommand:
+	/* [-- resizing --] */
+	if (GGI_use_whm) {
+	    /* fprintf(stderr, "(GGI_dispatch_event) \n"); */
+	    if (event->cmd.code==GGICMD_REQUEST_SWITCH) {
+		/*
+		 * ggi_cmddata_switchrequest *req;
+		 * req = &(event->cmd.data);
+		 * ggi_resize(GGIvisual, &(req->mode));
+		 */
+		/*
+		 * while( ggiEventPoll(GGIvisual, emAll, &tv) ) {
+		 *     ggiEventRead(GGIvisual, event, emAll);
+		 * }
+		 */
+	    }
+	}
+	break;
+#endif
+    default:
+	/* fprintf(stderr, "(GGI_dispatch_event) unhandled event\n"); */
+	break;
+    }
+    do_event(&gp_ev);
+    gp_ev.type = GE_plotdone;
+    do_event(&gp_ev);
+    return 0;
+}
+
+/* save currently displayed frame to alternate buffer */
+TERM_PUBLIC void
+GGI_save_frame_canvas()
+{
+    if (!GGI_saved_canvas && GGIvisual) {
+	int display_frame = ggiGetDisplayFrame(GGIvisual);
+
+	/* save the currently displayed frame to alternate frame */
+	ggiSetReadFrame(GGIvisual, display_frame);
+	ggiSetWriteFrame(GGIvisual, !display_frame);
+	ggiCopyBox(GGIvisual, 0, 0, GGIwidth, GGIcanvas_height, 0, 0);
+
+	/* write again directly to the display frame */
+	ggiSetWriteFrame(GGIvisual, display_frame);
+
+	/* remember that the alternate frame is valid */
+	GGI_saved_canvas = 1;
+    }
+}
+
+TERM_PUBLIC void
+GGI_save_frame_stl()
+{
+    if (!GGI_saved_stl) {
+	int display_frame = ggiGetDisplayFrame(GGIvisual);
+
+	/* clear the stl part of the alternate buffer */
+	ggiSetGCForeground(GGIvisual, GGIblack);
+	ggiSetWriteFrame(GGIvisual, !display_frame);
+	ggiDrawBox(GGIvisual, 0, GGIcanvas_height, GGIwidth, GGI_font_height);
+	ggiSetWriteFrame(GGIvisual, display_frame);
+
+	/* clear the currently displayed area, which is left
+	 * from a previous plot (see above, where the stl of
+	 * the previous plot is copied to the current frame) */
+	ggiSetReadFrame(GGIvisual, !display_frame);
+	ggiCopyBox(GGIvisual, 0, GGIcanvas_height,
+		   GGIwidth, GGI_font_height, 0, GGIcanvas_height);
+
+	GGI_saved_stl = 1;
+    }
+}
+
+TERM_PUBLIC void
+GGI_replot()
+{
+    struct gp_event_t ev = {
+	GE_replot,
+	0, 0, 0, 0
+    };
+
+    do_event(&ev);
+}
+
+TERM_PUBLIC void
+GGI_clear(const GGI_vertex_t* v, const int tag)
+{
+    if (tag && v->width) {
+	/* turn off current */
+	ggiSetReadFrame(GGIvisual, !ggiGetDisplayFrame(GGIvisual));
+	ggiCopyBox(GGIvisual, v->x, v->y, v->width, v->height, v->x, v->y);
+    }
+}
+
+TERM_PUBLIC void
+GGI_save_puts(GGI_vertex_t* v, const int tag)
+{
+    GGI_clear(v, tag);
+
+    if (v->width) {
+
+	/* draw the text in the axis color (gray) */
+	ggiSetGCForeground(GGIvisual, GGIaxisColor);
+
+	/* write the string directly to the display */
+	ggiPuts(GGIvisual, v->x, v->y, v->str);
+
+    }
+}
+
+TERM_PUBLIC void
+GGI_set_vertex(
+    GGI_vertex_t* v,
+    const int x,
+    const int y,
+    const char* str,
+    const int tag)
+{
+    GGI_clear(v, tag);
+
+    v->x = x;
+    v->y = y;
+    v->height = GGI_font_height;
+
+    if (str && *str) {
+	v->width = strlen(str) * GGI_font_width;
+	strcpy(v->str, str);
+    } else {
+	/* turn string off */
+	v->width = 0;
+	*(v->str) = '\0';
+    }
+}
+
+TERM_PUBLIC void
+GGI_relative(int r[2])
+{
+    int diff = r[1] - r[0];
+    if (diff < 0) {
+	r[0] = r[1];
+	r[1] = -diff;
+    } else {
+	r[1] = diff;
+    }
+}
+
+TERM_PUBLIC void
+GGI_clear_hline(int x1, int x2, int y)
+{
+    if (GGI_saved_canvas && x1 >= 0 && x2 >= 0 && y >= 0) {
+	int r[2];
+	ggiSetReadFrame(GGIvisual, !ggiGetDisplayFrame(GGIvisual));
+
+	r[0] = x1;
+	r[1] = x2;
+	GGI_relative(r);
+	/* horizontal line */
+	ggiCopyBox(GGIvisual, r[0], y, r[1], 1, r[0], y);
+    }
+}
+
+TERM_PUBLIC void
+GGI_clear_vline(int y1, int y2, int x)
+{
+    if (GGI_saved_canvas && y1 >= 0 && y2 >= 0 && x >= 0) {
+	int r[2];
+	ggiSetReadFrame(GGIvisual, !ggiGetDisplayFrame(GGIvisual));
+
+	r[0] = y1;
+	r[1] = y2;
+	GGI_relative(r);
+	/* vertical line */
+	ggiCopyBox(GGIvisual, x, r[0], 1, r[1], x, r[0]);
+    }
+}
+
+TERM_PUBLIC void
+GGI_draw_hline(int x1, int x2, int y)
+{
+    if (x1 >= 0 && x2 >= 0 && y >= 0) {
+	int r[2];
+
+	r[0] = x1;
+	r[1] = x2;
+	GGI_relative(r);
+	/* horizontal line */
+	ggiDrawHLine(GGIvisual, r[0], y, r[1]);
+    }
+}
+
+TERM_PUBLIC void
+GGI_draw_vline(int y1, int y2, int x)
+{
+    if (y1 >= 0 && y2 >= 0 && x >= 0) {
+	int r[2];
+
+	r[0] = y1;
+	r[1] = y2;
+	GGI_relative(r);
+	/* vertical line */
+	ggiDrawVLine(GGIvisual, x, r[0], r[1]);
+    }
+}
+
+TERM_PUBLIC void
+GGI_draw_ruler()
+{
+    if (GGI_ruler.x >= 0 && GGI_ruler.y >= 0) {
+	ggi_pixel current_foreground;
+
+	GGI_save_frame_canvas();
+
+	/* TODO: we could choose a nicer color here */
+	ggiGetGCForeground(GGIvisual, &current_foreground);
+	ggiSetGCForeground(GGIvisual, GGIaxisColor);
+
+	ggiDrawHLine(GGIvisual, 0, GGI_ruler.y, GGIwidth);
+	ggiDrawVLine(GGIvisual, GGI_ruler.x, 0, GGIcanvas_height);
+
+	/* restore old foreground color */
+	/* XXX need this ? */
+	ggiSetGCForeground(GGIvisual, current_foreground);
+    }
+}
+
+TERM_PUBLIC void
+GGI_clear_zoombox()
+{
+    GGI_clear_hline(GGI_zoombox[0].x, GGI_zoombox[1].x, GGI_zoombox[0].y);
+    GGI_clear_hline(GGI_zoombox[0].x, GGI_zoombox[1].x, GGI_zoombox[1].y);
+    GGI_clear_vline(GGI_zoombox[0].y, GGI_zoombox[1].y, GGI_zoombox[0].x);
+    GGI_clear_vline(GGI_zoombox[0].y, GGI_zoombox[1].y, GGI_zoombox[1].x);
+}
+
+TERM_PUBLIC void
+GGI_draw_zoombox()
+{
+    if (GGI_zoombox[0].x >= 0 && GGI_zoombox[0].y >= 0
+	&& GGI_zoombox[0].x >= 0 && GGI_zoombox[0].y >= 0) {
+	ggi_pixel current_foreground;
+
+	GGI_save_frame_canvas();
+
+	/* TODO: we could choose a nicer color here */
+	ggiGetGCForeground(GGIvisual, &current_foreground);
+	ggiSetGCForeground(GGIvisual, GGIaxisColor);
+
+	GGI_draw_hline(GGI_zoombox[0].x, GGI_zoombox[1].x, GGI_zoombox[0].y);
+	GGI_draw_hline(GGI_zoombox[0].x, GGI_zoombox[1].x, GGI_zoombox[1].y);
+	GGI_draw_vline(GGI_zoombox[0].y, GGI_zoombox[1].y, GGI_zoombox[0].x);
+	GGI_draw_vline(GGI_zoombox[0].y, GGI_zoombox[1].y, GGI_zoombox[1].x);
+
+	/* restore old foreground color */
+	/* XXX need this ? */
+	ggiSetGCForeground(GGIvisual, current_foreground);
+    }
+}
+
+TERM_PUBLIC void
+GGI_abort_zooming()
+{
+    /* empty string: finish zooming */
+    int i, j;
+    GGI_clear_zoombox();
+    for (i = 0; i < 2; i++) {
+	for (j = 0; j < 2; j++) {
+	    GGI_set_vertex(&(GGI_zoom[i][j]), 0, 0, (char*)0, GGI_saved_canvas);
+	}
+	GGI_zoombox[i].x = -1;
+    }
+}
+
+TERM_PUBLIC int
+GGI_waitforinput()
+{
+    char c;
+
+    /* XXX:  if the input device it not a tty (e.g. /dev/null)
+     *       mouse events are not processed. This is necessary
+     *       as on some systems /dev/null is not selectable.
+     */
+    if (GGIvisual) {
+	fd_set fds;
+	int fd = fileno(stdin);
+	int i, j;
+	do {
+	    int n;
+
+	    ggi_event_mask mask = emAll; /* TODO: choose a more selective mask */
+	    ggiSetEventMask(GGIvisual, mask);
+
+	    FD_ZERO(&fds);
+	    FD_SET(fd, &fds); /* listen to stdin */
+
+	    if (GGI_needs_update) {
+		/* draw the ruler below the other items */
+		GGI_draw_ruler();
+
+		/* update the zoombox */
+		GGI_draw_zoombox();
+		for (i = 0; i < 2; i++) {
+		    for (j = 0; j < 2; j++) {
+			GGI_save_puts(&(GGI_zoom[i][j]), GGI_saved_canvas);
+		    }
+		}
+
+		/* update the status line */
+		GGI_save_puts(&GGI_stl_vertex, GGI_saved_stl);
+
+		ggiFlush(GGIvisual);
+
+		GGI_needs_update = 0;
+	    }
+
+	    n = ggiEventSelect(GGIvisual, &mask, fd + 1,
+		SELECT_TYPE_ARG234 &fds, 0, 0, (struct timeval*)0);
+
+	    if (mask) {
+		ggi_event event;
+		/* mask pointer motions and key repeat events,
+		 * to they don't pile up */
+		ggiEventRead(GGIvisual, &event, mask);
+		ggiRemoveEventMask(GGIvisual, emPtrMove | emKeyRepeat);
+		if ('q' == GGI_dispatch_event(&event)) {
+		    term_reset();
+		    break;
+		} else {
+		    ggiAddEventMask(GGIvisual, emPtrMove | emKeyRepeat);
+		}
+	    }
+
+	} while (!FD_ISSET(fd, &fds) && GGIvisual);
+    }
+
+    if (read(0, &c, 1)!=1) return EOF;
+    else return c;
+}
+
+TERM_PUBLIC void
+GGI_put_tmptext(int i, const char str[])
+{
+    char* second;
+
+    switch (i) {
+	case 0: /* statusline text */
+
+	    if (!str || !(*str)) {
+		/* statusline is empty. This is the case,
+		 * if the mouse was just turned off. */
+		if (GGI_use_mouse) {
+		    /* The user just toggled of the mouse. */
+		    GGI_use_mouse = 0;
+		    GGI_set_size();
+		    GGI_replot();
+		}
+	    } else {
+		/* statusline is non-empty */
+		if (!GGI_use_mouse) {
+		    /* The mouse was off before and was just turned on. */
+		    GGI_use_mouse = 1;
+		    GGI_set_size();
+		    GGI_replot();
+		}
+		GGI_save_frame_stl();
+		GGI_set_vertex(&GGI_stl_vertex, 0, GGIcanvas_height, str, GGI_saved_stl);
+	    }
+	    break;
+
+	case 1: /* coordinate text for first  corner of zoombox */
+	case 2: /* coordinate text for second corner of zoombox */
+	    GGI_save_frame_canvas();
+	    second = (char*) strchr(str, '\r');
+	    --i; /* transform to [0, 1] */
+	    GGI_clear_zoombox();
+	    if (second == NULL) {
+		/* remove box and / or coordinates */
+		GGI_set_vertex(&(GGI_zoom[i][0]), 0, 0, (char*)0, GGI_saved_canvas);
+		GGI_set_vertex(&(GGI_zoom[i][1]), 0, 0, (char*)0, GGI_saved_canvas);
+		break;
+	    } else {
+		*second = '\0'; /* XXX this assumes that str is writable XXX */
+		second++;
+		GGI_set_vertex(&(GGI_zoom[i][0]), GGI_mouse_x, GGI_mouse_y - GGI_font_height - 1, str, GGI_saved_canvas);
+		GGI_set_vertex(&(GGI_zoom[i][1]), GGI_mouse_x, GGI_mouse_y + 1, second, GGI_saved_canvas);
+		GGI_zoombox[i].x = GGI_mouse_x;
+		GGI_zoombox[i].y = GGI_mouse_y;
+	    }
+	    break;
+    }
+    GGI_needs_update++;
+}
+
+TERM_PUBLIC void
+GGI_set_ruler(int x, int y)
+{
+    if (x < 0) {
+
+	/* turn ruler off */
+	GGI_clear_hline(0, GGIwidth, GGI_ruler.y);
+	GGI_clear_vline(0, GGIcanvas_height, GGI_ruler.x);
+	GGI_ruler.x = -1;
+	GGI_ruler.y = -1;
+
+    } else {
+	GGI_ruler.x = x;
+	GGI_ruler.y = GGI_y(y);
+    }
+    GGI_needs_update++;
+}
+
+TERM_PUBLIC void
+GGI_set_cursor(int c, int x, int y)
+{
+    /* TODO */
+    switch (c) {
+	case 0:
+	    GGI_abort_zooming();
+	    break;
+	case 1:
+	case 2:
+	case 3:
+	default:
+	    /* XXX not implemented */
+	    break;
+    }
+    GGI_needs_update++;
+}
+
+TERM_PUBLIC void
+GGI_set_clipboard(const char s[])
+{
+    /* XXX: not implemented */
+    (void) s;			/* avoid -Wunused */
+}
+
+#endif
+
+TERM_PUBLIC int
+GGI_make_palette(t_sm_palette *palette)
+{
+    /* reallocate only, if it has changed */
+    if (palette && (GGI_save_pal.colorFormulae < 0
+	    || palette->colorFormulae != GGI_save_pal.colorFormulae
+	    || palette->colorMode != GGI_save_pal.colorMode
+	    || palette->formulaR != GGI_save_pal.formulaR
+	    || palette->formulaG != GGI_save_pal.formulaG
+	    || palette->formulaB != GGI_save_pal.formulaB
+	    || palette->positive != GGI_save_pal.positive)) {
+	int i;
+	ggi_color color;
+	for (i = 0; i < ggi_pm3d_colors; i++) {
+	    color.r = (short)floor(palette->color[i].r * 0xffff),
+	    color.g = (short)floor(palette->color[i].g * 0xffff),
+	    color.b = (short)floor(palette->color[i].b * 0xffff),
+	    GGI_smooth_colors[i] = ggiMapColor(GGIvisual, &color);
+	}
+	GGI_save_pal = *palette;
+    } else {
+	return ggi_pm3d_colors;
+    }
+    return 0;
+}
+
+TERM_PUBLIC void
+GGI_previous_palette()
+{
+#if 0
+#ifdef ENABLE_XMI
+    fprintf(stderr, "(GGI_previous_palette) \n");
+    if (GGI_miPaintedSet) {
+	miPoint offset;
+	offset.x = 0; offset.y = 0;
+	miCopyPaintedSetToVisual(GGIvisual, GGI_miGC, GGI_miPaintedSet, offset);
+	miClearPaintedSet(GGIvisual, GGI_miPaintedSet);
+    }
+#endif
+#endif
+}
+
+TERM_PUBLIC void
+GGI_set_color(struct t_colorspec *colorspec)
+{
+    ggi_color rgb;
+    double gray = colorspec->value;
+
+    if (colorspec->type == TC_RGB) {
+	rgb.r = ((colorspec->lt >> 16) & 0xff) * (65535./255.);
+	rgb.g = ((colorspec->lt >> 8) & 0xff) * (65535./255.);
+	rgb.b = ((colorspec->lt) & 0xff) * (65535./255.);
+	ggiSetGCForeground(GGIvisual, ggiMapColor(GGIvisual,&rgb));
+    }
+    
+    if (colorspec->type != TC_FRAC)
+	return;
+
+    if (GGIvisual) {
+	int idx = (gray <= 0) ? 0 : (int)(gray * ggi_pm3d_colors);
+	if (idx >= ggi_pm3d_colors)
+	    idx = ggi_pm3d_colors - 1;
+	ggiSetGCForeground(GGIvisual, GGI_smooth_colors[idx]);
+#ifdef ENABLE_XMI
+	GGI_miGC->pixels[1] = GGI_smooth_colors[idx];
+#endif
+    }
+}
+
+#ifdef ENABLE_XMI
+TERM_PUBLIC void
+GGI_filled_polygon(int points, gpiPoint *corners)
+{
+    static miPoint offset = {0, 0};
+    if (GGI_miPaintedSet) {
+#define MI_POINTS 4
+	miPoint mi_corners[MI_POINTS];
+	unsigned int i;
+	if (MI_POINTS != points) {
+	    fprintf(stderr, "(GGI_filled_polygon) internal error %s:%d\n", __FILE__, __LINE__);
+	    return;
+	}
+	for (i = 0; i < MI_POINTS; i++) {
+	    mi_corners[i].x = corners[i].x;
+	    mi_corners[i].y = GGI_y(corners[i].y);
+	}
+	miFillPolygon(GGIvisual, GGI_miPaintedSet, GGI_miGC,
+	    MI_SHAPE_GENERAL, MI_COORD_MODE_ORIGIN, MI_POINTS, mi_corners);
+	miCopyPaintedSetToVisual(GGIvisual, GGI_miGC, GGI_miPaintedSet, offset);
+	miClearPaintedSet(GGIvisual, GGI_miPaintedSet);
+    }
+}
+#endif
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(ggi_driver)
+    "ggi", "GGI target",
+    GGI_XMAX, GGI_YMAX, GGI_VCHAR, GGI_HCHAR, GGI_VTIC, GGI_HTIC,
+    GGI_options, GGI_init, GGI_reset, GGI_text,
+    null_scale, GGI_graphics, GGI_move, GGI_vector,
+    GGI_linetype, GGI_put_text,
+    0, /* angle */
+    0, /* justify text */
+    0, /* point */
+    0, /* arrow */
+    0, /* set_font */
+    0, /* set_pointsize */
+    TERM_CAN_MULTIPLOT,
+    GGI_suspend,
+    GGI_resume,
+    GGI_fillbox,
+    0 /* linewidth */
+#ifdef USE_MOUSE
+    , GGI_waitforinput, GGI_put_tmptext, GGI_set_ruler, GGI_set_cursor, GGI_set_clipboard
+#endif
+    , GGI_make_palette,
+    GGI_previous_palette,
+    GGI_set_color,
+#ifdef ENABLE_XMI
+    GGI_filled_polygon
+#else
+    0 /* GGI_filled_polygon */
+#endif
+TERM_TABLE_END(ggi_driver)
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(ggi)
+"1 ggi",
+"?commands set terminal ggi",
+"?set terminal ggi",
+"?set term ggi",
+"?terminal ggi",
+"?term ggi",
+"?ggi",
+" The `ggi` driver can run on different targets as X or svgalib.",
+"",
+" Syntax:",
+"    set terminal ggi [acceleration <integer>] [[mode] {mode}]",
+"",
+" In X the window cannot be resized using window manager handles, but the",
+" mode can be given with the mode option, e.g.:",
+"  - V1024x768",
+"  - V800x600",
+"  - V640x480",
+"  - V320x200",
+" Please refer to the ggi documentation for other modes. The 'mode' keyword",
+" is optional. It is recommended to select the target by environment variables",
+" as explained in the libggi manual page. To get DGA on X, you should for",
+" example",
+"    bash> export GGI_DISPLAY=DGA",
+"    csh>  setenv GGI_DISPLAY DGA",
+"",
+" 'acceleration' is only used for targets which report relative pointer",
+" motion events (e.g. DGA) and is a strictly positive integer multiplication",
+" factor for the relative distances.  The default for acceleration is 7.",
+"",
+" Examples:",
+"    set term ggi acc 10",
+"    set term ggi acc 1 mode V1024x768",
+"    set term ggi V1024x768"
+END_HELP(ggi)
+#endif
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/gnugraph.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/gnugraph.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/gnugraph.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/gnugraph.trm.svn-base	2012-01-03 17:07:30.303563900 -0800
@@ -0,0 +1,456 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: gnugraph.trm,v 1.24 2006/07/21 02:35:46 sfeam Exp $
+ */
+
+/* GNUPLOT -- gnugraph.trm */
+
+/*[
+ * Copyright 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *  GNU plot(5) graphics language
+ *
+ * AUTHORS
+ *  Tony Richardson from the unixplot.trm by Colin Kelley, Thomas Williams,
+ *  and Russell Lang and from post.trm by Russell Lang.
+ *
+ * send your comments or suggestions to (info-gnuplot@ames.arc.nasa.gov).
+ */
+
+/*
+ * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
+ */
+
+/*
+ * Name changed from "unixplot" to "gnugraph" to distinguish the two different
+ * drivers. Also avoids duplications in the complete gnuplot documentation.
+ * (March 2003)
+ */
+
+/*
+ * This version of the 'unixplot' driver produces device independent
+ * output.  I've chosen parameter values so that the PostScript output
+ * produced by plot2ps is 5" x 3".  You can use the 'set size' command
+ * to get output up to 8.25" x 8.25", i.e. size values larger than
+ * 1 are okay.
+ */
+
+/*
+Unixplot library writes to stdout.  A fix was put in place by
+..!arizona!naucse!jdc to let set term and set output redirect
+stdout.  All other terminals write to gpoutfile.
+*/
+
+/* This is a device independent format, so the output should look
+ * look "reasonable" on any output device.  I set things up there so
+ * that the output of plot2ps is 5" x 3" (standard GNUPLOT size).
+ * You can use GNUPLOT's size command to obtain plots to almost the
+ * 8.25" x 8.25" limit.
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(gnugraph)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void UP_options __PROTO((void));
+TERM_PUBLIC void UP_init __PROTO((void));
+TERM_PUBLIC void UP_graphics __PROTO((void));
+TERM_PUBLIC void UP_text __PROTO((void));
+TERM_PUBLIC void UP_linetype __PROTO((int linetype));
+TERM_PUBLIC void UP_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void UP_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void UP_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
+TERM_PUBLIC int UP_text_angle __PROTO((int ang));
+TERM_PUBLIC int UP_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC void UP_reset __PROTO((void));
+#define UP_XMAX 19859
+#define UP_YMAX 11565
+/* UP_VCHAR = ((UP_FONTSIZE*UP_YMAX)/(UP_YINCHES*72))
+            = UP_FONTSIZE*UP_VFONTSC
+   UP_HCHAR = ((UP_FONTSIZE/2)*UP_XMAX)/(UP_XINCHES*72))
+            = UP_FONTSIZE*UP_HFONTSC
+*/
+
+#define UP_VFONTSC  53.5
+#define UP_VCHAR    535		/* 10 * VFONTSC */
+#define UP_HFONTSC  27.6
+#define UP_HCHAR    276		/* 10 * HFONTSC */
+
+#define UP_VTIC (UP_YMAX/80)
+#define UP_HTIC (UP_XMAX/80)
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+#define DEFAULT_GNUGRAPHFONT "Courier"
+
+/* Name of font */
+char up_font[MAX_ID_LEN+1] = DEFAULT_GNUGRAPHFONT;
+int up_fontsize = 10;
+
+/* plot2ps produces a 8.25" x 8.25" square. */
+#define UP_SCREENX 32768
+#define UP_SCREENY 32768
+#define UP_SCRXINC 8.25
+#define UP_SCRYINC 8.25
+
+/* We want a 5" x 3" graph by default. */
+#define UP_XINCHES 5
+#define UP_YINCHES 3
+/* UP_XMAX = (UP_SCREENX*UP_XINCHES)/UP_SCRXINC
+   UP_YMAX (UP_SCREENY*UP_YINCHES)/UP_SCRYINC */
+
+#define UP_XLAST (UP_XMAX - 1)
+#define UP_YLAST (UP_YMAX - 1)
+
+/* These offsets center plot2ps output in the middle of the page.  The
+ * amount of resizing that can be done is limited. */
+/*
+ * #define UP_XOFF 6454
+ * #define UP_YOFF 10601
+ */
+
+/* These offsets give a 1" offset from the lower left corner.  This
+ * gives a greater range of permissible values in GNUPLOT's size
+ * command. */
+#define UP_XOFF 3972
+#define UP_YOFF 3972
+
+enum JUSTIFY up_justify = LEFT;
+
+#define ROTATE(angle) pl_textangle(90*angle)
+
+static int handle_global;              /* T.Walter 1999-05-23 */
+
+/* We don't include plot.h from plotutils because of
+ * the name clash with ../plot.h.
+ */
+extern int pl_openpl __PROTO((void));
+extern int pl_space __PROTO((int, int, int, int));
+extern int pl_fontname __PROTO((const char *));
+extern int pl_fontsize __PROTO((int));
+extern int pl_erase __PROTO((void));
+extern int pl_linemod __PROTO((const char *));
+extern int pl_move __PROTO((int, int));
+extern int pl_cont __PROTO((int, int));
+extern int pl_alabel __PROTO((int, int, const char *));
+extern int pl_textangle __PROTO((int));
+extern int pl_closepl __PROTO((void));
+/* T.Walter added: */
+extern int pl_parampl __PROTO((const char *parameter, void *value));
+extern int pl_newpl __PROTO((const char *type, FILE *infile, FILE *outfile, FILE *errfile));
+extern int pl_selectpl __PROTO((int handle));
+extern int pl_deletepl __PROTO((int handle));
+extern double pl_ffontsize __PROTO((double size));
+
+/* Formats supported by GNU plotutils */
+enum PL_types {
+    PL_X, PL_PNM, PL_GIF, PL_AI, PL_PS, PL_CGM, PL_FIG, PL_PCL5,
+    PL_HPGL, PL_TEK, PL_META, PL_INVALID
+};
+
+struct gen_table term_up_pt_tbl[] =
+{
+    { "X", PL_X },
+    { "pnm", PL_PNM },
+    { "gif", PL_GIF },
+    { "ai", PL_AI },
+    { "ps", PL_PS },
+    { "cgm", PL_CGM },
+    { "fig", PL_FIG },
+    { "pcl5", PL_PCL5 },
+    { "hpgl", PL_HPGL },
+    { "tek", PL_TEK },
+    { "meta", PL_META },
+    { NULL, PL_INVALID }
+};
+
+/* Plot type, default */
+static int pl_plottype = PL_META;
+
+/* Plot size, default */
+static char pl_pagesize[MAX_ID_LEN+1] = "a4";
+
+enum UP_id { UP_DEFAULT, UP_PAGESIZE, UP_PLOTTYPE, UP_OTHER };
+
+static struct gen_table UP_opts[] =
+{
+    { "d$efault", UP_DEFAULT },
+    { "s$ize", UP_PAGESIZE },
+    { "t$ype", UP_PLOTTYPE },
+    { NULL, UP_OTHER }
+};
+
+TERM_PUBLIC void
+UP_options()
+{
+    struct value a;
+
+    while (!END_OF_COMMAND) {
+	switch(lookup_table(&UP_opts[0],c_token)) {
+	case UP_DEFAULT:
+	    strcpy(up_font, DEFAULT_GNUGRAPHFONT);
+	    up_fontsize = 10;
+	    term->v_char = (unsigned int) (up_fontsize * UP_VFONTSC);
+	    term->h_char = (unsigned int) (up_fontsize * UP_HFONTSC);
+	    c_token++;
+	    break;
+	case UP_PAGESIZE:
+	    c_token++;
+	    /* user is responsible for valid page size specification, e.g.
+	     * "a4", "letter", "b5", "a4,xoffset=-5mm,yoffset=2.0cm".
+	     * See GNU plotutils documentation for details. */
+	    quote_str(pl_pagesize, c_token, MAX_ID_LEN);
+	    /* else use default quietly */
+	    c_token++;
+	    break;
+	case UP_PLOTTYPE:
+	    c_token++;
+	    pl_plottype = lookup_table(&term_up_pt_tbl[0],c_token);
+	    if (pl_plottype == PL_INVALID)
+		pl_plottype = PL_META;
+	    c_token++;
+	    break;
+	case UP_OTHER:
+	default:
+	    if (isstring(c_token)) {
+		quote_str(up_font, c_token, MAX_ID_LEN);
+		c_token++;
+	    }
+	    if (!END_OF_COMMAND) {
+		/* We have font size specified */
+		up_fontsize = (int) real(const_express(&a));
+		term->v_char = (unsigned int) (up_fontsize * UP_VFONTSC);
+		term->h_char = (unsigned int) (up_fontsize * UP_HFONTSC);
+	    }
+	}
+    }
+
+    sprintf(term_options, "\"%s\" %d size \"%s\" type %s",
+	    up_font,
+	    up_fontsize,
+	    pl_pagesize,
+	    term_up_pt_tbl[pl_plottype].key);
+}
+
+TERM_PUBLIC void
+UP_init()
+{
+#if 1
+    pl_parampl ("PAGESIZE", pl_pagesize);
+
+    if ((handle_global = pl_newpl (term_up_pt_tbl[pl_plottype].key,
+				   NULL, gpoutfile, stderr)) < 0) {
+	int_error(NO_CARET, "GNU plotutils (gnugraph) failed to create \"%s\" plotter.",
+		  term_up_pt_tbl[pl_plottype].key);
+    }
+
+    pl_selectpl (handle_global);         /* select the Plotter for use */
+
+    pl_openpl ();
+    pl_space (0, 0, UP_SCREENX - 1, UP_SCREENY - 1);
+    pl_fontname (up_font);
+
+    /* T.Walter: Try to find the correct font size */
+# if 0
+    pl_fontsize (up_fontsize);  too small
+    pl_fontsize (up_fontsize*10);  too small
+    pl_fontsize (up_fontsize*100);  too large
+    pl_fontsize (up_fontsize*0.0525*GPMIN((UP_XMAX), (UP_YMAX)));  too large
+    pl_fontsize (up_fontsize/72.0*GPMIN((UP_XMAX), (UP_YMAX)));  too large
+    pl_fontsize (up_fontsize/72.0*0.0525*GPMIN((UP_XMAX), (UP_YMAX)));  too small
+    pl_fontsize (up_fontsize/72.0*0.0525*GPMIN((UP_SCREENX), (UP_SCREENY))); too small
+    pl_fontsize (up_fontsize/72.0*GPMIN((UP_SCREENX), (UP_SCREENY)));  too large
+    pl_fontsize (up_fontsize/72.0*8*0.0525*GPMIN((UP_XMAX), (UP_YMAX))); just about too large
+# endif /* 0 */
+    pl_fontsize (up_fontsize/72.0*0.0525*GPMIN((UP_SCREENX), (UP_SCREENY)));
+
+#else  /* Old code */
+    pl_openpl();
+    pl_space (0, 0, UP_SCREENX - 1, UP_SCREENY - 1);
+    pl_fontname (up_font);
+#endif
+    pl_fontsize(up_fontsize);
+}
+
+
+TERM_PUBLIC void
+UP_graphics()
+{
+    pl_erase();
+}
+
+
+TERM_PUBLIC void
+UP_text()
+{
+    /* Flush here so that output will be complete. */
+    fflush(stdout);
+}
+
+
+TERM_PUBLIC void
+UP_linetype(int linetype)
+{
+    /* T.Walter, 1999-05-23 */
+    static char *lt[2+5] = { "solid", "longdashed", "solid", "dotted",
+			     "shortdashed", "dotdashed", "longdashed"};
+
+    if (linetype < -2)
+	linetype = LT_BLACK;
+
+    if (linetype >= 5)
+	linetype %= 5;
+
+    pl_linemod(lt[linetype + 2]);
+}
+
+
+TERM_PUBLIC void
+UP_move(unsigned int x, unsigned int y)
+{
+    pl_move(x + UP_XOFF, y + UP_YOFF);
+}
+
+
+TERM_PUBLIC void
+UP_vector(unsigned int x, unsigned int y)
+{
+    pl_cont(x + UP_XOFF, y + UP_YOFF);
+}
+
+
+TERM_PUBLIC void
+UP_put_text(unsigned int x, unsigned int y, const char str[])
+{
+    UP_move(x, y);		/* Don't adjust x and y! It's done in UP_move. */
+    switch (up_justify) {
+    case LEFT:
+	pl_alabel('l', 'c', str);
+	break;
+    case CENTRE:
+	pl_alabel('c', 'c', str);
+	break;
+    case RIGHT:
+	pl_alabel('r', 'c', str);
+	break;
+    }
+
+}
+
+TERM_PUBLIC int
+UP_text_angle(int ang)
+{
+    ROTATE(ang ? 1 : 0);
+    return TRUE;
+}
+
+TERM_PUBLIC int
+UP_justify_text(enum JUSTIFY mode)
+{
+    up_justify = mode;
+    return TRUE;
+}
+
+TERM_PUBLIC void
+UP_reset()
+{
+    pl_closepl();
+
+    /* T.Walter, 1999-05-23 */
+
+    pl_selectpl (0);                     /* default plotter */
+
+    if (pl_deletepl (handle_global) < 0) /* delete plotter we used above */
+	fprintf (stderr, "GNU Plotutils (gnugraph) is not able to delete Plotter\n");
+
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(gnugraph_driver)
+    "gnugraph", "GNU plot(1) format [\042fontname\042 font_size]",
+    UP_XMAX, UP_YMAX, UP_VCHAR, UP_HCHAR,
+    UP_VTIC, UP_HTIC, UP_options, UP_init, UP_reset,
+    UP_text, null_scale, UP_graphics, UP_move, UP_vector,
+    UP_linetype, UP_put_text, UP_text_angle,
+    UP_justify_text, line_and_point, do_arrow, set_font_null
+TERM_TABLE_END(gnugraph_driver)
+
+#undef LAST_TERM
+#define LAST_TERM gnugraph_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#define TERM_HELP_GNUGRAPH
+#ifdef TERM_HELP
+START_HELP(gnugraph)
+"1 Gnugraph(GNU plotutils)",
+"?commands set terminal gnugraph",
+"?set terminal gnugraph",
+"?set term gnugraph",
+"?terminal gnugraph",
+"?term gnugraph",
+"?gnugraph",
+" The `gnugraph` driver produces device-independent output in the GNU plot",
+" graphics language.  The default size of the PostScript results generated by",
+" \"plot2ps\" is 5 x 3 inches; this can be increased up to about 8.25 x 8.25 by",
+" `set size`.",
+"",
+" Syntax:",
+"       set terminal gnugraph {\"<fontname>\"} {<fontsize>}",
+"                             {type <pt>} {size \"<size>\"}",
+"",
+" which defaults to 10-point \"Courier\".",
+"",
+" For `type`, the following options are accepted: `X`, `pnm`, `gif`, `ai`,",
+" `ps`, `cgm`, `fig`, `pcl5`, `hpgl`, `tek`, and `meta` (default). The",
+" `size` option (default is a4) is passed straight through to plotutils, it's",
+" the user's responsibility to provide correct values. Details can be found",
+" in the plotutils documentation.",
+"",
+" Examples:",
+"       set terminal gnugraph type hpgl size \"a4\"",
+"       set terminal gnugraph size \"a4,xoffset=-5mm,yoffset=2.0cm\" type pnm",
+"",
+" There is a non-GNU version of the `gnugraph` driver which cannot be compiled",
+" unless this version is left out."
+END_HELP(gnugraph)
+#endif
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/gpic.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/gpic.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/gpic.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/gpic.trm.svn-base	2012-01-03 17:07:30.531154100 -0800
@@ -0,0 +1,359 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: gpic.trm,v 1.18 2006/07/21 02:35:46 sfeam Exp $
+ */
+
+/* GNUPLOT - gpic.trm */
+
+/*[
+ * Copyright 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ */
+
+/*
+ * This terminal driver supports:
+ *   The GPIC graphics language for groff
+ *
+ * AUTHOR
+ *  Sigfrid Lundberg
+ *
+ * send your comments or suggestions to (siglun@volterra.teorekol.lu.se).
+ *
+ */
+
+/*
+ * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(gpic)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void GPIC_options __PROTO((void));
+TERM_PUBLIC void GPIC_init __PROTO((void));
+TERM_PUBLIC void GPIC_graphics __PROTO((void));
+TERM_PUBLIC void GPIC_text __PROTO((void));
+TERM_PUBLIC void GPIC_linetype __PROTO((int linetype));
+TERM_PUBLIC void GPIC_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void GPIC_vector __PROTO((unsigned int ux, unsigned int uy));
+TERM_PUBLIC void GPIC_arrow __PROTO((unsigned int sx, unsigned int sy,
+				     unsigned int ex, unsigned int ey,
+				     int head));
+TERM_PUBLIC void GPIC_put_text __PROTO((unsigned int x, unsigned int y,
+					const char str[]));
+TERM_PUBLIC int GPIC_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC int GPIC_text_angle __PROTO((int ang));
+TERM_PUBLIC void GPIC_reset __PROTO((void));
+#define GPIC_DOTS_PER_INCH (300)
+
+/* 5 inches wide by 3 inches high (default) */
+#define GPIC_XMAX (5*GPIC_DOTS_PER_INCH)
+#define GPIC_YMAX (3*GPIC_DOTS_PER_INCH)
+
+#define GPIC_HTIC (5*GPIC_DOTS_PER_INCH/72)
+#define GPIC_VTIC (5*GPIC_DOTS_PER_INCH/72)
+#define GPIC_HCHAR (GPIC_DOTS_PER_INCH*53/10/72)
+#define GPIC_VCHAR (GPIC_DOTS_PER_INCH*11/72)
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+#define GPIC_PTS_PER_INCH (72.27)
+/* dot size in pt */
+#define GPIC_UNIT (GPIC_PTS_PER_INCH/GPIC_DOTS_PER_INCH)
+#define GPIC_coord(x) ((float)x)/((float)GPIC_DOTS_PER_INCH)
+
+static void GPIC_close_line __PROTO((void));
+static float GPIC_x, GPIC_y;
+static unsigned int GPIC_ltype;
+static enum JUSTIFY GPIC_justify = LEFT;
+
+/* for DOTS point style */
+
+static const char *GPIC_lines[] =
+{
+    "thickness 1.0",		/* -2 border */
+    "",				/* -1 axes */
+    "",				/*  0 solid thin  */
+    "dotted",
+    "dashed 0.05",		/*  1 solid thick */
+    "dashed 0.075",		/*  2 solid Thick */
+};
+
+/* number of linetypes above */
+#define GPIC_NUMLINES (sizeof(GPIC_lines)/sizeof(char *))
+
+
+static int GPIC_linecount = 0;	/* number of points in line so far */
+
+
+TERM_PUBLIC void
+GPIC_options()
+{
+    float x, y;
+    struct value a;
+
+    GPIC_x = 0;
+    GPIC_y = 0;
+
+    if (!END_OF_COMMAND) {
+	x = real(const_express(&a));
+	if (!END_OF_COMMAND) {
+	    y = real(const_express(&a));
+	    GPIC_x = x;
+	    GPIC_y = y;
+	}
+    }
+    sprintf(term_options, "Origin is at (%f,%f)", GPIC_x, GPIC_y);
+
+}
+
+TERM_PUBLIC void
+GPIC_init()
+{
+    GPIC_linetype(-1);
+    fputs(".\\\"GNUPLOT: GROFF picture using the gpic preprocessor\n", gpoutfile);
+}
+
+
+
+TERM_PUBLIC void
+GPIC_graphics()
+{
+    register struct termentry *t = term;
+
+    fprintf(gpoutfile, ".PS %f %f\n", GPIC_coord(t->xmax),
+	    GPIC_coord(t->ymax));
+    fprintf(gpoutfile, "x=%f; y=%f\n", GPIC_x, GPIC_y);
+}
+
+
+TERM_PUBLIC void
+GPIC_text()
+{
+    GPIC_close_line();
+    fputs(".PE\n", gpoutfile);
+}
+
+TERM_PUBLIC void
+GPIC_linetype(int linetype)
+{
+    if (linetype < -2)
+	linetype = LT_BLACK;
+    if (linetype >= GPIC_NUMLINES - 2)
+	linetype %= (GPIC_NUMLINES - 2);
+    GPIC_ltype = linetype;
+}
+
+static void
+GPIC_close_line()
+{
+    if (GPIC_linecount > 0) {
+	fputs("; reset linewid\n", gpoutfile);
+	GPIC_linecount = 0;
+    }
+}
+
+TERM_PUBLIC void
+GPIC_move(unsigned int x, unsigned int y)
+{
+    GPIC_close_line();
+    fprintf(gpoutfile, "move to (x+%f,y+%f)\n", GPIC_coord(x), GPIC_coord(y));
+    GPIC_linecount = 1;
+}
+
+
+TERM_PUBLIC void
+GPIC_vector(unsigned int ux, unsigned int uy)
+{
+    if (GPIC_linecount == 1) {
+	fprintf(gpoutfile, "line %s to (x+%f,y+%f)",
+		GPIC_lines[GPIC_ltype + 2],
+		GPIC_coord(ux), GPIC_coord(uy));
+    } else {
+	fprintf(gpoutfile, "\
+ \\\n\
+   then to (x+%f,y+%f)",
+		GPIC_coord(ux), GPIC_coord(uy));
+    }
+    GPIC_linecount++;
+}
+
+
+TERM_PUBLIC void
+GPIC_arrow(
+    unsigned int sx, unsigned int sy,
+    unsigned int ex, unsigned int ey,
+    int head)
+{
+    GPIC_close_line();
+    if (head) {
+	fprintf(gpoutfile, "arrowhead=7; arrow from x+%f,y+%f to x+%f,y+%f\n",
+		GPIC_coord(sx), GPIC_coord(sy), GPIC_coord(ex), GPIC_coord(ey));
+    } else {
+	fprintf(gpoutfile, "line from x+%f,y+%f to x+%f,y+%f\n",
+		GPIC_coord(sx), GPIC_coord(sy), GPIC_coord(ex), GPIC_coord(ey));
+    }
+}
+
+
+TERM_PUBLIC void
+GPIC_put_text(unsigned int x, unsigned int y, const char str[])
+{
+    GPIC_close_line();
+    fprintf(gpoutfile, "\"%s\" ", str);
+    switch (GPIC_justify) {
+    case LEFT:{
+	    fputs("ljust ", gpoutfile);
+	    break;
+	}
+    case CENTRE:{
+	    fputs(" ", gpoutfile);
+	    break;
+	}
+    case RIGHT:{
+	    fputs("rjust ", gpoutfile);
+	    break;
+	}
+    }
+    fprintf(gpoutfile, "at x+%f,y+%f\n", GPIC_coord(x), GPIC_coord(y));
+}
+
+
+
+TERM_PUBLIC int
+GPIC_justify_text(enum JUSTIFY mode)
+{
+    GPIC_justify = mode;
+    return (TRUE);
+}
+
+TERM_PUBLIC int
+GPIC_text_angle(int ang)
+{
+    (void) ang;
+    GPIC_close_line();
+    return (FALSE);
+}
+
+TERM_PUBLIC void
+GPIC_reset()
+{
+    fflush(gpoutfile);
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(gpic_driver)
+    "gpic", "GPIC -- Produce graphs in groff using the gpic preprocessor",
+    GPIC_XMAX, GPIC_YMAX, GPIC_VCHAR, GPIC_HCHAR,
+    GPIC_VTIC, GPIC_HTIC, GPIC_options, GPIC_init, GPIC_reset,
+    GPIC_text, null_scale, GPIC_graphics, GPIC_move, GPIC_vector,
+    GPIC_linetype, GPIC_put_text, GPIC_text_angle,
+    GPIC_justify_text, line_and_point, GPIC_arrow, set_font_null
+TERM_TABLE_END(gpic_driver)
+#undef LAST_TERM
+#define LAST_TERM gpic_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(gpic)
+"1 gpic",
+"?commands set terminal gpic",
+"?set terminal gpic",
+"?set term gpic",
+"?terminal gpic",
+"?term gpic",
+"?gpic",
+" The `gpic` terminal driver generates GPIC graphs in the Free Software",
+" Foundations's \"groff\" package.  The default size is 5 x 3 inches.  The only",
+" option is the origin, which defaults to (0,0).",
+"",
+" Syntax:",
+"       set terminal gpic {<x> <y>}",
+"",
+" where `x` and `y` are in inches.",
+"",
+" A simple graph can be formatted using",
+"",
+"       groff -p -mpic -Tps file.pic > file.ps.",
+"",
+" The output from pic can be pipe-lined into eqn, so it is possible to put",
+" complex functions in a graph with the `set label` and `set {x/y}label`",
+" commands.  For instance,",
+"",
+"       set ylab '@space 0 int from 0 to x alpha ( t ) roman d t@'",
+"",
+" will label the y axis with a nice integral if formatted with the command:",
+"",
+"       gpic filename.pic | geqn -d@@ -Tps | groff -m[macro-package] -Tps",
+"           > filename.ps",
+"",
+" Figures made this way can be scaled to fit into a document.  The pic language",
+" is easy to understand, so the graphs can be edited by hand if need be.  All",
+" co-ordinates in the pic-file produced by `gnuplot` are given as x+gnuplotx",
+" and y+gnuploty.  By default x and y are given the value 0.  If this line is",
+" removed with an editor in a number of files, one can put several graphs in",
+" one figure like this (default size is 5.0x3.0 inches):",
+"",
+"       .PS 8.0",
+"       x=0;y=3",
+"       copy \"figa.pic\"",
+"       x=5;y=3",
+"       copy \"figb.pic\"",
+"       x=0;y=0",
+"       copy \"figc.pic\"",
+"       x=5;y=0",
+"       copy \"figd.pic\"",
+"       .PE",
+"",
+" This will produce an 8-inch-wide figure with four graphs in two rows on top",
+" of each other.",
+"",
+" One can also achieve the same thing by the command",
+"",
+"       set terminal gpic x y",
+"",
+" for example, using",
+"",
+"       .PS 6.0",
+"       copy \"trig.pic\"",
+"       .PE"
+END_HELP(gpic)
+#endif /* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/gpr.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/gpr.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/gpr.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/gpr.trm.svn-base	2012-01-03 17:07:30.764759900 -0800
@@ -0,0 +1,477 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: gpr.trm,v 1.13 2006/07/21 02:35:46 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - gpr.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *   APOLLO's GPR windowing system
+ *
+ * AUTHORS
+ *  Michael Aramini
+ *  Roque D Oliveira , oliveria@caen.engin.umich.edu
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+
+/*
+ * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(gpr)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void GPR_init __PROTO((void));
+TERM_PUBLIC void GPR_graphics __PROTO((void));
+TERM_PUBLIC void GPR_text __PROTO((void));
+TERM_PUBLIC void GPR_linetype __PROTO((int linetype));
+TERM_PUBLIC void GPR_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void GPR_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void GPR_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
+TERM_PUBLIC int GPR_text_angle __PROTO((int ang));
+TERM_PUBLIC int GPR_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC void GPR_reset __PROTO((void));
+/* landscape window */
+/*
+#define GPR_XMAX 720
+#define GPR_YMAX 450
+*/
+/* portrait window */
+#define GPR_XMAX 585
+#define GPR_YMAX 735
+#define GPR_VCHAR 19
+#define GPR_HCHAR 10
+#define GPR_VTIC (GPR_YMAX/80)
+#define GPR_HTIC (GPR_XMAX/80)
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+void GPRold_linetype __PROTO((int linetype));
+static void check __PROTO((char *messagex));
+int gpr_isa_pad __PROTO((void));
+#include <apollo/base.h>
+#include <apollo/error.h>
+#include <apollo/gpr.h>
+#include <apollo/pad.h>
+
+#define GPR_XLAST (GPR_XMAX - 1)
+#define GPR_YLAST (GPR_YMAX - 1)
+
+
+gpr_$direction_t gpr_path = gpr_$right;
+/* text angle, 0=horizontal, 1=vertical */
+int gpr_ang = 0;
+/* text is flush left */
+enum JUSTIFY gpr_justify = LEFT;
+
+static status_$t status;
+/* set it to 1 when debugging program */
+unsigned int Debug = 0;
+
+
+static void
+check(char *messagex)
+{
+    if (status.all = status_$ok) {
+	error_$print(status);
+	printf("Error occurred while %s.\n", messagex);
+    }
+}
+
+/* return whether stdout is a DM pad . Called by term.c */
+int
+gpr_isa_pad()
+{
+    pad_$isa(1, &status);
+    return (status.all == status_$ok);
+}
+
+
+TERM_PUBLIC void
+GPR_init()
+{
+    gpr_$offset_t dm_bitmap_size;
+    gpr_$bitmap_desc_t dm_bitmap_desc;
+    pad_$window_desc_t window;
+    short font_id;
+    stream_$id_t stream_id;
+    static gpr_$rgb_plane_t hi_plane;
+    static gpr_$disp_char_t display_characteristics;
+    static float screen_size_r_width, screen_size_r_height;
+    static short int disp_len = sizeof(gpr_$disp_char_t);
+    static short int disp_len_returned;
+
+
+    /* open a pad to do graphics in */
+    window.top = 0;
+    window.left = 0;
+    /* 10 accounts for width of window border */
+    window.width = GPR_XMAX + 10;
+    /* 35 accounts for height of window border */
+    window.height = GPR_YMAX + 35;
+    pad_$create_window("", (short) 0, pad_$transcript, (short) 1, window, &stream_id, &status);
+    check("pad_$create_window");
+
+/*  pad_$set_full_window(stream_id,(short) 1,&window, &status); */
+/*  pad_$set_border (stream_id,(short) 1, true, &status); */
+    pad_$set_scale(stream_id, (short) 1, (short) 1, &status);
+    pad_$set_auto_close(stream_id, (short) 1, true, &status);
+
+    gpr_$inq_disp_characteristics(gpr_$direct, stream_id, disp_len, &display_characteristics, &disp_len_returned, &status);
+    check("in gpr_$inq_display_characteristics");
+    /*x_window_size in pixels */
+    screen_size_r_width = (float) display_characteristics.x_window_size;
+    /*y_window_size in pixels */
+    screen_size_r_height = (float) display_characteristics.y_window_size;
+    hi_plane = display_characteristics.n_planes - 1;
+    if (Debug)
+	printf("width=%f height=%f \n", screen_size_r_width, screen_size_r_height);
+
+    dm_bitmap_size.x_size = 1280;
+    dm_bitmap_size.y_size = 1024;
+    gpr_$init(gpr_$direct, stream_id, dm_bitmap_size, hi_plane, &dm_bitmap_desc, &status);
+    check("in gpr_$init");
+/*
+  gpr_$set_obscured_opt(gpr_$pop_if_obs, &status);
+  check("in gpr_$set_obscured_opt");
+*/
+    gpr_$set_auto_refresh(true, &status);
+    check("in gpr_$set_auto_refresh");
+
+    /* load a font and make it current */
+    gpr_$load_font_file("f7x13", 5, &font_id, &status);
+    check("in gpr_$load_font_file");
+    gpr_$set_text_font(font_id, &status);
+    check("in gpr_$set_text_font");
+
+    /* set up color values */
+    gpr_$set_draw_value((gpr_$pixel_value_t) 7, &status);	/* white */
+    check("in gpr_set_draw_value");
+    gpr_$set_text_background_value((gpr_$pixel_value_t) (-1), &status);	/* trans */
+    check("in gpr_$set_text_background_value");
+    gpr_$set_text_value((gpr_$pixel_value_t) 7, &status);	/* white */
+    check("in gpr_$set_text_value");
+}
+
+
+TERM_PUBLIC void
+GPR_graphics()
+{
+    gpr_$coordinate_t locx, locy, marker_size;
+
+    (void) gpr_$acquire_display(&status);
+    check("in gpr_$acquire display");
+    gpr_$clear((gpr_$pixel_value_t) 0, &status);	/* black */
+    check("in gpr_$clear");
+
+    if (Debug) {
+	marker_size = (short) 10;
+
+	locx = (short) 5;
+	locy = (short) 5;
+	gpr_$set_draw_value((gpr_$pixel_value_t) 2, &status);	/* white */
+	gpr_$move((locx - marker_size / 2), locy, &status);
+	gpr_$line((locx + marker_size / 2), locy, &status);
+	gpr_$move(locx, (locy + marker_size / 2), &status);
+	gpr_$line(locx, (locy - marker_size / 2), &status);
+
+	locx = (short) (GPR_XMAX - 1 - 5);
+	locy = (short) 5;
+	gpr_$set_draw_value((gpr_$pixel_value_t) 3, &status);	/* white */
+	gpr_$move((locx - marker_size / 2), locy, &status);
+	gpr_$line((locx + marker_size / 2), locy, &status);
+	gpr_$move(locx, (locy + marker_size / 2), &status);
+	gpr_$line(locx, (locy - marker_size / 2), &status);
+
+	locx = (short) 5;
+	locy = (short) (GPR_YMAX - 1 - 5);
+	gpr_$set_draw_value((gpr_$pixel_value_t) 4, &status);	/* white */
+	gpr_$move((locx - marker_size / 2), locy, &status);
+	gpr_$line((locx + marker_size / 2), locy, &status);
+	gpr_$move(locx, (locy + marker_size / 2), &status);
+	gpr_$line(locx, (locy - marker_size / 2), &status);
+
+	locx = (short) (GPR_XMAX - 1 - 5);
+	locy = (short) (GPR_YMAX - 1 - 5);
+	gpr_$set_draw_value((gpr_$pixel_value_t) 5, &status);	/* white */
+	gpr_$move((locx - marker_size / 2), locy, &status);
+	gpr_$line((locx + marker_size / 2), locy, &status);
+	gpr_$move(locx, (locy + marker_size / 2), &status);
+	gpr_$line(locx, (locy - marker_size / 2), &status);
+
+	gpr_$set_draw_value((gpr_$pixel_value_t) 7, &status);	/* white */
+	check("in gpr_$set_draw_value");
+    }				/* end if(Debug) */
+}
+
+
+TERM_PUBLIC void
+GPR_text()
+{
+    gpr_$release_display(&status);
+    check("gpr_$release_display");
+}
+
+
+void
+GPRold_linetype(int linetype)
+{
+    static gpr_$line_pattern_t patterns[2 + 5] =
+    {
+	{0xFFFF},		/* solid              1111111111111111 */
+	{0x3FFF},		/* very long dashed   0011111111111111 */
+	{0xFFFF},		/* solid              1111111111111111 */
+	{0x5555},		/* dotted             0101010101010101 */
+	{0x3333},		/* short dashed       0011001100110011 */
+	{0xB5AD},		/* dot short-dashed   1011010110101101 */
+	{0x3FFF}		/* very long dashed   0011111111111111 */
+    };
+    if (linetype >= 5)
+	linetype %= 5;
+    gpr_$set_line_pattern((short) 1, patterns[linetype + 2], (short) 16, &status);
+    check("in gpr_$set_line_pattern");
+}
+
+TERM_PUBLIC void
+GPR_linetype(int linetype)
+{
+    static gpr_$line_pattern_t patterns[2 + 7] =
+    {
+	{0xFFFF},		/* solid              1111111111111111 */
+	{0x1111},		/* long-spaced dotted 0001000100010001 */
+	{0xFFFF},		/* solid              1111111111111111 */
+	{0x5555},		/* dotted             0101010101010101 */
+	{0x3333},		/* short  dashed      0011001100110011 */
+	{0x7777},		/* medium dashed      0111011101110111 */
+	{0x3F3F},		/* long   dashed      0011111100111111 */
+	{0x0F0F},		/* long-spaced dashed 0000111100001111 */
+	{0x5F5F}		/* dot dashed         0101111101011111 */
+    };
+    if (linetype >= 7)
+	linetype %= 7;
+    gpr_$set_line_pattern((short) 1, patterns[linetype + 2], (short) 16, &status);
+    check("in gpr_$set_line_pattern");
+
+/*
+  gpr_$set_draw_value((gpr_$pixel_value_t)(linetype + 1), &status);
+  check("in gpr_$set_draw_value");
+*/
+}
+
+
+TERM_PUBLIC void
+GPR_move(unsigned int x, unsigned int y)
+{
+    gpr_$move((short) x, (short) (GPR_YMAX - 1 - y), &status);
+    check("in gpr_$move");
+}
+
+
+TERM_PUBLIC void
+GPR_vector(unsigned int x, unsigned int y)
+{
+    gpr_$line((short) x, (short) (GPR_YMAX - 1 - y), &status);
+    check("in gpr_$line");
+}
+
+
+TERM_PUBLIC void
+GPR_put_text(unsigned int x, unsigned int y, const char str[])
+{
+    gpr_$coordinate_t xgpr, ygpr;
+    gpr_$offset_t str_size_in_pixels;
+    short int str_len;
+
+    gpr_$coordinate_t locx, locy, marker_size;
+
+    if (Debug) {
+	locx = (short) x;
+	locy = (short) (GPR_YMAX - 1 - y);
+	marker_size = (short) 20;
+	gpr_$set_draw_value((gpr_$pixel_value_t) 1, &status);	/* white */
+	gpr_$move((locx - marker_size / 2), locy, &status);
+	gpr_$line((locx + marker_size / 2), locy, &status);
+	gpr_$move(locx, (locy + marker_size / 2), &status);
+	gpr_$line(locx, (locy - marker_size / 2), &status);
+	gpr_$set_draw_value((gpr_$pixel_value_t) 7, &status);	/* white */
+    }
+    xgpr = (short) x;
+    ygpr = (short) (GPR_YMAX - 1 - y);
+    gpr_$set_text_path(gpr_path, &status);
+    check("gpr_$set_text_path");
+
+    str_len = (short) strlen(str);
+    /* Calculate how much space (in pixels) the string requires */
+    gpr_$inq_text_extent(str, str_len, &str_size_in_pixels, &status);
+    check("in gpr_$inq_text_extent");
+
+    switch (gpr_justify) {
+    case LEFT:
+	{
+	    switch (gpr_path) {
+	    case gpr_$up:	/* vertical */
+		{
+		    if (Debug)
+			printf("LEFT and up , str=%s\n", str);
+		    break;
+		}
+	    case gpr_$right:	/* horizontal */
+		{
+		    ygpr = ygpr + str_size_in_pixels.y_size / 2;
+		    if (Debug)
+			printf("LEFT and right, str=%s \n", str);
+		    break;
+		}
+	    }
+	    break;
+	}
+
+    case CENTRE:
+	{
+	    switch (gpr_path) {
+	    case gpr_$up:	/* vertical */
+		{
+		    xgpr = xgpr + str_size_in_pixels.x_size / 2;
+		    ygpr = ygpr + str_size_in_pixels.y_size / 2;
+		    if (Debug)
+			printf("CENTRE and up, str=%s \n", str);
+		    break;
+		}
+	    case gpr_$right:	/* horizontal */
+		{
+		    xgpr = xgpr - str_size_in_pixels.x_size / 2;
+		    ygpr = ygpr + str_size_in_pixels.y_size / 2;
+		    if (Debug)
+			printf("CENTRE and right, str=%s \n", str);
+		    break;
+		}
+	    }
+	    break;
+	}
+    case RIGHT:
+	{
+	    switch (gpr_path) {
+	    case gpr_$up:	/* vertical */
+		{
+		    ygpr = ygpr + str_size_in_pixels.y_size;
+		    if (Debug)
+			printf("RIGHT and up, str=%s \n", str);
+		    break;
+		}
+	    case gpr_$right:	/* horizontal */
+		{
+		    xgpr = xgpr - str_size_in_pixels.x_size;
+		    ygpr = ygpr + str_size_in_pixels.y_size / 2;
+		    if (Debug)
+			printf("RIGHT and right, str=%s \n", str);
+		    break;
+		}
+	    }
+	    break;
+	}
+    }
+
+    gpr_$move(xgpr, ygpr, &status);
+    check("in gpr_$move");
+    gpr_$text(str, str_len, &status);
+    check("in gpr_$text");
+}
+
+TERM_PUBLIC int
+GPR_text_angle(int ang)
+{
+    if (gpr_ang != ang) {
+	gpr_ang = ang;
+	gpr_path = (gpr_ang ? gpr_$up : gpr_$right);
+    }
+    return (TRUE);
+}
+
+TERM_PUBLIC int
+GPR_justify_text(enum JUSTIFY mode)
+{
+    gpr_justify = mode;
+    return (TRUE);
+}
+
+TERM_PUBLIC void
+GPR_reset()
+{
+    gpr_$terminate(false, &status);
+    check("in gpr_$terminate");
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(gpr_driver)
+    "gpr", "Apollo Graphics Primitive Resource, fixed-size window",
+    GPR_XMAX, GPR_YMAX, GPR_VCHAR, GPR_HCHAR,
+    GPR_VTIC, GPR_HTIC, options_null, GPR_init, GPR_reset,
+    GPR_text, null_scale, GPR_graphics, GPR_move, GPR_vector,
+    GPR_linetype, GPR_put_text, GPR_text_angle,
+    GPR_justify_text, line_and_point, do_arrow, set_font_null
+TERM_TABLE_END(gpr_driver)
+
+#undef LAST_TERM
+#define LAST_TERM gpr_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(gpr)
+"1 gpr",
+"?commands set terminal gpr",
+"?set terminal gpr",
+"?set term gpr",
+"?terminal gpr",
+"?term gpr",
+"?gpr",
+" The `gpr` terminal driver supports the Apollo Graphics Primitive Resource",
+" for a fixed-size window.  It has no options.",
+"",
+" If a variable window size is desired, use the `apollo` terminal instead."
+END_HELP(gpr)
+#endif /* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/grass.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/grass.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/grass.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/grass.trm.svn-base	2012-01-03 17:07:31.006386500 -0800
@@ -0,0 +1,639 @@
+/* Hello, Emacs, this is -*-C-*- */
+/*[
+ * GNUPLOT - grass.trm
+ * $Id:
+ *-
+ * Copyright (C) 1992-1995, 1999, 2004 James Darrell McCauley
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+ *
+ * This software  is provided "as is" without express or implied warranty.
+ *
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *  GRASS graphics driver
+ *
+ * AUTHOR
+ * James Darrell McCauley, PhD        http://soils.ecn.purdue.edu/~mccauley/
+ * Dept of Agricultural Engineering   mccauley@ecn.purdue.edu
+ * Purdue University                  tel: 317.494.1198 fax: 317.496.1115
+ *
+ * 05 Apr 1995 - cleaned up code by adding explicit function declarations.
+ *               compiles clean with 'gcc -Wall'
+ * 14 Apr 1995 - adapted for new layout, added font selection
+ *
+ * 13 Jan 1999 - Copyright statement changed to new gnuplot copyright
+ *               Permission given by orig author in private email (lh)
+ *
+ * send your comments or suggestions to (grassp-list@moon.cecer.army.mil).
+ *
+]*/
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(grass)
+#endif
+
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void GRASS_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void GRASS_options __PROTO((void));
+TERM_PUBLIC void GRASS_init __PROTO((void));
+TERM_PUBLIC void GRASS_reset __PROTO((void));
+TERM_PUBLIC void GRASS_graphics __PROTO((void));
+TERM_PUBLIC void GRASS_text __PROTO((void));
+TERM_PUBLIC void GRASS_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void GRASS_linetype __PROTO((int lt));
+TERM_PUBLIC void GRASS_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC int GRASS_text_angle __PROTO((int ang));
+TERM_PUBLIC int GRASS_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC void GRASS_point __PROTO((unsigned int x, unsigned int y, int point));
+TERM_PUBLIC int GRASS_set_font __PROTO((const char *font));
+/* TERM_PUBLIC void GRASS_set_pointsize __PROTO((double size)); */
+TERM_PUBLIC void GRASS_arrow __PROTO((unsigned int sx, unsigned int sy, unsigned int ex, unsigned int ey, int head));
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+#include <stdio.h>
+#include <string.h>
+/* #include "gis.h" */ /* this causes conflicts with things in term.c */
+
+#define GRASS_XMAX 1000
+#define GRASS_YMAX 1000
+#define GRASS_VCHAR 5
+#define GRASS_HCHAR 5
+#define GRASS_VTIC 3
+#define GRASS_HTIC 3
+
+#define PNT_SIZE 3
+#define TYPE_DOT  -1
+#define TYPE_X  0
+#define TYPE_PLUS   1
+#define TYPE_BOX    2
+#define TYPE_DIAMOND    3	/* need type 4 and 5 */
+#define TYPE_TRIANGLE 4
+#define TYPE_OCTO 5
+#define TYPE_ITRIANGLE 6
+#define TYPE_FBOX 7
+#define TYPE_FTRIANGLE 8
+#define TYPE_FITRIANGLE 9
+#define TYPE_FOCTO 10
+
+static void cont_abs __PROTO((int x, int y));
+static void draw_points_dot __PROTO((int x, int y));
+static void draw_points_diamond __PROTO((int x, int y));
+static void draw_points_box __PROTO((int x, int y));
+static void draw_points_fbox __PROTO((int x, int y));
+static void draw_points_itriangle __PROTO((int x, int y));
+static void draw_points_fitriangle __PROTO((int x, int y));
+static void draw_points_triangle __PROTO((int x, int y));
+static void draw_points_ftriangle __PROTO((int x, int y));
+static void draw_points_plus __PROTO((int x, int y));
+static void draw_points_octo __PROTO((int x, int y));
+static void draw_points_focto __PROTO((int x, int y));
+static void draw_points_x __PROTO((int x, int y));
+
+static int R__curx, R__cury;
+
+static int grass_yoffset;
+static int grass_xoffset;
+static int y_max;
+static int points_buf_x[PNT_SIZE*PNT_SIZE]; /* for filled point types */
+static int points_buf_y[PNT_SIZE*PNT_SIZE];
+
+extern int R_move_abs ();
+extern int R_cont_abs ();
+
+TERM_PUBLIC void
+GRASS_move(unsigned int x, unsigned int y)
+{
+  /* R_move_abs (grass_xoffset+x, grass_yoffset-y + y_max); */
+  R_move_abs (grass_xoffset+x, grass_yoffset-y);
+}
+
+static void
+cont_abs(int x, int y)
+{
+  /* R_cont_abs (grass_xoffset+x, grass_xoffset-y + y_max); */
+  R_cont_abs (grass_xoffset+x, grass_yoffset-y);
+}
+
+TERM_PUBLIC void
+GRASS_options()
+{
+  options_null ();		/* no options to begin with */
+}
+
+TERM_PUBLIC void
+GRASS_init()
+{
+    /* char buff[128]; */
+    char window_name[64];
+    float size = 3.0;
+    /* int backcolor; */
+    int dots_per_line;
+    int top, b, l, r;
+    /* int textcolor; */
+    struct termentry *t = term;
+
+    extern int G_gisinit();
+    extern int R_open_driver();
+    extern int D_setup();
+    extern int D_get_cur_wind();
+    extern int G_fatal_error();
+    extern int D_set_cur_wind();
+    extern int D_get_screen_window();
+    extern int R_set_window();
+    extern int R_text_size();
+    extern int R_font();
+    extern int R_screen_top();
+    extern int R_screen_bot();
+    extern int D_erase_window();
+
+    G_gisinit ("g.gnuplot");
+
+    R_open_driver ();
+
+    D_setup (0);
+
+    if (D_get_cur_wind (window_name))
+	G_fatal_error ("No current window");
+
+    if (D_set_cur_wind (window_name))
+	G_fatal_error ("Current window not available");
+
+    /* Set up the screen, conversions, and graphics */
+    D_get_screen_window (&top, &b, &l, &r);
+    /* D_set_overlay_mode (1); */
+
+    /* Figure out where to put text */
+
+    R_set_window (top, b, l, r);
+    t->xmax = r-l;
+    t->ymax = b-top;
+    grass_xoffset=l;
+    grass_yoffset=b;
+
+    dots_per_line = (int) (size / 100.0 * (float) (t->ymax));
+    t->v_char = t->h_char = (int) (.8 * (float) dots_per_line);
+    R_text_size (t->h_char, t->v_char);
+    R_font("romans");
+
+    t->v_tic = t->h_tic = 4;
+
+    y_max = t->ymax; /* kludge? */
+
+    R__curx = R_screen_top ();
+    R__cury = R_screen_bot () + grass_yoffset;
+
+    D_erase_window();
+
+    fprintf(stderr,"**********************************************\n");
+    fprintf(stderr,"DIAGNOSTIC TERMINAL SETUP\n");
+    fprintf(stderr,"top = %d\tb = %d\tl = %d\tr = %d\n", top,b,l,r);
+    fprintf(stderr,"name = %s\n", t->name);
+    fprintf(stderr,"description = %s\n", t->description);
+    fprintf(stderr,"xmax = %d\t", (int)t->xmax);
+    fprintf(stderr,"ymax = %d\n", (int)t->ymax);
+    fprintf(stderr,"v_char = %d\t", (int)t->v_char);
+    fprintf(stderr,"h_char = %d\n", (int)t->h_char);
+    fprintf(stderr,"v_tic = %d\t", (int)t->v_tic);
+    fprintf(stderr,"h_tic = %d\n", (int)t->h_tic);
+    fprintf(stderr,"**********************************************\n\n");
+}
+
+TERM_PUBLIC void
+GRASS_reset ()
+{
+    extern int R_standard_color();
+    extern int D_translate_color();
+    extern int R_flush();
+    extern int R_stabilize();
+    extern int R_close_driver();
+
+    R_standard_color (D_translate_color ("black"));
+    /* D_erase_window(); .* don't clear after g.gnuplot is finished */
+    R_flush ();
+    R_stabilize ();
+    R_close_driver ();
+}
+
+TERM_PUBLIC void
+GRASS_graphics ()
+{
+    extern int D_erase_window();
+    extern int R_flush();
+    extern int R_stabilize();
+    extern int R_standard_color();
+    extern int D_translate_color();
+
+    R_flush ();
+    R_stabilize ();
+    R_standard_color (D_translate_color ("black"));
+    D_erase_window();
+    return;
+}
+
+TERM_PUBLIC void
+GRASS_text ()
+{
+    extern int R_flush ();
+    extern int R_stabilize ();
+
+    R_flush ();
+    R_stabilize ();
+    return;			/* device can't be used as a terminal */
+}
+
+TERM_PUBLIC void
+GRASS_vector(unsigned int x, unsigned int y)
+{
+    extern int R_flush ();
+    extern int R_stabilize ();
+
+    cont_abs (x, y);
+    R_flush ();
+    R_stabilize ();
+}
+
+TERM_PUBLIC void
+GRASS_linetype(int lt)
+{
+    extern int R_standard_color();
+    extern int D_translate_color();
+    extern int R_flush ();
+    extern int R_stabilize ();
+
+    while (lt > 10) lt-=10;
+
+    if (lt <= LT_BLACK)
+	R_standard_color (D_translate_color ("gray"));
+    else if (lt == LT_AXIS)
+	R_standard_color (D_translate_color ("white"));
+    else if (lt == 0)
+	R_standard_color (D_translate_color ("red"));
+    else if (lt == 1)
+	R_standard_color (D_translate_color ("green"));
+    else if (lt == 2)
+	R_standard_color (D_translate_color ("magenta"));
+    else if (lt == 3)
+	R_standard_color (D_translate_color ("brown"));
+    else if (lt == 4)
+	R_standard_color (D_translate_color ("orange"));
+    else if (lt == 5)
+	R_standard_color (D_translate_color ("yellow"));
+    else if (lt == 6)
+	R_standard_color (D_translate_color ("blue"));
+    else if (lt == 7)
+	R_standard_color (D_translate_color ("violet"));
+    else if (lt == 8)
+	R_standard_color (D_translate_color ("indigo"));
+    else if (lt == 9)
+	R_standard_color (D_translate_color ("gray"));
+    else /* if (lt == 10) */
+	R_standard_color (D_translate_color ("white"));
+    R_flush ();
+    R_stabilize ();
+    return;
+}
+
+/* originally /usr/grass4/src/display/d.label/cmd/label.c */
+
+TERM_PUBLIC void
+GRASS_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    extern int R_text();
+    extern int R_flush ();
+    extern int R_stabilize ();
+
+    if (strlen (str) == 0)
+	return;
+
+    GRASS_move (x, y);
+    /* R_standard_color (D_translate_color ("white")); */
+    R_text (str);
+    R_flush ();
+    R_stabilize ();
+}
+
+TERM_PUBLIC int
+GRASS_text_angle (int ang)
+{
+  extern int R_text_rotation();
+
+  R_text_rotation((float)ang);
+  return TRUE;			/* GRASS can (?) rotate text */
+}
+
+TERM_PUBLIC int
+GRASS_justify_text (enum JUSTIFY mode)
+{
+    return (FALSE);		/* don't mess with this now */
+}
+
+
+TERM_PUBLIC void
+GRASS_point (unsigned int x, unsigned y, int point)
+{
+    switch (point) {
+    case TYPE_DOT:
+	draw_points_dot (x, y);
+	break;
+    case TYPE_X:
+	draw_points_x (x, y);
+	break;
+    case TYPE_PLUS:
+	draw_points_plus (x, y);
+	break;
+    case TYPE_BOX:
+	draw_points_box (x, y);
+	break;
+    case TYPE_DIAMOND:
+	draw_points_diamond (x, y);
+	break;
+    case TYPE_TRIANGLE:
+	draw_points_triangle (x, y);
+	break;
+    case TYPE_OCTO:
+	draw_points_octo (x, y);
+	break;
+    case TYPE_ITRIANGLE:
+	draw_points_itriangle (x, y);
+	break;
+    case TYPE_FBOX:
+	draw_points_fbox (x, y);
+	break;
+    case TYPE_FTRIANGLE:
+	draw_points_ftriangle (x, y);
+	break;
+    case TYPE_FITRIANGLE:
+	draw_points_fitriangle (x, y);
+	break;
+    case TYPE_FOCTO:
+	draw_points_focto (x, y);
+	break;
+    }
+}
+
+/* modified from /usr/grass4/src/display/d.points/cmd/main.c */
+
+static void
+draw_points_dot(int x, int y)
+{
+  GRASS_move (x, y);
+  cont_abs (x, y);
+}
+
+static void
+draw_points_diamond(int x, int y)
+{
+  GRASS_move (x, y + PNT_SIZE);
+  GRASS_vector (x + PNT_SIZE, y);
+  GRASS_vector (x, y - PNT_SIZE);
+  GRASS_vector (x - PNT_SIZE, y);
+  GRASS_vector (x, y + PNT_SIZE);
+}
+
+static void
+draw_points_box(int x, int y)
+{
+  GRASS_move (x - PNT_SIZE, y - PNT_SIZE);
+  GRASS_vector (x - PNT_SIZE, y + PNT_SIZE);
+  GRASS_vector (x + PNT_SIZE, y + PNT_SIZE);
+  GRASS_vector (x + PNT_SIZE, y - PNT_SIZE);
+  GRASS_vector (x - PNT_SIZE, y - PNT_SIZE);
+}
+
+static void
+draw_points_fbox(int x, int y)
+{
+  int R_polygon_abs();
+  points_buf_x[0] = grass_xoffset + x - PNT_SIZE;
+  points_buf_y[0]= grass_yoffset - (y + PNT_SIZE);
+  points_buf_x[1] = grass_xoffset + x + PNT_SIZE;
+  points_buf_y[1]= grass_yoffset - (y + PNT_SIZE);
+  points_buf_x[2] = grass_xoffset + x + PNT_SIZE;
+  points_buf_y[2]= grass_yoffset - (y - PNT_SIZE);
+  points_buf_x[3] = grass_xoffset + x - PNT_SIZE;
+  points_buf_y[3]= grass_yoffset - (y - PNT_SIZE);
+  R_polygon_abs(points_buf_x, points_buf_y, 4 );
+}
+
+static void
+draw_points_itriangle(int x, int y)
+{
+  GRASS_move (x - PNT_SIZE, y + PNT_SIZE);
+  GRASS_vector (x + PNT_SIZE, y + PNT_SIZE);
+  GRASS_vector (x , y - PNT_SIZE);
+  GRASS_vector (x - PNT_SIZE, y + PNT_SIZE);
+}
+
+static void
+draw_points_fitriangle(int x, int y)
+{
+  int R_polygon_abs();
+
+  points_buf_x[0] = grass_xoffset + x + PNT_SIZE;
+  points_buf_y[0] = grass_yoffset - (y + PNT_SIZE);
+  points_buf_x[1] = grass_xoffset + x ;
+  points_buf_y[1] = grass_yoffset - (y - PNT_SIZE);
+  points_buf_x[2] = grass_xoffset + x - PNT_SIZE;
+  points_buf_y[2] = grass_yoffset - (y + PNT_SIZE);
+  R_polygon_abs(points_buf_x, points_buf_y, 3 );
+}
+
+static void
+draw_points_triangle(int x, int y)
+{
+  GRASS_move (x - PNT_SIZE, y - PNT_SIZE);
+  GRASS_vector (x , y + PNT_SIZE);
+  GRASS_vector (x + PNT_SIZE, y - PNT_SIZE);
+  GRASS_vector (x - PNT_SIZE, y - PNT_SIZE);
+}
+
+static void
+draw_points_ftriangle(int x, int y)
+{
+  int R_polygon_abs();
+
+  points_buf_x[0] = grass_xoffset + x;
+  points_buf_y[0]= grass_yoffset - (y + PNT_SIZE);
+  points_buf_x[1] = grass_xoffset + x + PNT_SIZE;
+  points_buf_y[1]= grass_yoffset - (y - PNT_SIZE);
+  points_buf_x[2] = grass_xoffset + x - PNT_SIZE;
+  points_buf_y[2]= grass_yoffset - (y - PNT_SIZE);
+  R_polygon_abs(points_buf_x, points_buf_y, 3 );
+}
+
+static void
+draw_points_plus(int x, int y)
+{
+  GRASS_move (x - PNT_SIZE, y);
+  GRASS_vector (x + PNT_SIZE, y);
+  GRASS_move (x, y - PNT_SIZE);
+  GRASS_vector (x, y + PNT_SIZE);
+}
+
+/* depends on PNT_SIZE */
+static void
+draw_points_octo(int x, int y)
+{
+  /* CCW */
+  GRASS_move (x - (int) (PNT_SIZE/3), y - PNT_SIZE);   /* 1 */
+  GRASS_vector (x + (int) (PNT_SIZE/3), y - PNT_SIZE); /* 2 */
+  GRASS_vector (x + PNT_SIZE, y - (int) (PNT_SIZE/3)); /* 3 */
+  GRASS_vector (x + PNT_SIZE, y + (int) (PNT_SIZE/3)); /* 4 */
+  GRASS_vector (x + (int) (PNT_SIZE/3), y + PNT_SIZE); /* 5 */
+  GRASS_vector (x - (int) (PNT_SIZE/3), y + PNT_SIZE); /* 6 */
+  GRASS_vector (x - PNT_SIZE, y + (int) (PNT_SIZE/3)); /* 7 */
+  GRASS_vector (x - PNT_SIZE, y - (int) (PNT_SIZE/3)); /* 8 */
+  GRASS_vector (x - (int) (PNT_SIZE/3), y - PNT_SIZE); /* 1 */
+}
+
+/* depends on PNT_SIZE */
+static void
+draw_points_focto(int x, int y)
+{
+  int R_polygon_abs();
+
+  /* CCW */
+  points_buf_x[0] = grass_xoffset + x + (int) (PNT_SIZE/3);
+  points_buf_y[0] = grass_yoffset - (y - PNT_SIZE);
+  points_buf_x[1] = grass_xoffset + x + PNT_SIZE;
+  points_buf_y[1] = grass_yoffset - (y - (int) (PNT_SIZE/3));
+  points_buf_x[2] = grass_xoffset + x + PNT_SIZE;
+  points_buf_y[2] = grass_yoffset - (y + (int) (PNT_SIZE/3));
+  points_buf_x[3] = grass_xoffset + x + (int) (PNT_SIZE/3);
+  points_buf_y[3] = grass_yoffset - (y + PNT_SIZE);
+  points_buf_x[4] = grass_xoffset + x - (int) (PNT_SIZE/3);
+  points_buf_y[4] = grass_yoffset - (y + PNT_SIZE);
+  points_buf_x[5] = grass_xoffset + x - PNT_SIZE;
+  points_buf_y[5] = grass_yoffset - (y + (int) (PNT_SIZE/3));
+  points_buf_x[6] = grass_xoffset + x - PNT_SIZE;
+  points_buf_y[6] = grass_yoffset - (y - (int) (PNT_SIZE/3));
+  points_buf_x[7] = grass_xoffset + x - (int) (PNT_SIZE/3);
+  points_buf_y[7] = grass_yoffset - (y - PNT_SIZE);
+  R_polygon_abs(points_buf_x, points_buf_y, 8 );
+}
+
+static void
+draw_points_x(int x, int y)
+{
+  GRASS_move (x - PNT_SIZE, y - PNT_SIZE);
+  GRASS_vector (x + PNT_SIZE, y + PNT_SIZE);
+  GRASS_move (x + PNT_SIZE, y - PNT_SIZE);
+  GRASS_vector (x - PNT_SIZE, y + PNT_SIZE);
+}
+
+TERM_PUBLIC int
+GRASS_set_font(const char *font)
+{
+  char name[32];
+  int size,sep, R_font();
+  struct termentry *t = term;
+  int R_text_size (), dots_per_line;
+
+  /* G_warning(font); */
+
+  sep=strcspn(font,",");
+  strncpy(name,font,sep); name[sep]=NUL;
+  sscanf (&(font[sep+1]),"%d",&size);
+
+  if (size==0)
+    size=3;
+  dots_per_line = (int) (size / 100.0 * (float) (t->ymax));
+  t->v_char = t->h_char = (int) (.8 * (float) dots_per_line);
+  R_text_size (t->h_char, t->v_char);
+/* cyrilc,gothgbt,gothgrt,gothitt,greekc,greekcs,greekp,
+greeks,italicc,italiccs,italict,romanc,romancs,romand,
+romans,romant,scriptc,scripts */
+
+  if (strlen(name) > 5 )
+    R_font(name);
+  else
+    R_font("romans");
+  return TRUE;
+}
+
+#ifdef GRASS_POINTSIZE
+/* HBB FIXME 20040619: argument type wrong, but luckily unused anyway... */
+TERM_PUBLIC void
+GRASS_set_pointsize(double *size)
+{
+  return;
+}
+#endif /* GRASS_POINTSIZE */
+
+/* need to fix */
+TERM_PUBLIC void
+GRASS_arrow(
+    unsigned int sx, unsigned int sy,
+    unsigned int ex, unsigned int ey,
+    int head)
+{
+  do_arrow (sx, sy, ex, ey, 1);
+  return;
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+TERM_TABLE_START(grass_driver)
+    "grass", "GRASS Graphics Monitor",
+    GRASS_XMAX, GRASS_YMAX, GRASS_VCHAR, GRASS_HCHAR,
+    GRASS_VTIC, GRASS_HTIC, GRASS_options, GRASS_init, GRASS_reset,
+    GRASS_text, null_scale, GRASS_graphics, GRASS_move, GRASS_vector,
+    GRASS_linetype, GRASS_put_text, GRASS_text_angle,
+    GRASS_justify_text, GRASS_point, GRASS_arrow, GRASS_set_font
+TERM_TABLE_END(grass_driver)
+
+
+#undef LAST_TERM
+#define LAST_TERM grass_driver
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+
+#ifdef TERM_HELP
+START_HELP(grass)
+"1 grass",
+"?commands set terminal grass",
+"?set terminal grass",
+"?set term grass",
+"?terminal grass",
+"?term grass",
+"?grass",
+" The `grass` terminal driver gives `gnuplot` capabilities to users of the ",
+" GRASS geographic information system.  Contact grassp-list@moon.cecer.army.mil",
+" for more information.  Pages are written to the current frame of the GRASS",
+" Graphics Window.  There are no options."
+END_HELP(grass)
+#endif
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/hp26.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/hp26.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/hp26.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/hp26.trm.svn-base	2012-01-03 17:07:31.203898700 -0800
@@ -0,0 +1,704 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: hp26.trm,v 1.19 2007/01/16 23:11:55 sfeam Exp $
+ */
+
+/* GNUPLOT - HP26.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *  HP2623A
+ *
+ * AUTHORS
+ *   luecken@udel.edu (Bruce Lueckenhoff)
+ *   hplvlch!ch (Chuck Heller)
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+
+/*
+ * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(hp2623a)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void HP26_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void HP26_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void HP26_init __PROTO((void));
+TERM_PUBLIC void HP26_graphics __PROTO((void));
+TERM_PUBLIC void HP26_text __PROTO((void));
+TERM_PUBLIC void HP26_reset __PROTO((void));
+TERM_PUBLIC int HP26_text_angle __PROTO((int ang));
+TERM_PUBLIC void HP26_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC void HP26_linetype __PROTO((int linetype));
+TERM_PUBLIC void HP26_line_and_point __PROTO((unsigned int x, unsigned int y, int number));
+
+#define HP26_XMAX 512
+#define HP26_YMAX 390
+
+/* Use a size 1 character, or a 7 x 10 grid. */
+#define HP26_VCHAR	10
+#define HP26_HCHAR	7
+#define HP26_VTIC	5
+#define HP26_HTIC	5
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+#define HP26_XLAST (HP26_XMAX - 1)
+#define HP26_YLAST (HP26_XMAX - 1)
+
+static void HP26_do_point __PROTO((unsigned int x, unsigned int y, int number));
+static struct _HP26_Buffer_Node *BN_create __PROTO((int index, int size, int linetype));
+static void BN_delete __PROTO((struct _HP26_Buffer_Node * the_node));
+static int HP26_flush __PROTO((struct _HP26_Buffer_Node * the_buff));
+static void HP26_handle_overflow __PROTO((void));
+
+typedef struct _HP26_Buffer_Node {
+    int index;
+    int size;
+    int next;
+    int linetype;
+    int *x;
+    int *y;
+    TBOOLEAN *isa_move;
+} HP26_Buffer_Node;
+
+/* constructor method */
+static HP26_Buffer_Node *
+BN_create(int index, int size, int linetype)
+{
+    HP26_Buffer_Node *the_node;
+    the_node = (HP26_Buffer_Node *) gp_alloc(sizeof(HP26_Buffer_Node), "HP26");
+    if (the_node) {
+	the_node->index = index;
+	the_node->linetype = linetype;
+	the_node->size = size;
+	the_node->next = 0;
+	the_node->x = (int *) gp_alloc(size*sizeof(int), "HP26");
+	the_node->y = (int *) gp_alloc(size*sizeof(int), "HP26");
+	the_node->isa_move = (TBOOLEAN *) gp_alloc(size*sizeof(TBOOLEAN), "HP26");
+	if (the_node->x == NULL || the_node->y == NULL || the_node->isa_move == NULL)
+	    return (NULL);
+    }
+    memset(the_node->isa_move, 0, size*sizeof(TBOOLEAN));
+    return (the_node);
+}
+
+/* destructor method */
+static void
+BN_delete(HP26_Buffer_Node *the_node)
+{
+    free(the_node->x);
+    free(the_node->y);
+    free(the_node->isa_move);
+    free(the_node);
+}
+
+/* 2 for border and axes + 9 for plots + 1 for dots */
+#define HP26_gnu_map_size 12
+static HP26_Buffer_Node *HP26_gnu_map[HP26_gnu_map_size];
+static HP26_Buffer_Node *HP26_buff;
+static int HP26_pen_x;
+static int HP26_pen_y;
+static int HP26_angle;
+static int HP26_cursor_x;
+static int HP26_cursor_y;
+static TBOOLEAN HP26_in_text;
+static int HP26_linetype_current;
+static int HP26_reduction_int;
+static int HP26_reduction_slope;
+static int HP26_overflows;
+static int HP26_nop_move;
+static int HP26_nop_vect;
+static int HP26_nop_line;
+
+/* linetype stuff */
+#define	SOLID	1
+#define	USER	2
+#define LINE3	3
+#define LINE4	4
+#define LINE5	5
+#define LINE6	6
+#define	DOTS	7
+#define LINE8	8
+#define LINE9	9
+#define LINE10	10
+#define POINT	11
+
+
+
+#define swap(a, b) a ^= b; b ^= a; a ^= b;
+
+static char HP26_bin_short_table[32] =
+{
+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>',
+    '?', ' ', '!', '"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-',
+    '.', '/'
+};
+/* encodes an integer (assumed to be in range) into
+   binary short incremental format (j)*/
+#define short_encode(n) (HP26_bin_short_table[n+16])
+
+/* tells whether a given delta_x,delta_y pair can be expressed in
+   binary short incremental format */
+#define qualified(dx,dy) ((dx>-17)&&(dy>-17)&&(dx<16)&&(dy<16))
+
+
+static char HP26_bin_table[32] =
+{
+    ' ', '!', '"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-',
+    '.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<',
+    '=', '>', '?'
+};
+/* returns the high byte of integer n in binary absolute format (i) */
+#define bin_encode_hi(n) (HP26_bin_table[n>>5])
+/* returns the low byte of integer n in binary absolute format (i) */
+#define bin_encode_lo(n) (HP26_bin_table[n & 31])
+
+
+
+/* the guts of the program
+-- first checks if any work need be done and, failing that, returns
+	immediately
+-- tries to compress the vector stream
+-- goes through the buffer, using binary short incremental (2 bytes/point)
+	as much as possible, even if must output two pairs to express one vector
+	(it's no more expensive, and will hopefully damp any excessive switching
+	back and forth between the two formats)
+	if can't use binary short incremental, use binary
+	absolute(4 bytes/point)
+-- finally, resets the HP26_next pointer to zero    */
+static int
+HP26_flush(HP26_Buffer_Node *the_buff)
+{
+    int i, delta_x, delta_y, half_dx, half_dy;
+    int *buff_x, *buff_y;
+    TBOOLEAN *isa_move;
+    TBOOLEAN bin_short;
+
+    if (the_buff->next == 0)
+	return (FALSE);
+    /* init pointers for easy access */
+    buff_x = the_buff->x;
+    buff_y = the_buff->y;
+    isa_move = the_buff->isa_move;
+    if (HP26_in_text) {
+	fputs("\033*dT", gpoutfile);
+	HP26_in_text = FALSE;
+    }
+    if (HP26_linetype_current != the_buff->linetype
+	&& (the_buff->next > 1 || !isa_move[0])) {
+	fprintf(gpoutfile, "\033*m%dB", the_buff->linetype);
+	HP26_linetype_current = the_buff->linetype;
+    }
+
+    /* start escape sequence */
+    fputs("\033*p", gpoutfile);
+    /* initialize the state:  binary short incremental or binary absolute */
+    delta_x = buff_x[0] - HP26_pen_x;
+    delta_y = buff_y[0] - HP26_pen_y;
+    if (qualified(delta_x, delta_y)) {
+	fputc('j', gpoutfile);
+	bin_short = TRUE;
+    } else {
+	fputc('i', gpoutfile);
+	bin_short = FALSE;
+    }
+    /* now work through the list */
+    for (i = 0; i < the_buff->next; i++) {
+	if (i > 0) {
+	    delta_x = buff_x[i] - buff_x[i - 1];
+	    delta_y = buff_y[i] - buff_y[i - 1];
+	}
+	if ((delta_x == 0) && (delta_y == 0)) {
+	    if (i > 0 && !isa_move[i - 1] && !isa_move[i]) {
+		/* allow null vectors only when drawing dots */
+		HP26_nop_vect++;
+		continue;
+	    } else if (isa_move[i]) {
+		/* a null move */
+		HP26_nop_move++;
+		continue;
+	    }
+	} else if (i > 0
+		   && i + 1 < the_buff->next
+		   && isa_move[i]
+		   && isa_move[i + 1]) {
+	    /* consecutive moves are condensed into one */
+	    HP26_nop_move++;
+	    continue;
+	} else if (!qualified(delta_x, delta_y)
+		   && i > 0
+		   && i + 2 < the_buff->next
+		   && isa_move[i]
+		   && !isa_move[i + 1]
+		   && isa_move[i + 2]
+		   && qualified(buff_x[i + 1] - buff_x[i - 1], buff_y[i + 1] - buff_y[i - 1])) {
+	    swap(buff_x[i], buff_x[i + 1]);
+	    swap(buff_y[i], buff_y[i + 1]);
+	    /* set up new delta_x & delta_y */
+	    delta_x = buff_x[i] - buff_x[i - 1];
+	    delta_y = buff_y[i] - buff_y[i - 1];
+	}
+	if (qualified(delta_x, delta_y)) {
+	    if (!bin_short) {
+		fputc('j', gpoutfile);
+		bin_short = TRUE;
+	    }
+	    if (isa_move[i])
+		fputc('a', gpoutfile);
+	    fputc(short_encode(delta_x), gpoutfile);
+	    fputc(short_encode(delta_y), gpoutfile);
+	} else {
+	    half_dx = (delta_x + (delta_x > 0 ? 1 : -1)) / 2;
+	    half_dy = (delta_y + (delta_y > 0 ? 1 : -1)) / 2;
+	    if (bin_short && qualified(half_dx, half_dy)) {
+		if (isa_move[i])
+		    fputc('a', gpoutfile);
+		fputc(short_encode(half_dx), gpoutfile);
+		fputc(short_encode(half_dy), gpoutfile);
+		if (isa_move[i])
+		    fputc('a', gpoutfile);
+		fputc(short_encode(delta_x - half_dx), gpoutfile);
+		fputc(short_encode(delta_y - half_dy), gpoutfile);
+	    } else {
+		if (bin_short) {
+		    bin_short = FALSE;
+		    fputc('i', gpoutfile);
+		}
+		if (isa_move[i])
+		    fputc('a', gpoutfile);
+		fputc(bin_encode_hi(buff_x[i]), gpoutfile);
+		fputc(bin_encode_lo(buff_x[i]), gpoutfile);
+		fputc(bin_encode_hi(buff_y[i]), gpoutfile);
+		fputc(bin_encode_lo(buff_y[i]), gpoutfile);
+	    }
+	}
+    }				/* end for.. */
+    /* the term doesn't seem to mind leaving this out */
+    /* finish the escape sequence */
+    fputc('Z', gpoutfile);
+    /* set these for next time */
+    HP26_pen_x = buff_x[the_buff->next - 1];
+    HP26_pen_y = buff_y[the_buff->next - 1];
+    the_buff->next = 0;
+    return (TRUE);
+}
+
+static void
+HP26_handle_overflow()
+{
+    HP26_Buffer_Node *bigger, *old;
+    int x, y;
+    x = (HP26_buff->x)[HP26_buff->next - 1];
+    y = (HP26_buff->y)[HP26_buff->next - 1];
+    HP26_flush(HP26_buff);
+    bigger = BN_create(HP26_buff->index, HP26_buff->size * 2,
+		       HP26_buff->linetype);
+    if (bigger != NULL) {
+	old = HP26_buff;
+	HP26_gnu_map[bigger->index] = bigger;
+	/* special case since DOTS entry is shared 3 ways */
+	if (bigger->index == 0) {
+	    HP26_gnu_map[1] = bigger;
+	    HP26_gnu_map[3] = bigger;
+	}
+	HP26_buff = bigger;
+	BN_delete(old);
+    }
+    (HP26_buff->x)[0] = x;
+    (HP26_buff->y)[0] = y;
+    (HP26_buff->isa_move)[0] = TRUE;
+    HP26_buff->next = 1;
+    HP26_overflows++;
+}
+
+/* checks for NOP, overcapacity condition, and then adds vector to the list */
+TERM_PUBLIC void
+HP26_vector(unsigned int x, unsigned int y)
+{
+    if (HP26_buff->next > 2
+	&& x == (HP26_buff->x)[HP26_buff->next - 1]
+	&& y == (HP26_buff->y)[HP26_buff->next - 1]
+	&& !(HP26_buff->isa_move)[HP26_buff->next - 1]) {
+	HP26_nop_vect++;
+	return;
+    }
+    if (HP26_buff->next == HP26_buff->size)
+	HP26_handle_overflow();
+    /* otherwise add to the list */
+    (HP26_buff->x)[HP26_buff->next] = x;
+    (HP26_buff->y)[HP26_buff->next] = y;
+    (HP26_buff->isa_move)[HP26_buff->next] = FALSE;
+    HP26_buff->next++;
+}
+
+/* checks for NOP, checks for overcapacity, puts self on list */
+TERM_PUBLIC void
+HP26_move(unsigned int x, unsigned int y)
+{
+    if (HP26_buff->next > 0) {
+	if (((HP26_buff->x)[HP26_buff->next - 1] == x)
+	    && ((HP26_buff->y)[HP26_buff->next - 1] == y)) {
+	    /* null moves are NOP's */
+	    HP26_nop_move++;
+	    return;
+	} else if ((HP26_buff->isa_move)[HP26_buff->next - 1]) {
+	    /* consecutive moves are NOP's */
+	    (HP26_buff->x)[HP26_buff->next - 1] = x;
+	    (HP26_buff->y)[HP26_buff->next - 1] = y;
+	    HP26_nop_move++;
+	    return;
+	}
+    }
+    if (HP26_buff->next == HP26_buff->size)
+	HP26_handle_overflow();
+    (HP26_buff->x)[HP26_buff->next] = x;
+    (HP26_buff->y)[HP26_buff->next] = y;
+    (HP26_buff->isa_move)[HP26_buff->next] = TRUE;
+    HP26_buff->next++;
+    return;
+}
+
+TERM_PUBLIC void
+HP26_init()
+{
+    HP26_gnu_map[-2 + 2] = BN_create(0, 2048, DOTS);	/* border */
+    HP26_gnu_map[-1 + 2] = HP26_gnu_map[-2 + 2];	/* axes */
+    HP26_gnu_map[0 + 2] = BN_create(2, 3072, SOLID);	/* plot 0 */
+    HP26_gnu_map[1 + 2] = HP26_gnu_map[-2 + 2];		/* plot 1 */
+    HP26_gnu_map[2 + 2] = BN_create(4, 1024, LINE5);	/* plot 2 */
+    HP26_gnu_map[3 + 2] = BN_create(5, 256, LINE6);	/* plot 3 */
+    HP26_gnu_map[4 + 2] = BN_create(6, 256, LINE8);	/* plot 4 */
+    HP26_gnu_map[5 + 2] = BN_create(7, 128, LINE9);	/* plot 5 */
+    HP26_gnu_map[6 + 2] = BN_create(8, 128, LINE10);	/* plot 6 */
+    HP26_gnu_map[7 + 2] = BN_create(9, 64, LINE6);	/* plot 7 */
+    HP26_gnu_map[8 + 2] = BN_create(10, 64, LINE4);	/* plot 8 */
+    HP26_gnu_map[9 + 2] = BN_create(11, 512, POINT);	/* point plot */
+    HP26_buff = HP26_gnu_map[10];	/* set to an unlikely linetype */
+    HP26_linetype_current = 0;	/* set to force a linetype change */
+    HP26_angle = 1;		/* left to right, default */
+    fputs("\033*mp1m2a2Q", gpoutfile);
+    /*           1 2 3 4
+       1.  make text upright
+       2.  select text size 1
+       3.  make SET the default drawing op
+       4.  left justify text */
+    fflush(gpoutfile);
+}
+
+
+TERM_PUBLIC void
+HP26_graphics()
+{
+    fputs("\033*daflsC", gpoutfile);
+    /*           12345
+       1.  clear graphics display
+       2.  shut off the alphanumeric display
+       3.  graphics cursor off
+       4.  into graphics text mode
+       5.  enable graphics display */
+    /* set the pen & cursor positions to force an initial absolute move */
+    HP26_pen_x = HP26_pen_y = -200;
+    HP26_cursor_x = HP26_cursor_y = 800;
+    HP26_in_text = TRUE;
+    /* initialize statistics */
+    HP26_reduction_int = 0;
+    HP26_reduction_slope = 0;
+    HP26_nop_move = 0;
+    HP26_nop_vect = 0;
+    HP26_nop_line = 0;
+    HP26_overflows = 0;
+}
+
+
+TERM_PUBLIC void
+HP26_text()
+{
+    int i, j, curr;
+
+    /* always flush the current line first */
+    for (i = 0; i < HP26_gnu_map_size; i++)
+	if ((HP26_gnu_map[i])->linetype == HP26_linetype_current)
+	    HP26_flush(HP26_gnu_map[i]);
+    /* now flush the rest of the lines */
+    for (i = 0; i < HP26_gnu_map_size; i++) {
+	HP26_flush(HP26_gnu_map[i]);
+	curr = HP26_gnu_map[i]->linetype;
+	for (j = 0; j < HP26_gnu_map_size; j++)
+	    if ((HP26_gnu_map[j])->linetype == curr)
+		HP26_flush(HP26_gnu_map[j]);
+    }
+    fputs("\033*deT", gpoutfile);
+    /*           12
+       1. turn on the alphanumeric display
+       2. back to text mode */
+    fflush(gpoutfile);
+    /* informational:  tells how many points compressed, how
+       many NOP's of each type, and how many times a buffer
+       overflowed during this plot */
+    /*
+       if(HP26_reduction_int
+       + HP26_reduction_slope
+       + HP26_nop_move
+       + HP26_nop_vect
+       + HP26_overflows
+       + HP26_nop_line > 0){
+       if (HP26_reduction_int>0)
+       printf("%d int-compress",HP26_reduction_int);
+       if (HP26_reduction_slope>0)
+       printf("%d slope-compress",HP26_reduction_slope);
+       if (HP26_nop_move>0)
+       printf("  %d nop_move",HP26_nop_move);
+       if (HP26_nop_vect>0)
+       printf("  %d nop_vect",HP26_nop_vect);
+       if (HP26_nop_line>0)
+       printf("  %d nop_line",HP26_nop_line);
+       if (HP26_overflows>0)
+       printf("  %d buffer overflows",HP26_overflows);
+       printf("\n");
+       }
+     */
+}
+
+TERM_PUBLIC void
+HP26_reset()
+{
+    int i;
+    for (i = 2; i < HP26_gnu_map_size; i++)
+	BN_delete(HP26_gnu_map[i]);
+}
+
+TERM_PUBLIC int
+HP26_text_angle(int ang)
+{
+    HP26_angle = (ang ? 2 : 1);
+    fprintf(gpoutfile, "\033*m%dN", HP26_angle);
+    return (TRUE);
+}
+
+
+TERM_PUBLIC void
+HP26_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    char abs_str[10], rel_str[10];
+
+    if (!strlen(str))
+	return;
+    else {
+	fputs("\033*d", gpoutfile);
+	if (!HP26_in_text) {
+	    fputc('s', gpoutfile);
+	    HP26_in_text = TRUE;
+	}
+	sprintf(rel_str, "%d,%dP", x - HP26_cursor_x, y - HP26_cursor_y);
+	sprintf(abs_str, "%d,%dO", x, y);
+	if (strlen(rel_str) < strlen(abs_str))
+	    fputs(rel_str, gpoutfile);
+	else
+	    fputs(abs_str, gpoutfile);
+	fputs(str, gpoutfile);
+	HP26_pen_x = HP26_cursor_x = x;
+	HP26_pen_y = HP26_cursor_y = y;
+    }
+    /*
+       tmp = &(HP26_all_buffers[HP26_linetype_current]);
+       tmp->x[tmp->next] = x;
+       tmp->y[tmp->next] = y;
+       tmp->isa_move[tmp->next] = TRUE;
+       tmp->next++;
+       HP26_flush(tmp);
+       fprintf(gpoutfile,"\033*l%s\r",str);
+     */
+    return;
+}
+
+
+/* checks for NOP, sets HP26_buff to point to the right buffer */
+TERM_PUBLIC void
+HP26_linetype(int linetype)
+{
+    if (linetype < -2)
+	linetype = LT_BLACK;
+    if (linetype > 8)
+	linetype %= 9;
+    linetype += 2;
+    if (HP26_gnu_map[linetype] == HP26_buff) {
+	HP26_nop_line++;
+	return;			/* gnuplot just sent us another NOP */
+    }
+    HP26_buff = HP26_gnu_map[linetype];
+}
+
+
+
+/* switches to a solid linetype and calls do_point, then switches back */
+TERM_PUBLIC void
+HP26_line_and_point(unsigned int x, unsigned int y, int number)
+{
+    int line_save, not_solid;
+
+    /* shut up warnings with dummy initializer  -SB */
+    line_save = 0;
+    not_solid = (HP26_buff->linetype != SOLID);
+    if (not_solid) {
+	line_save = HP26_buff->linetype;
+	HP26_linetype(0);	/*switch to a solid line */
+    }
+    HP26_do_point(x, y, number);
+    if (not_solid)
+	HP26_linetype(line_save);
+}
+
+
+/* provides 9 point types so they stay in sync with the linetypes
+puts simpler point types first on the assumption they are more
+frequently used */
+static void
+HP26_do_point(unsigned int x, unsigned int y, int number)
+{
+    int htic, vtic;
+    HP26_Buffer_Node *tmp;
+
+    vtic = HP26_VTIC / 2;
+    htic = HP26_HTIC / 2;
+    if (number < 0) {
+	/* do a dot -- special case */
+	tmp = HP26_buff;
+	HP26_buff = HP26_gnu_map[11];	/* point plot */
+	HP26_vector(x, y);
+	HP26_buff = tmp;
+    }
+    switch (number % 9) {
+    case 0:
+	/* do triangle */
+	HP26_move(x - htic, y - vtic);
+	HP26_vector(x, y + vtic);
+	HP26_vector(x + htic, y - vtic);
+	HP26_vector(x - htic, y - vtic);
+	break;
+    case 1:
+	/* do nambla */
+	HP26_move(x - htic, y + vtic);
+	HP26_vector(x, y - vtic);
+	HP26_vector(x + htic, y + vtic);
+	HP26_vector(x - htic, y + vtic);
+	break;
+    case 2:
+	/* do left triangle */
+	HP26_move(x - htic, y);
+	HP26_vector(x + htic, y + vtic);
+	HP26_vector(x + htic, y - vtic);
+	HP26_vector(x - htic, y);
+	break;
+    case 3:
+	/* do right triangle */
+	HP26_move(x + htic, y);
+	HP26_vector(x - htic, y + vtic);
+	HP26_vector(x - htic, y - vtic);
+	HP26_vector(x + htic, y);
+	break;
+    case 4:
+	/* do box */
+	HP26_move(x - htic, y - vtic);
+	HP26_vector(x - htic, y + vtic);
+	HP26_vector(x + htic, y + vtic);
+	HP26_vector(x + htic, y - vtic);
+	HP26_vector(x - htic, y - vtic);
+	break;
+    case 5:
+	/* do plus */
+	HP26_move(x, y + vtic);
+	HP26_vector(x, y - vtic);
+	HP26_move(x - htic, y);
+	HP26_vector(x + htic, y);
+	break;
+    case 6:
+	/* do X */
+	HP26_move(x + htic, y + vtic);
+	HP26_vector(x - htic, y - vtic);
+	HP26_move(x - htic, y + vtic);
+	HP26_vector(x + htic, y - vtic);
+	break;
+    default:
+	/* do diamond */
+	HP26_move(x, y - vtic);
+	HP26_vector(x - htic, y);
+	HP26_vector(x, y + vtic);
+	HP26_vector(x + htic, y);
+	HP26_vector(x, y - vtic);
+	break;
+    }
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(hp2623a_driver)
+    "hp2623A", "HP2623A and maybe others",
+    HP26_XMAX, HP26_YMAX, HP26_VCHAR, HP26_HCHAR,
+    HP26_VTIC, HP26_HTIC, options_null, HP26_init, HP26_reset,
+    HP26_text, null_scale, HP26_graphics, HP26_move, HP26_vector,
+    HP26_linetype, HP26_put_text, HP26_text_angle,
+    null_justify_text, HP26_line_and_point, do_arrow, set_font_null
+TERM_TABLE_END(hp2623a_driver)
+
+#undef LAST_TERM
+#define LAST_TERM hp2623a_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(hp2623a)
+"1 hp2623a",
+"?commands set terminal hp2623a",
+"?set terminal hp2623a",
+"?set term hp2623a",
+"?terminal hp2623a",
+"?term hp2623a",
+"?hp2623a",
+" The `hp2623a` terminal driver supports the Hewlett Packard HP2623A.  It has",
+" no options."
+END_HELP(hp2623a)
+#endif
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/hp2648.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/hp2648.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/hp2648.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/hp2648.trm.svn-base	2012-01-03 17:07:31.459561700 -0800
@@ -0,0 +1,201 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: hp2648.trm,v 1.13 2006/07/21 02:35:47 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT -  hp2648.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *  HP2648 and HP2647
+ *
+ * AUTHORS
+ *  Russell Lang
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+
+/*
+ * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(hp2648)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void HP2648init __PROTO((void));
+TERM_PUBLIC void HP2648graphics __PROTO((void));
+TERM_PUBLIC void HP2648text __PROTO((void));
+TERM_PUBLIC void HP2648linetype __PROTO((int linetype));
+TERM_PUBLIC void HP2648move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void HP2648vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void HP2648put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC int HP2648_text_angle __PROTO((int ang));
+TERM_PUBLIC void HP2648reset __PROTO((void));
+
+#define HP2648XMAX 720
+#define HP2648YMAX 360
+
+#define HP2648VCHAR		12
+#define HP2648HCHAR		7
+#define HP2648VTIC		8
+#define HP2648HTIC		8
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+#define HP2648XLAST (HP2648XMAX - 1)
+#define HP2648YLAST (HP2648YMAX - 1)
+
+
+TERM_PUBLIC void
+HP2648init()
+{
+    fprintf(gpoutfile, "\033*m1m1n136,1cZ");
+/*                   1     2 3     4
+	1. mode
+	2. textsize=1
+	3. textangle=1
+        4. define line type 2 to be *   *   *   * etc.
+*/
+}
+
+
+TERM_PUBLIC void
+HP2648graphics()
+{
+    fprintf(gpoutfile, "\033*dacZ");
+/*                   1     23
+	1. mode
+	2. clear grahics screen
+	3. graphics video on
+*/
+}
+
+
+TERM_PUBLIC void
+HP2648text()
+{
+}
+
+
+TERM_PUBLIC void
+HP2648linetype(int linetype)
+{
+    static int hpline[] = { 1, 7, 1, 4, 5, 6, 8, 9, 10, 7, 2 };
+    fprintf(gpoutfile, "\033*m%dbZ", hpline[(linetype + 2) % 11]);
+}
+
+
+TERM_PUBLIC void
+HP2648move(unsigned int x, unsigned int y)
+{
+    fprintf(gpoutfile, "\033*paf%d,%dZ", x, y);
+    /*               1     23     4
+       1        plot mode
+       2        "pen up"
+       3        goto absolute x,y
+       4        end command
+     */
+}
+
+
+TERM_PUBLIC void
+HP2648vector(unsigned int x, unsigned int y)
+{
+    fprintf(gpoutfile, "\033*pbf%d,%dZ", x, y);
+    /*                     1
+       1        "pen down"
+     */
+}
+
+
+TERM_PUBLIC void
+HP2648put_text(unsigned int x, unsigned int y, const char *str)
+{
+    HP2648move(x, y - HP2648VCHAR / 2 + 1);
+    fprintf(gpoutfile, "\033*l%s\n", str);
+}
+
+
+TERM_PUBLIC int
+HP2648_text_angle(int ang)
+{
+int hp_ang = (ang ? 1 : 0);
+
+    fprintf(gpoutfile, "\033*m%dnZ\n", hp_ang+1);
+    return TRUE;
+}
+
+TERM_PUBLIC void
+HP2648reset()
+{
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+TERM_TABLE_START(hp2648_driver)
+    "hp2648", "HP2648 and HP2647",
+    HP2648XMAX, HP2648YMAX, HP2648VCHAR, HP2648HCHAR,
+    HP2648VTIC, HP2648HTIC, options_null, HP2648init, HP2648reset,
+    HP2648text, null_scale, HP2648graphics, HP2648move, HP2648vector,
+    HP2648linetype, HP2648put_text, HP2648_text_angle,
+    null_justify_text, line_and_point, do_arrow, set_font_null
+TERM_TABLE_END(hp2648_driver)
+
+#undef LAST_TERM
+#define LAST_TERM hp2648_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(hp2648)
+"1 hp2648",
+"?commands set terminal hp2648",
+"?set terminal hp2648",
+"?set term hp2648",
+"?terminal hp2648",
+"?term hp2648",
+"?hp2648",
+" The `hp2648` terminal driver supports the Hewlett Packard HP2647 and HP2648.",
+" It has no options."
+END_HELP(hp2648)
+#endif
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/hp500c.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/hp500c.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/hp500c.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/hp500c.trm.svn-base	2012-01-03 17:07:31.670107700 -0800
@@ -0,0 +1,548 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: hp500c.trm,v 1.17 2006/07/21 02:35:47 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - hp500c.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *  hpdj 500c
+ *
+ * AUTHORS
+ *  John Engels      -- \
+ *  Russell Lang     ----> HPLJII.trm
+ *  Maurice Castro   -- /
+ *  UdoHessenauer    ----> derived this version from the above one
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+
+/* The following HP Deskjet500c  driver uses generic bit mapped graphics
+   routines from bitmap.c to build up a bit map in memory.  The driver
+   interchanges colomns and lines in order to access entire lines
+   easily and returns the lines to get bits in the right order :
+   (x,y) -> (y,XMAX-1-x). */
+/* This interchange is done by calling b_makebitmap() with reversed
+   xmax and ymax, and then setting b_rastermode to TRUE.  b_setpixel()
+   will then perform the interchange before each pixel is plotted */
+/* by John Engels JENGELS@BNANDP51.BITNET, inspired by the hpljet driver
+   of Jyrki Yli-Nokari */
+
+/*
+ * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(hp500c)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void HP500C_options __PROTO((void));
+TERM_PUBLIC void HP500C_init __PROTO((void));
+TERM_PUBLIC void HP500C_reset __PROTO((void));
+TERM_PUBLIC void HP500C_linetype __PROTO((int linetype));
+TERM_PUBLIC void HP500C_graphics __PROTO((void));
+TERM_PUBLIC void HP500C_text __PROTO((void));
+/* default values for term_tbl */
+#define HP500C_75PPI_XMAX (1920/4)
+#define HP500C_75PPI_YMAX (1920/4)
+#define HP500C_75PPI_HCHAR (1920/4/6)
+#define HP500C_75PPI_VCHAR (1920/4/10)
+#define HP500C_75PPI_VTIC 5
+#define HP500C_75PPI_HTIC 5
+
+#define GOT_HP500C_PROTO
+#endif
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+
+/* We define 4 different print qualities : 300ppi, 150ppi, 100ppi and
+   75ppi.  (Pixel size = 1, 2, 3, 4 dots) */
+
+#define HP500C_DPP (hpdj_dpp)	/* dots per pixel */
+#define HP500C_PPI (300/HP500C_DPP)	/* pixel per inch */
+/* make XMAX and YMAX a multiple of 8 */
+#define HP500C_XMAX (8*(unsigned int)(xsize*1920/HP500C_DPP/8.0+0.9))
+#define HP500C_YMAX (8*(unsigned int)(ysize*1920/HP500C_DPP/8.0+0.9))
+
+/* Courier font with 6 lines per inch */
+#define HP500C_VCHAR (HP500C_PPI/6)
+/* Courier font with 10 caracters per inch */
+#define HP500C_HCHAR (HP500C_PPI/10)
+
+
+/* Save current cursor position */
+#define HP500C_PUSH_CURSOR fputs("\033&f0S",gpoutfile)
+/* Restore cursor position */
+#define HP500C_POP_CURSOR fputs("\033&f1S",gpoutfile)
+
+/* be sure to use courier font with 6lpi and 10cpi */
+#define HP500C_COURIER fputs("\033(0N\033(s0p10.0h12.0v0s0b3T\033&l6D",gpoutfile)
+
+
+static int HP_compress __PROTO((unsigned char *op, unsigned char *oe,
+			       unsigned char *cp));
+static unsigned char HP_complement __PROTO((int c));
+static int HP_compress_to_TIFF __PROTO((unsigned char *op, unsigned char *oe,
+				       unsigned char *cp));
+static int HP_nocompress __PROTO((unsigned char *op, unsigned char *oe,
+				 unsigned char *cp));
+
+static int hpdj_dpp = 4;
+static int HP_COMP_MODE = 0;
+
+/* bm_pattern not appropriate for 300ppi graphics */
+#ifndef GOT_300_PATTERN
+#define GOT_300_PATTERN
+static unsigned int b_300ppi_pattern[] =
+{
+    0xffff, 0x1111,
+    0xffff, 0x3333, 0x0f0f, 0x3f3f, 0x0fff, 0x00ff, 0x33ff
+};
+#endif
+
+
+TERM_PUBLIC void
+HP500C_options()
+{
+    char opt[6];
+
+#define HPDJCERROR "expecting dots per inch size 75, 100, 150 or 300 and/or compression method"
+    while (!END_OF_COMMAND) {
+	if (token[c_token].length > 4)
+	    int_error(c_token, HPDJCERROR);
+
+	/* almost_equals() won't accept numbers - use strcmp() instead */
+	capture(opt, c_token, c_token, 6);
+	if (!strcmp(opt, "75")) {
+	    hpdj_dpp = 4;
+	    HP_COMP_MODE = 0;
+
+	} else if (!strcmp(opt, "100")) {
+	    hpdj_dpp = 3;
+	    HP_COMP_MODE = 0;
+	} else if (!strcmp(opt, "150")) {
+	    hpdj_dpp = 2;
+	    HP_COMP_MODE = 0;
+	} else if (!strcmp(opt, "300")) {
+	    hpdj_dpp = 1;
+	    HP_COMP_MODE = 0;
+	} else if (!strcmp(opt, "rle")) {
+	    HP_COMP_MODE = 1;
+	} else if (!strcmp(opt, "tiff")) {
+	    HP_COMP_MODE = 2;
+	}
+	c_token++;
+    }
+
+    term->xmax = HP500C_XMAX;
+    term->ymax = HP500C_YMAX;
+    switch (hpdj_dpp) {
+    case 1:
+	strcpy(term_options, "300");
+	term->v_tic = 15;
+	term->h_tic = 15;
+	break;
+    case 2:
+	strcpy(term_options, "150");
+	term->v_tic = 8;
+	term->h_tic = 8;
+	break;
+    case 3:
+	strcpy(term_options, "100");
+	term->v_tic = 6;
+	term->h_tic = 6;
+	break;
+    case 4:
+	strcpy(term_options, "75");
+	term->v_tic = 5;
+	term->h_tic = 5;
+	break;
+    }
+    switch (HP_COMP_MODE) {
+    case 0:
+	strcat(term_options, " no comp");
+	break;
+    case 1:
+	strcat(term_options, " RLE");
+	break;
+    case 2:
+	strcat(term_options, " TIFF");
+	break;
+    case 3:			/* not implemented yet */
+	strcat(term_options, " Delta Row");
+	break;
+    }
+}
+
+TERM_PUBLIC void
+HP500C_init()
+{
+    /* HBB 980226: all changes to term-> fields *must* happen here, not
+     * in graphics() !*/
+    switch (hpdj_dpp) {
+    case 1:
+	b_charsize(FNT13X25);
+	term->v_char = FNT13X25_VCHAR;
+	term->h_char = FNT13X25_HCHAR;
+	break;
+    case 2:
+	b_charsize(FNT13X25);
+	term->v_char = FNT13X25_VCHAR;
+	term->h_char = FNT13X25_HCHAR;
+	break;
+    case 3:
+	b_charsize(FNT9X17);
+	term->v_char = FNT9X17_VCHAR;
+	term->h_char = FNT9X17_HCHAR;
+	break;
+    case 4:
+	b_charsize(FNT5X9);
+	term->v_char = FNT5X9_VCHAR;
+	term->h_char = FNT5X9_HCHAR;
+	break;
+    }
+}
+
+TERM_PUBLIC void
+HP500C_reset()
+{
+#ifdef VMS
+    fflush_binary();
+#endif
+}
+
+
+
+/* HP DeskJet 500c routines */
+
+TERM_PUBLIC void
+HP500C_linetype(int linetype)
+{
+    if (linetype < 0)
+	linetype = 7;
+    else if (linetype >= 8) {
+	linetype %= 8;
+    }
+    switch (linetype) {
+    case 0:
+	linetype = 6;
+	break;
+    case 1:
+	linetype = 5;
+	break;
+    case 2:
+	linetype = 3;
+	break;
+    case 3:
+	linetype = 2;
+	break;
+    case 4:
+	linetype = 1;
+	break;
+    case 5:
+	linetype = 4;
+	break;
+    case 6:
+	linetype = 7;
+    }
+    b_setvalue(linetype);
+
+}
+
+#if 0
+void
+HP500C_point(unsigned int x, unsigned int y, int value)
+{
+    HP500C_linetype(value);
+    do_point(x,y,value);
+}
+#endif
+
+TERM_PUBLIC void
+HP500C_graphics()
+{
+    /* HBB 980226: moved block of code from here to init() */
+    /* rotate plot -90 degrees by reversing XMAX and YMAX and by
+       setting b_rastermode to TRUE */
+    b_makebitmap(HP500C_YMAX, HP500C_XMAX, 3);
+    b_rastermode = TRUE;
+}
+
+/*
+ * Run-length encoding for the DeskJet. We have pairs of <count>
+ * <what>, where count goes from 0 (meaning one count) to 255
+ * this might double the size of the image.
+ */
+
+static int
+HP_compress(unsigned char *op, unsigned char *oe, unsigned char *cp)
+{
+    unsigned char *ce = cp;
+
+    while (op < oe) {
+	unsigned char prevchar;
+	unsigned char count;
+
+	prevchar = *op;		/* remember char */
+	count = 1;		/* its read the first time */
+
+	while (++op < oe && *op == prevchar && count < 255) {
+            /* set op to the next char */
+	    count++;		/* and count it  */
+	}
+	*ce++ = --count;	/* were ready, so correct the count */
+	*ce++ = prevchar;	/* and store <what> */
+    }
+    *ce = 0;			/* just to be safe   */
+    return ce - cp;		/* length of  cbufs */
+}
+
+static unsigned char
+HP_complement(int c)
+{
+    return (unsigned char) (256 - c);
+}
+
+
+static int
+HP_compress_to_TIFF(
+    unsigned char *op,		/* original pointer */
+    unsigned char *oe,		/* end of orig string */
+    unsigned char *cp)		/* pointer for compressed data */
+{
+    unsigned char *countposition;
+    unsigned char *ce = cp;
+
+    while (op < oe) {
+	unsigned char prevchar;
+	unsigned char count;
+
+	prevchar = *op;		/* gelesenes Zeichen aufbewaren */
+	count = 1;		/* bisher wurde es einmal gelesen */
+
+	while (++op < oe && *op == prevchar && count < 128) {
+	    count++;
+	}
+	*ce = HP_complement(count - 1);
+        /* remember count for building blocks of literal bytes */
+	countposition = ce++;
+	*ce++ = prevchar;
+
+	if (count < 2) {
+	    while (op < oe && (prevchar != *op || *op != *(op + 1))) {
+                /* only use rle for at leat 3 equal bytes */
+		*ce++ = *op;
+		count++;
+		prevchar = *op++;
+		if (op > oe)
+		    puts("FATAL op> oe!!\n");
+	    }
+	    if (op < oe && prevchar == *op) {
+		op--;
+		count--;
+		ce--;
+	    }
+	    *countposition = count - 1;
+	}
+    }
+    return ce - cp;
+
+}
+
+static int
+HP_nocompress(
+    unsigned char *op,
+    unsigned char *oe,
+    unsigned char *cp)
+{
+    unsigned char *ce = cp;
+
+    while (op < oe)
+	*ce++ = *op++;
+    return ce - cp;
+}
+
+/* 0 compression raster bitmap dump. Compatible with HP DeskJet 500
+   hopefully compatible with other HP Deskjet printers */
+
+TERM_PUBLIC void
+HP500C_text()
+{
+    register int x, j, row, count = 0;
+    unsigned char *obuf, *oe, *cbuf, *ce;
+
+    if ((obuf = (unsigned char *) malloc(100 * b_psize)) == 0)
+	puts("FATAL!-- couldn't get enough memory for obuf");
+    if ((cbuf = (unsigned char *) malloc(400 * b_psize)) == 0)
+	puts("FATAL!-- couldn't get enough memory for cbuf");
+
+    oe = obuf;
+
+    fprintf(gpoutfile, "\
+\033*t%dR\
+\033*r1A\
+\033*b%1dM\
+\033*r%dS\
+\033*r-3U",
+	    HP500C_PPI,
+	    HP_COMP_MODE,
+	    b_ysize);
+
+    /* dump bitmap in raster mode */
+    for (x = b_xsize - 1; x >= 0; x--) {
+	row = (b_ysize / 8) - 1;
+	for (j = row; j >= 0; j--) {
+	    *oe++ = (char) (*((*b_p)[j] + x));
+	}
+	switch (HP_COMP_MODE) {
+	case 2:
+	    count = HP_compress_to_TIFF(obuf, oe, cbuf);
+	    break;
+	case 1:
+	    count = HP_compress(obuf, oe, cbuf);
+	    break;
+	case 0:
+	    count = HP_nocompress(obuf, oe, cbuf);
+	    break;
+	}
+	fprintf(gpoutfile, "\033*b%dV", count);
+	ce = cbuf;
+	while (count--)
+	    fputc(*ce++, gpoutfile);
+	oe = obuf;
+
+	for (j = row; j >= 0; j--) {
+	    *oe++ = (char) (*((*b_p)[j + b_psize] + x));
+	}
+	switch (HP_COMP_MODE) {
+	case 2:
+	    count = HP_compress_to_TIFF(obuf, oe, cbuf);
+	    break;
+	case 1:
+	    count = HP_compress(obuf, oe, cbuf);
+	    break;
+	case 0:
+	    count = HP_nocompress(obuf, oe, cbuf);
+	    break;
+
+	}
+
+	fprintf(gpoutfile, "\033*b%dV", count);
+	ce = cbuf;
+	while (count--)
+	    fputc(*ce++, gpoutfile);
+	oe = obuf;
+
+	for (j = row; j >= 0; j--) {
+	    *oe++ = (char) (*((*b_p)[j + (2 * b_psize)] + x));
+	}
+	switch (HP_COMP_MODE) {
+	case 2:
+	    count = HP_compress_to_TIFF(obuf, oe, cbuf);
+	    break;
+	case 1:
+	    count = HP_compress(obuf, oe, cbuf);
+	    break;
+	case 0:
+	    count = HP_nocompress(obuf, oe, cbuf);
+	    break;
+	}
+	fprintf(gpoutfile, "\033*b%dW", count);
+	ce = cbuf;
+	while (count--)
+	    fputc(*ce++, gpoutfile);
+	oe = obuf;
+
+    }
+    fputs("\033*rbC", gpoutfile);
+    free(cbuf);
+    free(obuf);
+    b_freebitmap();
+
+#ifndef VMS
+    /* most vms spoolers add a formfeed character */
+    putc('\f', gpoutfile);
+#endif /* !VMS */
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(hp500c_driver)
+    "hp500c", "HP DeskJet 500c, [75 100 150 300] [rle tiff]",
+    HP500C_75PPI_XMAX, HP500C_75PPI_YMAX, HP500C_75PPI_VCHAR,
+    HP500C_75PPI_HCHAR, HP500C_75PPI_VTIC, HP500C_75PPI_HTIC, HP500C_options,
+    HP500C_init, HP500C_reset, HP500C_text, null_scale,
+    HP500C_graphics, b_move, b_vector, HP500C_linetype,
+    b_put_text, b_text_angle, null_justify_text, do_point,
+    do_arrow, set_font_null, 0, TERM_BINARY,
+    0, 0, b_boxfill
+TERM_TABLE_END(hp500c_driver)
+
+#undef LAST_TERM
+#define LAST_TERM hp500c_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(hp500c)
+"1 hp500c",
+"?commands set terminal hp500c",
+"?set terminal hp500c",
+"?set term hp500c",
+"?terminal hp500c",
+"?term hp500c",
+"?hp500c",
+" The `hp500c` terminal driver supports the Hewlett Packard HP DeskJet 500c.",
+" It has options for resolution and compression.",
+"",
+" Syntax:",
+"       set terminal hp500c {<res>} {<comp>}",
+"",
+" where `res` can be 75, 100, 150 or 300 dots per inch and `comp` can be \"rle\",",
+" or \"tiff\".  Any other inputs are replaced by the defaults, which are 75 dpi",
+" and no compression.  Rasterization at the higher resolutions may require a",
+" large amount of memory."
+END_HELP(hp500c)
+#endif /* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/hpgl.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/hpgl.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/hpgl.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/hpgl.trm.svn-base	2012-01-03 17:07:31.865614700 -0800
@@ -0,0 +1,2692 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: hpgl.trm,v 1.23 2009/03/02 23:55:26 sfeam Exp $
+ */
+
+/* GNUPLOT - hpgl.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.h.
+ *
+ * This terminal driver supports:
+ *  hpgl, hp7550, hp7580b, HP Laserjet III
+ *  hp7550 has been replaced by  "hpgl 8 eject"
+ *  hp7580b has been replaced by "hpgl 4"
+ *
+ * AUTHORS
+ *  Colin Kelley, Thomas Williams, Russell Lang
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+
+/*
+ *
+ * MODIFIED for expanded HPGL/2 and PCL utilites
+ *  Tom Swiler (tom@silica.mse.ufl.edu)
+ * Modified June 1995 Ian MacPhedran to support newterm format
+ * Modified October 1995 Ian MacPhedran to simplify HPGL terminals
+ * Modified January 96 by David Denholm and Emmanuel Bigler for cp850
+ *                               and iso international character sets
+ * Modified February 99 by Jeremy Brenes to give PCL5 terminal optional
+ * multi-pen support (6 pen default), a default 34" plotting width for
+ * use with large color plotters such as the HP Designjet 750C,
+ * various alternative plot sizes, and variable fontsizes;
+ * Also decreased the HPGL terminal's fixed fontsize to make it more
+ * reasonable when plots get scaled to 34"
+ * Modified July 99 by Jeremy Brenes to make extended plot area smaller;
+ * added solid/dashed lines option, additional font types, mixed fonts
+ * Modified November 99 by Jeremy Brenes to add a postscript pointtypes
+ * option, special purpose negative pointtypes, and a pointsize function
+ *
+ */
+#define HPGL
+#define PCL
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(hpgl)
+register_term(pcl5)
+#endif /* TERM_REGISTER */
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void HPGL_options __PROTO((void));
+TERM_PUBLIC void HPGL2_options __PROTO((void));
+TERM_PUBLIC void PCL_options __PROTO((void));
+TERM_PUBLIC void HPGL_init __PROTO((void));
+/* TERM_PUBLIC void HPGL2_init __PROTO((void)); */
+TERM_PUBLIC void PCL_init __PROTO((void));
+TERM_PUBLIC void HPGL_graphics __PROTO((void));
+TERM_PUBLIC void HPGL2_graphics __PROTO((void));
+TERM_PUBLIC void PCL_graphics __PROTO((void));
+TERM_PUBLIC void HPGL_text __PROTO((void));
+/* TERM_PUBLIC void HPGL2_text __PROTO((void)); */
+TERM_PUBLIC void PCL_text __PROTO((void));
+TERM_PUBLIC void HPGL_linetype __PROTO((int linetype));
+TERM_PUBLIC void HPGL2_linetype __PROTO((int linetype));
+TERM_PUBLIC void HPGL_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC void HPGL2_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC void HPGL_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void HPGL_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void HPGL2_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void HPGL2_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void HPGL2_encode __PROTO((int d));
+TERM_PUBLIC int HPGL_text_angle __PROTO((int ang));
+TERM_PUBLIC int HPGL2_text_angle __PROTO((int ang));
+TERM_PUBLIC void HPGL_reset __PROTO((void));
+/* TERM_PUBLIC void HPGL2_reset __PROTO((void)); */
+TERM_PUBLIC void PCL_reset __PROTO((void));
+TERM_PUBLIC int HPGL2_justify_text __PROTO((enum JUSTIFY just));
+TERM_PUBLIC int HPGL2_set_font __PROTO((const char *font));
+TERM_PUBLIC void HPGL2_point __PROTO((unsigned int x, unsigned int y, int number));
+TERM_PUBLIC void HPGL2_neg_point __PROTO((unsigned int x, unsigned int y, int number));
+TERM_PUBLIC void HPGL2_pointsize __PROTO((double size));
+#define GOT_HPGL_PROTO
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+/*
+ * The maximum plot size, in plotter units.
+ * Note that the actual size of larger plots may be limited by
+ * available printer memory.
+ */
+
+#define HPGL_PUPI	1016	/* Plotter units per inch */
+
+#define HPGL_XMAX_A	10000
+#define HPGL_YMAX_A	7500
+
+#define HPGL_XMAX_B	13000
+#define HPGL_YMAX_B	7500
+
+#define HPGL_XMAX_C	45333
+#define HPGL_YMAX_C	34000
+
+#define HPGL_XMAX_D	52000
+#define HPGL_YMAX_D	34000
+
+#define HPGL_XMAX	HPGL_XMAX_A
+#define HPGL_YMAX	HPGL_YMAX_A
+
+#define PCL_XMAX	HPGL_XMAX_C
+#define PCL_YMAX	(HPGL_YMAX_C-60)
+
+/*
+ * Tic sizes
+ */
+
+#define HPGL_VTIC	(HPGL_YMAX/70)
+#define HPGL_HTIC	(HPGL_YMAX/70)
+
+#define PCL_VTIC	((HPGL_YMAX_C-60)/320)
+#define PCL_HTIC	((HPGL_YMAX_C-60)/320)
+
+/*
+ * Font size for HPGL
+ */
+
+#define HPGL_VCHAR	(HPGL_YMAX/100*8/10)	/* 0.8% */
+#define HPGL_HCHAR	(HPGL_XMAX/100*3/10)	/* 0.3% */
+
+/*
+ * Font size for HPGL/2
+ */
+
+#define HPGL2_DEF_POINT	12	/* Height of font */
+
+#define HPGL2_DEF_PITCH	(3 * 72 / (HPGL2_DEF_POINT * 2))
+#define HPGL2_VCHAR	((int) HPGL_PUPI * HPGL2_DEF_POINT / 72)
+#define HPGL2_HCHAR	(HPGL2_VCHAR * 2 / 3)
+
+/*
+ * Point size for HPGL/2
+ */
+
+static double HPGL2_psize = 1.0;	/* Default point size */
+
+/*
+ * Number of available pointtypes for HPGL/2
+ */
+
+#define  HPGL2_NUM_NOPSPOINTS 6;	/* for nopspoints option */
+#define  HPGL2_NUM_PSPOINTS 75;	/* for pspoints option */
+
+/*
+ * Control constants
+ */
+
+#define DOWN		0	/* Pen is down */
+#define UP 		1	/* Pen is up */
+#define UNKNOWN		-10	/* Unknown status for lots of things */
+
+/*
+ * For Polyline Encoded, either use base 64 or base 32.
+ * Save space with base 64, but get 8-bit characters.
+ */
+
+#define HPGL2_BASE64 1
+
+#if HPGL2_BASE64
+#define HPGL2_BITS 6
+#define HPGL2_LOW_OFFS 63
+#define HPGL2_HIGH_OFFS 191
+#define HPGL2_MASK 63
+#else
+#define HPGL2_BITS 5
+#define HPGL2_LOW_OFFS 63
+#define HPGL2_HIGH_OFFS 95
+#define HPGL2_MASK 31
+#endif
+
+/*
+ * Data structures for options
+ */
+
+struct HPGL2_font_str {
+    const char *compare, *name;
+    int symbol_set, spacing;
+    double pitch, height;
+    int posture, stroke_weight, typeface;
+};
+
+struct PCL_mode_str {
+    const char *compare, *name, *command;
+    unsigned int xmax, ymax;
+};
+
+/*
+ * The default font goes first.  Although it is the ugliest,  the
+ * stick font is probably supported by the most devices.
+ */
+
+static struct HPGL2_font_str GPFAR HPGL2_font_table[] = {
+    {"u$nivers", "univers", 277, 1, 0.0, HPGL2_DEF_POINT, 0, 0, 4148},
+    {"s$tick", "stick", 277, 0, HPGL2_DEF_PITCH, 0.0, 0, 0, 48},
+    {"cg_t$imes", "cg_times", 277, 1, 0.0, HPGL2_DEF_POINT, 0, 0, 4101},
+    {"z$apf_dingbats", "zapf_dingbats", 364, 1, 0.0, HPGL2_DEF_POINT, 0, 0, 4141},
+    {"an$tique_olive", "antique_olive", 277, 1, 0.0, HPGL2_DEF_POINT, 0, 0, 4168},
+    {"ar$ial", "arial", 277, 1, 0.0, HPGL2_DEF_POINT, 0, 0, 16602},
+    {"cou$rier", "courier", 277, 1, 0.0, HPGL2_DEF_POINT, 0, 0, 4099},
+    {"g$aramond_antigua", "garamond_antigua", 277, 1, 0.0, HPGL2_DEF_POINT, 0, 0, 4197},
+    {"l$etter_gothic", "letter_gothic", 277, 1, 0.0, HPGL2_DEF_POINT, 0, 0, 4102},
+    {"cg_o$mega", "cg_omega", 277, 1, 0.0, HPGL2_DEF_POINT, 0, 0, 4113},
+    {"al$bertus", "albertus", 277, 1, 0.0, HPGL2_DEF_POINT, 0, 1, 4362},
+    {"ti$mes_new_roman", "times_new_roman", 277, 1, 0.0, HPGL2_DEF_POINT, 0, 0, 16901},
+    {"cl$arendon", "clarendon", 277, 1, 0.0, HPGL2_DEF_POINT, 4, 3, 4140},
+    {"cor$onet", "coronet", 277, 1, 0.0, HPGL2_DEF_POINT, 1, 0, 4116},
+    {"m$arigold", "marigold", 277, 1, 0.0, HPGL2_DEF_POINT, 0, 0, 4297},
+    {"tr$uetype_symbols", "truetype_symbols", 621, 1, 0.0, HPGL2_DEF_POINT, 0, 0, 16686},
+    {"w$ingdings", "wingdings", 18540, 1, 0.0, HPGL2_DEF_POINT, 1, 0, 31402}
+};
+
+#define HPGL2_FONTS (sizeof(HPGL2_font_table) / sizeof (struct HPGL2_font_str))
+static struct HPGL2_font_str *HPGL2_font = &HPGL2_font_table[0];
+
+/*
+ * The default mode goes first.  Landscape style plots are probably the
+ * most compatable with other HPGL devices.
+ */
+
+static struct PCL_mode_str GPFAR PCL_mode_table[] = {
+    {"l$andscape", "landscape", "\033&l1O", PCL_XMAX, PCL_YMAX},
+    {"p$ortrait", "portrait", "\033&l0O", PCL_YMAX, PCL_XMAX}
+};
+
+#define PCL_MODES (sizeof(PCL_mode_table) / sizeof (struct PCL_mode_str))
+static struct PCL_mode_str *PCL_mode = &PCL_mode_table[0];
+
+/*
+ * Various line types and widths to distinguish data sets in monochrome
+ */
+
+static const char *HPGL2_lt[] = { "", ",2", ",2", ",2", ",2", ",2", ",2", ",2" },
+		  *HPGL2_pw[] = { ".24", ".16", ".08"};
+
+#define HPGL2_LINETYPES (sizeof(HPGL2_lt) / sizeof(char *))
+#define HPGL2_PENWIDTHS (sizeof(HPGL2_pw) / sizeof(char *))
+
+/* encoding vector for cp850 , characters 128 (0200) -> 255 (0377) */
+
+static char hpgl_cp_850[128][4] = {
+
+/* 0200 */ "\0164\017",
+/* 0201 */ "\016O\017",
+/* 0202 */ "\016E\017",
+/* 0203 */ "\016@\017",
+/* 0204 */ "\016L\017",
+/* 0205 */ "\016H\017",
+/* 0206 */ "\016T\017",
+/* 0207 */ "\0165\017",
+
+/* 0210 */ "\016A\017",
+/* 0211 */ "\016M\017",
+/* 0212 */ "\016I\017",
+/* 0213 */ "\016]\017",
+/* 0214 */ "\016Q\017",
+/* 0215 */ "\016Y\017",
+/* 0216 */ "\016X\017",
+/* 0217 */ "\016P\017",
+
+/* 0220 */ "\016\134\017",
+/* 0221 */ "\016W\017",
+/* 0222 */ "\016S\017",
+/* 0223 */ "\016B\017",
+/* 0224 */ "\016N\017",
+/* 0225 */ "\016J\017",
+/* 0226 */ "\016C\017",
+/* 0227 */ "\016K\017",
+
+/* 0230 */ "\016o\017",
+/* 0231 */ "\016Z\017",
+/* 0232 */ "\016[\017",
+/* 0233 */ "\016V\017",
+/* 0234 */ "\016;\017",
+/* 0235 */ "\016R\017",
+/* 0236 */ "",
+/* 0237 */ "\016>\017",
+
+/* 0240 */ "\016D\017",
+/* 0241 */ "\016U\017",
+/* 0242 */ "\016F\017",
+/* 0243 */ "\016G\017",
+/* 0244 */ "\0167\017",
+/* 0245 */ "\0166\017",
+/* 0246 */ "\016y\017",
+/* 0247 */ "\016z\017",
+
+/* 0250 */ "\0169\017",
+
+/* 0251 */ "",
+/* 0252 */ "",
+
+/* 0253 */ "\016x\017",
+/* 0254 */ "\016w\017",
+/* 0255 */ "\0168\017",
+/* 0256 */ "\016{\017",
+/* 0257 */ "\016}\017",
+
+/* 0260 */ "",
+/* 0261 */ "",
+/* 0262 */ "",
+/* 0263 */ "",
+/* 0264 */ "",
+
+/* 0265 */ "\016`\017",
+/* 0266 */ "\016\042\017",
+/* 0267 */ "\016!\017",
+
+/* 0270 */ "",
+/* 0271 */ "",
+/* 0272 */ "",
+/* 0273 */ "",
+/* 0274 */ "",
+
+/* 0275 */ "\016?\017",
+/* 0276 */ "\016<\017",
+
+/* 0277 */ "",
+
+/* 0300 */ "",
+/* 0301 */ "",
+/* 0302 */ "",
+/* 0303 */ "",
+/* 0304 */ "",
+/* 0305 */ "",
+
+/* 0306 */ "\016b\017",
+/* 0307 */ "\016a\017",
+
+/* 0310 */ "",
+/* 0311 */ "",
+/* 0312 */ "",
+/* 0313 */ "",
+/* 0314 */ "",
+/* 0315 */ "",
+/* 0316 */ "",
+
+/* 0317 */ "\016:\017",
+
+/* 0320 */ "\016d\017",
+/* 0321 */ "\016c\017",
+/* 0322 */ "\016$\017",
+/* 0323 */ "\016%\017",
+/* 0324 */ "\016#\017",
+
+/* 0325 */ "",
+
+/* 0326 */ "\016e\017",
+/* 0327 */ "\016&\017",
+
+/* 0330 */ "\016'\017",
+
+/* 0331 */ "",
+/* 0332 */ "",
+/* 0333 */ "",
+/* 0334 */ "",
+/* 0335 */ "",
+
+/* 0336 */ "\016f\017",
+/* 0337 */ "",
+
+/* 0340 */ "\016g\017",
+/* 0341 */ "\016^\017",
+/* 0342 */ "\016_\017",
+/* 0343 */ "\016h\017",
+/* 0344 */ "\016j\017",
+/* 0345 */ "\016i\017",
+/* 0346 */ "",
+/* 0347 */ "\016q\017",
+
+/* 0350 */ "\016p\017",
+/* 0351 */ "\016m\017",
+/* 0352 */ "\016.\017",
+/* 0353 */ "\016-\017",
+/* 0354 */ "",
+/* 0355 */ "",
+/* 0356 */ "\0160\017",
+/* 0357 */ "\016(\017",
+
+/* 0360 */ "\016v\017",
+/* 0361 */ "\016~\017",
+/* 0362 */ "",
+/* 0363 */ "",
+/* 0364 */ "",
+/* 0365 */ "\016=\017",
+/* 0366 */ "",
+/* 0367 */ "",
+
+/* 0370 */ "\016z\017",
+/* 0371 */ "\016+\017",
+/* 0372 */ "",
+/* 0373 */ "",
+/* 0374 */ "",
+/* 0375 */ "",
+/* 0376 */ "",
+/* 0377 */ ""
+};
+
+
+/* encoding vector for iso-8859-1 , characters 128 (0200) -> 255 (0377) */
+
+static char hpgl_iso_8859_1[128][4] = {
+
+/* 0200 */ "",
+/* 0201 */ "",
+/* 0202 */ "",
+/* 0203 */ "",
+/* 0204 */ "",
+/* 0205 */ "",
+/* 0206 */ "",
+/* 0207 */ "",
+
+/* 0210 */ "",
+/* 0211 */ "",
+/* 0212 */ "",
+/* 0213 */ "",
+/* 0214 */ "",
+/* 0215 */ "",
+/* 0216 */ "",
+/* 0217 */ "",
+
+/* 0220 */ "",
+/* 0221 */ "\016\017",
+/* 0222 */ "\016\017",
+/* 0223 */ "",
+/* 0224 */ "",
+/* 0225 */ "",
+/* 0226 */ "",
+/* 0227 */ "",
+
+/* 0230 */ "",
+/* 0231 */ "",
+/* 0232 */ "",
+/* 0233 */ "",
+/* 0234 */ "",
+/* 0235 */ "",
+/* 0236 */ "",
+/* 0237 */ "",
+
+/* 0240 */ "",
+/* 0241 */ "\0168\017",
+/* 0242 */ "\0165\017",
+/* 0243 */ "\016;\017",
+/* 0244 */ "\016:\017",
+/* 0245 */ "\016<\017",
+/* 0246 */ "\017|\017",
+/* 0247 */ "\016=\017",
+
+/* 0250 */ "\016+\017",
+/* 0251 */ "",
+/* 0252 */ "\016y\017",
+/* 0253 */ "\016{\017",
+/* 0254 */ "",
+/* 0255 */ "",
+/* 0256 */ "",
+/* 0257 */ "\0160\017",
+
+/* 0260 */ "\016z\017",
+/* 0261 */ "\016~\017",
+/* 0262 */ "",
+/* 0263 */ "",
+/* 0264 */ "",
+/* 0265 */ "",
+/* 0266 */ "",
+/* 0267 */ "",
+
+/* 0270 */ "",
+/* 0271 */ "",
+/* 0272 */ "\016z\017",
+/* 0273 */ "\016}\017",
+/* 0274 */ "\016w\017",
+/* 0275 */ "\016x\017",
+/* 0276 */ "",
+/* 0277 */ "\0169\017",
+
+/* 0300 */ "\016!\017",
+/* 0301 */ "\016`\017",
+/* 0302 */ "\016\042\017",
+/* 0303 */ "\016a\017",
+/* 0304 */ "\016X\017",
+/* 0305 */ "\016P\017",
+/* 0306 */ "\016S\017",
+/* 0307 */ "\0164\017",
+
+/* 0310 */ "\016#\017",
+/* 0311 */ "\016\134\017",
+/* 0312 */ "\016$\017",
+/* 0313 */ "\016%\017",
+/* 0314 */ "\016f\017",
+/* 0315 */ "\016e\017",
+/* 0316 */ "\016\046\017",
+/* 0317 */ "\016'\017",
+
+/* 0320 */ "\016c\017",
+/* 0321 */ "\0166\017",
+/* 0322 */ "\016h\017",
+/* 0323 */ "\016g\017",
+/* 0324 */ "\016_\017",
+/* 0325 */ "\016i\017",
+/* 0326 */ "\016Z\017",
+/* 0327 */ "",
+
+/* 0330 */ "\016R\017",
+/* 0331 */ "\016-\017",
+/* 0332 */ "\016m\017",
+/* 0333 */ "\016.\017",
+/* 0334 */ "\016[\017",
+/* 0335 */ "",
+/* 0336 */ "\016p\017",
+/* 0337 */ "\016^\017",
+
+/* 0340 */ "\016H\017",
+/* 0341 */ "\016D\017",
+/* 0342 */ "\016@\017",
+/* 0343 */ "\016b\017",
+/* 0344 */ "\016L\017",
+/* 0345 */ "\016T\017",
+/* 0346 */ "\016W\017",
+/* 0347 */ "\0165\017",
+
+/* 0350 */ "\016I\017",
+/* 0351 */ "\016E\017",
+/* 0352 */ "\016A\017",
+/* 0353 */ "\016M\017",
+/* 0354 */ "\016Y\017",
+/* 0355 */ "\016U\017",
+/* 0356 */ "\016Q\017",
+/* 0357 */ "\016]\017",
+
+/* 0360 */ "\016d\017",
+/* 0361 */ "\0167\017",
+/* 0362 */ "\016J\017",
+/* 0363 */ "\016F\017",
+/* 0364 */ "\016B\017",
+/* 0365 */ "\016j\017",
+/* 0366 */ "\016N\017",
+/* 0367 */ "",
+
+/* 0370 */ "\016V\017",
+/* 0371 */ "\016K\017",
+/* 0372 */ "\016G\017",
+/* 0373 */ "\016C\017",
+/* 0374 */ "\016O\017",
+/* 0375 */ "",
+/* 0376 */ "\016q\017",
+/* 0377 */ "\016o\017"
+};
+
+
+/*
+ * Static variables to keep track of where we are, etc.
+ */
+
+static int HPGL_ang = 0, HPGL_x = UNKNOWN, HPGL_y = UNKNOWN,
+	   HPGL_penstate = UNKNOWN, HPGL_pentype, HPGL2_pentype = UNKNOWN,
+	   HPGL2_in_pe, HPGL2_lost;
+
+/*
+ * The subroutines, grouped by function for different versions.
+ */
+
+static int HPGL_numpen, HPGL_eject;
+
+TERM_PUBLIC void
+HPGL_options()
+{
+    HPGL_numpen = 6;		/* default to six pens */
+    HPGL_eject = 0;		/* default to no eject */
+
+    while (!END_OF_COMMAND) {
+	if (almost_equals(c_token, "eje$ct"))
+	    HPGL_eject = 1;
+	else if (isanumber(c_token)) {
+	    HPGL_numpen = (int) real(&token[c_token].l_val);
+	    if (HPGL_numpen <= 0) {
+		HPGL_numpen = 6;
+		int_error(c_token, "Number of pens must be positive");
+	    }
+	} else
+	    int_error(c_token, "expecting \"eject\" or number of pens");
+
+	c_token++;
+    }
+
+
+    sprintf(term_options, "%d pens %s", HPGL_numpen,
+	    HPGL_eject ? "eject" : "noeject");
+}
+
+static int HPGL2_color = 1, HPGL2_numpen = 6;	/* default to 6 pen color */
+static int HPGL2_dashed = 0;	/* current dashed linetype */
+static int HPGL2_solid = 1;	/* default to solid lines */
+static int HPGL2_font_num = 0;	/* font from options */
+static int HPGL2_font_num_current = 0; /* current font */
+static int pspointset = 0;	/* default to standard point types */
+static double HPGL2_point_size = HPGL2_DEF_POINT; /* pointsize from options */
+static double HPGL2_point_size_current = 0; /* current pointsize */
+static const char *PCL_dim = "noextended"; /* default plotting dimensions */
+
+
+enum HPGL2_id {
+    HPGL2_MONOCHROME, HPGL2_COLOR, HPGL2_SOLID, HPGL2_DASHED, HPGL2_FONT,
+    HPGL2_SIZE, HPGL2_NOPSPOINTS, HPGL2_PSPOINTS,
+    HPGL2_INVALID
+};
+
+static struct gen_table HPGL2_opts[] =
+{
+    { "mono$chrome", HPGL2_MONOCHROME },
+    { "col$or", HPGL2_COLOR },
+    { "col$our", HPGL2_COLOR },
+    { "sol$id", HPGL2_SOLID },
+    { "das$hed", HPGL2_DASHED },
+    { "f$ont", HPGL2_FONT },
+    { "s$ize", HPGL2_SIZE },
+    { "n$opspoints", HPGL2_NOPSPOINTS },
+    { "p$spoints", HPGL2_PSPOINTS },
+    { NULL, HPGL2_INVALID }
+};
+
+TERM_PUBLIC void
+HPGL2_options()
+{
+    struct termentry *t = term;
+    int i;
+
+    while (!END_OF_COMMAND) {
+	switch(lookup_table(&HPGL2_opts[0],c_token)) {
+	case HPGL2_MONOCHROME:
+	    HPGL2_color = 0;
+	    c_token++;
+	    break;
+	case HPGL2_COLOR:
+	    HPGL2_color = 1;
+	    c_token++;
+	    if (!END_OF_COMMAND && isanumber(c_token)) {
+		HPGL2_numpen = (int) real(&token[c_token].l_val);
+		if (HPGL2_numpen <= 0) {
+		    HPGL2_numpen = 6;
+		    int_error(c_token, "Number of pens must be a positive");
+		}
+	    c_token++;
+	    }
+	    break;
+	case HPGL2_SOLID:
+	    HPGL2_solid = 1;
+	    c_token++;
+	    break;
+	case HPGL2_DASHED:
+	    HPGL2_solid = 0;
+	    c_token++;
+	    break;
+	case HPGL2_FONT:
+	    c_token++;
+	    if (!END_OF_COMMAND) {
+		for (i = 0; i < HPGL2_FONTS && !almost_equals(c_token, HPGL2_font_table[i].compare); i++);
+		if (i < HPGL2_FONTS) {
+		    HPGL2_font = &HPGL2_font_table[i];
+		    HPGL2_font_num = i;
+		    HPGL2_font_num_current = HPGL2_font_num;
+		} else
+		    int_error(c_token,
+			      "expecting font: stick, cg_times, univers, zapf_dingbats, antique_olive,\narial, courier, garamond_antigua, letter_gothic, cg_omega, albertus,\ntimes_new_roman, clarendon, coronet, marigold, truetype_symbols, or wingdings");
+		c_token++;
+	    } else
+		int_error(c_token,
+			  "expecting font: stick, cg_times, univers, zapf_dingbats, antique_olive,\narial, courier, garamond_antigua, letter_gothic, cg_omega, albertus,\ntimes_new_roman, clarendon, coronet, marigold, truetype_symbols, or wingdings");
+	    break;
+	case HPGL2_SIZE:
+	    c_token++;
+	    if (!END_OF_COMMAND) {
+		if ((HPGL2_point_size = real(&token[c_token].l_val)) > 0.0) {
+		    HPGL2_point_size_current = HPGL2_point_size;
+		    t->v_char = (int) HPGL_PUPI *HPGL2_point_size / 72;
+		    t->h_char = t->v_char * 2 / 3;
+		    if (HPGL2_font->spacing)
+			HPGL2_font->height = HPGL2_point_size;
+		    else
+			HPGL2_font->pitch = 72 * 3 / (HPGL2_point_size * 2);
+		} else
+		    int_error(c_token, "expecting point size: real number");
+		c_token++;
+	    } else
+		int_error(c_token, "expecting point size: real number");
+	    break;
+	case HPGL2_NOPSPOINTS:
+	    c_token++;
+	    pspointset = 0;
+	    break;
+	case  HPGL2_PSPOINTS:
+	    c_token++;
+	    pspointset = 1;
+	    break;
+	case HPGL2_INVALID:
+	    c_token++;
+	default:
+	    break;
+	}
+    }
+
+    sprintf(term_options+strlen(term_options)," %s %d %s \\\n"
+					      "   %s %s %f %s",
+	    HPGL2_color ? "color" : "monochrome",
+	    HPGL2_color == 1 ? HPGL2_numpen : 1,
+	    HPGL2_solid ? "solid" : "dashed",
+	    HPGL2_font->name,
+	    HPGL2_font->spacing ? "height" : "pitch",
+	    HPGL2_font->spacing ? HPGL2_font->height : HPGL2_font->pitch,
+	    pspointset ? "pspoints" : "nopspoints");
+}
+
+#if 0
+/* Unused for now */
+
+enum PCL_id {
+    PCL_MODE, PCL_EXTENDED, PCL_EXTENDED, PCL_LEGAL, PCL_LETTER,
+    PCL_INVALID
+};
+
+static struct gen_table PCL_opts[] =
+{
+    { "m$ode", PCL_MODE },
+    { "ext$ended", PCL_EXTENDED },
+    { "noext$ended", PCL_NOEXTENDED },
+    { "leg$al", PCL_LEGAL },
+    { "let$ter", PCL_LETTER },
+    { NULL, PCL_INVALID }
+};
+#endif
+
+TERM_PUBLIC void
+PCL_options()
+{
+    int i;
+
+    if (!END_OF_COMMAND && almost_equals(c_token, "m$ode")) {
+	c_token++;
+	if (!END_OF_COMMAND) {
+	    for (i = 0; i < PCL_MODES && !almost_equals(c_token, PCL_mode_table[i].compare); i++);
+	    if (i < PCL_MODES)
+		PCL_mode = &PCL_mode_table[i];
+	    else
+		int_error(c_token, "expecting mode: portrait or landscape");
+	    c_token++;
+	} else
+	    int_error(c_token, "expecting mode: portrait or landscape");
+    }
+    if (!END_OF_COMMAND && almost_equals(c_token, "ext$ended")) {
+	PCL_mode->xmax = (HPGL_XMAX_D);
+	PCL_mode->ymax = (HPGL_YMAX_D - 60);
+	PCL_dim = "extended";
+	c_token++;
+    } else if (!END_OF_COMMAND && almost_equals(c_token, "noext$ended")) {
+	PCL_mode->xmax = (HPGL_XMAX_C);
+	PCL_mode->ymax = (HPGL_YMAX_C - 60);
+	PCL_dim = "noextended";
+	c_token++;
+    } else if (!END_OF_COMMAND && almost_equals(c_token, "leg$al")) {
+	PCL_mode->xmax = (HPGL_XMAX_B);
+	PCL_mode->ymax = (HPGL_YMAX_B - 60);
+	PCL_dim = "legal";
+	c_token++;
+    } else if (!END_OF_COMMAND && almost_equals(c_token, "let$ter")) {
+	PCL_mode->xmax = (HPGL_XMAX_A);
+	PCL_mode->ymax = (HPGL_YMAX_A - 60);
+	PCL_dim = "letter";
+	c_token++;
+    }
+    sprintf(term_options, "%s %s", PCL_mode->name, PCL_dim);
+    HPGL2_options();
+}
+
+TERM_PUBLIC void
+HPGL_init()
+{
+}
+
+/* void HPGL2_init ()
+{
+} */
+
+TERM_PUBLIC void
+PCL_init()
+{
+    struct termentry *t = term;
+/*
+ * Reset printer, set to one copy, orientation of user's choice.
+ * Make the change to the new orientation all at once.
+ */
+    fprintf(gpoutfile, "\033E\033&l1X%s\n", PCL_mode->command);
+    t->xmax = PCL_mode->xmax;
+    t->ymax = PCL_mode->ymax;
+/*
+ * Enter HPGL/2 graphics mode
+ * Necessary here to keep the first DI0,1DI1,0 orientation command from being
+ * printed as literal text on the page for some devices. Hopefully this
+ * workaround has no bad consequences elsewhere; omit this line if it does.
+ */
+    fputs("\033%0B", gpoutfile);
+}
+
+TERM_PUBLIC void
+HPGL_graphics()
+{
+    fputs("\033.Y\n\033.I81;;17:\033.N;19:\033.M500:\n", gpoutfile);
+/*	       1
+	1. enable eavesdropping
+*/
+    fprintf(gpoutfile,
+	    "IN;%s\nSC0,%d,0,%d;\nSR%f,%f;\n",
+	    ((encoding == S_ENC_CP850) || (encoding == S_ENC_ISO8859_1)) ?
+	    "CA7;" : "",
+	    HPGL_XMAX, HPGL_YMAX, ((double) (HPGL_HCHAR) * 200 / 3 / HPGL_XMAX), ((double) (HPGL_VCHAR) * 100 / 2 / HPGL_YMAX));
+/*	 1    2             3
+	1. reset to power-up defaults
+	2. set SCaling
+	3. set character size
+*/
+    HPGL_ang = 0;
+}
+
+TERM_PUBLIC void
+HPGL2_graphics()
+{
+/*
+ * IN - Initialize
+ * SP - Select pen
+ * SD - Set default font
+ */
+    fprintf(gpoutfile, "INSP1SD1,%d,2,%d,", HPGL2_font->symbol_set, HPGL2_font->spacing);
+    if (HPGL2_font->spacing)
+	fprintf(gpoutfile, "4,%f,", HPGL2_font->height);
+    else
+	fprintf(gpoutfile, "3,%f,", HPGL2_font->pitch);
+    fprintf(gpoutfile, "5,%d,6,%d,7,%d;SS;\n", HPGL2_font->posture, HPGL2_font->stroke_weight, HPGL2_font->typeface);
+/*
+ * Add a set of user-defined dashed linetypes if the dashed option is
+ * selected. Of course, the UL's below can be edited to user preference.
+ */
+    if (HPGL2_solid == 0) {
+	fputs("\
+UL1,100;\n\
+UL2,8,8,9,8,8,9,8,8,9,8,8,9;\n\
+UL3,6,6,6,7,6,6,6,7,6,6,6,7,6,6,6,7;\n\
+UL4,5,5,5,10,5,5,5,10,5,5,5,10;\n\
+UL5,5,5,5,5,5,8,5,5,5,5,5,8,5,5,5,5,5,9;\n\
+UL6,8,8,0,9,8,8,0,9,8,8,0,9;\n\
+UL7,4,4,4,4,0,4,4,4,4,4,0,4,4,4,4,4,0,4;\n\
+UL8,6,6,6,6,6,6,0,6,6,6,6,6,6,6,0,6;\n",
+		gpoutfile);
+    }
+/*
+ * Control variables
+ */
+    HPGL_ang = 0;		/* Horizontal */
+    HPGL2_in_pe = FALSE;	/* Not in PE command */
+    HPGL2_lost = TRUE;		/* Pen position is unknown */
+    HPGL_penstate = UP;		/* Pen is up */
+}
+
+TERM_PUBLIC void
+PCL_graphics()
+{
+/*
+ * Enter HPGL/2 graphics mode
+ */
+    fputs("\033%0B", gpoutfile);
+    HPGL2_graphics();
+}
+
+TERM_PUBLIC void
+HPGL_text()
+{
+    if (HPGL_eject == 0) {
+	fputs("PUSP0;\033.Z\n\0", gpoutfile);
+/*		 1 2   3
+	1. pen up
+	2. park pen
+	3. disable eavesdropping
+*/
+    } else {
+	fputs("PUSP0;PG;\033.Z\n\0", gpoutfile);
+/*		 1 2   3  4
+	1. pen up
+	2. park pen
+	3. page eject
+	4. disable eavesdropping
+*/
+    }
+    HPGL_penstate = UP;
+}
+
+#if 0				/* not used */
+void
+HPGL2_text()
+{
+/*
+ * If in Polyline Encoded command, leave Polyline Encoded command
+ */
+    if (HPGL2_in_pe) {
+	fputs(";\n", gpoutfile);
+	HPGL2_in_pe = 0;
+    }
+/*
+ * Pen up, park pen
+ */
+    fputs("PUSP0;", gpoutfile);
+    HPGL_penstate = UP;
+}
+#endif
+
+TERM_PUBLIC void
+PCL_text()
+{
+    if (HPGL2_in_pe) {
+	fputs(";\n", gpoutfile);
+	HPGL2_in_pe = 0;
+    }
+/*
+ * Go into PCL mode and eject the page
+ */
+    fputs("\033%1A\033&l0H\n\0", gpoutfile);
+}
+
+TERM_PUBLIC void
+HPGL_linetype(int linetype)
+{
+    if (linetype < -2)
+	linetype = LT_BLACK;
+/* allow for set number of pens */
+    linetype = (linetype + 2) % HPGL_numpen + 1;
+/* only select pen if necessary */
+    if (HPGL_pentype != linetype) {
+	fprintf(gpoutfile, "PU;\nSP%d;\n", linetype);
+	HPGL_pentype = linetype;
+	HPGL_penstate = UP;
+    }
+}
+
+TERM_PUBLIC void
+HPGL2_linetype(int linetype)
+{
+/*
+ * If in Polyline Encoded command, leave Polyline Encoded command
+ */
+    if (HPGL2_in_pe) {
+	fputs(";\n", gpoutfile);
+	HPGL2_in_pe = 0;
+    }
+/* allow for set number of pens for color displays */
+    if (HPGL2_color == 1) {
+	if (linetype >= 0) {
+	    if (HPGL2_solid == 0)
+		HPGL2_dashed = linetype % HPGL2_LINETYPES + 1;
+	    linetype = (linetype + 2) % HPGL2_numpen + 1;
+	}
+/* only select pen if necessary */
+	if (linetype != HPGL2_pentype) {
+	    if (linetype >= 0) {
+		if (HPGL2_solid == 0) {
+		    fprintf(gpoutfile, "PU;\nSP%d;\nLT%d;", linetype, HPGL2_dashed);
+		} else
+		    fprintf(gpoutfile, "PU;\nSP%d;\nLT;", linetype);
+/* Borders and Tics */
+	    } else if (linetype == LT_BLACK) {
+		fprintf(gpoutfile, "PU;\nSP1;\nPW.2LT");
+/* Axes and Grids */
+	    } else if (linetype == LT_AXIS)
+		fprintf(gpoutfile, "PU;\nSP1;\nPW.2LT1,.25");
+	    HPGL_penstate = UP;
+	    HPGL2_pentype = linetype;
+	}
+/* allow for lots of linetypes for monochrome displays */
+    } else {
+	if (linetype >= 0) {
+	    if (HPGL2_solid == 0)
+		HPGL2_dashed = linetype % HPGL2_LINETYPES + 1;
+	    linetype = linetype % (HPGL2_LINETYPES * HPGL2_PENWIDTHS);
+	}
+/* only select pen if necessary */
+	if (linetype != HPGL2_pentype) {
+	    if (linetype >= 0) {
+		if (HPGL2_solid == 0) {
+		    fprintf(gpoutfile, "PW%sLT%d%s", HPGL2_pw[linetype / HPGL2_LINETYPES], HPGL2_dashed,
+			    HPGL2_lt[linetype % HPGL2_LINETYPES]);
+		} else
+		    fprintf(gpoutfile, "PW%sLT", HPGL2_pw[linetype / HPGL2_LINETYPES]);
+/* Borders and Tics */
+	    } else if (linetype == LT_BLACK) {
+		fprintf(gpoutfile, "PW.2LT");
+/* Axes and Grids */
+	    } else if (linetype == LT_AXIS)
+		fprintf(gpoutfile, "PW.1LT1,.25");
+	    HPGL2_pentype = linetype;
+	}
+    }
+}
+
+TERM_PUBLIC void
+HPGL_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    if (HPGL_ang == 1)
+	HPGL_move(x + HPGL_VCHAR / 4, y);
+    else
+	HPGL_move(x, y - HPGL_VCHAR / 4);
+    if (encoding == S_ENC_CP850) {
+	unsigned char *s;
+	fputs("LB", gpoutfile);
+	for (s = (unsigned char *) str; *s; ++s)
+	    if (*s >= 128 && hpgl_cp_850[*s - 128][0])
+		fputs(hpgl_cp_850[*s - 128], gpoutfile);
+	    else
+		putc(*s, gpoutfile);
+	fputs("\003\n", gpoutfile);
+    } else if (encoding == S_ENC_ISO8859_1) {
+	unsigned char *s;
+	fputs("LB", gpoutfile);
+	for (s = (unsigned char *) str; *s; ++s)
+	    if (*s >= 128 && hpgl_iso_8859_1[*s - 128][0])
+		fputs(hpgl_iso_8859_1[*s - 128], gpoutfile);
+	    else
+		putc(*s, gpoutfile);
+	fputs("\003\n", gpoutfile);
+    } else
+	fprintf(gpoutfile, "LB%s\003\n", str);
+}
+
+TERM_PUBLIC void
+HPGL2_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    struct termentry *t = term;
+/*
+ * Position the pen
+ */
+    if (HPGL_ang == 1)
+	HPGL2_move(x + t->v_char / 4, y);
+    else
+	HPGL2_move(x, y - t->v_char / 4);
+/*
+ * If in Polyline Encoded command, leave Polyline Encoded command
+ */
+    if (HPGL2_in_pe) {
+	fputs(";\n", gpoutfile);
+	HPGL2_in_pe = 0;
+    }
+/*
+ * Print the text string
+ */
+    fprintf(gpoutfile, "LB%s\003\n", str);
+    HPGL2_lost = 1;
+}
+
+/*
+ * Some early HPGL plotters (e.g. HP7220C) require the
+ * Pen Up/Down and Pen (move) Absolute commands to be separate.
+ */
+
+TERM_PUBLIC void
+HPGL_move(unsigned int x, unsigned int y)
+{
+    if (HPGL_x != x || HPGL_y != y) {	/* only move if necessary */
+	fprintf(gpoutfile, "PU;PA%d,%d;\n", x, y);
+	HPGL_penstate = UP;
+	HPGL_x = x;
+	HPGL_y = y;
+    }
+}
+
+TERM_PUBLIC void
+HPGL_vector(unsigned int x, unsigned int y)
+{
+    if (HPGL_penstate != DOWN) {
+	fprintf(gpoutfile, "PD;PA%d,%d;\n", x, y);
+	HPGL_penstate = DOWN;
+    } else
+	fprintf(gpoutfile, "PA%d,%d;\n", x, y);
+    HPGL_x = x;
+    HPGL_y = y;
+}
+
+TERM_PUBLIC void
+HPGL2_move(unsigned int x, unsigned int y)
+{
+    int dx, dy;
+    if (HPGL2_in_pe) {
+	dx = x - HPGL_x;
+	dy = y - HPGL_y;
+	fputs("<", gpoutfile);
+    } else {
+#if HPGL2_BASE64
+	fputs("PE<", gpoutfile);
+#else
+	fputs("PE7<", gpoutfile);
+#endif
+	if (HPGL2_lost) {
+	    dx = x;
+	    dy = y;
+	    HPGL2_lost = 0;
+	    fputs("=", gpoutfile);
+	} else {
+	    dx = x - HPGL_x;
+	    dy = y - HPGL_y;
+	}
+	HPGL2_in_pe = 1;
+    }
+#if HPGL2_EXPLICIT_PD
+    if (HPGL_penstate == DOWN)
+	HPGL_penstate = UP;
+#endif
+    HPGL2_encode(dx);
+    HPGL2_encode(dy);
+    fputs("\n", gpoutfile);
+    HPGL_x = x;
+    HPGL_y = y;
+}
+
+TERM_PUBLIC void
+HPGL2_vector(unsigned int x, unsigned int y)
+{
+    int dx, dy;
+    if (HPGL2_in_pe) {
+	dx = x - HPGL_x;
+	dy = y - HPGL_y;
+    } else {
+#if HPGL2_BASE64
+	fputs("PE", gpoutfile);
+#else
+	fputs("PE7", gpoutfile);
+#endif
+	if (HPGL2_lost) {
+	    dx = x;
+	    dy = y;
+	    HPGL2_lost = 0;
+	    fputs("=", gpoutfile);
+	} else {
+	    dx = x - HPGL_x;
+	    dy = y - HPGL_y;
+	}
+	HPGL2_in_pe = 1;
+    }
+#if HPGL2_EXPLICIT_PD
+/*
+ * Put the pen down in the current position,
+ * relative vector of 0,0.
+ */
+    if (HPGL_penstate == UP) {
+	fputc((char) HPGL2_HIGH_OFFS, gpoutfile);
+	fputc((char) HPGL2_HIGH_OFFS, gpoutfile);
+	HPGL_penstate = DOWN;
+    }
+#endif
+    HPGL2_encode(dx);
+    HPGL2_encode(dy);
+    fputs("\n", gpoutfile);
+    HPGL_x = x;
+    HPGL_y = y;
+}
+
+/*
+ * Routine to encode position in base 32 or base 64 characters
+ */
+
+TERM_PUBLIC void
+HPGL2_encode(int d)
+{
+    int c;
+
+    if ((d <<= 1) < 0)
+	d = 1 - d;
+    do {
+	c = d & HPGL2_MASK;
+	d >>= HPGL2_BITS;
+	if (d > 0)
+	    fputc((char) (c + HPGL2_LOW_OFFS), gpoutfile);
+	else
+	    fputc((char) (c + HPGL2_HIGH_OFFS), gpoutfile);
+    } while (d > 0);
+}
+
+TERM_PUBLIC int
+HPGL_text_angle(int ang)
+{
+    if (ang == -90 || ang == 270)
+	HPGL_ang = -1;
+    else
+	HPGL_ang = (ang ? 1 : 0);
+
+    if (HPGL_ang == 0) 			/* Horizontal */
+	fputs("DI1,0;\n", gpoutfile);
+    else if (HPGL_ang == -1)		/* Vertical Down */
+	fputs("DI0,-1;\n", gpoutfile);
+    else				/* Vertical Up */
+	fputs("DI0,1;\n", gpoutfile);
+    return TRUE;
+}
+
+TERM_PUBLIC int
+HPGL2_text_angle(int ang)
+{
+/*
+ * If in Polyline Encoded command, leave Polyline Encoded command
+ */
+    if (ang == -90 || ang == 270)
+	HPGL_ang = -1;
+    else
+	HPGL_ang = (ang ? 1 : 0);
+
+    if (HPGL2_in_pe) {
+	fputs(";", gpoutfile);
+	HPGL2_in_pe = 0;
+    }
+    if (HPGL_ang == 1)			/* Vertical Up */
+	fputs("DI0,1", gpoutfile);
+    else if (HPGL_ang == -1)		/* Vertical Down */
+	fputs("DI0,-1", gpoutfile);
+    else				/* Horizontal */
+	fputs("DI1,0", gpoutfile);
+    return TRUE;
+}
+
+TERM_PUBLIC void
+HPGL_reset()
+{
+/*
+ * do nothing
+ */
+}
+
+#if 0
+void
+HPGL2_reset()
+{
+/*
+ * Park the pen
+ * Advance a page
+ * End with ";"
+ */
+    fputs("SP0PG;\n", gpoutfile);
+}
+
+#endif
+
+TERM_PUBLIC void
+PCL_reset()
+{
+/*
+ * Return to PCL mode
+ * Printer reset (conditional eject)
+ */
+    fputs("\033%0A\033E\n", gpoutfile);
+}
+
+TERM_PUBLIC int
+HPGL2_justify_text(enum JUSTIFY just)
+{
+/*
+ * If in Polyline Encoded command, leave Polyline Encoded command
+ */
+    if (HPGL2_in_pe) {
+	fputs(";\n", gpoutfile);
+	HPGL2_in_pe = 0;
+    }
+    switch (just) {
+    case LEFT:
+	fputs("LO1", gpoutfile);
+	break;
+    case CENTRE:
+	fputs("LO4", gpoutfile);
+	break;
+    case RIGHT:
+	fputs("LO7", gpoutfile);
+	break;
+    default:
+	return 0;
+    }
+    return 1;
+}
+
+TERM_PUBLIC int
+HPGL2_set_font(const char *font)
+{
+    struct termentry *t = term;
+    char name[MAX_ID_LEN + 1];
+    int i, sep, int_size, sep2;
+    double size;
+/*
+ * If in Polyline Encoded command, leave Polyline Encoded command
+ */
+    if (HPGL2_in_pe) {
+	fputs(";\n", gpoutfile);
+	HPGL2_in_pe = 0;
+    }
+/* determine font, use default from options if invalid */
+    sep = strcspn(font, ",");
+    strncpy(name, font, sep);
+    name[sep] = NUL;
+    for (i = 0; i < HPGL2_FONTS; i++) {
+	sep2 = strcspn(HPGL2_font_table[i].compare, "$");
+	if (strncmp(name, HPGL2_font_table[i].compare, sep2) == 0)
+	    break;
+    }
+    if (i >= HPGL2_FONTS)
+	i = HPGL2_font_num;
+/* determine font size, use default from options if invalid */
+    int_size = 0;
+    sscanf(&(font[sep + 1]), "%d", &int_size);
+    if (int_size > 0) {
+	size = int_size;
+    } else
+	size = HPGL2_point_size;
+/* apply font changes only if necessary */
+    if (size == HPGL2_point_size_current && i == HPGL2_font_num_current)
+	return FALSE;
+    HPGL2_font = &HPGL2_font_table[i];
+    HPGL2_font_num_current = i;
+    HPGL2_point_size_current = size;
+    t->v_char = (int) HPGL_PUPI *HPGL2_point_size_current / 72;
+    t->h_char = t->v_char * 2 / 3;
+    fprintf(gpoutfile, "SD1,%d,2,%d,", HPGL2_font->symbol_set, HPGL2_font->spacing);
+    if (HPGL2_font->spacing) {
+	HPGL2_font->height = HPGL2_point_size_current;
+	fprintf(gpoutfile, "4,%f,", HPGL2_font->height);
+    } else {
+	HPGL2_font->pitch = 72 * 3 / (HPGL2_point_size_current * 2);
+	fprintf(gpoutfile, "3,%f,", HPGL2_font->pitch);
+    }
+    fprintf(gpoutfile, "5,%d,6,%d,7,%d;SS;\n", HPGL2_font->posture, HPGL2_font->stroke_weight, HPGL2_font->typeface);
+    return TRUE;
+}
+
+TERM_PUBLIC void
+HPGL2_point(unsigned int x, unsigned int y, int number)
+{
+    int htic, vtic;
+    if (pspointset) {		/* postscript style points */
+	if (number < 0) {
+	    HPGL2_neg_point(x, y, number);
+	} else {
+	    htic = (int) (HPGL2_psize * PCL_HTIC / 2);
+	    vtic = (int) (HPGL2_psize * PCL_VTIC / 2);
+	    number %= HPGL2_NUM_PSPOINTS;
+	    switch (number) {
+	    case 0:		/* plus */
+		HPGL2_move(x - htic, y);
+		HPGL2_vector(x - htic, y);
+		HPGL2_vector(x + htic, y);
+		HPGL2_move(x, y - vtic);
+		HPGL2_vector(x, y - vtic);
+		HPGL2_vector(x, y + vtic);
+		break;
+	    case 1:		/* X */
+		HPGL2_move(x - htic, y - vtic);
+		HPGL2_vector(x - htic, y - vtic);
+		HPGL2_vector(x + htic, y + vtic);
+		HPGL2_move(x - htic, y + vtic);
+		HPGL2_vector(x - htic, y + vtic);
+		HPGL2_vector(x + htic, y - vtic);
+		break;
+	    case 2:		/* star */
+		HPGL2_move(x - htic, y);
+		HPGL2_vector(x - htic, y);
+		HPGL2_vector(x + htic, y);
+		HPGL2_move(x, y - vtic);
+		HPGL2_vector(x, y - vtic);
+		HPGL2_vector(x, y + vtic);
+		HPGL2_move(x - htic, y - vtic);
+		HPGL2_vector(x - htic, y - vtic);
+		HPGL2_vector(x + htic, y + vtic);
+		HPGL2_move(x - htic, y + vtic);
+		HPGL2_vector(x - htic, y + vtic);
+		HPGL2_vector(x + htic, y - vtic);
+		break;
+	    case 3:		/* hollow square 1 */
+		HPGL2_move(x - (3 * htic / 4), y - (3 * vtic / 4));
+		HPGL2_vector(x + (3 * htic / 4), y - (3 * vtic / 4));
+		HPGL2_vector(x + (3 * htic / 4), y + (3 * vtic / 4));
+		HPGL2_vector(x - (3 * htic / 4), y + (3 * vtic / 4));
+		HPGL2_vector(x - (3 * htic / 4), y - (3 * vtic / 4));
+		HPGL2_move(x, y);
+		HPGL2_vector(x, y);
+		break;
+	    case 4:		/* solid square 1 */
+		HPGL2_move(x - (3 * htic / 4), y - (3 * vtic / 4));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "RA%.2f,%.2f;EP;\n", ((double) x + (3 * htic / 4)), ((double) y + (3 * vtic / 4)));
+		break;
+	    case 5:		/* hollow circle 1 */
+		HPGL2_move(x, y);
+		HPGL2_vector(x, y);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "CI%.2f;\n", ((double) 3 * (htic) / 4));
+		break;
+	    case 6:		/* solid circle 1 */
+		HPGL2_move(x, y);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "WG%.2f,0,360;EP;\n", ((double) 3 * (htic) / 4));
+		break;
+	    case 7:		/* hollow triangle 1 */
+		HPGL2_move(x, y + (3 * vtic / 4));
+		HPGL2_vector(x - (3 * sqrt(3) * htic / 8), y - (3 * vtic / 8));
+		HPGL2_vector(x + (3 * sqrt(3) * htic / 8), y - (3 * vtic / 8));
+		HPGL2_vector(x, y + (3 * vtic / 4));
+		HPGL2_move(x, y);
+		HPGL2_vector(x, y);
+		break;
+	    case 8:		/* solid triangle 1 */
+		HPGL2_move(x, y + (3 * vtic / 4));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM0;\n");
+		HPGL2_vector(x - (3 * sqrt(3) * htic / 8), y - (3 * vtic / 8));
+		HPGL2_vector(x + (3 * sqrt(3) * htic / 8), y - (3 * vtic / 8));
+		HPGL2_vector(x, y + (3 * vtic / 4));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM2;FP;EP;\n");
+		break;
+	    case 9:		/* hollow triangle 2 */
+		HPGL2_move(x, y - (3 * vtic / 4));
+		HPGL2_vector(x - (3 * sqrt(3) * htic / 8), y + (3 * vtic / 8));
+		HPGL2_vector(x + (3 * sqrt(3) * htic / 8), y + (3 * vtic / 8));
+		HPGL2_vector(x, y - (3 * vtic / 4));
+		HPGL2_move(x, y);
+		HPGL2_vector(x, y);
+		break;
+	    case 10:		/* solid triangle 2 */
+		HPGL2_move(x, y - (3 * vtic / 4));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM0;\n");
+		HPGL2_vector(x - (3 * sqrt(3) * htic / 8), y + (3 * vtic / 8));
+		HPGL2_vector(x + (3 * sqrt(3) * htic / 8), y + (3 * vtic / 8));
+		HPGL2_vector(x, y - (3 * vtic / 4));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM2;FP;EP;\n");
+		break;
+	    case 11:		/* hollow diamond 1 */
+		HPGL2_move(x - (3 * htic / 4), y);
+		HPGL2_vector(x, y - (3 * vtic / 4));
+		HPGL2_vector(x + (3 * htic / 4), y);
+		HPGL2_vector(x, y + (3 * vtic / 4));
+		HPGL2_vector(x - (3 * htic / 4), y);
+		HPGL2_move(x, y);
+		HPGL2_vector(x, y);
+		break;
+	    case 12:		/* solid diamond 1 */
+		HPGL2_move(x - (3 * htic / 4), y);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM0;\n");
+		HPGL2_vector(x, y - (3 * vtic / 4));
+		HPGL2_vector(x + (3 * htic / 4), y);
+		HPGL2_vector(x, y + (3 * vtic / 4));
+		HPGL2_vector(x - (3 * htic / 4), y);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM2;FP;EP;\n");
+		break;
+	    case 13:		/* hollow pentagon 1 */
+		HPGL2_move(x, y + (3 * vtic / 4));
+		HPGL2_vector(x - (cos(.1 * acos(-1)) * 3 * htic / 4), y + (sin(.1 * acos(-1)) * 3 * vtic / 4));
+		HPGL2_vector(x - (sin(.2 * acos(-1)) * 3 * htic / 4), y - (cos(.2 * acos(-1)) * 3 * vtic / 4));
+		HPGL2_vector(x + (sin(.2 * acos(-1)) * 3 * htic / 4), y - (cos(.2 * acos(-1)) * 3 * vtic / 4));
+		HPGL2_vector(x + (cos(.1 * acos(-1)) * 3 * htic / 4), y + (sin(.1 * acos(-1)) * 3 * vtic / 4));
+		HPGL2_vector(x, y + (3 * vtic / 4));
+		HPGL2_move(x, y);
+		HPGL2_vector(x, y);
+		break;
+	    case 14:		/* solid pentagon */
+		HPGL2_move(x, y + (3 * vtic / 4));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM0;\n");
+		HPGL2_vector(x - (cos(.1 * acos(-1)) * 3 * htic / 4), y + (sin(.1 * acos(-1)) * 3 * vtic / 4));
+		HPGL2_vector(x - (sin(.2 * acos(-1)) * 3 * htic / 4), y - (cos(.2 * acos(-1)) * 3 * vtic / 4));
+		HPGL2_vector(x + (sin(.2 * acos(-1)) * 3 * htic / 4), y - (cos(.2 * acos(-1)) * 3 * vtic / 4));
+		HPGL2_vector(x + (cos(.1 * acos(-1)) * 3 * htic / 4), y + (sin(.1 * acos(-1)) * 3 * vtic / 4));
+		HPGL2_vector(x, y + (3 * vtic / 4));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM2;FP;EP;\n");
+		break;
+	    case 15:		/* hollow circle 2 */
+		HPGL2_move(x, y + vtic);
+		HPGL2_vector(x, y);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "CI%d;\n", htic);
+		break;
+	    case 16:		/* semisolid circle 1 */
+		HPGL2_move(x, y);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "WG%d,0,90;EP;EW%d,90,270;\n", htic, htic);
+		break;
+	    case 17:		/* semisolid circle 2 */
+		HPGL2_move(x, y);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "WG%d,90,90;EP;EW%d,180,270;\n", htic, htic);
+		break;
+	    case 18:		/* semisolid circle 3 */
+		HPGL2_move(x, y);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "WG%d,0,180;EP;EW%d,180,180;\n", htic, htic);
+		break;
+	    case 19:		/* semisolid circle 4 */
+		HPGL2_move(x, y);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "WG%d,180,90;EP;EW%d,270,270;\n", htic, htic);
+		break;
+	    case 20:		/* semisolid circle 5 */
+		HPGL2_move(x, y);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "WG%d,0,90;EP;EW%d,90,90;WG%d,180,90;EP;EW%d,270,90;\n", htic, htic, htic, htic);
+		break;
+	    case 21:		/* semisolid circle 6 */
+		HPGL2_move(x, y);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "WG%d,90,180;EP;EW%d,270,180;\n", htic, htic);
+		break;
+	    case 22:		/* semisolid circle 7 */
+		HPGL2_move(x, y);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "WG%d,0,270;EP;EW%d,270,90;\n", htic, htic);
+		break;
+	    case 23:		/* semisolid circle 8 */
+		HPGL2_move(x, y);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "WG%d,270,90;EP;EW%d,0,270;\n", htic, htic);
+		break;
+	    case 24:		/* semisolid circle 9 */
+		HPGL2_move(x, y);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "WG%d,270,180;EP;EW%d,90,180;\n", htic, htic);
+		break;
+	    case 25:		/* semisolid circle 10 */
+		HPGL2_move(x, y);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "WG%d,90,90;EP;EW%d,180,90;WG%d,270,90;EP;EW%d,0,90;\n", htic, htic, htic, htic);
+		break;
+	    case 26:		/* semisolid circle 11 */
+		HPGL2_move(x, y);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "WG%d,270,270;EP;EW%d,180,90;\n", htic, htic);
+		break;
+	    case 27:		/* semisolid circle 12 */
+		HPGL2_move(x, y);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "WG%d,180,180;EP;EW%d,0,180;\n", htic, htic);
+		break;
+	    case 28:		/* semisolid circle 13 */
+		HPGL2_move(x, y);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "WG%d,180,270;EP;EW%d,90,90;\n", htic, htic);
+		break;
+	    case 29:		/* semisolid circle 14 */
+		HPGL2_move(x, y);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "WG%d,90,270;EP;EW%d,0,90;\n", htic, htic);
+		break;
+	    case 30:		/* solid circle 2 */
+		HPGL2_move(x, y);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "WG%d,0,360;EP;\n", htic);
+		break;
+	    case 31:		/* hollow square 2 */
+		HPGL2_move(x - htic, y - vtic);
+		HPGL2_vector(x + htic, y - vtic);
+		HPGL2_vector(x + htic, y + vtic);
+		HPGL2_vector(x - htic, y + vtic);
+		HPGL2_vector(x - htic, y - vtic);
+		HPGL2_move(x, y + vtic);
+		HPGL2_vector(x, y);
+		break;
+	    case 32:		/* semisolid square 1 */
+		HPGL2_move(x, y + vtic);
+		HPGL2_vector(x - htic, y + vtic);
+		HPGL2_vector(x - htic, y - vtic);
+		HPGL2_vector(x + htic, y - vtic);
+		HPGL2_vector(x + htic, y);
+		HPGL2_move(x, y);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "RA%d,%d;EP;\n", x + htic, y + vtic);
+		break;
+	    case 33:		/* semisolid square 2 */
+		HPGL2_move(x - htic, y);
+		HPGL2_vector(x - htic, y - vtic);
+		HPGL2_vector(x + htic, y - vtic);
+		HPGL2_vector(x + htic, y + vtic);
+		HPGL2_vector(x, y + vtic);
+		HPGL2_move(x - htic, y);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "RA%d,%d;EP;\n", x, y + vtic);
+		break;
+	    case 34:		/* semisolid square 3 */
+		HPGL2_move(x - htic, y);
+		HPGL2_vector(x - htic, y - vtic);
+		HPGL2_vector(x + htic, y - vtic);
+		HPGL2_vector(x + htic, y);
+		HPGL2_move(x - htic, y);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "RA%d,%d;EP;\n", x + htic, y + vtic);
+		break;
+	    case 35:		/* semisolid square 4 */
+		HPGL2_move(x, y - vtic);
+		HPGL2_vector(x + htic, y - vtic);
+		HPGL2_vector(x + htic, y + vtic);
+		HPGL2_vector(x - htic, y + vtic);
+		HPGL2_vector(x - htic, y);
+		HPGL2_move(x - htic, y - vtic);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "RA%d,%d;EP;\n", x, y);
+		break;
+	    case 36:		/* semisolid square 5 */
+		HPGL2_move(x, y - vtic);
+		HPGL2_vector(x + htic, y - vtic);
+		HPGL2_vector(x + htic, y);
+		HPGL2_move(x, y + vtic);
+		HPGL2_vector(x - htic, y + vtic);
+		HPGL2_vector(x - htic, y);
+		HPGL2_move(x - htic, y - vtic);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "RA%d,%d;EP;\n", x, y);
+		HPGL2_move(x, y);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "RA%d,%d;EP;\n", x + htic, y + vtic);
+		break;
+	    case 37:		/* semisolid square 6 */
+		HPGL2_move(x, y - vtic);
+		HPGL2_vector(x + htic, y - vtic);
+		HPGL2_vector(x + htic, y + vtic);
+		HPGL2_vector(x, y + vtic);
+		HPGL2_move(x - htic, y - vtic);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "RA%d,%d;EP;\n", x, y + vtic);
+		break;
+	    case 38:		/* semisolid square 7 */
+		HPGL2_move(x, y - vtic);
+		HPGL2_vector(x + htic, y - vtic);
+		HPGL2_vector(x + htic, y);
+		HPGL2_move(x - htic, y - vtic);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "RA%d,%d;EP;\n", x, y + vtic);
+		HPGL2_move(x, y);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "RA%d,%d;EP;\n", x + htic, y + vtic);
+		break;
+	    case 39:		/* semisolid square 8 */
+		HPGL2_move(x + htic, y);
+		HPGL2_vector(x + htic, y + vtic);
+		HPGL2_vector(x - htic, y + vtic);
+		HPGL2_vector(x - htic, y - vtic);
+		HPGL2_vector(x, y - vtic);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "RA%d,%d;EP;\n", x + htic, y);
+		break;
+	    case 40:		/* semisolid square 9 */
+		HPGL2_move(x, y + vtic);
+		HPGL2_vector(x - htic, y + vtic);
+		HPGL2_vector(x - htic, y - vtic);
+		HPGL2_vector(x, y - vtic);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "RA%d,%d;EP;\n", x + htic, y + vtic);
+		break;
+	    case 41:		/* semisolid square 10 */
+		HPGL2_move(x - htic, y);
+		HPGL2_vector(x - htic, y - vtic);
+		HPGL2_vector(x, y - vtic);
+		HPGL2_move(x + htic, y);
+		HPGL2_vector(x + htic, y + vtic);
+		HPGL2_vector(x, y + vtic);
+		HPGL2_move(x - htic, y);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "RA%d,%d;EP;\n", x, y + vtic);
+		HPGL2_move(x, y - vtic);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "RA%d,%d;EP;\n", x + htic, y);
+		break;
+	    case 42:		/* semisolid square 11 */
+		HPGL2_move(x - htic, y);
+		HPGL2_vector(x - htic, y - vtic);
+		HPGL2_vector(x, y - vtic);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "RA%d,%d;EP;\n", x + htic, y + vtic);
+		HPGL2_move(x - htic, y);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "RA%d,%d;EP;\n", x, y + vtic);
+		break;
+	    case 43:		/* semisolid square 12 */
+		HPGL2_move(x + htic, y);
+		HPGL2_vector(x + htic, y + vtic);
+		HPGL2_vector(x - htic, y + vtic);
+		HPGL2_vector(x - htic, y);
+		HPGL2_move(x - htic, y - vtic);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "RA%d,%d;EP;\n", x + htic, y);
+		break;
+	    case 44:		/* semisolid square 13 */
+		HPGL2_move(x, y + vtic);
+		HPGL2_vector(x - htic, y + vtic);
+		HPGL2_vector(x - htic, y);
+		HPGL2_move(x - htic, y - vtic);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "RA%d,%d;EP;\n", x + htic, y);
+		HPGL2_move(x, y);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "RA%d,%d;EP;\n", x + htic, y + vtic);
+		break;
+	    case 45:		/* semisolid square 14 */
+		HPGL2_move(x + htic, y);
+		HPGL2_vector(x + htic, y + vtic);
+		HPGL2_vector(x, y + vtic);
+		HPGL2_move(x - htic, y - vtic);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "RA%d,%d;EP;\n", x + htic, y);
+		HPGL2_move(x - htic, y);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "RA%d,%d;EP;\n", x, y + vtic);
+		break;
+	    case 46:		/* solid square 2 */
+		HPGL2_move(x - htic, y - vtic);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "RA%d,%d;EP;\n", x + htic, y + vtic);
+		break;
+	    case 47:		/* hollow diamond 2 */
+		HPGL2_move(x - htic, y);
+		HPGL2_vector(x, y - vtic);
+		HPGL2_vector(x + htic, y);
+		HPGL2_vector(x, y + vtic);
+		HPGL2_vector(x - htic, y);
+		HPGL2_move(x - (htic / 2), y + (vtic / 2));
+		HPGL2_vector(x, y);
+		break;
+	    case 48:		/* semisolid diamond 1 */
+		HPGL2_move(x - (htic / 2), y + (vtic / 2));
+		HPGL2_vector(x - htic, y);
+		HPGL2_vector(x, y - vtic);
+		HPGL2_vector(x + htic, y);
+		HPGL2_vector(x + (htic / 2), y + (vtic / 2));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM0;\n");
+		HPGL2_vector(x, y + vtic);
+		HPGL2_vector(x - (htic / 2), y + (vtic / 2));
+		HPGL2_vector(x, y);
+		HPGL2_vector(x + (htic / 2), y + (vtic / 2));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM2;FP;EP;\n");
+		break;
+	    case 49:		/* semisolid diamond 2 */
+		HPGL2_move(x - (htic / 2), y - (vtic / 2));
+		HPGL2_vector(x, y - vtic);
+		HPGL2_vector(x + htic, y);
+		HPGL2_vector(x, y + vtic);
+		HPGL2_vector(x - (htic / 2), y + (vtic / 2));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM0;\n");
+		HPGL2_vector(x - htic, y);
+		HPGL2_vector(x - (htic / 2), y - (vtic / 2));
+		HPGL2_vector(x, y);
+		HPGL2_vector(x - (htic / 2), y + (vtic / 2));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM2;FP;EP;\n");
+		break;
+	    case 50:		/* semisolid diamond 3 */
+		HPGL2_move(x - (htic / 2), y - (vtic / 2));
+		HPGL2_vector(x, y - vtic);
+		HPGL2_vector(x + htic, y);
+		HPGL2_vector(x + (htic / 2), y + (vtic / 2));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM0;\n");
+		HPGL2_vector(x - (htic / 2), y - (vtic / 2));
+		HPGL2_vector(x - htic, y);
+		HPGL2_vector(x, y + vtic);
+		HPGL2_vector(x + (htic / 2), y + (vtic / 2));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM2;FP;EP;\n");
+		break;
+	    case 51:		/* semisolid diamond 4 */
+		HPGL2_move(x + (htic / 2), y - (vtic / 2));
+		HPGL2_vector(x + htic, y);
+		HPGL2_vector(x, y + vtic);
+		HPGL2_vector(x - htic, y);
+		HPGL2_vector(x - (htic / 2), y - (vtic / 2));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM0;\n");
+		HPGL2_vector(x, y);
+		HPGL2_vector(x + (htic / 2), y - (vtic / 2));
+		HPGL2_vector(x, y - vtic);
+		HPGL2_vector(x - (htic / 2), y - (vtic / 2));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM2;FP;EP;\n");
+		break;
+	    case 52:		/* semisolid diamond 5 */
+		HPGL2_move(x - (htic / 2), y + (vtic / 2));
+		HPGL2_vector(x - htic, y);
+		HPGL2_vector(x - (htic / 2), y - (vtic / 2));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM0;\n");
+		HPGL2_vector(x, y);
+		HPGL2_vector(x + (htic / 2), y - (vtic / 2));
+		HPGL2_vector(x, y - vtic);
+		HPGL2_vector(x - (htic / 2), y - (vtic / 2));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM2;FP;EP;\n");
+		HPGL2_move(x + (htic / 2), y - (vtic / 2));
+		HPGL2_vector(x + htic, y);
+		HPGL2_vector(x + (htic / 2), y + (vtic / 2));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM0;\n");
+		HPGL2_vector(x, y + vtic);
+		HPGL2_vector(x - (htic / 2), y + (vtic / 2));
+		HPGL2_vector(x, y);
+		HPGL2_vector(x + (htic / 2), y + (vtic / 2));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM2;FP;EP;\n");
+		break;
+	    case 53:		/* semisolid diamond 6 */
+		HPGL2_move(x + (htic / 2), y - (vtic / 2));
+		HPGL2_vector(x + htic, y);
+		HPGL2_vector(x, y + vtic);
+		HPGL2_vector(x - (htic / 2), y + (vtic / 2));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM0;\n");
+		HPGL2_vector(x - htic, y);
+		HPGL2_vector(x, y - vtic);
+		HPGL2_vector(x + (htic / 2), y - (vtic / 2));
+		HPGL2_vector(x - (htic / 2), y + (vtic / 2));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM2;FP;EP;\n");
+		break;
+	    case 54:		/* semisolid diamond 7 */
+		HPGL2_move(x + (htic / 2), y - (vtic / 2));
+		HPGL2_vector(x + htic, y);
+		HPGL2_vector(x + (htic / 2), y + (vtic / 2));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM0;\n");
+		HPGL2_vector(x, y + vtic);
+		HPGL2_vector(x - htic, y);
+		HPGL2_vector(x, y - vtic);
+		HPGL2_vector(x + (htic / 2), y - (vtic / 2));
+		HPGL2_vector(x, y);
+		HPGL2_vector(x + (htic / 2), y + (vtic / 2));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM2;FP;EP;\n");
+		break;
+	    case 55:		/* semisolid diamond 8 */
+		HPGL2_move(x + (htic / 2), y + (vtic / 2));
+		HPGL2_vector(x, y + vtic);
+		HPGL2_vector(x - htic, y);
+		HPGL2_vector(x, y - vtic);
+		HPGL2_vector(x + (htic / 2), y - (vtic / 2));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM0;\n");
+		HPGL2_vector(x, y);
+		HPGL2_vector(x + (htic / 2), y + (vtic / 2));
+		HPGL2_vector(x + htic, y);
+		HPGL2_vector(x + (htic / 2), y - (vtic / 2));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM2;FP;EP;\n");
+		break;
+	    case 56:		/* semisolid diamond 9 */
+		HPGL2_move(x - (htic / 2), y + (vtic / 2));
+		HPGL2_vector(x - htic, y);
+		HPGL2_vector(x, y - vtic);
+		HPGL2_vector(x + (htic / 2), y - (vtic / 2));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM0;\n");
+		HPGL2_vector(x - (htic / 2), y + (vtic / 2));
+		HPGL2_vector(x, y + vtic);
+		HPGL2_vector(x + htic, y);
+		HPGL2_vector(x + (htic / 2), y - (vtic / 2));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM2;FP;EP;\n");
+		break;
+	    case 57:		/* semisolid diamond 10 */
+		HPGL2_move(x + (htic / 2), y + (vtic / 2));
+		HPGL2_vector(x, y + vtic);
+		HPGL2_vector(x - (htic / 2), y + (vtic / 2));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM0;\n");
+		HPGL2_vector(x, y);
+		HPGL2_vector(x - (htic / 2), y - (vtic / 2));
+		HPGL2_vector(x - htic, y);
+		HPGL2_vector(x - (htic / 2), y + (vtic / 2));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM2;FP;EP;\n");
+		HPGL2_move(x - (htic / 2), y - (vtic / 2));
+		HPGL2_vector(x, y - vtic);
+		HPGL2_vector(x + (htic / 2), y - (vtic / 2));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM0;\n");
+		HPGL2_vector(x, y);
+		HPGL2_vector(x + (htic / 2), y + (vtic / 2));
+		HPGL2_vector(x + htic, y);
+		HPGL2_vector(x + (htic / 2), y - (vtic / 2));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM2;FP;EP;\n");
+		break;
+	    case 58:		/* semisolid diamond 11 */
+		HPGL2_move(x - (htic / 2), y - (vtic / 2));
+		HPGL2_vector(x, y - vtic);
+		HPGL2_vector(x + (htic / 2), y - (vtic / 2));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM0;\n");
+		HPGL2_vector(x, y);
+		HPGL2_vector(x - (htic / 2), y - (vtic / 2));
+		HPGL2_vector(x - htic, y);
+		HPGL2_vector(x, y + vtic);
+		HPGL2_vector(x + htic, y);
+		HPGL2_vector(x + (htic / 2), y - (vtic / 2));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM2;FP;EP;\n");
+		break;
+	    case 59:		/* semisolid diamond 12 */
+		HPGL2_move(x + (htic / 2), y + (vtic / 2));
+		HPGL2_vector(x, y + vtic);
+		HPGL2_vector(x - htic, y);
+		HPGL2_vector(x - (htic / 2), y - (vtic / 2));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM0;\n");
+		HPGL2_vector(x + (htic / 2), y + (vtic / 2));
+		HPGL2_vector(x + htic, y);
+		HPGL2_vector(x, y - vtic);
+		HPGL2_vector(x - (htic / 2), y - (vtic / 2));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM2;FP;EP;\n");
+		break;
+	    case 60:		/* semisolid diamond 13 */
+		HPGL2_move(x - (htic / 2), y + (vtic / 2));
+		HPGL2_vector(x - htic, y);
+		HPGL2_vector(x - (htic / 2), y - (vtic / 2));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM0;\n");
+		HPGL2_vector(x, y - vtic);
+		HPGL2_vector(x + htic, y);
+		HPGL2_vector(x, y + vtic);
+		HPGL2_vector(x - (htic / 2), y + (vtic / 2));
+		HPGL2_vector(x, y);
+		HPGL2_vector(x - (htic / 2), y - (vtic / 2));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM2;FP;EP;\n");
+		break;
+	    case 61:		/* semisolid diamond 14 */
+		HPGL2_move(x + (htic / 2), y + (vtic / 2));
+		HPGL2_vector(x, y + vtic);
+		HPGL2_vector(x - (htic / 2), y + (vtic / 2));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM0;\n");
+		HPGL2_vector(x - htic, y);
+		HPGL2_vector(x, y - vtic);
+		HPGL2_vector(x + htic, y);
+		HPGL2_vector(x + (htic / 2), y + (vtic / 2));
+		HPGL2_vector(x, y);
+		HPGL2_vector(x - (htic / 2), y + (vtic / 2));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM2;FP;EP;\n");
+		break;
+	    case 62:		/* solid diamond 2 */
+		HPGL2_move(x - htic, y);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM0;\n");
+		HPGL2_vector(x, y - vtic);
+		HPGL2_vector(x + htic, y);
+		HPGL2_vector(x, y + vtic);
+		HPGL2_vector(x - htic, y);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM2;FP;EP;\n");
+		break;
+	    case 63:		/* hollow square 3 */
+		HPGL2_move(x - (3 * htic / 4), y - (3 * vtic / 4));
+		HPGL2_vector(x + (3 * htic / 4), y - (3 * vtic / 4));
+		HPGL2_vector(x + (3 * htic / 4), y + (3 * vtic / 4));
+		HPGL2_vector(x - (3 * htic / 4), y + (3 * vtic / 4));
+		HPGL2_vector(x - (3 * htic / 4), y - (3 * vtic / 4));
+		break;
+	    case 64:		/* hollow circle 3 */
+		HPGL2_move(x, y);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "CI%.2f;\n", ((double) 3 * (htic) / 4));
+		break;
+	    case 65:		/* hollow triangle 3 */
+		HPGL2_move(x, y + (3 * vtic / 4));
+		HPGL2_vector(x - (3 * sqrt(3) * htic / 8), y - (3 * vtic / 8));
+		HPGL2_vector(x + (3 * sqrt(3) * htic / 8), y - (3 * vtic / 8));
+		HPGL2_vector(x, y + (3 * vtic / 4));
+		break;
+	    case 66:		/* hollow triangle 4 */
+		HPGL2_move(x, y - (3 * vtic / 4));
+		HPGL2_vector(x - (3 * sqrt(3) * htic / 8), y + (3 * vtic / 8));
+		HPGL2_vector(x + (3 * sqrt(3) * htic / 8), y + (3 * vtic / 8));
+		HPGL2_vector(x, y - (3 * vtic / 4));
+		break;
+	    case 67:		/* hollow diamond 3 */
+		HPGL2_move(x - (3 * htic / 4), y);
+		HPGL2_vector(x, y - (3 * vtic / 4));
+		HPGL2_vector(x + (3 * htic / 4), y);
+		HPGL2_vector(x, y + (3 * vtic / 4));
+		HPGL2_vector(x - (3 * htic / 4), y);
+		break;
+	    case 68:		/* hollow pentagon 2 */
+		HPGL2_move(x, y + (3 * vtic / 4));
+		HPGL2_vector(x - (cos(.1 * acos(-1)) * 3 * htic / 4), y + (sin(.1 * acos(-1)) * 3 * vtic / 4));
+		HPGL2_vector(x - (sin(.2 * acos(-1)) * 3 * htic / 4), y - (cos(.2 * acos(-1)) * 3 * vtic / 4));
+		HPGL2_vector(x + (sin(.2 * acos(-1)) * 3 * htic / 4), y - (cos(.2 * acos(-1)) * 3 * vtic / 4));
+		HPGL2_vector(x + (cos(.1 * acos(-1)) * 3 * htic / 4), y + (sin(.1 * acos(-1)) * 3 * vtic / 4));
+		HPGL2_vector(x, y + (3 * vtic / 4));
+		break;
+	    case 69:		/* opaque square */
+		HPGL2_move(x - htic, y - vtic);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "FT10,30;RA%d,%d;EP;FT;\n", x + (3 * htic / 4), y + (3 * vtic / 4));
+		break;
+	    case 70:		/* opaque circle */
+		HPGL2_move(x, y);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "FT10,30;WG%.2f,0,360;EP;FT;\n", ((double) 3 * (htic) / 4));
+		break;
+	    case 71:		/* opaque triangle 1 */
+		HPGL2_move(x, y + (3 * vtic / 4));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM0;\n");
+		HPGL2_vector(x - (3 * sqrt(3) * htic / 8), y - (3 * vtic / 8));
+		HPGL2_vector(x + (3 * sqrt(3) * htic / 8), y - (3 * vtic / 8));
+		HPGL2_vector(x, y + (3 * vtic / 4));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM2;FT10,30;FP;EP;FT;\n");
+		break;
+	    case 72:		/* opaque triangle 2 */
+		HPGL2_move(x, y - (3 * vtic / 4));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM0;\n");
+		HPGL2_vector(x - (3 * sqrt(3) * htic / 8), y + (3 * vtic / 8));
+		HPGL2_vector(x + (3 * sqrt(3) * htic / 8), y + (3 * vtic / 8));
+		HPGL2_vector(x, y - (3 * vtic / 4));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM2;FT10,30;FP;EP;FT;\n");
+		break;
+	    case 73:		/* opaque diamond */
+		HPGL2_move(x - (3 * htic / 4), y);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM0;\n");
+		HPGL2_vector(x, y - (3 * vtic / 4));
+		HPGL2_vector(x + (3 * htic / 4), y);
+		HPGL2_vector(x, y + (3 * vtic / 4));
+		HPGL2_vector(x - (3 * htic / 4), y);
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM2;FT10,30;FP;EP;FT;\n");
+		break;
+	    case 74:		/* opaque pentagon */
+		HPGL2_move(x, y + (3 * vtic / 4));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM0;\n");
+		HPGL2_vector(x - (cos(.1 * acos(-1)) * 3 * htic / 4), y + (sin(.1 * acos(-1)) * 3 * vtic / 4));
+		HPGL2_vector(x - (sin(.2 * acos(-1)) * 3 * htic / 4), y - (cos(.2 * acos(-1)) * 3 * vtic / 4));
+		HPGL2_vector(x + (sin(.2 * acos(-1)) * 3 * htic / 4), y - (cos(.2 * acos(-1)) * 3 * vtic / 4));
+		HPGL2_vector(x + (cos(.1 * acos(-1)) * 3 * htic / 4), y + (sin(.1 * acos(-1)) * 3 * vtic / 4));
+		HPGL2_vector(x, y + (3 * vtic / 4));
+		fputs(";\n", gpoutfile);
+		HPGL2_in_pe = 0;
+		fprintf(gpoutfile, "PM2;FT10,30;FP;EP;FT;\n");
+		break;
+	    }
+	}
+    } else {			/* default style points */
+	if (number < 0) {
+	    HPGL2_neg_point(x, y, number);
+	} else {
+	    htic = (int) (HPGL2_psize * PCL_HTIC / 2);
+	    vtic = (int) (HPGL2_psize * PCL_VTIC / 2);
+	    number %= HPGL2_NUM_NOPSPOINTS;
+	    switch (number) {
+	    case 0:		/* diamond */
+		HPGL2_move(x - htic, y);
+		HPGL2_vector(x, y - vtic);
+		HPGL2_vector(x + htic, y);
+		HPGL2_vector(x, y + vtic);
+		HPGL2_vector(x - htic, y);
+		HPGL2_move(x, y);
+		HPGL2_vector(x, y);
+		break;
+	    case 1:		/* plus */
+		HPGL2_move(x - htic, y);
+		HPGL2_vector(x - htic, y);
+		HPGL2_vector(x + htic, y);
+		HPGL2_move(x, y - vtic);
+		HPGL2_vector(x, y - vtic);
+		HPGL2_vector(x, y + vtic);
+		break;
+	    case 2:		/* box */
+		HPGL2_move(x - htic, y - vtic);
+		HPGL2_vector(x - htic, y - vtic);
+		HPGL2_vector(x + htic, y - vtic);
+		HPGL2_vector(x + htic, y + vtic);
+		HPGL2_vector(x - htic, y + vtic);
+		HPGL2_vector(x - htic, y - vtic);
+		HPGL2_move(x, y);
+		HPGL2_vector(x, y);
+		break;
+	    case 3:		/* X */
+		HPGL2_move(x - htic, y - vtic);
+		HPGL2_vector(x - htic, y - vtic);
+		HPGL2_vector(x + htic, y + vtic);
+		HPGL2_move(x - htic, y + vtic);
+		HPGL2_vector(x - htic, y + vtic);
+		HPGL2_vector(x + htic, y - vtic);
+		break;
+	    case 4:		/* triangle */
+		HPGL2_move(x, y + (4 * vtic / 3));
+		HPGL2_vector(x - (4 * htic / 3), y - (2 * vtic / 3));
+		HPGL2_vector(x + (4 * htic / 3), y - (2 * vtic / 3));
+		HPGL2_vector(x, y + (4 * vtic / 3));
+		HPGL2_move(x, y);
+		HPGL2_vector(x, y);
+		break;
+	    case 5:		/* star */
+		HPGL2_move(x - htic, y);
+		HPGL2_vector(x - htic, y);
+		HPGL2_vector(x + htic, y);
+		HPGL2_move(x, y - vtic);
+		HPGL2_vector(x, y - vtic);
+		HPGL2_vector(x, y + vtic);
+		HPGL2_move(x - htic, y - vtic);
+		HPGL2_vector(x - htic, y - vtic);
+		HPGL2_vector(x + htic, y + vtic);
+		HPGL2_move(x - htic, y + vtic);
+		HPGL2_vector(x - htic, y + vtic);
+		HPGL2_vector(x + htic, y - vtic);
+		break;
+	    }
+	}
+    }
+}
+
+/*
+ * This is for special purpose negative point types. If they are not needed,
+ * they should be safely ignorable, but the special pointypes can be omitted
+ * if necessary, leaving only the dot (which is -1).
+ */
+
+TERM_PUBLIC void
+HPGL2_neg_point(unsigned int x, unsigned int y, int number)
+{
+    int htic, vtic;
+    htic = (int) (HPGL2_psize * PCL_HTIC / 2);
+    vtic = (int) (HPGL2_psize * PCL_VTIC / 2);
+    switch (number) {
+    case -20:			/* well 18 */
+	HPGL2_move(x - htic, y - vtic);
+	HPGL2_vector(x + htic, y + vtic);
+	HPGL2_move(x, y);
+	fputs(";\n", gpoutfile);
+	HPGL2_in_pe = 0;
+	fprintf(gpoutfile, "CI%.2f;\n", ((double) 3 * (htic) / 4));
+	break;
+    case -19:			/* well 17 */
+	HPGL2_move(x, y - vtic);
+	HPGL2_vector(x, y - (vtic / 2));
+	HPGL2_move(x, y + (vtic / 2));
+	HPGL2_vector(x, y + vtic);
+	HPGL2_move(x, y - vtic);
+	HPGL2_vector(x - (htic / 4), y - (3 * vtic / 4));
+	HPGL2_move(x, y - vtic);
+	HPGL2_vector(x + (htic / 4), y - (3 * vtic / 4));
+	HPGL2_move(x, y);
+	fputs(";\n", gpoutfile);
+	HPGL2_in_pe = 0;
+	fprintf(gpoutfile, "CI%.2f;\n", ((double) (htic) / 2));
+	break;
+    case -18:			/* well 16 */
+	HPGL2_move(x - htic, y);
+	HPGL2_vector(x + htic, y);
+	HPGL2_move(x, y - vtic);
+	HPGL2_vector(x, y + vtic);
+	HPGL2_move(x, y);
+	fputs(";\n", gpoutfile);
+	HPGL2_in_pe = 0;
+	fprintf(gpoutfile, "CI%.2f;\n", ((double) 3 * (htic) / 4));
+	break;
+    case -17:			/* well 15 */
+	HPGL2_move(x - htic, y - vtic);
+	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y - (3 * sqrt(2) * vtic / 8));
+	HPGL2_move(x + (sqrt(2) * htic / 2), y - (sqrt(2) * vtic / 2));
+	HPGL2_vector(x + (3 * sqrt(2) * htic / 8), y - (3 * sqrt(2) * vtic / 8));
+	HPGL2_move(x + htic, y + vtic);
+	HPGL2_vector(x + (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
+	HPGL2_move(x - (sqrt(2) * htic / 2), y + (sqrt(2) * vtic / 2));
+	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
+	HPGL2_move(x - htic, y);
+	HPGL2_vector(x - (3 * htic / 4), y);
+	HPGL2_move(x + (3 * htic / 4), y);
+	HPGL2_vector(x + htic, y);
+	HPGL2_move(x, y - vtic);
+	HPGL2_vector(x, y - (3 * vtic / 4));
+	HPGL2_move(x, y + (3 * vtic / 4));
+	HPGL2_vector(x, y + vtic);
+	HPGL2_move(x, y);
+	fputs(";\n", gpoutfile);
+	HPGL2_in_pe = 0;
+	fprintf(gpoutfile, "EW%.2f,0,180;\n", ((double) 3 * (htic) / 4));
+	fprintf(gpoutfile, "WG%.2f,180,180;EP;\n", ((double) 3 * (htic) / 4));
+	break;
+    case -16:			/* well 14 */
+	HPGL2_move(x - htic, y - vtic);
+	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y - (3 * sqrt(2) * vtic / 8));
+	HPGL2_move(x + htic, y + vtic);
+	HPGL2_vector(x + (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
+	HPGL2_move(x - (sqrt(2) * htic / 2), y + (sqrt(2) * vtic / 2));
+	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
+	HPGL2_move(x - htic, y);
+	HPGL2_vector(x - (3 * htic / 4), y);
+	HPGL2_move(x + (3 * htic / 4), y);
+	HPGL2_vector(x + htic, y);
+	HPGL2_move(x, y + (3 * vtic / 4));
+	HPGL2_vector(x, y + vtic);
+	HPGL2_move(x, y);
+	fputs(";\n", gpoutfile);
+	HPGL2_in_pe = 0;
+	fprintf(gpoutfile, "WG%.2f,0,360;EP;\n", ((double) 3 * (htic) / 4));
+	break;
+    case -15:			/* well 13 */
+	HPGL2_move(x - htic, y - vtic);
+	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y - (3 * sqrt(2) * vtic / 8));
+	HPGL2_move(x + (sqrt(2) * htic / 2), y - (sqrt(2) * vtic / 2));
+	HPGL2_vector(x + (3 * sqrt(2) * htic / 8), y - (3 * sqrt(2) * vtic / 8));
+	HPGL2_move(x + htic, y + vtic);
+	HPGL2_vector(x + (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
+	HPGL2_move(x - (sqrt(2) * htic / 2), y + (sqrt(2) * vtic / 2));
+	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
+	HPGL2_move(x - htic, y);
+	HPGL2_vector(x - (3 * htic / 4), y);
+	HPGL2_move(x + (3 * htic / 4), y);
+	HPGL2_vector(x + htic, y);
+	HPGL2_move(x, y - vtic);
+	HPGL2_vector(x, y - (3 * vtic / 4));
+	HPGL2_move(x, y + (3 * vtic / 4));
+	HPGL2_vector(x, y + vtic);
+	HPGL2_move(x, y);
+	fputs(";\n", gpoutfile);
+	HPGL2_in_pe = 0;
+	fprintf(gpoutfile, "WG%.2f,0,360;EP;\n", ((double) 3 * (htic) / 4));
+	break;
+    case -14:			/* well 12 */
+	HPGL2_move(x - htic, y - vtic);
+	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y - (3 * sqrt(2) * vtic / 8));
+	HPGL2_move(x + (sqrt(2) * htic / 2), y - (sqrt(2) * vtic / 2));
+	HPGL2_vector(x + (3 * sqrt(2) * htic / 8), y - (3 * sqrt(2) * vtic / 8));
+	HPGL2_move(x + htic, y + vtic);
+	HPGL2_vector(x + (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
+	HPGL2_move(x - (sqrt(2) * htic / 2), y + (sqrt(2) * vtic / 2));
+	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
+	HPGL2_move(x - htic, y);
+	HPGL2_vector(x - (3 * htic / 4), y);
+	HPGL2_move(x + (3 * htic / 4), y);
+	HPGL2_vector(x + htic, y);
+	HPGL2_move(x, y - vtic);
+	HPGL2_vector(x, y - (3 * vtic / 4));
+	HPGL2_move(x, y + (3 * vtic / 4));
+	HPGL2_vector(x, y + vtic);
+	HPGL2_move(x, y);
+	fputs(";\n", gpoutfile);
+	HPGL2_in_pe = 0;
+	fprintf(gpoutfile, "CI%.2f;\n", ((double) 3 * (htic) / 4));
+	break;
+    case -13:			/* well 11 */
+	HPGL2_move(x - htic, y - vtic);
+	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y - (3 * sqrt(2) * vtic / 8));
+	HPGL2_move(x + htic, y + vtic);
+	HPGL2_vector(x + (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
+	HPGL2_move(x, y);
+	fputs(";\n", gpoutfile);
+	HPGL2_in_pe = 0;
+	fprintf(gpoutfile, "WG%.2f,0,360;EP;\n", ((double) 3 * (htic) / 4));
+	break;
+    case -12:			/* well 10 */
+	HPGL2_move(x + (sqrt(2) * htic / 2), y + (sqrt(2) * vtic / 2));
+	HPGL2_vector(x + (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
+	HPGL2_move(x - (sqrt(2) * htic / 2), y + (sqrt(2) * vtic / 2));
+	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
+	HPGL2_move(x - htic, y);
+	HPGL2_vector(x - (3 * htic / 4), y);
+	HPGL2_move(x + (3 * htic / 4), y);
+	HPGL2_vector(x + htic, y);
+	HPGL2_move(x, y - vtic);
+	HPGL2_vector(x, y - (3 * vtic / 4));
+	HPGL2_move(x, y + (3 * vtic / 4));
+	HPGL2_vector(x, y + vtic);
+	HPGL2_move(x, y);
+	fputs(";\n", gpoutfile);
+	HPGL2_in_pe = 0;
+	fprintf(gpoutfile, "EW%.2f,0,180;\n", ((double) 3 * (htic) / 4));
+	fprintf(gpoutfile, "WG%.2f,180,180;EP;\n", ((double) 3 * (htic) / 4));
+	break;
+    case -11:			/* well 9 */
+	HPGL2_move(x + (sqrt(2) * htic / 2), y + (sqrt(2) * vtic / 2));
+	HPGL2_vector(x + (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
+	HPGL2_move(x - (sqrt(2) * htic / 2), y + (sqrt(2) * vtic / 2));
+	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
+	HPGL2_move(x - htic, y);
+	HPGL2_vector(x - (3 * htic / 4), y);
+	HPGL2_move(x + (3 * htic / 4), y);
+	HPGL2_vector(x + htic, y);
+	HPGL2_move(x, y - vtic);
+	HPGL2_vector(x, y - (3 * vtic / 4));
+	HPGL2_move(x, y + (3 * vtic / 4));
+	HPGL2_vector(x, y + vtic);
+	HPGL2_move(x, y);
+	fputs(";\n", gpoutfile);
+	HPGL2_in_pe = 0;
+	fprintf(gpoutfile, "CI%.2f;\n", ((double) 3 * (htic) / 4));
+	break;
+    case -10:			/* well 8 */
+	HPGL2_move(x - htic, y);
+	HPGL2_vector(x - (3 * htic / 4), y);
+	HPGL2_move(x + (3 * htic / 4), y);
+	HPGL2_vector(x + htic, y);
+	HPGL2_move(x, y - vtic);
+	HPGL2_vector(x, y - (3 * vtic / 4));
+	HPGL2_move(x, y + (3 * vtic / 4));
+	HPGL2_vector(x, y + vtic);
+	HPGL2_move(x, y);
+	fputs(";\n", gpoutfile);
+	HPGL2_in_pe = 0;
+	fprintf(gpoutfile, "EW%.2f,0,180;\n", ((double) 3 * (htic) / 4));
+	fprintf(gpoutfile, "WG%.2f,180,180;EP;\n", ((double) 3 * (htic) / 4));
+	break;
+    case -9:			/* well 7 */
+	HPGL2_move(x - (sqrt(2) * htic / 2), y - (sqrt(2) * vtic / 2));
+	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y - (3 * sqrt(2) * vtic / 8));
+	HPGL2_move(x + (sqrt(2) * htic / 2), y - (sqrt(2) * vtic / 2));
+	HPGL2_vector(x + (3 * sqrt(2) * htic / 8), y - (3 * sqrt(2) * vtic / 8));
+	HPGL2_move(x + (sqrt(2) * htic / 2), y + (sqrt(2) * vtic / 2));
+	HPGL2_vector(x + (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
+	HPGL2_move(x - (sqrt(2) * htic / 2), y + (sqrt(2) * vtic / 2));
+	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
+	HPGL2_move(x - htic, y);
+	HPGL2_vector(x - (3 * htic / 4), y);
+	HPGL2_move(x + (3 * htic / 4), y);
+	HPGL2_vector(x + htic, y);
+	HPGL2_move(x, y - vtic);
+	HPGL2_vector(x, y - (3 * vtic / 4));
+	HPGL2_move(x, y + (3 * vtic / 4));
+	HPGL2_vector(x, y + vtic);
+	HPGL2_move(x, y);
+	fputs(";\n", gpoutfile);
+	HPGL2_in_pe = 0;
+	fprintf(gpoutfile, "EW%.2f,0,180;\n", ((double) 3 * (htic) / 4));
+	fprintf(gpoutfile, "WG%.2f,180,180;EP;\n", ((double) 3 * (htic) / 4));
+	break;
+    case -8:			/* well 6 */
+	HPGL2_move(x + (sqrt(2) * htic / 2), y + (sqrt(2) * vtic / 2));
+	HPGL2_vector(x + (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
+	HPGL2_move(x - (sqrt(2) * htic / 2), y + (sqrt(2) * vtic / 2));
+	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
+	HPGL2_move(x - htic, y);
+	HPGL2_vector(x - (3 * htic / 4), y);
+	HPGL2_move(x + (3 * htic / 4), y);
+	HPGL2_vector(x + htic, y);
+	HPGL2_move(x, y + (3 * vtic / 4));
+	HPGL2_vector(x, y + vtic);
+	HPGL2_move(x, y);
+	fputs(";\n", gpoutfile);
+	HPGL2_in_pe = 0;
+	fprintf(gpoutfile, "WG%.2f,0,360;EP;\n", ((double) 3 * (htic) / 4));
+	break;
+    case -7:			/* well 5 */
+	HPGL2_move(x - (sqrt(2) * htic / 2), y - (sqrt(2) * vtic / 2));
+	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y - (3 * sqrt(2) * vtic / 8));
+	HPGL2_move(x + (sqrt(2) * htic / 2), y - (sqrt(2) * vtic / 2));
+	HPGL2_vector(x + (3 * sqrt(2) * htic / 8), y - (3 * sqrt(2) * vtic / 8));
+	HPGL2_move(x + (sqrt(2) * htic / 2), y + (sqrt(2) * vtic / 2));
+	HPGL2_vector(x + (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
+	HPGL2_move(x - (sqrt(2) * htic / 2), y + (sqrt(2) * vtic / 2));
+	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
+	HPGL2_move(x - htic, y);
+	HPGL2_vector(x - (3 * htic / 4), y);
+	HPGL2_move(x + (3 * htic / 4), y);
+	HPGL2_vector(x + htic, y);
+	HPGL2_move(x, y - vtic);
+	HPGL2_vector(x, y - (3 * vtic / 4));
+	HPGL2_move(x, y + (3 * vtic / 4));
+	HPGL2_vector(x, y + vtic);
+	HPGL2_move(x, y);
+	fputs(";\n", gpoutfile);
+	HPGL2_in_pe = 0;
+	fprintf(gpoutfile, "WG%.2f,0,360;EP;\n", ((double) 3 * (htic) / 4));
+	break;
+    case -6:			/* well 4 */
+	HPGL2_move(x - (sqrt(2) * htic / 2), y - (sqrt(2) * vtic / 2));
+	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y - (3 * sqrt(2) * vtic / 8));
+	HPGL2_move(x + (sqrt(2) * htic / 2), y - (sqrt(2) * vtic / 2));
+	HPGL2_vector(x + (3 * sqrt(2) * htic / 8), y - (3 * sqrt(2) * vtic / 8));
+	HPGL2_move(x + (sqrt(2) * htic / 2), y + (sqrt(2) * vtic / 2));
+	HPGL2_vector(x + (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
+	HPGL2_move(x - (sqrt(2) * htic / 2), y + (sqrt(2) * vtic / 2));
+	HPGL2_vector(x - (3 * sqrt(2) * htic / 8), y + (3 * sqrt(2) * vtic / 8));
+	HPGL2_move(x - htic, y);
+	HPGL2_vector(x - (3 * htic / 4), y);
+	HPGL2_move(x + (3 * htic / 4), y);
+	HPGL2_vector(x + htic, y);
+	HPGL2_move(x, y - vtic);
+	HPGL2_vector(x, y - (3 * vtic / 4));
+	HPGL2_move(x, y + (3 * vtic / 4));
+	HPGL2_vector(x, y + vtic);
+	HPGL2_move(x, y);
+	fputs(";\n", gpoutfile);
+	HPGL2_in_pe = 0;
+	fprintf(gpoutfile, "CI%.2f;\n", ((double) 3 * (htic) / 4));
+	break;
+    case -5:			/* well 3 */
+	HPGL2_move(x, y);
+	fputs(";\n", gpoutfile);
+	HPGL2_in_pe = 0;
+	fprintf(gpoutfile, "WG%.2f,0,360;EP;\n", ((double) 3 * (htic) / 4));
+	break;
+    case -4:			/* well 2 */
+	HPGL2_move(x - htic, y);
+	HPGL2_vector(x - (3 * htic / 4), y);
+	HPGL2_move(x + (3 * htic / 4), y);
+	HPGL2_vector(x + htic, y);
+	HPGL2_move(x, y - vtic);
+	HPGL2_vector(x, y - (3 * vtic / 4));
+	HPGL2_move(x, y + (3 * vtic / 4));
+	HPGL2_vector(x, y + vtic);
+	HPGL2_move(x, y);
+	fputs(";\n", gpoutfile);
+	HPGL2_in_pe = 0;
+	fprintf(gpoutfile, "CI%.2f;\n", ((double) 3 * (htic) / 4));
+	break;
+    case -3:			/* well 1 */
+	HPGL2_move(x, y);
+	fputs(";\n", gpoutfile);
+	HPGL2_in_pe = 0;
+	fprintf(gpoutfile, "CI%.2f;\n", ((double) 3 * (htic) / 4));
+	break;
+    case -2:			/* v box */
+	HPGL2_move(x - htic, y);
+	HPGL2_vector(x - (3 * htic / 4), y);
+	HPGL2_move(x + (3 * htic / 4), y);
+	HPGL2_vector(x + htic, y);
+	HPGL2_move(x, y - vtic);
+	HPGL2_vector(x, y - (3 * vtic / 4));
+	HPGL2_move(x, y + (3 * vtic / 4));
+	HPGL2_vector(x, y + vtic);
+	HPGL2_move(x - (3 * htic / 4), y - (3 * vtic / 4));
+	HPGL2_vector(x + (3 * htic / 4), y - (3 * vtic / 4));
+	HPGL2_vector(x + (3 * htic / 4), y + (3 * vtic / 4));
+	HPGL2_vector(x - (3 * htic / 4), y + (3 * vtic / 4));
+	HPGL2_vector(x - (3 * htic / 4), y - (3 * vtic / 4));
+	HPGL2_move(x - (htic / 2), y + (vtic / 2));
+	HPGL2_vector(x, y - (vtic / 2));
+	HPGL2_vector(x + (htic / 2), y + (vtic / 2));
+	break;
+    default:			/* dot */
+	HPGL2_move(x, y);
+	HPGL2_vector(x, y);
+	break;
+	return;
+    }
+}
+
+TERM_PUBLIC void
+HPGL2_pointsize(double size)
+{
+    HPGL2_psize = (size >= 0 ? size : 1);
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+TERM_TABLE_START(hpgl_driver)
+    "hpgl", "HP7475 and relatives [number of pens] [eject]",
+    HPGL_XMAX, HPGL_YMAX, HPGL_VCHAR, HPGL_HCHAR,
+    HPGL_VTIC, HPGL_HTIC, HPGL_options, HPGL_init, HPGL_reset,
+    HPGL_text, null_scale, HPGL_graphics, HPGL_move, HPGL_vector,
+    HPGL_linetype, HPGL_put_text, HPGL_text_angle, null_justify_text, do_point, do_arrow, set_font_null TERM_TABLE_END(hpgl_driver)
+#undef LAST_TERM
+#define LAST_TERM hpgl_driver
+    TERM_TABLE_START(pcl5_driver)
+    "pcl5", "HP Designjet 750C, HP Laserjet III/IV, etc. (many options)",
+    PCL_XMAX, PCL_YMAX, HPGL2_VCHAR, HPGL2_HCHAR,
+    PCL_VTIC, PCL_HTIC, PCL_options, PCL_init, PCL_reset,
+    PCL_text, null_scale, PCL_graphics, HPGL2_move, HPGL2_vector,
+    HPGL2_linetype, HPGL2_put_text, HPGL2_text_angle,
+    HPGL2_justify_text, HPGL2_point, do_arrow, HPGL2_set_font, HPGL2_pointsize TERM_TABLE_END(pcl5_driver)
+#undef LAST_TERM
+#define LAST_TERM pcl5_driver
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+#ifdef TERM_HELP
+START_HELP(hpgl)
+"1 hpgl",
+"?commands set terminal hpgl",
+"?set terminal hpgl",
+"?set term hpgl",
+"?terminal hpgl",
+"?term hpgl",
+"?hpgl",
+"?commands set terminal pcl5",
+"?set terminal pcl5",
+"?set term pcl5",
+"?terminal pcl5",
+"?term pcl5",
+"?pcl5",
+" The `hpgl` driver produces HPGL output for devices like the HP7475A plotter.",
+" There are two options which can be set: the number of pens and `eject`,",
+" which tells the plotter to eject a page when done.  The default is to use 6",
+" pens and not to eject the page when done.",
+"",
+" The international character sets ISO-8859-1 and CP850 are recognized via",
+" `set encoding iso_8859_1` or `set encoding cp850` (see `set encoding` for",
+" details).",
+"",
+" Syntax:",
+"       set terminal hpgl {<number_of_pens>} {eject}",
+"",
+" The selection",
+"",
+"       set terminal hpgl 8 eject",
+"",
+" is equivalent to the previous `hp7550` terminal, and the selection",
+"",
+"       set terminal hpgl 4",
+"",
+" is equivalent to the previous `hp7580b` terminal.",
+"",
+" The `pcl5` driver supports plotters such as the Hewlett-Packard Designjet",
+" 750C, the Hewlett-Packard Laserjet III, and the Hewlett-Packard Laserjet IV.",
+" It actually uses HPGL-2, but there is a name conflict among the terminal",
+" devices.  It has several options which must be specified in the order",
+" indicated below:",
+"",
+" Syntax:",
+"       set terminal pcl5 {mode <mode>} {<plotsize>}",
+"           {{color {<number_of_pens>}} | monochrome} {solid | dashed}",
+"           {font <font>} {size <fontsize>} {pspoints | nopspoints}",
+"",
+" <mode> is `landscape` or `portrait`. <plotsize> is the physical",
+" plotting size of the plot, which is one of the following: `letter` for",
+" standard (8 1/2\" X 11\") displays, `legal` for (8 1/2\" X 14\") displays,",
+" `noextended` for (36\" X 48\") displays (a letter size ratio) or,",
+" `extended` for (36\" X 55\") displays (almost a legal size ratio).",
+" `color` is for multi-pen (i.e. color) plots, and <number_of_pens> is",
+" the number of pens (i.e. colors) used in color plots. `monochrome` is for",
+" one (e.g. black) pen plots. `solid` draws all lines as solid lines, or",
+" `dashed` will draw lines with different dashed and dotted line patterns.",
+" <font> is `stick`, `univers`, `cg_times`, `zapf_dingbats`, `antique_olive`,",
+" `arial`, `courier`, `garamond_antigua`, `letter_gothic`, `cg_omega`,",
+" `albertus`, `times_new_roman`, `clarendon`, `coronet`, `marigold`,",
+" `truetype_symbols`, or `wingdings`. <fontsize> is the font size in points.",
+" The point type selection can be the standard default set by specifying",
+" `nopspoints`, or the same set of point types found in the postscript terminal",
+" by specifying `pspoints`.",
+"",
+" Note that built-in support of some of these options is printer device",
+" dependent. For instance, all the fonts are supposedly supported by the HP",
+" Laserjet IV, but only a few (e.g. univers, stick) may be supported by the HP",
+" Laserjet III and the Designjet 750C. Also, color obviously won't work on the",
+" the laserjets since they are monochrome devices.",
+"",
+" Defaults: landscape, noextended, color (6 pens), solid, univers, 12 point,",
+"           and nopspoints.",
+"",
+" With `pcl5` international characters are handled by the printer; you just put",
+" the appropriate 8-bit character codes into the text strings.  You don't need",
+" to bother with `set encoding`.",
+"",
+" HPGL graphics can be imported by many software packages."
+END_HELP(hpgl)
+#endif /* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/hpljii.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/hpljii.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/hpljii.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/hpljii.trm.svn-base	2012-01-03 17:07:32.168399900 -0800
@@ -0,0 +1,430 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: hpljii.trm,v 1.24 2006/07/21 02:35:47 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - hpljii.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004   Thomas Williams, Colin Kelley
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *  hpljii, hpdj
+ *
+ * AUTHORS
+ *  John Engels
+ *  Russell Lang
+ *  Maurice Castro
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+
+/* The following HP laserjet series II driver uses generic bit mapped graphics
+   routines from bitmap.c to build up a bit map in memory.  The driver
+   interchanges colomns and lines in order to access entire lines
+   easily and returns the lines to get bits in the right order :
+   (x,y) -> (y,XMAX-1-x). */
+/* This interchange is done by calling b_makebitmap() with reversed
+   xmax and ymax, and then setting b_rastermode to TRUE.  b_setpixel()
+   will then perform the interchange before each pixel is plotted */
+/* by John Engels JENGELS@BNANDP51.BITNET, inspired by the hpljet driver
+   of Jyrki Yli-Nokari */
+
+/*
+ * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(hpljii)
+register_term(hpdj)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void HPLJII_options __PROTO((void));
+TERM_PUBLIC void HPLJII_init __PROTO((void));
+TERM_PUBLIC void HPLJII_graphics __PROTO((void));
+TERM_PUBLIC void HPLJII_text __PROTO((void));
+TERM_PUBLIC void HPLJII_linetype __PROTO((int linetype));
+TERM_PUBLIC void HPLJII_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC void HPLJII_reset __PROTO((void));
+
+TERM_PUBLIC void HPDJ_graphics __PROTO((void));
+TERM_PUBLIC void HPDJ_text __PROTO((void));
+
+/* default values for term_tbl */
+#define HPLJII_75PPI_XMAX (1920/4)
+#define HPLJII_75PPI_YMAX (1920/4)
+#define HPLJII_75PPI_HCHAR (1920/4/6)
+#define HPLJII_75PPI_VCHAR (1920/4/10)
+#define HPLJII_75PPI_VTIC 5
+#define HPLJII_75PPI_HTIC 5
+#endif
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+/* We define 4 different print qualities : 300ppi, 150ppi, 100ppi and
+   75ppi.  (Pixel size = 1, 2, 3, 4 dots) */
+
+#define HPLJII_DPP (hplj_dpp)	/* dots per pixel */
+#define HPLJII_PPI (300/HPLJII_DPP)	/* pixel per inch */
+/* make XMAX and YMAX a multiple of 8 */
+#define HPLJII_XMAX (8*(unsigned int)(xsize*1920/HPLJII_DPP/8.0+0.9))
+#define HPLJII_YMAX (8*(unsigned int)(ysize*1920/HPLJII_DPP/8.0+0.9))
+
+/* Courier font with 6 lines per inch */
+#define HPLJII_VCHAR (HPLJII_PPI/6)
+/* Courier font with 10 caracters per inch */
+#define HPLJII_HCHAR (HPLJII_PPI/10)
+/* Save current cursor position */
+#define HPLJII_PUSH_CURSOR fputs("\033&f0S",gpoutfile)
+/* Restore cursor position */
+#define HPLJII_POP_CURSOR fputs("\033&f1S",gpoutfile)
+/* be sure to use courier font with 6lpi and 10cpi */
+#define HPLJII_COURIER fputs("\033(0N\033(s0p10.0h12.0v0s0b3T\033&l6D",gpoutfile)
+
+
+static void HPLJII_putc __PROTO((unsigned int x, unsigned int y, int c, int ang));
+    /* note: c is char, but must be declared int due to an old K&R ANSI-C strict HP cc */
+static int hplj_dpp = 4;
+/* bm_pattern not appropriate for 300ppi graphics */
+#ifndef GOT_300_PATTERN
+# define GOT_300_PATTERN
+static unsigned int b_300ppi_pattern[] =
+{
+    0xffff, 0x1111, 0xffff, 0x3333,
+    0x0f0f, 0x3f3f, 0x0fff, 0x00ff, 0x33ff
+};
+#endif
+
+TERM_PUBLIC void
+HPLJII_options()
+{
+    char opt[4];
+    int parse_error = 0;
+
+    if (END_OF_COMMAND) {
+	term_options[0] = NUL;
+    } else {
+	if (token[c_token].length > 3) {
+	    parse_error = 1;	/* see below */
+	} else {
+	    /* almost_equals() won't accept numbers - use strcmp() instead */
+	    capture(opt, c_token, c_token, 4);
+	    if (!strcmp(opt, "75")) {
+		hplj_dpp = 4;
+	    } else if (!strcmp(opt, "100")) {
+		hplj_dpp = 3;
+	    } else if (!strcmp(opt, "150")) {
+		hplj_dpp = 2;
+	    } else if (!strcmp(opt, "300")) {
+		hplj_dpp = 1;
+	    } else {
+		/* error, but set dpi anyway, since term it already set */
+		parse_error = 1;
+	    }
+	    c_token++;
+	}
+    }
+
+    term->xmax = HPLJII_XMAX;
+    term->ymax = HPLJII_YMAX;
+    switch (hplj_dpp) {
+    case 1:
+	strcpy(term_options, "300");
+	term->v_tic = 15;
+	term->h_tic = 15;
+	break;
+    case 2:
+	strcpy(term_options, "150");
+	term->v_tic = 8;
+	term->h_tic = 8;
+	break;
+    case 3:
+	strcpy(term_options, "100");
+	term->v_tic = 6;
+	term->h_tic = 6;
+	break;
+    case 4:
+	strcpy(term_options, "75");
+	term->v_tic = 5;
+	term->h_tic = 5;
+	break;
+    }
+
+    if (parse_error)
+	int_error(c_token, "expecting dots per inch size 75, 100, 150 or 300");
+}
+
+
+TERM_PUBLIC void
+HPLJII_init()
+{
+    term->v_char = HPLJII_VCHAR;
+    term->h_char = HPLJII_HCHAR;
+}
+
+
+TERM_PUBLIC void
+HPLJII_graphics()
+{
+    HPLJII_COURIER;
+    HPLJII_PUSH_CURSOR;
+    /* rotate plot -90 degrees by reversing XMAX and YMAX and by
+       setting b_rastermode to TRUE */
+    b_makebitmap(HPLJII_YMAX, HPLJII_XMAX, 1);
+    b_rastermode = TRUE;
+}
+
+
+/* HPLJIItext by rjl - no compression */
+TERM_PUBLIC void
+HPLJII_text()
+{
+    register int x, j, row;
+
+    fprintf(gpoutfile, "\033*t%dR", HPLJII_PPI);
+    HPLJII_POP_CURSOR;
+    fputs("\033*r1A", gpoutfile);
+
+    /* dump bitmap in raster mode */
+    for (x = b_xsize - 1; x >= 0; x--) {
+	row = (b_ysize / 8) - 1;
+	fprintf(gpoutfile, "\033*b0m%dW", b_ysize / 8);
+	for (j = row; j >= 0; j--) {
+	    (void) fputc((char) (*((*b_p)[j] + x)), gpoutfile);
+	}
+    }
+    fputs("\033*rB", gpoutfile);
+
+    b_freebitmap();
+
+#ifndef VMS
+    /* most vms spoolers add a formfeed character */
+    putc('\f', gpoutfile);
+#endif /* !VMS */
+}
+
+
+
+TERM_PUBLIC void
+HPLJII_linetype(int linetype)
+{
+
+    if (hplj_dpp == 1) {
+	if (linetype >= 7)
+	    linetype %= 7;
+	/* b_pattern not appropriate for 300ppi graphics */
+	b_linemask = b_300ppi_pattern[linetype + 2];
+	b_maskcount = 0;
+    } else {
+	b_setlinetype(linetype);
+    }
+}
+
+TERM_PUBLIC void
+HPLJII_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    switch (b_angle) {
+    case 0:
+	y -= HPLJII_VCHAR / 5;
+	HPLJII_POP_CURSOR;
+	HPLJII_PUSH_CURSOR;
+	/* (0,0) is the upper left point of the paper */
+	fprintf(gpoutfile, "\033*p%+dx%+dY", x * HPLJII_DPP
+		,(HPLJII_YMAX - y - 1) * HPLJII_DPP);
+	fputs(str, gpoutfile);
+/*       for (; *str; ++str, x += HPLJII_HCHAR)
+            HPLJII_putc (x, y, *str, b_angle);*/
+	break;
+    case 1:
+	y += (HPLJII_HCHAR - 2 * HPLJII_VCHAR) / 2;
+	y += (HPLJII_VCHAR + HPLJII_HCHAR) * strlen(str) / 2;
+	for (; *str; ++str, y -= HPLJII_VCHAR)
+	    HPLJII_putc(x, y, *str, b_angle);
+	break;
+    }
+}
+
+static void
+HPLJII_putc(unsigned int x, unsigned int y, int c, int ang)
+{
+    HPLJII_POP_CURSOR;
+    HPLJII_PUSH_CURSOR;
+    (void) ang;			/* avoid -Wunused warnings */
+    /* (0,0) is the upper left point of the paper */
+    fprintf(gpoutfile, "\033*p%+dx%+dY",
+	    x * HPLJII_DPP, (HPLJII_YMAX - y - 1) * HPLJII_DPP);
+    fputc(c, gpoutfile);
+}
+
+
+TERM_PUBLIC void
+HPLJII_reset()
+{
+#ifdef VMS
+    fflush_binary();
+#endif /* VMS */
+}
+
+
+/* HP DeskJet routines */
+TERM_PUBLIC void
+HPDJ_graphics()
+{
+    switch (hplj_dpp) {
+    case 1:
+	b_charsize(FNT13X25);
+	term->v_char = FNT13X25_VCHAR;
+	term->h_char = FNT13X25_HCHAR;
+	break;
+    case 2:
+	b_charsize(FNT13X25);
+	term->v_char = FNT13X25_VCHAR;
+	term->h_char = FNT13X25_HCHAR;
+	break;
+    case 3:
+	b_charsize(FNT9X17);
+	term->v_char = FNT9X17_VCHAR;
+	term->h_char = FNT9X17_HCHAR;
+	break;
+    case 4:
+	b_charsize(FNT5X9);
+	term->v_char = FNT5X9_VCHAR;
+	term->h_char = FNT5X9_HCHAR;
+	break;
+    }
+    /* rotate plot -90 degrees by reversing XMAX and YMAX and by
+       setting b_rastermode to TRUE */
+    b_makebitmap(HPLJII_YMAX, HPLJII_XMAX, 1);
+    b_rastermode = TRUE;
+}
+
+
+/* 0 compression raster bitmap dump. Compatible with HP DeskJet 500
+   hopefully compatible with other HP Deskjet printers */
+TERM_PUBLIC void
+HPDJ_text()
+{
+    register int x, j, row;
+
+    fprintf(gpoutfile, "\
+\033*b0M\
+\033*t%dR\
+\033*r1A",
+	    HPLJII_PPI);
+
+    /* dump bitmap in raster mode */
+    for (x = b_xsize - 1; x >= 0; x--) {
+	row = (b_ysize / 8) - 1;
+	fprintf(gpoutfile, "\033*b%dW", b_ysize / 8);
+	for (j = row; j >= 0; j--) {
+	    (void) fputc((char) (*((*b_p)[j] + x)), gpoutfile);
+	}
+    }
+    fputs("\033*rbC", gpoutfile);
+
+    b_freebitmap();
+
+#ifndef VMS			/* most vms spoolers add a formfeed character */
+    putc('\f', gpoutfile);
+#endif /* !VMS */
+}
+
+#endif
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(hpljii_driver)
+    "hpljii", "HP Laserjet series II, [75 100 150 300]",
+    HPLJII_75PPI_XMAX, HPLJII_75PPI_YMAX, HPLJII_75PPI_VCHAR,
+    HPLJII_75PPI_HCHAR, HPLJII_75PPI_VTIC, HPLJII_75PPI_HTIC, HPLJII_options,
+    HPLJII_init, HPLJII_reset, HPLJII_text, null_scale,
+    HPLJII_graphics, b_move, b_vector, HPLJII_linetype,
+    HPLJII_put_text, b_text_angle, null_justify_text, line_and_point,
+    do_arrow, set_font_null, 0, TERM_BINARY,
+    0, 0, b_boxfill
+TERM_TABLE_END(hpljii_driver)
+
+#undef LAST_TERM
+#define LAST_TERM hpljii_driver
+
+TERM_TABLE_START(hpdj_driver)
+    "hpdj", "HP DeskJet 500, [75 100 150 300]",
+    HPLJII_75PPI_XMAX, HPLJII_75PPI_YMAX, HPLJII_75PPI_VCHAR,
+    HPLJII_75PPI_HCHAR, HPLJII_75PPI_VTIC, HPLJII_75PPI_HTIC, HPLJII_options,
+    HPLJII_init, HPLJII_reset, HPDJ_text, null_scale,
+    HPDJ_graphics, b_move, b_vector, HPLJII_linetype,
+    b_put_text, b_text_angle, null_justify_text, line_and_point,
+    do_arrow, set_font_null, 0, TERM_BINARY,
+    0, 0, b_boxfill
+TERM_TABLE_END(hpdj_driver)
+
+#undef LAST_TERM
+#define LAST_TERM hpdj_driver
+
+#endif
+#endif
+
+#ifdef TERM_HELP
+START_HELP(hpljii)
+"1 hpljii",
+"?commands set terminal hpljii",
+"?set terminal hpljii",
+"?set term hpljii",
+"?terminal hpljii",
+"?term hpljii",
+"?hpljii",
+"?commands set terminal hpdj",
+"?set terminal hpdj",
+"?set term hpdj",
+"?terminal hpdj",
+"?term hpdj",
+"?hpdj",
+" The `hpljii` terminal driver supports the HP Laserjet Series II printer.  The",
+" `hpdj` driver supports the HP DeskJet 500 printer.  These drivers allow a",
+" choice of resolutions.",
+"",
+" Syntax:",
+"       set terminal hpljii | hpdj {<res>}",
+"",
+" where `res` may be 75, 100, 150 or 300 dots per inch; the default is 75.",
+" Rasterization at the higher resolutions may require a large amount of memory.",
+"",
+" The `hp500c` terminal is similar to `hpdj`; `hp500c` additionally supports",
+" color and compression."
+END_HELP(hpljii)
+#endif /* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/hppj.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/hppj.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/hppj.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/hppj.trm.svn-base	2012-01-03 17:07:32.371927700 -0800
@@ -0,0 +1,291 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: hppj.trm,v 1.15 2006/07/21 02:35:47 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - hppj.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *  hppj
+ *
+ * AUTHORS
+ *  Dan Merget (danm@sr.hp.com)
+ *
+ * This file was based on the hpljii file by:
+ *  John Engels
+ *  Russell Lang
+ *  Maurice Castro
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+
+/* The following HP laserjet series II driver uses generic bit mapped graphics
+ * routines from bitmap.c to build up a bit map in memory.
+ */
+
+/*
+ * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(hppj)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void HPPJ_options __PROTO((void));
+TERM_PUBLIC void HPPJ_init __PROTO((void));
+TERM_PUBLIC void HPPJ_reset __PROTO((void));
+TERM_PUBLIC void HPPJ_graphics __PROTO((void));
+TERM_PUBLIC void HPPJ_text __PROTO((void));
+TERM_PUBLIC void HPPJ_linetype __PROTO((int linetype));
+
+/* We define 3 different font sizes: 5x9, 9x17, and 13x25 */
+
+#define HPPJ_DPI 180		/* dots per inch */
+#define HPPJ_PLANES 3		/* color planes */
+#define HPPJ_COLORS (1 << HPPJ_PLANES)
+/* make XMAX and YMAX a multiple of 8 */
+#define HPPJ_XMAX (8*(unsigned int)(9.5 * HPPJ_DPI / 8.0 + 0.9))
+#define HPPJ_YMAX (8 * HPPJ_DPI)
+
+/* default values for term_tbl */
+#define HPPJ_9x17_VCHAR FNT9X17_VCHAR
+#define HPPJ_9x17_HCHAR FNT9X17_HCHAR
+#define HPPJ_9x17_VTIC (FNT9X17_VCHAR / 2)
+#define HPPJ_9x17_HTIC (FNT9X17_HCHAR / 2)
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+static int hppj_font = FNT9X17;
+
+TERM_PUBLIC void
+HPPJ_options()
+{
+    char opt[10];
+#define HPPJERROR "expecting font size FNT5X9, FNT9X17, or FNT13X25"
+
+    term_options[0] = NUL;	/* default to empty string and 9x17 font */
+    hppj_font = FNT9X17;	/* in case of error or empty options     */
+
+    if (!END_OF_COMMAND) {
+	if (token[c_token].length > 8) {
+	    int_error(c_token, HPPJERROR);
+	}
+	capture(opt, c_token, c_token, /*4 */ 9);	/* HBB 980226 */
+	if (!strcmp(opt, "FNT5X9")) {
+	    hppj_font = FNT5X9;
+	    strcpy(term_options, "FNT5X9");
+	} else if (!strcmp(opt, "FNT9X17")) {
+	    hppj_font = FNT9X17;
+	    strcpy(term_options, "FNT9X17");
+	} else if (!strcmp(opt, "FNT13X25")) {
+	    hppj_font = FNT13X25;
+	    strcpy(term_options, "FNT13X25");
+	} else {
+	    int_error(c_token, HPPJERROR);
+	}
+	c_token++;
+    }
+}
+
+
+TERM_PUBLIC void
+HPPJ_init()
+{
+    /* HBB 980226: moved this here, from graphics(): only init() may
+     * change fields of *term ! */
+    switch (hppj_font) {
+    case FNT5X9:
+	term->v_char = FNT5X9_VCHAR;
+	term->h_char = FNT5X9_HCHAR;
+	term->v_tic = FNT5X9_VCHAR / 2;
+	term->h_tic = FNT5X9_HCHAR / 2;
+	break;
+    case FNT9X17:
+	term->v_char = FNT9X17_VCHAR;
+	term->h_char = FNT9X17_HCHAR;
+	term->v_tic = FNT9X17_VCHAR / 2;
+	term->h_tic = FNT9X17_HCHAR / 2;
+	break;
+    case FNT13X25:
+	term->v_char = FNT13X25_VCHAR;
+	term->h_char = FNT13X25_HCHAR;
+	term->v_tic = FNT13X25_VCHAR / 2;
+	term->h_tic = FNT13X25_HCHAR / 2;
+	break;
+    }
+}
+
+
+TERM_PUBLIC void
+HPPJ_reset()
+{
+#ifdef VMS
+    fflush_binary();
+#endif /* VMS */
+}
+
+
+TERM_PUBLIC void
+HPPJ_graphics()
+{
+    /* HBB 980226: move a block of code from here to init() */
+    b_charsize(hppj_font);
+
+    b_makebitmap(HPPJ_XMAX, HPPJ_YMAX, HPPJ_PLANES);
+}
+
+
+TERM_PUBLIC void
+HPPJ_text()
+{
+    int x, plane, y;		/* loop indexes */
+    int minRow, maxRow;		/* loop bounds */
+    int numBytes;		/* Number of run-length coded bytes to output */
+    int numReps;		/* Number of times the current byte is repeated */
+
+    fprintf(gpoutfile, "\
+\033E\033*t%dR\033*r%dS\
+\033*b0X\033*b0Y\033*r%dU\
+\033*v%dA\033*v%dB\033*v%dC\033*v%dI\
+\033*v%dA\033*v%dB\033*v%dC\033*v%dI\
+\033*v%dA\033*v%dB\033*v%dC\033*v%dI\
+\033*v%dA\033*v%dB\033*v%dC\033*v%dI\
+\033*v%dA\033*v%dB\033*v%dC\033*v%dI\
+\033*v%dA\033*v%dB\033*v%dC\033*v%dI\
+\033*v%dA\033*v%dB\033*v%dC\033*v%dI\
+\033*v%dA\033*v%dB\033*v%dC\033*v%dI\
+\033*b1M\033*r1A",
+	    HPPJ_DPI, HPPJ_YMAX,
+	    HPPJ_PLANES,
+	    90, 88, 85, 0,
+	    53, 8, 14, 1,
+	    3, 26, 22, 2,
+	    4, 4, 29, 3,
+	    53, 5, 25, 4,
+	    2, 22, 64, 5,
+	    89, 83, 13, 6,
+	    4, 4, 6, 7);
+
+    /* dump bitmap in raster mode using run-length encoding */
+    for (x = HPPJ_XMAX - 1; x >= 0; --x) {
+	for (plane = 0; plane < HPPJ_PLANES; plane++) {
+	    minRow = b_psize * plane;
+	    maxRow = b_psize * plane + b_psize - 1;
+
+	    /* Print column header */
+	    numBytes = 0;
+	    for (y = maxRow; y >= minRow; --y) {
+		if (y == minRow || *((*b_p)[y] + x) != *((*b_p)[y - 1] + x)) {
+		    numBytes += 2;
+		}
+	    }
+	    fprintf(gpoutfile, "\033*b%d", numBytes);
+	    (void) fputc((char) (plane < HPPJ_PLANES - 1 ? 'V' : 'W'), gpoutfile);
+
+	    /* Print remainder of column */
+	    numReps = 0;
+	    for (y = maxRow; y >= minRow; --y) {
+		if (y == minRow || *((*b_p)[y] + x) != *((*b_p)[y - 1] + x)) {
+		    (void) fputc((char) (numReps), gpoutfile);
+		    (void) fputc((char) (*((*b_p)[y] + x)), gpoutfile);
+		    numReps = 0;
+		} else {
+		    numReps++;
+		}
+	    }
+	}
+    }
+    fputs("\033*r1B\033E", gpoutfile);
+
+    b_freebitmap();
+}
+
+
+TERM_PUBLIC void
+HPPJ_linetype(int linetype)
+{
+    if (linetype >= 0) {
+	b_setlinetype(0);
+	b_setvalue((linetype % (HPPJ_COLORS - 1)) + 1);
+    } else {
+	b_setlinetype(linetype + 2);
+	b_setvalue(HPPJ_COLORS - 1);
+    }
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(hppj_driver)
+    "hppj", "HP PaintJet and HP3630 [FNT5X9 FNT9X17 FNT13X25]",
+    HPPJ_XMAX, HPPJ_YMAX,
+    HPPJ_9x17_VCHAR, HPPJ_9x17_HCHAR, HPPJ_9x17_VTIC, HPPJ_9x17_HTIC,
+    HPPJ_options, HPPJ_init, HPPJ_reset, HPPJ_text, null_scale, HPPJ_graphics,
+    b_move, b_vector, HPPJ_linetype, b_put_text, b_text_angle,
+    null_justify_text, do_point, do_arrow, set_font_null, 0, TERM_BINARY,
+    0, 0, b_boxfill
+TERM_TABLE_END(hppj_driver)
+
+#undef LAST_TERM
+#define LAST_TERM hppj_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(hppj)
+"1 hppj",
+"?commands set terminal hppj",
+"?set terminal hppj",
+"?set term hppj",
+"?terminal hppj",
+"?term hppj",
+"?hppj",
+" The `hppj` terminal driver supports the HP PaintJet and HP3630 printers.  The",
+" only option is the choice of font.",
+"",
+" Syntax:",
+"       set terminal hppj {FNT5X9 | FNT9X17 | FNT13X25}",
+"",
+" with the middle-sized font (FNT9X17) being the default."
+END_HELP(hppj)
+#endif
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/imagen.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/imagen.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/imagen.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/imagen.trm.svn-base	2012-01-03 17:07:32.579465900 -0800
@@ -0,0 +1,912 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: imagen.trm,v 1.20 2006/07/21 02:35:47 sfeam Exp $
+ */
+
+/* GNUPLOT - imagen.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *   Imagen laser printers
+ *
+ * AUTHORS
+ *   Paul E. McKenney, David Kotz
+ *   Rewritten/extended by:
+ *	Hans Olav Eggestad
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+
+/*
+ * Original for direct Imagen output (but retaining many of the
+ * LaTeX extensions) by Paul E. McKenney, 1989.
+ * Further modified by David Kotz to fit into gnuplot 2.0.
+ * Information Science and Technology Division, SRI International,
+ * 333 Ravenswood Ave, Menlo Park, CA 94025.
+ * Mail to mckenney@sri.com.
+ */
+/*
+ * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(imagen)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void IMAGEN_init __PROTO((void));
+TERM_PUBLIC void IMAGEN_graphics __PROTO((void));
+TERM_PUBLIC void IMAGEN_options __PROTO((void));
+TERM_PUBLIC void IMAGEN_text __PROTO((void));
+TERM_PUBLIC void IMAGEN_linetype __PROTO((int lt));
+TERM_PUBLIC void IMAGEN_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void IMAGEN_vector __PROTO((unsigned int ux, unsigned int uy));
+TERM_PUBLIC int IMAGEN_text_angle __PROTO((int ang));
+TERM_PUBLIC int IMAGEN_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC void IMAGEN_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
+TERM_PUBLIC void IMAGEN_reset __PROTO((void));
+#define IMAGEN_PTS_PER_INCH (300)
+#define IMAGEN_XMAX (IMAGEN_PTS_PER_INCH * 11)	/* 10.0 inches */
+#define IMAGEN_YMAX (IMAGEN_PTS_PER_INCH * 78 / 10)	/* 7.5 inches */
+#define IMAGEN_HTIC (20)
+#define IMAGEN_VTIC (20)
+#define IMAGEN_VCHAR (IMAGEN_FONTSIZE*5)
+#define IMAGEN_HCHAR (IMAGEN_VCHAR/2)
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+static void IM_page __PROTO((void));
+static void IMAGEN_draw_path __PROTO((void));
+static void IMAGEN_setpos __PROTO((int ux, int uy));
+static unsigned char *IMAGEN_cvts __PROTO((unsigned char *str, int *width, int *height));
+static void IMAGEN_putwd __PROTO((unsigned int w));
+static void IMAGEN_createfamily __PROTO((char *c, int sz));
+static void IMAGEN_setfont __PROTO((int sz));
+static void IMP_set_draw_pattern __PROTO((int pattern, int sz));
+static void IMAGEN_mapsinit __PROTO((void));
+static void IMAGEN_createmap __PROTO((int name, unsigned short *map));
+
+
+/*
+#ifndef __malloc_h
+#include <malloc.h>
+#endif
+*/
+#include "impcodes.h"
+
+/* default is landscape */
+#define IMAGEN_A4_H  (IMAGEN_PTS_PER_INCH * 83 / 10)
+#define IMAGEN_A4_W  (IMAGEN_PTS_PER_INCH * 116 / 10)
+
+/* width in current orientation */
+static int IMAGEN_Xmax = IMAGEN_XMAX;
+static int IMAGEN_Ymax = IMAGEN_YMAX;
+
+#define IMAGEN_FONTSIZE 12
+#define IMAGEN_FONT "cour"
+
+
+static unsigned short IMP_gmap[128];
+static unsigned char IMP_chmap[256];
+
+static int IMAGEN_page_h = IMAGEN_A4_H;
+static int IMAGEN_page_w = IMAGEN_A4_W;
+static int IM_win_horiz = 1;
+static int IM_win_verti = 1;
+static int IM_plot_nr = 0;
+
+static int IMAGEN_fontsize = IMAGEN_FONTSIZE;
+static int IMAGEN_familytable[36];
+static int IMAGEN_orgX;		/* absolute-pixel-ORIgin of graph page. */
+static int IMAGEN_orgY;
+static int IMAGEN_orgx;		/* absolute-pixel-ORIgin of current graph. */
+static int IMAGEN_orgy;
+static int IMAGEN_posx;		/* current drawing position (lines).    */
+static int IMAGEN_posy;
+/* static int IMAGEN_inplot; */
+static int IMAGEN_xmax = IMAGEN_XMAX;	/* width of graph in pixels.    */
+static int IMAGEN_ymax = IMAGEN_YMAX;	/* height of graph in pixels.   */
+static int IMAGEN_winx = IMAGEN_XMAX;	/* width of window in pixels.   */
+static int IMAGEN_winy = IMAGEN_YMAX;	/* height of window in pixels.  */
+static int IMAGEN_hchar;	/* Height of CHAR in current font.      */
+static int IMAGEN_wchar;	/* Width of CHAR in current font.       */
+static int IMAGEN_blofs;	/* BaseLine OFfSet from bounding box.   */
+static int IMAGEN_angle = -1;	/* 0 for horizontal text, 1 for vertical */
+static int IMAGEN_portrait;	/* 0 for landscape */
+static enum JUSTIFY IMAGEN_justify = LEFT;	/* left/center/right */
+
+#define STOREPATH 100
+static unsigned int IM_xvector[STOREPATH]; /* draw path vector of x values */
+static unsigned int IM_yvector[STOREPATH]; /* draw path vector of y values */
+static unsigned int IM_veclen;	/* length of allocated path vector */
+static unsigned int IM_vecpos = 0; /* current pos in vector */
+
+/* char IMPdrpattern[10][10] = { {0}, {30,10,0}, {0}, {10,30,0}, {2,20,0},
+	{20,10,0}, {30,20,10,20,0}, {30,20,4,10,10,10,4,20,0}, {40,20,0}, {30,15,4,15,0}
+};
+*/
+
+static char IMPdrpattern[10][10] =
+{
+/* -2 */ {0},
+/* -1 */ {1, 8, 0},
+/*  0 */ {0},
+/*  1 */ {16, 4, 0},
+/*  2 */ {3, 8, 0},
+/*  3 */ {8, 8, 0},
+/*  4 */ {16, 6, 3, 6, 0},
+/*  5 */ {16, 6, 8, 6, 0},
+/*  6 */ {16, 4, 1, 4, 8, 4, 1, 4, 0},
+/*  7 */ {16, 4, 1, 8, 1, 4, 0}
+};
+
+enum IMAGEN_id { IMAGEN_PORTRAIT, IMAGEN_LANDSCAPE, IMAGEN_OTHER };
+
+static struct gen_table IMAGEN_opts[] =
+{
+    { "p$ortrait", IMAGEN_PORTRAIT },
+    { "l$andscape", IMAGEN_LANDSCAPE },
+    { NULL, IMAGEN_OTHER }
+};
+
+TERM_PUBLIC void
+IMAGEN_options()
+{
+    struct value a;
+
+    while (!END_OF_COMMAND) {
+	switch(lookup_table(&IMAGEN_opts[0],c_token)) {
+	case IMAGEN_PORTRAIT:
+	    IMAGEN_portrait = TRUE;
+	    IMAGEN_page_h = IMAGEN_A4_W;
+	    IMAGEN_page_w = IMAGEN_A4_H;
+	    IMAGEN_Xmax = IMAGEN_YMAX;
+	    IMAGEN_Ymax = IMAGEN_XMAX;
+	    c_token++;
+	    break;
+	case IMAGEN_LANDSCAPE:
+	    IMAGEN_portrait = FALSE;
+	    c_token++;
+	    break;
+	case IMAGEN_OTHER:
+	default:
+	    if (equals(c_token, "[")) {	/* windows spesified */
+		c_token++;
+		/* if (IM_plot_nr>1) */
+		if (equals(c_token, "]")) {
+		    IM_page();
+		    c_token++;
+		    break;
+		}
+		if (END_OF_COMMAND) {
+		    int_error(c_token, "no. windows: [horizontal,vertical] expected");
+		} else if (!equals(c_token, ",")) {
+		    IM_win_horiz = (int) real(const_express(&a));
+		}
+		if (!equals(c_token, ","))
+		    int_error(c_token, "',' expected");
+		c_token++;
+		if (!equals(c_token, "]")) {
+		    IM_win_verti = (int) real(const_express(&a));
+		}
+		if (!equals(c_token, "]"))
+		    int_error(c_token, "expecting ']'");
+		c_token++;
+	    } else {
+		/* We have font size specified */
+		IMAGEN_fontsize = (int) real(const_express(&a));
+		if (IMAGEN_fontsize < 8)
+		    IMAGEN_fontsize = 8;
+		if (IMAGEN_fontsize > 15)
+		    IMAGEN_fontsize = 15;
+	    }
+	}
+    }
+    sprintf(term_options, "%d %s [%1d,%1d]", IMAGEN_fontsize, (IMAGEN_portrait) ? "portrait" :
+	    "landscape", IM_win_horiz, IM_win_verti);
+}
+
+
+TERM_PUBLIC void
+IMAGEN_init()
+{
+    register struct termentry *t = term;
+    /* char font[10];   */  /* font name */
+
+    IMAGEN_posx = IMAGEN_posy = 0;
+
+    IMAGEN_orgX = (IMAGEN_page_w - IMAGEN_Xmax) / 2;
+    IMAGEN_orgY = (IMAGEN_page_h - IMAGEN_Ymax) / 2;
+
+    IMAGEN_xmax = IMAGEN_winx = (int) (IMAGEN_Xmax / IM_win_horiz);
+    IMAGEN_ymax = IMAGEN_winy = (int) (IMAGEN_Ymax / IM_win_verti);
+
+    t->xmax = (unsigned int) (IMAGEN_xmax);
+    t->ymax = (unsigned int) (IMAGEN_ymax);
+
+    fputs("@document(language impress, paper a4)", gpoutfile);
+
+    if (IMAGEN_portrait) {
+	putc(imP_SET_ABS_V, gpoutfile);
+	IMAGEN_putwd(3520);
+    }
+    putc(imP_SET_HV_SYSTEM, gpoutfile);
+    putc(((IMAGEN_portrait ? 3 : 0) << 5) | (3 << 3) | (IMAGEN_portrait ? 0 : 5), gpoutfile);
+
+    /* sprintf(font, "cour%02d", IMAGEN_FONTSIZE); */
+    IMAGEN_mapsinit();
+    IMAGEN_createmap(1, IMP_gmap);
+    /* IMAGEN_createfamily(font, IMAGEN_FONTSIZE); */
+    IMAGEN_setfont(IMAGEN_fontsize);
+
+    IMAGEN_text_angle(0);
+
+    putc(imP_SET_ABS_H, gpoutfile);
+    IMAGEN_putwd(0);
+    putc(imP_SET_ABS_V, gpoutfile);
+    IMAGEN_putwd(0);
+
+    IMAGEN_linetype(LT_AXIS);
+    /*
+       if ((IM_xvector = (unsigned int *) malloc(STOREPATH*sizeof(int))) == NULL) {
+       fputs("Imagendriver: Unable to allocate memory for draw path\n", stderr);
+       exit(1);
+       }
+       if ((IM_yvector = (unsigned int *) malloc(STOREPATH*sizeof(int))) == NULL) {
+       fputs("Imagendriver: Unable to allocate memory for draw path\n", stderr);
+       exit(1);
+       }
+     */
+    IM_veclen = STOREPATH;
+    IM_vecpos = 0;
+}
+
+static void
+IM_page()
+{
+    if (IM_vecpos) {
+	/* fprintf(stderr,"graphics, draw path\n"); */
+	IMAGEN_draw_path();
+    }
+    putc(imP_ENDPAGE, gpoutfile);
+}
+
+TERM_PUBLIC void
+IMAGEN_graphics()
+{
+    int tmpx, tmpy;
+/*    int xoff, yoff; */
+
+    if (IM_vecpos) {
+	/* fprintf(stderr,"graphics, draw path\n"); */
+	IMAGEN_draw_path();
+    }
+    if (IM_plot_nr >= (IM_win_horiz * IM_win_verti)) {
+	IM_page();
+	IM_plot_nr = 0;
+    }
+    IM_plot_nr++;
+    tmpx = IMAGEN_orgX + ((IM_plot_nr - 1) % IM_win_horiz) * IMAGEN_winx;
+    tmpy = IMAGEN_orgY + ((IM_win_verti - 1) - (int) ((IM_plot_nr - 1) / IM_win_horiz)) * IMAGEN_winy;
+    IMAGEN_orgx = tmpx + (int) ((IMAGEN_winx - IMAGEN_xmax) / 2);
+    IMAGEN_orgy = tmpy + (int) ((IMAGEN_winy - IMAGEN_ymax) / 2);
+}
+
+
+TERM_PUBLIC void
+IMAGEN_text()
+{
+}
+
+
+#define DRAW_PATTERNS 6
+
+
+TERM_PUBLIC void
+IMAGEN_linetype(int lt)
+{
+    static int lastlinetype = -10;
+    int pen /*, pattern */ ;
+
+    if (IM_vecpos) {
+	/* fprintf(stderr,"move, draw path\n"); */
+	IMAGEN_draw_path();
+    }
+
+    if (lt < -2)
+	lt = LT_BLACK;
+
+    if (lt == LT_BLACK) {
+	pen = 4;
+    } else {
+	pen = (int) (lt / 8) * 2;
+	if (pen <= 0)
+	    pen = 1;
+    }
+    lt = (lt % 8) + 2;
+
+    if (lastlinetype == lt)
+	return;
+
+    lastlinetype = lt;
+
+    putc(imP_SET_PEN, gpoutfile);
+    putc(pen, gpoutfile);
+    IMP_set_draw_pattern(lt, pen);
+}
+
+
+TERM_PUBLIC void
+IMAGEN_move(unsigned int x, unsigned int y)
+{
+    if (IM_vecpos) {
+	/* fprintf(stderr,"move, draw path\n"); */
+	IMAGEN_draw_path();
+    }
+    IM_xvector[0] = x + IMAGEN_orgx;
+    IM_yvector[0] = y + IMAGEN_orgy;
+    /* fprintf(stderr,"Ny vector: startpos: %1d %1d\n",IM_xvector[0],IM_yvector[0]); */
+    IM_vecpos = 1;
+    /*
+       IMAGEN_posx = x;
+       IMAGEN_posy = y;
+     */
+}
+
+TERM_PUBLIC void
+IMAGEN_vector(unsigned int ux, unsigned int uy)
+{
+    /* void IMAGEN_draw_path(); */
+
+    /* Store path. */
+    IM_xvector[IM_vecpos] = ux + IMAGEN_orgx;
+    IM_yvector[IM_vecpos] = uy + IMAGEN_orgy;
+    /* fprintf(stderr,"Ny node: nr: %1d; %1d %1d\n",IM_vecpos,IM_xvector[IM_vecpos],IM_yvector[IM_vecpos]);  */
+    IM_vecpos++;
+    if (IM_vecpos >= IM_veclen) {
+	IMAGEN_draw_path();
+	IM_xvector[0] = ux + IMAGEN_orgx;
+	IM_yvector[0] = uy + IMAGEN_orgy;
+	IM_vecpos = 1;
+    }
+}
+
+static void
+IMAGEN_draw_path()
+{
+/*    unsigned int pos; */
+    register int i;
+
+    putc(imP_CREATE_PATH, gpoutfile);
+    IMAGEN_putwd(IM_vecpos);
+    for (i = 0; i < IM_vecpos; i++) {
+	/*
+	   IMAGEN_putwd(IM_xvector[i] + IMAGEN_orgx);
+	   IMAGEN_putwd(IM_yvector[i] + IMAGEN_orgy);
+	 */
+	IMAGEN_putwd(IM_xvector[i]);
+	IMAGEN_putwd(IM_yvector[i]);
+    }
+    IM_vecpos = 0;
+    /* Draw path with black pen. */
+
+    putc(imP_DRAW_PATH, gpoutfile);
+    putc(15, gpoutfile);
+
+    /* Set current position to end of line. */
+
+    /* IMAGEN_move(ux, uy); */
+}
+
+static void
+IMAGEN_setpos(int ux, int uy)
+{
+    /* Set x and y position (for text), also set beginning-of-line. */
+
+    putc(imP_SET_ABS_H, gpoutfile);
+    IMAGEN_putwd(ux + IMAGEN_orgx);
+    putc(imP_SET_ABS_V, gpoutfile);
+    IMAGEN_putwd(uy + IMAGEN_orgy);
+    putc(imP_SET_BOL, gpoutfile);
+    if (IMAGEN_angle == 1)
+	IMAGEN_putwd(uy + IMAGEN_orgx);		/* vertical */
+    else
+	IMAGEN_putwd(ux + IMAGEN_orgx);		/* horizontal */
+}
+
+TERM_PUBLIC int
+IMAGEN_text_angle(int ang)
+{
+    if (IM_vecpos) {
+	/* fprintf(stderr,"text_angle, draw path\n"); */
+	IMAGEN_draw_path();
+    }
+    if (IMAGEN_angle != ang) {
+	IMAGEN_angle = ang;	/* record for later use */
+	putc(imP_SET_ADV_DIRS, gpoutfile);
+	putc(ang == 0 ? 0 : 7, gpoutfile);	/* 0=>horiz : 7=>vert */
+    }
+    return (TRUE);
+}
+
+TERM_PUBLIC int
+IMAGEN_justify_text(enum JUSTIFY mode)
+{
+    if (IM_vecpos) {
+	/* fprintf(stderr,"justify_text, draw path\n"); */
+	IMAGEN_draw_path();
+    }
+    IMAGEN_justify = mode;
+    return (TRUE);
+}
+
+static unsigned char *
+IMAGEN_cvts(unsigned char *str, int *width, int *height)
+{
+    unsigned char *cp1;
+    unsigned char *cp2;
+    static unsigned char *buf = NULL;
+    int h;
+    int maxw;
+    int w;
+
+    /* Free up old buffer, if there is one, get a new one.  Since       */
+    /* all transformations shorten the string, get a buffer that is     */
+    /* the same size as the input string.                               */
+
+    if (buf != NULL)
+	(void) free(buf);
+    buf = (unsigned char *) gp_alloc(strlen((char *) str)+2, "converted label string");
+
+    /* Do the transformations. */
+
+    cp1 = str;
+    cp2 = buf;
+    h = 1;
+    maxw = 0;
+    w = 0;
+    while (strlen((char *) cp1) > 0) {
+	switch (*cp1) {
+	case ' ':		/* Space character. */
+	    *cp2++ = imP_SP;
+	    w++;
+	    break;
+
+	case '\\':		/* Escape sequence. */
+	    if (*++cp1 == '\\') {
+		/* Begin new line. */
+		h++;
+		if (w > maxw)
+		    maxw = w;
+		w = 0;
+		*cp2++ = '\n';
+		/* *cp2++ = imP_CRLF; */
+		break;
+	    }
+	    /* Fall through to just copy next char out. */
+
+	default:
+	    /* *cp2++ = *cp1; */
+	    *cp2++ = IMP_chmap[*cp1];
+	    w++;
+	    break;
+	}
+	cp1++;
+    }
+
+    *cp2++ = '\n';
+    *cp2 = '\0';
+    if (w > maxw)
+	maxw = w;
+
+    if (height != NULL)
+	*height = IMAGEN_angle ?
+	    IMAGEN_wchar * maxw :
+	    IMAGEN_hchar * h;
+    if (width != NULL)
+	*width = IMAGEN_angle ?
+	    IMAGEN_hchar * h :
+	    IMAGEN_wchar * maxw;
+    return (buf);
+}
+
+TERM_PUBLIC void
+IMAGEN_put_text(unsigned int x, unsigned int y, const char str[])
+{
+    unsigned char *cvstr, *p;
+    int height;
+    int width;
+    int sx, sy;
+
+    if (IM_vecpos) {
+	/* fprintf(stderr,"put_text, draw path\n"); */
+	IMAGEN_draw_path();
+    }
+    cvstr = IMAGEN_cvts((unsigned char *) str, &width, &height);
+
+    if (IMAGEN_angle) {		/* vertical */
+	/* x += IMAGEN_hchar; */
+	x -= width / 2 - IMAGEN_hchar;
+	/* y -= height/2; */
+    } else			/* horizontal */
+	y += height / 2 - IMAGEN_hchar;
+
+    while ((p = (unsigned char *) strchr((char *) cvstr, '\n'))) {
+	*p = '\0';
+	sx = x;
+	sy = y;
+	if (IMAGEN_angle)
+	    sx = x - IMAGEN_blofs;
+	else
+	    sy = y + IMAGEN_blofs;
+
+	width = strlen((char *) cvstr) * IMAGEN_wchar;
+
+	switch (IMAGEN_justify) {
+	case LEFT:
+	    break;
+	case CENTRE:
+	    if (IMAGEN_angle) {
+		sy = y - width / 2;
+	    } else {
+		sx = x - width / 2;
+	    }
+	    break;
+	    /*x -= width/2; break; */
+	case RIGHT:
+	    if (IMAGEN_angle) {
+		sy = y - width;
+	    } else {
+		sx = x - width;
+	    }
+	    break;
+	    /* x -= width; break; */
+	}
+
+	IMAGEN_setpos(sx, sy);
+	fputs((char *) cvstr, gpoutfile);
+	cvstr = ++p;
+	if (IMAGEN_angle) {	/* vertical */
+	    x += IMAGEN_hchar;
+	} else {
+	    y -= IMAGEN_hchar;
+	}
+
+    }
+}
+
+TERM_PUBLIC void
+IMAGEN_reset()
+{
+    if (IM_vecpos) {
+	/* fprintf(stderr,"reset, draw path\n"); */
+	IMAGEN_draw_path();
+    }
+    putc(imP_EOF, gpoutfile);
+}
+
+static void
+IMAGEN_putwd(unsigned int w)
+{
+    /* fprintf(stderr,"%1u\n",w); */
+    putc(w >> 8, gpoutfile);
+    putc(w, gpoutfile);
+}
+
+static void
+IMAGEN_createfamily(char *c, int sz)
+{
+
+    putc(imP_CREATE_FAMILY_TABLE, gpoutfile);
+    putc(sz, gpoutfile);
+    putc(1, gpoutfile);
+    putc(1, gpoutfile);
+    /* putc(0, gpoutfile); */
+    fputs(c, gpoutfile);
+    putc(0, gpoutfile);
+}
+
+static void
+IMAGEN_setfont(int sz)
+{
+    char font[20];
+
+    if (!IMAGEN_familytable[sz]) {
+	sprintf(font, "%s%02d", IMAGEN_FONT, sz);
+	IMAGEN_createfamily(font, sz);
+	IMAGEN_familytable[sz] = sz;
+    }
+    IMAGEN_hchar = sz * 5;
+    IMAGEN_wchar = IMAGEN_hchar / 2;
+    IMAGEN_blofs = IMAGEN_hchar / 3;
+    term->v_char = IMAGEN_hchar;
+    term->h_char = IMAGEN_wchar;
+    putc(imP_SET_FAMILY, gpoutfile);
+    putc(sz, gpoutfile);
+    putc(imP_SET_SP, gpoutfile);
+    IMAGEN_putwd(IMAGEN_wchar);
+    putc(imP_SET_IL, gpoutfile);
+    IMAGEN_putwd(IMAGEN_hchar);
+}
+
+static void
+IMP_set_draw_pattern(int pattern, int sz)
+{
+    int i /*,j */ ;
+    putc(imP_SET_DRAW_PATTERN, gpoutfile);
+    putc(0, gpoutfile);
+    putc(imP_SET_DRAW_PATTERN, gpoutfile);
+    /* if ( strlen(IMPdrpattern[pattern]) == 1 ) {
+       putc(type,gpoutfile);
+       return;
+       } */
+    putc(strlen(IMPdrpattern[pattern]), gpoutfile);
+    for (i = 0; i < strlen(IMPdrpattern[pattern]); i++) {
+	IMAGEN_putwd(IMPdrpattern[pattern][i] * sz);
+    }
+}
+
+
+static void
+IMAGEN_mapsinit()
+{
+
+    register int i /*, j */ ;
+
+    for (i = 32; i < 127; i++) {
+	IMP_gmap[i] = i;
+    }
+    IMP_gmap[1] = 225;
+    IMP_gmap[2] = 233;
+    IMP_gmap[3] = 61736;
+    IMP_gmap[4] = 241;
+    IMP_gmap[5] = 249;
+    IMP_gmap[6] = 61864;
+    IMP_gmap[7] = 162;
+    IMP_gmap[8] = 163;
+    IMP_gmap[9] = 164;
+    IMP_gmap[10] = 165;
+    IMP_gmap[11] = 167;
+    IMP_gmap[12] = 171;
+    IMP_gmap[13] = 182;
+    IMP_gmap[14] = 61346;
+    IMP_gmap[15] = 191;
+    IMP_gmap[16] = 187;
+    IMP_gmap[17] = 188;
+    IMP_gmap[18] = 189;
+    IMP_gmap[19] = 190;
+    IMP_gmap[20] = 210;
+    IMP_gmap[21] = 211;
+    IMP_gmap[22] = 251;
+    IMP_gmap[23] = 61232;
+    IMP_gmap[24] = 212;
+    IMP_gmap[25] = 137;
+    IMP_gmap[26] = 176;
+    IMP_gmap[27] = 161;
+    IMP_gmap[28] = 139;
+    IMP_gmap[29] = 133;
+    IMP_gmap[30] = 140;
+    IMP_gmap[31] = 61249;
+    IMP_gmap[32] = 8738;
+    IMP_gmap[34] = 186;
+    IMP_gmap[36] = 164;
+    IMP_gmap[39] = 185;
+    IMP_gmap[127] = 61286;
+
+    /* for (i=1;i<127;i++) fprintf(stderr,"%d -> %d\n",i,IMP_gmap[i]); */
+
+    for (i = 32; i <= 127; i++) {
+	IMP_chmap[i] = i;
+    }
+    for (i = 128; i <= 255; i++) {
+	IMP_chmap[i] = 128;	/* first map all non printable chars to SPACE */
+    }
+
+    IMP_chmap[161] = 27;
+    IMP_chmap[162] = 7;
+    IMP_chmap[163] = 8;
+    IMP_chmap[164] = 120;
+    IMP_chmap[165] = 10;
+    IMP_chmap[166] = 124;
+    IMP_chmap[167] = 11;
+    IMP_chmap[168] = 25;
+    IMP_chmap[169] = 21;
+    IMP_chmap[170] = 45;
+    IMP_chmap[171] = 12;
+    IMP_chmap[172] = 83;
+    IMP_chmap[173] = 45;
+    IMP_chmap[174] = 20;
+    IMP_chmap[175] = 126;
+    IMP_chmap[176] = 26;
+    IMP_chmap[177] = 12;
+    IMP_chmap[178] = 1;
+    IMP_chmap[179] = 2;
+    IMP_chmap[180] = 29;
+    IMP_chmap[181] = 52;
+    IMP_chmap[182] = 13;
+    IMP_chmap[183] = 5;
+    IMP_chmap[184] = 28;
+    IMP_chmap[185] = 3;
+    IMP_chmap[186] = 45;
+    IMP_chmap[187] = 16;
+    IMP_chmap[188] = 17;
+    IMP_chmap[189] = 18;
+    IMP_chmap[190] = 19;
+    IMP_chmap[191] = 15;
+    IMP_chmap[192] = 65;
+    IMP_chmap[193] = 65;
+    IMP_chmap[194] = 65;
+    IMP_chmap[195] = 65;
+    IMP_chmap[196] = 65;
+    IMP_chmap[197] = 3;
+    IMP_chmap[198] = 1;
+    IMP_chmap[199] = 67;
+    IMP_chmap[200] = 69;
+    IMP_chmap[201] = 69;
+    IMP_chmap[202] = 69;
+    IMP_chmap[203] = 69;
+    IMP_chmap[204] = 73;
+    IMP_chmap[205] = 73;
+    IMP_chmap[206] = 73;
+    IMP_chmap[207] = 73;
+    IMP_chmap[208] = 68;
+    IMP_chmap[209] = 78;
+    IMP_chmap[210] = 79;
+    IMP_chmap[211] = 79;
+    IMP_chmap[212] = 79;
+    IMP_chmap[213] = 79;
+    IMP_chmap[214] = 79;
+    IMP_chmap[215] = 13;
+    IMP_chmap[216] = 2;
+    IMP_chmap[217] = 85;
+    IMP_chmap[218] = 85;
+    IMP_chmap[219] = 85;
+    IMP_chmap[220] = 85;
+    IMP_chmap[221] = 89;
+    IMP_chmap[222] = 32;
+    IMP_chmap[223] = 22;
+    IMP_chmap[224] = 97;
+    IMP_chmap[225] = 97;
+    IMP_chmap[226] = 97;
+    IMP_chmap[227] = 97;
+    IMP_chmap[228] = 97;
+    IMP_chmap[229] = 6;
+    IMP_chmap[230] = 4;
+    IMP_chmap[231] = 99;
+    IMP_chmap[232] = 101;
+    IMP_chmap[233] = 101;
+    IMP_chmap[234] = 101;
+    IMP_chmap[235] = 101;
+    IMP_chmap[236] = 105;
+    IMP_chmap[237] = 105;
+    IMP_chmap[238] = 105;
+    IMP_chmap[239] = 105;
+    IMP_chmap[240] = 100;
+    IMP_chmap[241] = 110;
+    IMP_chmap[242] = 111;
+    IMP_chmap[243] = 111;
+    IMP_chmap[244] = 111;
+    IMP_chmap[245] = 111;
+    IMP_chmap[246] = 111;
+    IMP_chmap[247] = 10;
+    IMP_chmap[248] = 5;
+    IMP_chmap[249] = 117;
+    IMP_chmap[250] = 117;
+    IMP_chmap[251] = 117;
+    IMP_chmap[252] = 117;
+    IMP_chmap[253] = 121;
+    IMP_chmap[254] = 32;
+    IMP_chmap[255] = 121;
+}
+
+static void
+IMAGEN_createmap(int name, unsigned short *map)
+{
+    register int i, j;
+    unsigned char s[4], *p;
+
+    p = s;
+    *p++ = imP_CREATE_MAP;
+    *p++ = name;
+    j = 0;
+    for (i = 0; i < 127; i++) {
+	if (map[i])
+	    j++;
+    }
+    *p = j;
+    for (i = 0; i < 3; i++)
+	putc(s[i], gpoutfile);
+
+    s[3] = 1;
+    for (j = 0; j < 127; j++) {
+	if (map[j]) {
+	    p = s;
+	    *p++ = j;
+	    *p++ = map[j] >> 8;
+	    *p = map[j] & 255;
+	    for (i = 0; i < 4; i++)
+		putc(s[i], gpoutfile);
+	}
+    }
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(imagen_driver)
+    "imagen", "Imagen laser printer",
+    IMAGEN_XMAX, IMAGEN_YMAX, IMAGEN_VCHAR, IMAGEN_HCHAR,
+    IMAGEN_VTIC, IMAGEN_HTIC, IMAGEN_options, IMAGEN_init, IMAGEN_reset,
+    IMAGEN_text, null_scale, IMAGEN_graphics, IMAGEN_move,
+    IMAGEN_vector, IMAGEN_linetype, IMAGEN_put_text, IMAGEN_text_angle,
+    IMAGEN_justify_text, line_and_point, do_arrow, set_font_null
+TERM_TABLE_END(imagen_driver)
+
+#undef LAST_TERM
+#define LAST_TERM imagen_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(imagen)
+"1 imagen",
+"?commands set terminal imagen",
+"?set terminal imagen",
+"?set term imagen",
+"?terminal imagen",
+"?term imagen",
+"?imagen",
+" The `imagen` terminal driver supports Imagen laser printers.  It is capable",
+" of placing multiple graphs on a single page.",
+"",
+" Syntax:",
+"       set terminal imagen {<fontsize>} {portrait | landscape}",
+"                           {[<horiz>,<vert>]}",
+"",
+" where `fontsize` defaults to 12 points and the layout defaults to `landscape`.",
+" `<horiz>` and `<vert>` are the number of graphs in the horizontal and",
+" vertical directions; these default to unity.",
+"",
+" Example:",
+"       set terminal imagen portrait [2,3]",
+"",
+" puts six graphs on the page in three rows of two in portrait orientation."
+END_HELP(imagen)
+#endif
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/impcodes.h.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/impcodes.h.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/impcodes.h.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/impcodes.h.svn-base	2012-01-03 17:07:32.776978100 -0800
@@ -0,0 +1,64 @@
+/*
+ * $Id: impcodes.h,v 1.1.1.1 1998/04/15 19:16:49 lhecking Exp $
+ */
+
+/*
+ * Copyright (c) 1985 Regents of the University of California.
+ * All rights reserved.  The Berkeley software License Agreement
+ * specifies the terms and conditions for redistribution.
+ *
+ *	@(#)imPcodes.h	5.1 (Berkeley) 9/21/85
+ */
+
+#define	imP_SP	128
+#define	imP_SP1	129
+#define	imP_OLD_MMOVE	130
+#define	imP_MPLUS	131
+#define	imP_MMINUS	132
+#define	imP_MMOVE	133
+#define	imP_SMOVE	134
+
+#define	imP_SET_ABS_H	135
+#define	imP_SET_REL_H	136
+#define	imP_SET_ABS_V	137
+#define	imP_SET_REL_V	138
+
+#define	imP_SRULE	192
+#define	imP_BRULE	193
+
+#define	imP_SET_HPOS	195
+#define	imP_SET_VPOS	196
+#define	imP_CRLF	197
+#define	imP_SGLY	198
+#define	imP_BGLY	199
+#define	imP_DELG	200
+#define	imP_DELC	201
+#define	imP_DELF	202
+
+#define	imP_SET_HV_SYSTEM	205
+#define	imP_SET_ADV_DIRS	206
+#define	imP_SET_FAMILY	207
+#define	imP_SET_IL	208
+#define	imP_SET_BOL	209
+#define	imP_SET_SP	210
+#define	imP_PUSH	211
+#define	imP_POP	212
+#define	imP_PAGE	213
+#define	imP_SET_PUSH_MASK	214
+#define	imP_ENDPAGE	219
+
+#define	imP_CREATE_FAMILY_TABLE	221
+#define	imP_CREATE_MAP	222
+
+#define	imP_CREATE_PATH	230
+#define	imP_SET_TEXTURE	231
+#define	imP_SET_PEN	232
+#define	imP_FILL_PATH	233
+#define	imP_DRAW_PATH	234
+#define	imP_BITMAP	235
+#define	imP_SET_MAGN	236
+#define	imP_SET_DRAW_PATTERN	237
+
+#define	imP_EOF	255
+
+
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/kyo.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/kyo.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/kyo.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/kyo.trm.svn-base	2012-01-03 17:07:37.212480500 -0800
@@ -0,0 +1,224 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: kyo.trm,v 1.12 2006/07/21 02:35:47 sfeam Exp $
+ *
+ */
+
+/* Prescribe (KYOCERA) driver - Michael Waldor */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/* Modified for gnuplot 2.0 sk@sun4 24-Apr-1990 13:23 */
+
+/*
+ * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(prescribe)
+register_term(kyo)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void PRE_init __PROTO((void));
+TERM_PUBLIC void KYO_init __PROTO((void));
+TERM_PUBLIC void PRE_graphics __PROTO((void));
+TERM_PUBLIC void PRE_text __PROTO((void));
+TERM_PUBLIC void PRE_linetype __PROTO((int linetype));
+TERM_PUBLIC void PRE_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void PRE_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void PRE_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC int PRE_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC void PRE_reset __PROTO((void));
+
+#define PRE_XMAX 2567
+#define PRE_YMAX 1815		/* X:Y = sqrt(2) */
+
+#define PRE_VCHAR (PRE_YMAX/30)
+#define PRE_HCHAR 33		/* about 9 chars per inch */
+#define PRE_HTIC (PRE_XMAX/80)
+#define PRE_VTIC PRE_HTIC
+
+/* for Courier font: */
+#define KYO_VCHAR (14*(300/72))	/* 12 pt + 2 pt baselineskip */
+#define KYO_HCHAR (300/10)	/*  10 chars per inch */
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+#define PRE_XLAST (PRE_XMAX - 1)
+#define PRE_YLAST (PRE_YMAX - 1)
+
+enum JUSTIFY pre_justify = LEFT;	/* text is flush left */
+
+TERM_PUBLIC void
+PRE_init()
+{
+    fputs("!R! RES;\n", gpoutfile);
+    /* UNIT: units are dots, 300 dots = 1 in = 72 pt */
+    /* SPO: landscape format */
+    /* STM, SLM set top, left margin */
+    /* Font: bold Helvetica (proportional font) */
+    fputs("PAGE; UNIT D; SPO L; STM 280; SLM 440;\n", gpoutfile);
+    fputs("FTMD 15; FONT 29; SCPI 9;\n", gpoutfile);
+}
+
+TERM_PUBLIC void
+KYO_init()
+{
+    fputs("!R! RES;\n", gpoutfile);
+    /* UNIT: units are dots, 300 dots = 1 in = 72 pt */
+    /* SPO: landscape format */
+    /* STM, SLM set top, left margin */
+    /* Font: Courier (fixed width font) */
+    fputs("PAGE; UNIT D; SPO L; STM 280; SLM 440;\n", gpoutfile);
+    fputs("FTMD 15; FONT 17; SCPI 10;\n", gpoutfile);
+}
+
+TERM_PUBLIC void
+PRE_graphics()
+{
+}
+
+TERM_PUBLIC void
+PRE_text()
+{				/* eject page after each plot */
+    fputs("PAGE;\n", gpoutfile);
+}
+
+TERM_PUBLIC void
+PRE_linetype(int linetype)
+{
+    /* actually choose pendiameter */
+    if (linetype < 0)
+	linetype = -linetype;
+    else
+	linetype = 3;
+    (void) fprintf(gpoutfile, "SPD %d;\n", linetype);
+}
+
+TERM_PUBLIC void
+PRE_move(unsigned int x, unsigned int y)
+{
+    (void) fprintf(gpoutfile, "MAP %1d,%1d;\n", x, PRE_YMAX - y);
+}
+
+TERM_PUBLIC void
+PRE_vector(unsigned int x, unsigned int y)
+{
+    (void) fprintf(gpoutfile, "DAP %1d, %1d;\n", x, PRE_YMAX - y);
+}
+
+TERM_PUBLIC void
+PRE_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    PRE_move(x, y);
+    switch (pre_justify) {
+    case RIGHT:
+	(void) fprintf(gpoutfile, "RTXT \"%s\", B;\n", str);
+	break;
+    default:
+	(void) fprintf(gpoutfile, "TEXT \"%s\", B;\n", str);
+    }
+}
+
+TERM_PUBLIC int
+PRE_justify_text(enum JUSTIFY mode)
+{
+    pre_justify = mode;
+    switch (pre_justify) {
+    case LEFT:
+    case RIGHT:
+	return (TRUE);
+    default:
+	return (FALSE);
+    }
+
+}
+
+TERM_PUBLIC void
+PRE_reset()
+{
+    fputs("PAGE; RES; EXIT;\n", gpoutfile);
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+TERM_TABLE_START(prescribe_driver)
+    "prescribe", "Prescribe - for the Kyocera Laser Printer",
+    PRE_XMAX, PRE_YMAX, PRE_VCHAR, PRE_HCHAR,
+    PRE_VTIC, PRE_HTIC, options_null, PRE_init, PRE_reset,
+    PRE_text, null_scale, PRE_graphics, PRE_move, PRE_vector,
+    PRE_linetype, PRE_put_text, null_text_angle,
+    PRE_justify_text, line_and_point, do_arrow, set_font_null
+TERM_TABLE_END(prescribe_driver)
+
+#undef LAST_TERM
+#define LAST_TERM prescribe_driver
+
+TERM_TABLE_START(kyo_driver)
+    "kyo", "Kyocera Laser Printer with Courier font",
+    PRE_XMAX, PRE_YMAX, KYO_VCHAR, KYO_HCHAR,
+    PRE_VTIC, PRE_HTIC, options_null, KYO_init, PRE_reset,
+    PRE_text, null_scale, PRE_graphics, PRE_move, PRE_vector,
+    PRE_linetype, PRE_put_text, null_text_angle,
+    PRE_justify_text, line_and_point, do_arrow, set_font_null
+TERM_TABLE_END(kyo_driver)
+
+#undef LAST_TERM
+#define LAST_TERM kyo_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(kyo)
+"1 kyo",
+"?commands set terminal kyo",
+"?set terminal kyo",
+"?set term kyo",
+"?terminal kyo",
+"?term kyo",
+"?kyo",
+"?commands set terminal prescribe",
+"?set terminal prescribe",
+"?set term prescribe",
+"?terminal prescribe",
+"?term prescribe",
+"?prescribe",
+" The `kyo` and `prescribe` terminal drivers support the Kyocera laser printer.",
+" The only difference between the two is that `kyo` uses \"Helvetica\" whereas",
+" `prescribe` uses \"Courier\".  There are no options."
+END_HELP(kyo)
+#endif
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/latex.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/latex.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/latex.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/latex.trm.svn-base	2012-01-03 17:07:37.473156500 -0800
@@ -0,0 +1,1009 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: latex.trm,v 1.34.2.1 2009/10/10 06:07:05 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - latex.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *   LaTeX pictures (latex).
+ *   LaTeX pictures with emTeX specials (emtex).
+ *
+ * AUTHORS
+ *   David Kotz, Russell Lang
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+
+/* modified to optimize use of \rule for long lines */
+/* TLDC: modified to have nice line types */
+
+/* the following LATEX driver has been modified by
+   Russell Lang, eln272v@monu1.cc.monash.oz from the
+   GnuTeX 1.3 driver by David Kotz, David.Kotz@Dartmouth.edu.
+   Since then it has been further extended by David Kotz.
+   EmTeX driver by Russell Lang. */
+
+/*  9 Dec 1992  LATEX_put_text rewritten to handle \\ newlines
+                Daniel S. Lewart (d-lewart@uiuc.edu) */
+
+/* Since it took me a little while to figure out what is happening,
+ * I may as well write it down.
+ *  There are three length scales of interest: inches, points
+ * and dots. inches are obvious. points are the usual typesetting
+ * thing (ie approx 72 points per inch). This driver works in
+ * units of dots, which corresponds to pixels on a 300 DPI printer.
+ * We do a \setlength{unitlength}{...pt} to make teX work in
+ * terms of dots.  The ... is called LATEX_UNIT in here.
+ *   The reason I had to get involved in all of this is because
+ * font size (in pts) was not being scaled up by DOTS_PER_POINT
+ * - drd, Sept 1996
+ */
+
+/* E A Merritt Feb 2007 - change sequence of point types to match
+ * PostScript and other terminals. Uses symbols from amssymb package.
+ */
+
+/* T.Sefzick Oct 2009 - rotate text when option 'rotated' is given.
+ * needs graphics or graphicx package.
+ */
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(latex)
+#ifdef EMTEX
+register_term(emtex)
+#endif
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void LATEX_options __PROTO((void));
+TERM_PUBLIC void LATEX_init __PROTO((void));
+TERM_PUBLIC void LATEX_graphics __PROTO((void));
+TERM_PUBLIC void LATEX_text __PROTO((void));
+TERM_PUBLIC void LATEX_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
+TERM_PUBLIC void LATEX_linetype __PROTO((int linetype));
+TERM_PUBLIC void LATEX_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void LATEX_point __PROTO((unsigned int x, unsigned int y, int number));
+TERM_PUBLIC void LATEX_vector __PROTO((unsigned int ux, unsigned int uy));
+TERM_PUBLIC void LATEX_arrow __PROTO((unsigned int sx, unsigned int sy, unsigned int ex, unsigned int ey, int head));
+TERM_PUBLIC int LATEX_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC int LATEX_text_angle __PROTO((int ang));
+TERM_PUBLIC void LATEX_reset __PROTO((void));
+TERM_PUBLIC void LATEX_fillbox __PROTO((int style, unsigned int x1, unsigned int y1, 
+					unsigned int width, unsigned int height));
+
+#ifdef EMTEX
+TERM_PUBLIC void EMTEX_init __PROTO((void));
+TERM_PUBLIC void EMTEX_reset __PROTO((void));
+TERM_PUBLIC void EMTEX_text __PROTO((void));
+#endif
+
+#ifdef EEPIC
+TERM_PUBLIC void EEPIC_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void EEPIC_vector __PROTO((unsigned int ux, unsigned int uy));
+#endif
+
+#define TINY_STEP 0.5		/* tiny steps for high quality lines */
+
+#define LATEX_PTS_PER_INCH (72.27)
+#define DOTS_PER_INCH (300)	/* resolution of printer we expect to use */
+#define LATEX_UNIT (LATEX_PTS_PER_INCH/DOTS_PER_INCH)	/* dot size in pt */
+
+/* 5 inches wide by 3 inches high (default) */
+#define LATEX_XMAX (5*DOTS_PER_INCH)	/* (LATEX_PTS_PER_INCH/LATEX_UNIT*5.0) */
+#define LATEX_YMAX (3*DOTS_PER_INCH)	/* (LATEX_PTS_PER_INCH/LATEX_UNIT*3.0) */
+
+#define LATEX_HTIC (5*DOTS_PER_INCH/72)		/* (5 pts) */
+#define LATEX_VTIC (5*DOTS_PER_INCH/72)		/* (5 pts) */
+#define LATEX_HCHAR (DOTS_PER_INCH*53/10/72)	/* (5.3 pts) */
+#define LATEX_VCHAR (DOTS_PER_INCH*11/72)	/* (11 pts) */
+#endif
+
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+static int LATEX_posx;
+static int LATEX_posy;
+static int LATEX_fontsize = 10;
+static char LATEX_font[MAX_ID_LEN+1] = "doc";
+static enum JUSTIFY latex_justify = LEFT;
+static int latex_angle = 0;
+static TBOOLEAN latex_rotate = FALSE;
+
+static TBOOLEAN latex_explicit_size = FALSE;
+static size_units latex_explicit_units = INCHES;
+
+/* Default line-drawing character */
+/* the definition of plotpoint varies with linetype */
+#define LATEX_DOT "\\usebox{\\plotpoint}"
+#define LATEX_TINY_DOT "\\rule{1pt}{1pt}"	/* for dots plot style */
+
+/* POINTS */
+#define LATEX_POINT_TYPES 15	/* we supply more point types */
+
+static const char GPFAR *GPFAR LATEX_points[] = {
+    "\\makebox(0,0){$+$}",
+    "\\makebox(0,0){$\\times$}",
+    "\\makebox(0,0){$\\ast$}",
+    "\\raisebox{-.8pt}{\\makebox(0,0){$\\Box$}}",
+    "\\makebox(0,0){$\\blacksquare$}",
+    "\\makebox(0,0){$\\circ$}",
+    "\\makebox(0,0){$\\bullet$}",
+    "\\makebox(0,0){$\\triangle$}",
+    "\\makebox(0,0){$\\blacktriangle$}",
+    "\\makebox(0,0){$\\triangledown$}",
+    "\\makebox(0,0){$\\blacktriangledown$}",
+    "\\makebox(0,0){$\\lozenge$}",
+    "\\makebox(0,0){$\\blacklozenge$}",
+    "\\makebox(0,0){$\\heartsuit$}",
+    "\\makebox(0,0){$\\spadesuit$}",
+};
+
+/* LINES */
+static float LATEX_size = 0;	/* current thick of line in points */
+static float LATEX_dotspace = 0;	/* current dotspace of line in points */
+#define LATEX_LINE_TYPES 6	/* number of line types below */
+#define LATEX_THIN_LINE 0	/* the thinnest solid line type */
+static struct {
+    float size;			/* size of dot, or thick of line in points */
+    float dotspace;		/* inter-dot space in points; 0 for lines */
+} GPFAR LATEX_lines[] =
+
+{
+    {0.4, 0.0},			/* thin solid line */
+    {0.4, 5.0},			/* thin dotted line */
+    {0.8, 0.0},			/* thick solid line */
+    {1.0, 5.0},			/* thick dotted line */
+    {1.2, 0.0},			/* Thick solid line */
+    {1.0, 10.0},		/* thick widely dotted line */
+};
+
+/* for drawing dotted and solid lines */
+static void LATEX_dot_line __PROTO((int x1, int x2, int y1, int y2));
+static void LATEX_solid_line __PROTO((int x1, int x2, int y1, int y2));
+static void LATEX_rule __PROTO((int code, double x, double y, double width, double height));
+static void LATEX_flushdot __PROTO((void));
+#define LATEX_flushrule() LATEX_rule(2, 0.,0.,0.,0.)	/* flush old rule */
+static TBOOLEAN LATEX_moved = TRUE;	/* pen is up after move */
+static float LATEX_dotsize;	/* size of LATEX_DOT in units */
+static TBOOLEAN LATEX_needsdot = FALSE;		/* does dotted line need termination? */
+
+#ifdef EMTEX
+static TBOOLEAN emtex = FALSE;		/* not currently using emtex */
+static void EMTEX_solid_line __PROTO((int x1, int x2, int y1, int y2));
+#endif
+
+/* ARROWS */
+/* the set of non-vertical/non-horizontal LaTeX vector slopes */
+/* except negatives - they are handled specially */
+static struct vslope {
+    int dx, dy;
+} GPFAR LATEX_slopes[] =
+
+{
+    {1, 1},
+    {1, 2},
+    {1, 3},
+    {1, 4},
+    {2, 1},
+    {2, 3},
+    {3, 1},
+    {3, 2},
+    {3, 4},
+    {4, 1},
+    {4, 3},
+    {0, 0}			/* terminator */
+};
+
+/* figure out the best arrow */
+static void best_latex_arrow __PROTO((int, int, int, int, int, int));
+
+enum LATEX_id { LATEX_COURIER, LATEX_ROMAN, LATEX_DEFAULT, LATEX_SIZE, LATEX_ROTATE, LATEX_NOROTATE, LATEX_OTHER };
+
+static struct gen_table LATEX_opts[] =
+{
+    { "c$ourier", LATEX_COURIER },
+    { "r$oman", LATEX_ROMAN },
+    { "d$efault", LATEX_DEFAULT },
+    { "si$ze", LATEX_SIZE },
+    { "rot$ate", LATEX_ROTATE },
+    { "no$rotate", LATEX_NOROTATE },
+    { NULL, LATEX_OTHER }
+};
+
+
+TERM_PUBLIC void
+LATEX_options()
+{
+    latex_explicit_size = FALSE;
+
+    while (!END_OF_COMMAND) {
+	switch(lookup_table(&LATEX_opts[0],c_token)) {
+	case LATEX_COURIER:
+	    strcpy(LATEX_font, "cmtt");
+	    c_token++;
+	    break;
+	case LATEX_ROMAN:
+	    strcpy(LATEX_font, "cmr");
+	    c_token++;
+	    break;
+	case LATEX_DEFAULT:
+	    strcpy(LATEX_font, "doc");
+	    c_token++;
+	    break;
+	case LATEX_SIZE:
+	    {
+	    float xmax_t = 5., ymax_t = 3.;
+	    c_token++;
+	    latex_explicit_size = TRUE;
+	    latex_explicit_units = parse_term_size(&xmax_t, &ymax_t, INCHES);
+	    term->xmax = xmax_t * DOTS_PER_INCH/72;
+	    term->ymax = ymax_t * DOTS_PER_INCH/72;
+	    break;
+	    }
+	case LATEX_ROTATE:
+	    latex_rotate = TRUE;
+	    c_token++;
+	    break;
+	case LATEX_NOROTATE:
+	    latex_rotate = FALSE;
+	    c_token++;
+	    break;
+	case LATEX_OTHER:
+	default:
+	    /* if isannumber? */
+	    LATEX_fontsize = int_expression();
+	}
+    }
+
+    /* tell gnuplot core about char. sizes. Horizontal spacing
+     * is about half the text pointsize
+     */
+    term->v_char = (unsigned int) (LATEX_fontsize * DOTS_PER_INCH / 72);
+    term->h_char = (unsigned int) (LATEX_fontsize * DOTS_PER_INCH / 144);
+
+    if (strcmp(LATEX_font, "doc")==0)
+	strncpy(term_options, "(document specific font)",MAX_LINE_LEN);
+    else
+	sprintf(term_options, "%s %d",
+		LATEX_font[2] == 't' ? "courier" : "roman", LATEX_fontsize);
+
+    if (latex_explicit_size) {
+	if (latex_explicit_units == CM)
+	    sprintf(&(term_options[strlen(term_options)]), "size %.2fcm, %.2fcm ",
+		2.54*(float)term->xmax/(DOTS_PER_INCH),
+		2.54*(float)term->ymax/(DOTS_PER_INCH));
+	else
+	    sprintf(&(term_options[strlen(term_options)]), "size %.2fin, %.2fin ",
+		(float)term->xmax/(DOTS_PER_INCH),
+		(float)term->ymax/(DOTS_PER_INCH));
+    }
+
+    if (latex_rotate) {
+	sprintf(&(term_options[strlen(term_options)]), " rotate");
+    } else {
+	sprintf(&(term_options[strlen(term_options)]), " norotate");
+    }
+
+}
+
+
+TERM_PUBLIC void
+LATEX_init()
+{
+#ifdef EMTEX
+    emtex = FALSE;
+#endif
+    LATEX_posx = LATEX_posy = 0;
+
+    fprintf(gpoutfile, "\
+%% GNUPLOT: LaTeX picture\n\
+\\setlength{\\unitlength}{%fpt}\n\
+\\ifx\\plotpoint\\undefined\\newsavebox{\\plotpoint}\\fi\n",
+	    LATEX_UNIT);
+
+    LATEX_linetype(LT_AXIS);
+    LATEX_size = 0;
+}
+
+TERM_PUBLIC void
+LATEX_graphics()
+{
+    int xscale, yscale;
+
+    /* set size of canvas */
+    if (!latex_explicit_size) {
+	term->xmax = LATEX_XMAX;
+	term->ymax = LATEX_YMAX;
+    }
+
+    /* bounding box */
+    xscale = xsize * term->xmax;
+    yscale = ysize * term->ymax;
+
+    fprintf(gpoutfile, "\\begin{picture}(%d,%d)(0,0)\n", xscale, yscale);
+    if (strcmp(LATEX_font, "doc") != 0) {
+        fprintf(gpoutfile, "\
+\\font\\gnuplot=%s10 at %dpt\n\
+\\gnuplot\n",
+		LATEX_font, LATEX_fontsize);
+    }
+}
+
+
+TERM_PUBLIC void
+LATEX_text()
+{
+    LATEX_flushrule();
+    LATEX_flushdot();
+    fputs("\\end{picture}\n", gpoutfile);
+    LATEX_posx = LATEX_posy = 0;	/* current position */
+    LATEX_moved = TRUE;		/* pen is up after move */
+}
+
+TERM_PUBLIC void
+LATEX_linetype(int linetype)
+{
+    float size;
+
+    if (linetype >= LATEX_LINE_TYPES)
+	linetype %= LATEX_LINE_TYPES;
+
+#ifdef EMTEX
+    if (!emtex)
+#endif
+	LATEX_flushrule();
+    LATEX_flushdot();
+
+    /* Find the new desired line thickness. */
+    /* negative linetypes (for axes) use a thin line */
+    /* only relevant for drawing axes/border in 3d */
+    size = (linetype >= 0 ? LATEX_lines[linetype].size
+	    : LATEX_lines[LATEX_THIN_LINE].size);
+
+    /* If different from current size, redefine \plotpoint */
+    if (size != LATEX_size) {
+	fprintf(gpoutfile,
+		"\\sbox{\\plotpoint}{\\rule[%.3fpt]{%.3fpt}{%.3fpt}}%%\n",
+		-size / 2, size, size);
+#ifdef EMTEX
+	if (emtex)		/* change line width */
+	    fprintf(gpoutfile, "\\special{em:linewidth %.1fpt}%%\n", size);
+#endif
+    }
+    LATEX_size = size;
+    LATEX_dotsize = size / LATEX_UNIT;
+    LATEX_dotspace = (linetype >= 0) ? LATEX_lines[linetype].dotspace : 0;
+    LATEX_moved = TRUE;		/* reset */
+}
+
+TERM_PUBLIC void
+LATEX_move(unsigned int x, unsigned int y)
+{
+    LATEX_flushdot();
+
+    LATEX_posx = x;
+    LATEX_posy = y;
+    LATEX_moved = TRUE;		/* reset */
+}
+
+
+TERM_PUBLIC void
+LATEX_point(unsigned int x, unsigned int y, int number)
+{
+    LATEX_move(x, y);
+
+    /* Print the character defined by 'number'; number < 0 means
+       to use a dot, otherwise one of the defined points. */
+    fprintf(gpoutfile, "\\put(%d,%d){%s}\n", x, y,
+	    (number < 0 ? LATEX_TINY_DOT
+	     : LATEX_points[number % LATEX_POINT_TYPES]));
+}
+
+
+TERM_PUBLIC void
+LATEX_vector(unsigned int ux, unsigned int uy)
+{
+    if (LATEX_dotspace == 0.0) {
+	/* solid line */
+#ifdef EMTEX
+	if (emtex)
+	    EMTEX_solid_line(LATEX_posx, (int) ux, LATEX_posy, (int) uy);
+	else
+#endif
+	    LATEX_solid_line(LATEX_posx, (int) ux, LATEX_posy, (int) uy);
+    } else
+	/* dotted line */
+	LATEX_dot_line(LATEX_posx, (int) ux, LATEX_posy, (int) uy);
+
+    LATEX_posx = ux;
+    LATEX_posy = uy;
+}
+
+static void
+LATEX_solid_line(int x1, int x2, int y1, int y2)
+{
+    float slope;
+    int inc;
+    float dx, dy, x, y;
+    float offset, length;
+    int code;			/* possibly combine with previous rule */
+
+    /* we draw a solid line using the current line thickness (size) */
+    /* we do it with lots of \\rules */
+
+    if (x1 == x2 && y1 == y2) {	/* zero-length line - just a dot */
+	if (LATEX_moved) {
+	    LATEX_flushrule();
+	    /* plot a dot */
+	    fprintf(gpoutfile, "\\put(%u,%u){%s}\n", x1, y1, LATEX_DOT);
+	}
+    } else {
+	code = (LATEX_moved ? 0 : 1);	/* no combine after move */
+	LATEX_moved = FALSE;
+	if (x1 == x2)		/* vertical line - special case */
+	    LATEX_rule(code, (double) x1, (double) y1,
+		       LATEX_dotsize, (double) y2 - y1);
+	else if (y1 == y2)	/* horizontal line - special case */
+	    LATEX_rule(code, (double) x1, (double) y1, (double) x2 - x1,
+		       LATEX_dotsize);
+	else {
+	    dx = (float) x2 - x1;
+	    dy = (float) y2 - y1;
+	    slope = dy / dx;
+	    if (ABS(slope) <= 1.0) {
+		/* longer than high */
+		x = GPMIN(ABS(dx), (0.25 + 1.0 / ABS(slope)) * LATEX_dotsize);
+		offset = sign(dy) * GPMIN(LATEX_dotsize, ABS(dy));
+		dy = dy - offset;
+		length = x * LATEX_UNIT;
+		inc = (x == ABS(dx) ? 1 : GPMAX(1, ABS(dy) / TINY_STEP + 0.5));
+		if (inc == 1) {
+		    fprintf(gpoutfile, "\\put(%u,%.2f){\\rule{%.3fpt}{%.3fpt}}\n",
+			    (x2 >= x1 ? x1 : x2), ((float) y1 + y2 - LATEX_dotsize) / 2,
+			    length, LATEX_dotsize * LATEX_UNIT);
+		} else {
+		    dy = dy / inc;
+		    dx = (dx - sign(dx) * x) / (inc - 1);
+		    fprintf(gpoutfile,
+			    "\\multiput(%.2f,%.2f)(%.3f,%.3f){%u}{\\rule{%.3fpt}{%.3fpt}}\n",
+			    (dx >= 0.0 ? (float) x1 : x1 - x),
+			    (float) y1 - (ABS(dy) - offset) / 2,
+			    dx, dy, inc, length, ABS(dy) * LATEX_UNIT);
+		}
+/* done with one section, now smooth it */
+		x = x / 2;
+		dx = sign(dx) * x;
+		dx = (float) x2 - x1 - dx;
+		dy = (float) y2 - y1;
+		fprintf(gpoutfile, "\\multiput(%.2f,%.2f)(%.3f,%.3f){2}{\\rule{%.3fpt}{%.3fpt}}\n",
+			(dx >= 0.0 ? (float) x1 : x1 - x), (float) y1 - LATEX_dotsize / 2,
+			dx, dy, x * LATEX_UNIT, LATEX_dotsize * LATEX_UNIT);
+		LATEX_moved = TRUE;
+	    } else {
+		/* higher than long */
+		y = GPMIN(ABS(dy), (0.25 + ABS(slope)) * LATEX_dotsize);
+		offset = sign(dx) * GPMIN(LATEX_dotsize, ABS(dx));
+		dx = dx - offset;
+		length = y * LATEX_UNIT;
+		inc = (y == ABS(dy) ? 1 : GPMAX(1, ABS(dx) / TINY_STEP + 0.5));
+		if (inc == 1) {
+		    fprintf(gpoutfile, "\\put(%.2f,%u){\\rule{%.3fpt}{%.3fpt}}\n",
+			    ((float) x1 + x2 - LATEX_dotsize) / 2, (y2 >= y1 ? y1 : y2),
+			    LATEX_dotsize * LATEX_UNIT, length);
+		} else {
+		    dx = dx / inc;
+		    dy = (dy - sign(dy) * y) / (inc - 1);
+		    fprintf(gpoutfile,
+			    "\\multiput(%.2f,%.2f)(%.3f,%.3f){%u}{\\rule{%.3fpt}{%.3fpt}}\n",
+			    (float) x1 - (ABS(dx) - offset) / 2,
+			    (dy >= 0 ? (float) y1 : y1 - y),
+			    dx, dy, inc, ABS(dx) * LATEX_UNIT, length);
+		}
+/* done with one section, now smooth it */
+		y = y / 2;
+		dx = (float) x2 - x1;
+		dy = sign(dy) * y;
+		dy = (float) y2 - y1 - dy;
+		fprintf(gpoutfile, "\\multiput(%.2f,%.2f)(%.3f,%.3f){2}{\\rule{%.3fpt}{%.3fpt}}\n",
+			(float) x1 - LATEX_dotsize / 2, (dy >= 0.0 ? (float) y1 : y1 - y),
+			dx, dy, LATEX_dotsize * LATEX_UNIT, y * LATEX_UNIT);
+		LATEX_moved = TRUE;
+	    }
+	}
+    }
+}
+
+/* Draw a \rule. Width or height may be negative; we can correct.
+ * The rule is never output immediately. The previous rule is output
+ * as-is if code is 0, and the previous rule is
+ * combined with the current rule (if possible) if code is 1.
+ * The previous rule is output, and the new one ignored, if code is 2.
+ */
+static void
+LATEX_rule(
+    int code,			/* how do we treat this rule? */
+    double x, double y,
+    double width,
+    double height)
+{
+    static float lastx, lasty;
+    static float lastw, lasth;
+    static TBOOLEAN isvalid = FALSE;	/* is 'last' data valid? */
+    TBOOLEAN combine = (code == 1);
+    TBOOLEAN flush = (code == 2);
+
+    if (!flush)
+	if (width == 0 || height == 0)
+	    return;		/* ignore this rule */
+
+    if (isvalid && combine) {
+	/* try to combine new rule with old rule */
+	if ((int) lastx == (int) x && lastw == width) {		/* vertical rule */
+	    if (lasth * height >= 0) {	/* same sign */
+		lasth += height;
+		return;
+	    }
+	} else if ((int) lasty == (int) y && lasth == height) {		/* horiz rule */
+	    if (lastw * width >= 0) {	/* same sign */
+		lastw += width;
+		return;
+	    }
+	}
+	/* oh well, output last and remember the new one */
+    }
+    if (isvalid) {
+	/* output the rule */
+	if (lastw < 0) {
+	    lastx += lastw;
+	    lastw = -lastw;
+	}
+	if (lasth < 0) {
+	    lasty += lasth;
+	    lasth = -lasth;
+	}
+	/* if very small use canned dot */
+	if (lastw < LATEX_dotsize || lasth < LATEX_dotsize)
+	    fprintf(gpoutfile, "\\put(%.1f,%.1f){%s}\n",
+		    lastx, lasty, LATEX_DOT);
+	else
+	    fprintf(gpoutfile, "\\put(%.1f,%.1f){\\rule[%.3fpt]{%.3fpt}{%.3fpt}}\n",
+		    lastx, lasty, -LATEX_dotsize * LATEX_UNIT / 2,
+		    lastw * LATEX_UNIT, lasth * LATEX_UNIT);
+    }
+    if (flush) {
+	isvalid = FALSE;
+    } else {
+	lastx = x;
+	lasty = y;
+	lastw = width;
+	lasth = height;
+	isvalid = TRUE;
+    }
+}
+
+static void
+LATEX_dot_line(int x1, int x2, int y1, int y2)
+{
+    static float LATEX_left;	/* fraction of space left after last dot */
+
+    /* we draw a dotted line using the current dot spacing */
+
+    if (LATEX_moved)
+	LATEX_left = 1.0;	/* reset after a move */
+
+    /* zero-length line? */
+    if (x1 == x2 && y1 == y2) {
+	if (LATEX_moved)
+	    /* plot a dot */
+	    fprintf(gpoutfile, "\\put(%u,%u){%s}\n", x1, y1, LATEX_DOT);
+    } else {
+	float dotspace = LATEX_dotspace / LATEX_UNIT;
+	float x, y;		/* current position */
+	float xinc, yinc;	/* increments */
+	float slope;		/* slope of line */
+	float lastx = -1;	/* last x point plotted */
+	float lasty = -1;	/* last y point plotted */
+	int numdots = 0;	/* number of dots in this section */
+
+	/* first, figure out increments for x and y */
+	if (x2 == x1) {
+	    xinc = 0.0;
+	    yinc = (y2 - y1 > 0) ? dotspace : -dotspace;
+	} else {
+	    slope = ((float) y2 - y1) / ((float) x2 - x1);
+	    xinc = dotspace / sqrt(1 + slope * slope) * sign(x2 - x1);
+	    yinc = slope * xinc;
+	}
+
+	/* now draw the dotted line */
+	/* we take into account where we last placed a dot */
+	for (x = x1 + xinc * (1 - LATEX_left), y = y1 + yinc * (1 - LATEX_left);
+	     (x2 - x) * xinc >= 0 && (y2 - y) * yinc >= 0;	/* same sign or zero */
+	     lastx = x, x += xinc,
+	     lasty = y, y += yinc)
+	    numdots++;
+	if (numdots == 1)
+	    fprintf(gpoutfile, "\\put(%.2f,%.2f){%s}\n",
+		    lastx, lasty, LATEX_DOT);
+	else if (numdots > 0)
+	    fprintf(gpoutfile, "\\multiput(%u,%u)(%.3f,%.3f){%u}{%s}\n",
+		    x1, y1, xinc, yinc, numdots, LATEX_DOT);
+
+	/* how much is left over, as a fraction of dotspace? */
+	if (xinc != 0.0) {	/* xinc must be nonzero */
+	    if (lastx >= 0)
+		LATEX_left = ABS(x2 - lastx) / ABS(xinc);
+	    else
+		LATEX_left += ABS(x2 - x1) / ABS(xinc);
+	} else
+	    if (lasty >= 0)
+		LATEX_left = ABS(y2 - lasty) / ABS(yinc);
+	    else
+		LATEX_left += ABS(y2 - y1) / ABS(yinc);
+    }
+
+    LATEX_needsdot = (LATEX_left > 0);
+
+    LATEX_moved = FALSE;
+}
+
+static void
+LATEX_flushdot()
+{
+    if (LATEX_needsdot)
+	fprintf(gpoutfile, "\\put(%d,%d){%s}\n",
+		LATEX_posx, LATEX_posy, LATEX_DOT);
+    LATEX_needsdot = FALSE;
+}
+
+TERM_PUBLIC void
+LATEX_arrow(
+    unsigned int sx, unsigned int sy,
+    unsigned int ex, unsigned int ey,
+    int head)
+{
+    best_latex_arrow(sx, sy, ex, ey, 1, head);
+
+    LATEX_posx = ex;
+    LATEX_posy = ey;
+}
+
+static void
+best_latex_arrow(
+    int sx, int sy, int ex, int ey, /* start and end points */
+    int who,			/* 1=LATEX, 2=EEPIC */
+    int head)
+{
+    int dx = ex - sx;
+    int dy = ey - sy;
+    float m;			/* slope of line */
+    float arrowslope;		/* slope of arrow */
+    float minerror = 0;		/* best-case error */
+    struct vslope *slope;	/* one of the slopes */
+    struct vslope *bestslope;	/* the slope with min error */
+
+    /* We try to draw a real arrow (ie, \vector). If we can't get
+       * a slope that is close, we draw a bent arrow.
+     */
+
+    if (dx == 0) {
+	/* vertical arrow */
+	fprintf(gpoutfile, "\\put(%d,%d){\\%s(0,%d){%d}}\n",
+		sx, sy, head ? "vector" : "line",
+		sign(ey - sy), ABS(ey - sy));
+    } else if (dy == 0) {
+	/* horizontal arrow */
+	fprintf(gpoutfile, "\\put(%d,%d){\\%s(%d,0){%d}}\n",
+		sx, sy, head ? "vector" : "line",
+		sign(ex - sx), ABS(ex - sx));
+    } else {
+	/* Slanted arrow. We'll give it a try.
+	 * we try to find the closest-slope arrowhead.
+	 */
+	bestslope = NULL;
+	minerror = 0;		/* to shut up turbo C */
+	m = ABS((float) dy / dx);	/* the slope we want */
+	for (slope = LATEX_slopes; slope->dx != 0.0; slope++) {
+	    /* find the slope of the arrow */
+	    arrowslope = (float) slope->dy / slope->dx;
+	    if (bestslope == NULL || ABS(m - arrowslope) < minerror) {
+		minerror = ABS(m - arrowslope);
+		bestslope = slope;
+	    }
+	}
+
+	/* now we have the best slope arrow */
+	/* maybe it's exactly the right slope! */
+	if (minerror == 0.0)	/* unlikely but possible */
+	    fprintf(gpoutfile, "\\put(%d,%d){\\%s(%d,%d){%d}}\n",
+		    sx, sy, head ? "vector" : "line",
+		    bestslope->dx * sign(ex - sx), bestslope->dy * sign(ey - sy),
+		    ABS(ex - sx));
+	else {
+	    /* we draw the line the usual way, with thin lines */
+#ifdef EMTEX
+	    if (emtex) {
+		LATEX_linetype(LATEX_THIN_LINE);
+		EMTEX_solid_line(sx, ex, sy, ey);
+	    } else
+#endif
+	    if (who == 1) {
+		LATEX_linetype(LATEX_THIN_LINE);
+		LATEX_solid_line(sx, ex, sy, ey);
+	    }
+#ifdef EEPIC
+	    else {
+		EEPIC_move(sx, sy);
+		EEPIC_vector(ex, ey);
+	    }
+#endif /* EEPIC */
+	    /* and then draw an arrowhead (a short vector) there */
+	    if (head)
+		fprintf(gpoutfile, "\\put(%d,%d){\\vector(%d,%d){0}}\n",
+			ex, ey,
+			bestslope->dx * sign(ex - sx), bestslope->dy * sign(ey - sy));
+	}
+    }
+}
+
+TERM_PUBLIC void
+LATEX_put_text(unsigned int x, unsigned int y, const char str[])
+{
+    static const char *justify[] = { "[l]", "", "[r]" };
+    int flag, i;
+
+    /* ignore empty strings */
+    if (str[0] == NUL)
+	return;
+
+    if (!latex_rotate)
+    for (flag = FALSE, i = 0; str[i] && !flag;)
+	flag = (str[i++] == '\\') && (str[i++] == '\\');
+
+    fprintf(gpoutfile, "\\put(%d,%d)", x, y);
+    if (latex_rotate && latex_angle)
+    	fprintf (gpoutfile, "{\\rotatebox{%d}", latex_angle);
+    if ((str[0] == '{') || (str[0] == '[')) {
+	fprintf(gpoutfile, "{\\makebox(0,0)%s}\n", str);
+    } else if (flag)
+	fprintf(gpoutfile, "{\\makebox(0,0)%s{\\shortstack{%s}}}\n",
+		justify[latex_justify], str);
+    else
+	fprintf(gpoutfile, "{\\makebox(0,0)%s{%s}}\n",
+		justify[latex_justify], str);
+    if (latex_rotate && latex_angle)
+    	fprintf (gpoutfile, "}");
+}
+
+TERM_PUBLIC int
+LATEX_justify_text(enum JUSTIFY mode)
+{
+    latex_justify = mode;
+    return (TRUE);
+}
+
+TERM_PUBLIC int
+LATEX_text_angle(int ang)
+{
+    /* we can't really write text vertically, but this will
+       put the ylabel centred at the left of the plot, and
+       then we'll make a \shortstack */
+    /* latex_angle is not used elsewhere, so we use it for
+       'real' text rotation using '\rotatebox' */
+    latex_angle = ang;
+    return (TRUE);
+}
+
+TERM_PUBLIC void
+LATEX_reset()
+{
+    LATEX_posx = LATEX_posy = 0;	/* current position */
+    LATEX_moved = TRUE;		/* pen is up after move */
+}
+
+
+TERM_PUBLIC void
+LATEX_fillbox(int style, unsigned int x1, unsigned int y1, unsigned
+int width, unsigned int height)
+{
+    /* TODO: Something other than black/white */
+    if ((style & 0xf) == FS_EMPTY)
+	return;
+    if ((style & 0xf) == FS_SOLID && (style >> 4) < 50)
+	return;
+    if ((style & 0xf) == FS_PATTERN && ((style >> 4) & 1) == 0)
+	return;
+
+    fprintf(gpoutfile, "\\put(%d,%d){\\rule{%gpt}{%gpt}}\n", x1, y1,
+	    width*LATEX_UNIT, height*LATEX_UNIT);
+}
+
+
+#ifdef EMTEX
+
+TERM_PUBLIC void
+EMTEX_init()
+{
+    emtex = TRUE;
+    LATEX_posx = LATEX_posy = 0;
+    fprintf(gpoutfile, "\
+%% GNUPLOT: LaTeX picture with emtex specials\n\
+\\setlength{\\unitlength}{%fpt}\n\
+\\ifx\\plotpoint\\undefined\\newsavebox{\\plotpoint}\\fi\n",
+	    LATEX_UNIT);
+    LATEX_linetype(LT_AXIS);
+}
+
+
+TERM_PUBLIC void
+EMTEX_reset()
+{
+    emtex = FALSE;
+    LATEX_posx = LATEX_posy = 0;
+}
+
+
+TERM_PUBLIC void
+EMTEX_text()
+{
+    fputs("\\end{picture}\n", gpoutfile);
+}
+
+
+static void
+EMTEX_solid_line(int x1, int x2, int y1, int y2)
+{
+    /* emtex special solid line */
+    if (LATEX_moved)
+	fprintf(gpoutfile, "\\put(%d,%d){\\special{em:moveto}}\n", x1, y1);
+    if ((x1 != x2) || (y1 != y2))
+	fprintf(gpoutfile, "\\put(%d,%d){\\special{em:lineto}}\n", x2, y2);
+    LATEX_posx = x2;
+    LATEX_posy = y2;
+    LATEX_moved = FALSE;
+}
+
+
+#endif /* EMTEX */
+
+#endif /* TERM_BODY */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(latex_driver)
+    "latex", "LaTeX picture environment",
+    LATEX_XMAX, LATEX_YMAX, LATEX_VCHAR, LATEX_HCHAR,
+    LATEX_VTIC, LATEX_HTIC, LATEX_options, LATEX_init, LATEX_reset,
+    LATEX_text, null_scale, LATEX_graphics, LATEX_move, LATEX_vector,
+    LATEX_linetype, LATEX_put_text, LATEX_text_angle,
+    LATEX_justify_text, LATEX_point, LATEX_arrow, set_font_null,
+    NULL,      /* pointsize */
+    0,         /* flags */
+    NULL, NULL, /* suspend, resume */
+    LATEX_fillbox, NULL, /* linewidth */
+#ifdef USE_MOUSE
+    NULL, NULL, NULL, NULL, NULL,
+#endif
+    NULL /* Color stuff */
+TERM_TABLE_END(latex_driver)
+ 
+#undef LAST_TERM
+#define LAST_TERM latex_driver
+
+
+#ifdef EMTEX
+TERM_TABLE_START(emtex_driver)
+    "emtex", "LaTeX picture environment with emTeX specials",
+    LATEX_XMAX, LATEX_YMAX, LATEX_VCHAR, LATEX_HCHAR,
+    LATEX_VTIC, LATEX_HTIC, LATEX_options, EMTEX_init, EMTEX_reset,
+    EMTEX_text, null_scale, LATEX_graphics, LATEX_move, LATEX_vector,
+    LATEX_linetype, LATEX_put_text, LATEX_text_angle,
+    LATEX_justify_text, LATEX_point, LATEX_arrow, set_font_null
+TERM_TABLE_END(emtex_driver)
+
+#undef LAST_TERM
+#define LAST_TERM emtex_driver
+
+#endif /* EMTEX */
+#endif /* TERM_TABLE */
+
+
+#ifdef TERM_HELP
+START_HELP(latex)
+"1 latex",
+"?commands set terminal emtex",
+"?set terminal emtex",
+"?set term emtex",
+"?terminal emtex",
+"?term emtex",
+"?emtex",
+"?commands set terminal latex",
+"?set terminal latex",
+"?set term latex",
+"?terminal latex",
+"?term latex",
+"?latex",
+" Syntax:",
+"       set terminal {latex | emtex} {default | {courier|roman} {<fontsize>}}",
+"                    {size <XX>{unit}, <YY>{unit}} {rotate | norotate}",
+"",
+" By default the plot will inherit font settings from the embedding document.",
+" You have the option of forcing either Courier (cmtt) or Roman (cmr) fonts",
+" instead. In this case you may also specify a fontsize.",
+" Unless your driver is capable of building fonts at any size (e.g. dvips),",
+" stick to the standard 10, 11 and 12 point sizes.",
+"",
+" METAFONT users beware: METAFONT does not like odd sizes.",
+"",
+" All drivers for LaTeX offer a special way of controlling text positioning:",
+" If any text string begins with '{', you also need to include a '}' at the",
+" end of the text, and the whole text will be centered both horizontally and",
+" vertically.  If the text string begins with '[', you need to follow this with",
+" a position specification (up to two out of t,b,l,r), ']{', the text itself,",
+" and finally '}'.  The text itself may be anything LaTeX can typeset as an",
+" LR-box.  '\\rule{}{}'s may help for best positioning.",
+"",
+" Points, among other things, are drawn using the LaTeX commands \"\\Diamond\" and",
+" \"\\Box\".  These commands no longer belong to the LaTeX2e core; they are included",
+" in the latexsym package, which is part of the base distribution and thus part",
+" of any LaTeX implementation.  Please do not forget to use this package.",
+" Other point types use symbols from the amssymb package.",
+"",
+" The default size for the plot is 5 inches by 3 inches. The `size` option",
+" changes this to whatever the user requests. By default the X and Y sizes",
+" are taken to be in inches, but other units are possible (currently only cm).",
+"",
+" If 'rotate' is specified, rotated text, especially a rotated y-axis label,",
+" is possible (the packages graphics or graphicx are needed). The 'stacked'",
+" y-axis label mechanism is then deactivated.",
+"",
+" Examples:",
+" About label positioning:",
+" Use gnuplot defaults (mostly sensible, but sometimes not really best):",
+"        set title '\\LaTeX\\ -- $ \\gamma $'",
+" Force centering both horizontally and vertically:",
+"        set label '{\\LaTeX\\ -- $ \\gamma $}' at 0,0",
+" Specify own positioning (top here):",
+"        set xlabel '[t]{\\LaTeX\\ -- $ \\gamma $}'",
+" The other label -- account for long ticlabels:",
+"        set ylabel '[r]{\\LaTeX\\ -- $ \\gamma $\\rule{7mm}{0pt}}'"
+END_HELP(latex)
+#endif /* TERM_TABLE */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/linux.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/linux.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/linux.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/linux.trm.svn-base	2012-01-03 17:07:37.675681700 -0800
@@ -0,0 +1,351 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: linux.trm,v 1.29 2006/07/21 02:35:47 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - linux.trm */
+
+/*[
+ * Copyright 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *  SVGA up to 1024x768x256 for PC's running the Linux Operating System
+ *  (also VGA 640x480x16, and SVGA 800x600x256)
+ *
+ * AUTHOR
+ *  Scott Heavner (sdh@po.cwru.edu)
+ *  based on original linux.trm by Tommy Frandsen (frandsen@diku.dk)
+ *  patched by David J. Liu (liu@molecule.phri.nyu.edu)
+ *  to increase perfomance and safety based on the features of SVGALib/GL.
+ *  send your comments or suggestions to (pixar!info-gnuplot@sun.com).
+ */
+
+/*
+ * Compile with Linux SVGAlib 0.95 currently maintained by
+ * Harm Hanemaayer (hhanemaa@cs.ruu.nl).
+ * supports Trident, Tseng, Cirrus, Oak and generic vga.
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(linux)
+#endif
+
+#ifdef TERM_PROTO
+
+#define LINUX_VCHAR FNT5X9_VCHAR
+#define LINUX_HCHAR FNT5X9_HCHAR
+#define LINUX_VTIC 5
+#define LINUX_HTIC 5
+#define LINUX_XMAX 0		/* These two entries are just place holders. */
+#define LINUX_YMAX 0		/* The actual values will be filled in init. */
+
+TERM_PUBLIC void LINUX_options __PROTO((void));
+TERM_PUBLIC void LINUX_init __PROTO((void));
+TERM_PUBLIC void LINUX_reset __PROTO((void));
+TERM_PUBLIC void LINUX_text __PROTO((void));
+TERM_PUBLIC void LINUX_graphics __PROTO((void));
+TERM_PUBLIC void LINUX_linetype __PROTO((int linetype));
+TERM_PUBLIC void LINUX_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void LINUX_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC int LINUX_text_angle __PROTO((int ang));
+TERM_PUBLIC void LINUX_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC void LINUX_suspend __PROTO((void));
+TERM_PUBLIC void LINUX_resume __PROTO((void));
+
+/* also used in vgagl.trm, so export it: */
+TERM_PUBLIC int LINUX_graphics_allowed;
+
+#endif
+
+#ifdef TERM_BODY
+
+#define _STRING_H_
+#include <vga.h>
+
+static int linux_vmode = G1024x768x256;		/* default mode */
+static int vgacolor[] = { 7, 8, 2, 3, 4, 5, 9, 14, 12, 15, 13, 10, 11, 1, 6 };
+static int graphics_on = FALSE;
+static vga_modeinfo *modeinfo;
+static int linux_startx, linux_starty, linux_lasty;
+static int linux_angle;
+TERM_PUBLIC int LINUX_graphics_allowed = FALSE; /* also used in vgagl.trm */
+extern void drop_privilege __PROTO((void));
+extern void take_privilege __PROTO((void));
+
+typedef int (*linux_line_func_ptr) __PROTO((int x1, int y1, int x2, int y2));
+
+static void LINUX_putc __PROTO((unsigned int x, unsigned int y, int c, int ang,
+				linux_line_func_ptr line_func));
+
+/* this function is called at the very beginning of main() to initialize
+ *  the vgalib and to revoke suid privileges.
+ * /dev/console and /dev/tty\d and /dev/vc/\d are considered graphic terminals, all other
+ * don't support the linux terminal */
+
+void
+LINUX_setup()
+{
+    char line[256];
+    FILE *pipe;
+
+    LINUX_graphics_allowed = FALSE;
+
+    if (geteuid() != 0)
+	return;			/* if we aren't root, we cannot init graphics */
+
+    if ((pipe = popen("/usr/bin/tty", "r")) != NULL) {
+	line[0] = 0;
+	fgets(line, 256, pipe);
+	pclose(pipe);
+	line[strlen(line) - 1] = '\0';
+	if (
+	    strcmp(line, "/dev/console") == 0 ||
+
+	    ( ( strncmp(line, "/dev/tty", 8) == 0 || strncmp(line, "/dev/vc/", 8) == 0 )
+	     && isdigit((unsigned char) line[8]))
+
+	     ) {
+	    LINUX_graphics_allowed = TRUE;
+	} else {
+	    /* check for socket name as set for example by `screen' */
+	    char* sty = getenv("STY");
+	    if (sty) {
+		int n1, n2;
+		if (3 == sscanf(sty, "%d.tty%d.%s", &n1, &n2, line)) {
+		    /* we could check here, if host is the
+		     * same as gethostname() returns. */
+		    LINUX_graphics_allowed = TRUE;
+		}
+	    }
+	}
+    }
+    if (LINUX_graphics_allowed) {
+	take_privilege();
+	vga_init();
+	drop_privilege();
+    } else {
+	/* err - shouldn't we give up root uid whatever happens ?
+	 * or perhaps vga_init() does it ?
+	 */
+	setuid(getuid());
+    }
+}
+
+TERM_PUBLIC
+void LINUX_options()
+{
+    if (!LINUX_graphics_allowed) {
+	int_error(NO_CARET, "Linux terminal driver not available");
+    }
+    fprintf(stderr, "%s\n", vga_getmodename(linux_vmode));
+}
+
+TERM_PUBLIC
+void LINUX_init()
+{
+    /* vga_init () has been moved to immediately after main () for security */
+    if (vga_getdefaultmode() != -1)
+	linux_vmode = vga_getdefaultmode();
+    /* get the default mode from GSVGAMODE, if available */
+    if (!vga_hasmode(linux_vmode))
+	linux_vmode = G640x480x16;
+    /* test default mode first */
+    if (!vga_hasmode(linux_vmode)) {
+	fputs("Error, unable to initiate graphics.\n", stderr);
+	return;
+    }				/* this mode is the bottom line */
+    modeinfo = vga_getmodeinfo(linux_vmode);
+    term->xmax = modeinfo->width;
+    term->ymax = modeinfo->height;
+    linux_lasty = modeinfo->height - 1;
+}
+
+TERM_PUBLIC void
+LINUX_reset()
+{
+    if (graphics_on) {
+	vga_setmode(TEXT);
+	graphics_on = FALSE;
+    }
+}
+
+TERM_PUBLIC void
+LINUX_text()
+{
+    if (graphics_on) {
+	vga_getch();
+	vga_setmode(TEXT);
+	graphics_on = FALSE;
+    }
+}
+
+TERM_PUBLIC void
+LINUX_graphics()
+{
+    if (!graphics_on) {
+	vga_setmode(linux_vmode);
+	graphics_on = TRUE;
+    }
+}
+
+TERM_PUBLIC void
+LINUX_suspend()
+{
+    vga_flip();
+}
+
+TERM_PUBLIC void
+LINUX_resume()
+{
+    vga_flip();
+}
+
+TERM_PUBLIC void
+LINUX_linetype(int linetype)
+{
+    if (linetype < -2)
+	linetype = LT_BLACK;
+    if (linetype >= 13)
+	linetype %= 13;
+    vga_setcolor(vgacolor[linetype + 2]);
+}
+
+TERM_PUBLIC void
+LINUX_move(unsigned int x, unsigned int y)
+{
+    linux_startx = x;
+    linux_starty = y;
+}
+
+TERM_PUBLIC void
+LINUX_vector(unsigned int x, unsigned int y)
+{
+    vga_drawline(linux_startx, linux_lasty - linux_starty, x, linux_lasty - y);
+    linux_startx = x;
+    linux_starty = y;
+}
+
+TERM_PUBLIC int
+LINUX_text_angle(int ang)
+{
+    linux_angle = (ang ? 1 : 0);
+    return TRUE;
+}
+
+static void
+LINUX_putc(
+    unsigned int x, unsigned int y,
+    int c,
+    int ang,
+    linux_line_func_ptr line_func)
+{
+    int i, j, k;
+    unsigned int pixelon;
+
+    i = (int) (c) - 32;
+    for (j = 0; j < FNT5X9_VBITS; j++) {
+	for (k = 0; k < FNT5X9_HBITS; k++) {
+	    pixelon = (((unsigned int) (fnt5x9[i][j])) >> k & 1);
+	    if (pixelon) {
+		switch (ang) {
+		case 0:
+		    (*line_func) (x + k + 1, y - j, x + k + 1, y - j);
+		    break;
+		case 1:
+		    (*line_func) (x - j, y - k - 1, x - j, y - k - 1);
+		    break;
+		}
+	    }
+	}
+    }
+}
+
+TERM_PUBLIC void
+LINUX_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    int i;
+    switch (linux_angle) {
+    case 0:
+	y -= LINUX_VCHAR / 2;
+	break;
+    case 1:
+	x += LINUX_VCHAR / 2;
+	break;
+    }
+    for (i = 0; str[i]; i++) {
+	LINUX_putc(x, linux_lasty - y, str[i], linux_angle, vga_drawline);
+	switch (linux_angle) {
+	case 0:
+	    x += LINUX_HCHAR;
+	    break;
+	case 1:
+	    y += LINUX_HCHAR;
+	    break;
+	}
+    }
+}
+
+#endif
+
+#ifdef TERM_TABLE
+TERM_TABLE_START(linux_driver)
+    "linux", "Linux PC with (s)vgalib",
+    LINUX_XMAX, LINUX_YMAX, LINUX_VCHAR, LINUX_HCHAR,
+    LINUX_VTIC, LINUX_HTIC, LINUX_options, LINUX_init, LINUX_reset,
+    LINUX_text, null_scale, LINUX_graphics, LINUX_move, LINUX_vector,
+    LINUX_linetype, LINUX_put_text, LINUX_text_angle,
+    null_justify_text, do_point, do_arrow, set_font_null,
+    0,				/* pointsize */
+    TERM_CAN_MULTIPLOT, LINUX_suspend, LINUX_resume
+TERM_TABLE_END(linux_driver)
+#undef LAST_TERM
+#define LAST_TERM linux_driver
+#endif
+
+#ifdef TERM_HELP
+START_HELP(linux)
+"1 linux",
+"?commands set terminal linux",
+"?set terminal linux",
+"?set term linux",
+"?terminal linux",
+"?term linux",
+"?linux",
+" The `linux` driver has no additional options to specify.  It looks at the",
+" environment variable GSVGAMODE for the default mode; if not set, it uses",
+" 1024x768x256 as default mode or, if that is not possible, 640x480x16",
+" (standard VGA)."
+END_HELP(linux)
+#endif
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/lua.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/lua.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/lua.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/lua.trm.svn-base	2012-01-03 17:07:37.897256300 -0800
@@ -0,0 +1,1298 @@
+/*
+ *  $Id: lua.trm,v 1.5.2.1 2009/12/02 05:05:09 sfeam Exp $
+ *  $Date: 2009/12/02 05:05:09 $
+ *  $Rev: 90 $
+ */
+
+/* 
+ *  GNUPLOT - lua.trm
+ */
+
+/*[
+ *
+ * Copyright 2008   Peter Hedwig <peter@affenbande.org>
+ *
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+
+#include "driver.h"
+
+#define LUA_TERM_REVISON "$Rev: 97 $"
+
+/*  TERM_CAN_DASH is new in 4.3cvs */
+#ifdef TERM_CAN_DASH
+ #define GNUPLOT_LUA_4_3
+#endif
+
+#ifdef TERM_REGISTER
+register_term(lua)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void LUA_options __PROTO((void));
+TERM_PUBLIC void LUA_init __PROTO((void));
+TERM_PUBLIC void LUA_reset __PROTO((void));
+TERM_PUBLIC void LUA_text __PROTO((void));
+/* scale */
+TERM_PUBLIC void LUA_graphics __PROTO((void));
+TERM_PUBLIC void LUA_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void LUA_vector __PROTO((unsigned int ux, unsigned int uy));
+TERM_PUBLIC void LUA_linetype __PROTO((int linetype));
+TERM_PUBLIC void LUA_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
+TERM_PUBLIC int  LUA_text_angle __PROTO((int ang));
+TERM_PUBLIC int  LUA_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC void LUA_point __PROTO((unsigned int x, unsigned int y, int number));
+TERM_PUBLIC void LUA_arrow __PROTO((unsigned int sx, unsigned int sy, unsigned int ex, unsigned int ey, int head));
+TERM_PUBLIC int  LUA_set_font __PROTO((const char *font));
+TERM_PUBLIC void LUA_pointsize __PROTO((double ptsize)); 
+TERM_PUBLIC void LUA_boxfill __PROTO((int style, unsigned int x1,
+                                     unsigned int y1, unsigned int width,
+                                     unsigned int height));
+TERM_PUBLIC void LUA_linewidth __PROTO((double width));
+TERM_PUBLIC int  LUA_make_palette __PROTO((t_sm_palette *));
+TERM_PUBLIC void LUA_previous_palette __PROTO((void));
+TERM_PUBLIC void LUA_set_color __PROTO((t_colorspec *));
+TERM_PUBLIC void LUA_filled_polygon __PROTO((int, gpiPoint *));
+TERM_PUBLIC void LUA_image __PROTO((unsigned, unsigned, coordval *, gpiPoint *, t_imagecolor));
+TERM_PUBLIC void LUA_path __PROTO((int p));
+
+/* defaults */
+#define LUA_XMAX 10000.0
+#define LUA_YMAX 10000.0
+
+#define LUA_HTIC	100
+#define LUA_VTIC	100
+#define LUA_HCHAR	160
+#define LUA_VCHAR	420
+#define LUA_TERM_DESCRIPTION "Lua generic terminal driver"
+
+/* gnuplot 4.3, term->tscale */
+#define LUA_TSCALE   1.0
+
+#endif /* TERM_PROTO */
+
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+#include <lua.h>
+#include <lualib.h>
+#include <lauxlib.h>
+
+static lua_State *L = NULL;
+
+static char *LUA_script = NULL;
+
+static int lua_term_status, lua_term_result;
+static int tb, luaterm;
+
+/*
+ * static buffer, because we cannot free memory after
+ * calling int_error that never returns
+ */
+static char last_error_msg[MAX_LINE_LEN+1] = "";
+
+/*
+ * Handle Lua functions
+ */
+#define LUA_GP_FNC "gp"
+
+/* 
+ *  returns a table with the coords of 
+ *  the plot's bounding box
+ */
+static int
+LUA_GP_get_boundingbox() {
+  lua_newtable (L);
+  lua_pushstring (L, "xleft");
+  lua_pushinteger(L, plot_bounds.xleft);
+  lua_rawset (L, -3);
+  lua_pushstring (L, "xright");
+  lua_pushinteger(L, plot_bounds.xright);
+  lua_rawset (L, -3);
+  lua_pushstring (L, "ybot");
+  lua_pushinteger(L, plot_bounds.ybot);
+  lua_rawset (L, -3);
+  lua_pushstring (L, "ytop");
+  lua_pushinteger(L, plot_bounds.ytop);
+  lua_rawset (L, -3);
+  return(1);
+}
+
+/* gp.term_options(char *str) */
+static int
+LUA_GP_term_options(lua_State *L) {
+  int n = lua_gettop(L);  /* Number of arguments */
+  const char *opt_str;
+  if (n != 1)
+    return luaL_error(L, "Got %d arguments expected 1", n);
+
+  opt_str = luaL_checkstring(L, 1);
+  n = strlen(opt_str);
+  if (n > MAX_LINE_LEN)
+    return luaL_error(L, "Option string consists of %d characters but only %d are allowed", n, MAX_LINE_LEN);
+
+  strncpy(term_options, opt_str, MAX_LINE_LEN);
+  term_options[MAX_LINE_LEN] = '\0';
+  return(0);
+}
+
+
+/* close Lua context and clean up */
+static void
+LUA_close(void) {
+  if (L) {
+    lua_close(L);
+    L = NULL;
+  }
+  if (LUA_script) {
+    free(LUA_script);
+    LUA_script = NULL;
+  }
+}
+
+/* gp.write(char *str) */
+static int
+LUA_GP_write(lua_State *L) {
+  int n = lua_gettop(L);  /* Number of arguments */
+  const char *out_str;
+  if (n != 1)
+      return luaL_error(L, "Got %d arguments expected 1", n);
+
+  out_str = luaL_checkstring(L, 1);
+  fputs(out_str, gpoutfile);
+
+  return(0);
+}
+
+/*
+  gp.int_error(int t_num, char *msg)
+  gp.int_error(char *msg)  
+ 
+ */
+static int
+LUA_GP_int_error(lua_State *L) {
+  int t_num = NO_CARET;
+  const char *msg = "";
+
+  int n = lua_gettop(L);  /* Number of arguments */
+  switch (n) {
+    case 1:
+      msg = luaL_checkstring(L, 1);
+      break;
+    case 2:
+      t_num = luaL_checkint(L, 1);
+      msg  = luaL_checkstring(L, 2);
+      break;
+    default:
+      return luaL_error(L, "Got %d arguments expected 1 or 2", n);
+      break;
+  }
+
+  snprintf(last_error_msg, MAX_LINE_LEN, "%s Lua context closed.", msg);
+
+  /* close Lua context on fatal errors */
+  LUA_close();
+
+  int_error(t_num, last_error_msg);
+  
+  return(0);
+}
+
+/* 
+  gp.int_warn(int t_num, char *errmsg)
+  gp.int_warn(char *errmsg)  
+
+*/
+static int
+LUA_GP_int_warn(lua_State *L) {
+  int t_num = NO_CARET;
+  const char *msg = "";
+
+  int n = lua_gettop(L);  /* Number of arguments */
+  switch (n) {
+    case 1:
+      msg = luaL_checkstring(L, 1);
+      break;
+    case 2:
+      t_num = luaL_checkint(L, 1);
+      msg = luaL_checkstring(L, 2);
+      break;
+    default:
+      return luaL_error(L, "Got %d arguments expected 1 or 2", n);
+      break;
+  }
+  int_warn(t_num, msg);
+
+  return(0);
+}
+
+/* 
+  gp.term_out(char *terminal_msg)
+  
+  Print user messages, e.g. help messages
+*/
+static int
+LUA_GP_term_out(lua_State *L) {
+  char c;             /* dummy input char */
+  char *line;
+  int pagelines = 0;  
+  const char *msg = "";
+  
+  int n = lua_gettop(L);  /* Number of arguments */
+  switch (n) {
+    case 1:
+      msg = luaL_checkstring(L, 1);
+      break;
+    default:
+      return luaL_error(L, "Got %d arguments expected 1", n);
+      break;
+  }
+
+  line = strtok((char*)msg, "\n");
+  while(line != NULL) {
+    /* built-in dumb pager code stolen from help.c
+      maybe someone has a fancy old ATARI :-) */
+    if (pagelines >= 22) {
+      fputs("Press return for more: ", stderr);
+#if defined(ATARI) || defined(MTOS)
+      do
+        c = tos_getch();
+      while (c != '\x04' && c != '\r' && c != '\n');
+#else
+      do
+        c = getchar();
+      while (c != EOF && c != '\n');
+#endif
+      pagelines = 0;
+    }
+    fputs(line, stderr);
+    fputs("\n", stderr);
+    pagelines++;
+    line = strtok(NULL, "\n");
+  }
+  return(0);
+}
+
+/*
+  gp.is_multiplot()
+
+*/
+static int
+LUA_GP_is_multiplot(lua_State *L) {
+  lua_pushboolean(L, multiplot);
+  return(1);
+}
+
+/*
+  returns all internal and userdefined variables
+  [name] = {type, val1 [, val2]},
+  [name] = {type, val1 [, val2]},
+  ...
+*/
+static int
+LUA_GP_get_all_variables(lua_State *L) {
+  struct udvt_entry *udv = first_udv;
+  struct value *val;
+  
+  lua_newtable(L);
+  while (udv) {
+    /* ignore mouse related variables */
+    if(!strncmp(udv->udv_name, "MOUSE_", 6)) {
+      udv = udv->next_udv;
+      continue;
+    }
+    lua_newtable(L);
+    if (udv->udv_undef) {
+      lua_pushnil(L);
+      lua_rawseti(L, -2, 2);
+    } else {
+      val = &(udv->udv_value);
+      switch (val->type) {
+      case INTGR:
+        lua_pushstring(L, "int");
+        lua_rawseti(L, -2, 2);
+        lua_pushinteger(L, val->v.int_val);
+        lua_rawseti(L, -2, 3);
+        break;
+      case CMPLX:
+        if (val->v.cmplx_val.imag  != 0.0) {
+          lua_pushstring(L, "cmplx");
+          lua_rawseti(L, -2, 2);
+          lua_pushnumber(L, val->v.cmplx_val.imag);
+          lua_rawseti(L, -2, 4);
+        } else {
+          lua_pushstring(L, "real");
+          lua_rawseti(L, -2, 2);
+        }
+#ifdef HAVE_ISNAN
+        if (isnan(val->v.cmplx_val.real)) {
+          lua_pushnil(L);
+          lua_rawseti(L, -2, 3);
+        } else
+#endif
+        {
+          lua_pushnumber(L, val->v.cmplx_val.real);
+          lua_rawseti(L, -2, 3);
+        }
+        break;
+#ifdef GP_STRING_VARS
+      case STRING:
+        lua_pushstring(L, "string");
+        lua_rawseti(L, -2, 2);
+        if (val->v.string_val) {
+          lua_pushstring(L, val->v.string_val);
+          lua_rawseti(L, -2, 3);
+        }
+        break;
+#endif
+        default:
+          lua_pushstring(L, "unknown");
+          lua_rawseti(L, -2, 2);
+      }
+    }
+    lua_setfield(L, -2, udv->udv_name);
+    udv = udv->next_udv;
+  }
+  return(1);
+}
+
+
+static const luaL_reg gp_methods[] = {
+  {"write", LUA_GP_write},
+  {"int_error", LUA_GP_int_error},
+  {"int_warn", LUA_GP_int_warn},
+  {"term_out", LUA_GP_term_out},
+  {"get_boundingbox", LUA_GP_get_boundingbox},
+  {"is_multiplot", LUA_GP_is_multiplot},
+  {"get_all_variables", LUA_GP_get_all_variables},
+  {"term_options", LUA_GP_term_options},
+  {NULL, NULL}
+};
+
+
+static void
+LUA_register_gp_fnc ()
+{
+  luaL_register(L, LUA_GP_FNC, gp_methods);
+}
+
+
+/*
+  read variables from script
+*/
+static void
+LUA_get_term_vars(void) {
+  lua_getfield(L, luaterm, "description");
+  term->description = (lua_isstring(L, -1)) ? lua_tostring(L, -1) : LUA_TERM_DESCRIPTION;
+  lua_pop(L, 1);  
+  
+  lua_getfield(L, luaterm, "xmax");
+  term->xmax = (lua_isnumber(L, -1)) ? (unsigned int)lua_tointeger(L, -1) : LUA_XMAX;
+  lua_pop(L, 1);  
+  
+  lua_getfield(L, luaterm, "ymax");
+  term->ymax = (lua_isnumber(L, -1)) ? (unsigned int)lua_tointeger(L, -1) : LUA_YMAX;
+  lua_pop(L, 1);  
+  
+  lua_getfield(L, luaterm, "v_char");
+  term->v_char = (lua_isnumber(L, -1)) ? (unsigned int)lua_tointeger(L, -1) : LUA_VCHAR;
+  lua_pop(L, 1);
+  
+  lua_getfield(L, luaterm, "h_char");
+  term->h_char = (lua_isnumber(L, -1)) ? (unsigned int)lua_tointeger(L, -1) : LUA_HCHAR;
+  lua_pop(L, 1);
+
+  lua_getfield(L, luaterm, "v_tic");
+  term->v_tic = (lua_isnumber(L, -1)) ? (unsigned int)lua_tointeger(L, -1) : LUA_VTIC;
+  lua_pop(L, 1);
+  
+  lua_getfield(L, luaterm, "h_tic");
+  term->h_tic = (lua_isnumber(L, -1)) ? (unsigned int)lua_tointeger(L, -1) : LUA_HTIC;
+  lua_pop(L, 1);
+  
+  lua_getfield(L, luaterm, "flags");
+  term->flags = (lua_isnumber(L, -1)) ? (int)lua_tointeger(L, -1) : TERM_BINARY;
+  lua_pop(L, 1);
+
+#ifdef GNUPLOT_LUA_4_3
+  lua_getfield(L, luaterm, "tscale");
+  term->tscale = (lua_isnumber(L, -1)) ? (double)lua_tonumber(L, -1) : LUA_TSCALE;
+  lua_pop(L, 1);
+#endif
+}
+
+static void
+LUA_set_term_vars() {
+  extern const char lua_ident[];
+
+  /* set term.version */
+  lua_pushstring(L, gnuplot_version);
+  lua_setfield(L, luaterm, "gp_version");
+  /* set term.patchlevel */
+  lua_pushstring(L, gnuplot_patchlevel);
+  lua_setfield(L, luaterm, "gp_patchlevel");
+  /* set term.patchlevel */
+  lua_pushstring(L, LUA_TERM_REVISON);
+  lua_setfield(L, luaterm, "lua_term_revision");
+  /* set term.lua_ident */
+  lua_pushstring(L, lua_ident);
+  lua_setfield(L, luaterm, "lua_ident");
+#ifdef GNUPLOT_LUA_4_3
+  lua_pushboolean(L, 1);
+#else
+  lua_pushboolean(L, 0);
+#endif
+  lua_setfield(L, luaterm, "IS_GNUPLOT_43");
+  
+  /* some static definitions */
+  lua_pushinteger(L, TERM_CAN_MULTIPLOT);     /* tested if stdout not redirected */
+  lua_setfield(L, luaterm, "TERM_CAN_MULTIPLOT");
+  lua_pushinteger(L, TERM_CANNOT_MULTIPLOT);  /* tested if stdout is redirected  */
+  lua_setfield(L, luaterm, "TERM_CANNOT_MULTIPLOT");
+  lua_pushinteger(L, TERM_BINARY);            /* open output file with "b"       */
+  lua_setfield(L, luaterm, "TERM_BINARY");
+  lua_pushinteger(L, TERM_INIT_ON_REPLOT);    /* call term->init() on replot     */
+  lua_setfield(L, luaterm, "TERM_INIT_ON_REPLOT");
+  lua_pushinteger(L, TERM_IS_POSTSCRIPT);     /* post, next, pslatex, etc        */
+  lua_setfield(L, luaterm, "TERM_IS_POSTSCRIPT");
+  lua_pushinteger(L, TERM_ENHANCED_TEXT);     /* enhanced text mode is enabled   */
+  lua_setfield(L, luaterm, "TERM_ENHANCED_TEXT");
+  lua_pushinteger(L, TERM_NO_OUTPUTFILE);     /* terminal doesnt write to a file */
+  lua_setfield(L, luaterm, "TERM_NO_OUTPUTFILE");
+  lua_pushinteger(L, TERM_CAN_CLIP);          /* terminal does its own clipping  */
+  lua_setfield(L, luaterm, "TERM_CAN_CLIP");
+#ifdef GNUPLOT_LUA_4_3
+  lua_pushinteger(L, TERM_CAN_DASH);          /* terminal knows dashed lines */
+  lua_setfield(L, luaterm, "TERM_CAN_DASH");
+#endif
+}
+
+static int
+LUA_init_luaterm_function(const char *fnc) {
+  if (!L)
+    int_error(NO_CARET, "Missing Lua context! No script?");
+
+  lua_getfield(L, luaterm, fnc);
+  if(lua_isfunction(L, -1)) {
+    return(1);
+  } else {
+    int_warn(NO_CARET, "Script lacks function `%s'!", fnc);
+    lua_pop(L, 1); /* clean stack */
+  }
+  return(0);
+}
+
+
+static int
+LUA_call_report (int status)
+{
+  if (status) {
+    const char *msg = lua_tostring(L, -1);
+    if (msg == NULL) msg = "(error with no message)";
+    snprintf(last_error_msg, MAX_LINE_LEN, "%s. Lua context closed.", msg);
+    LUA_close();
+    int_error(NO_CARET, last_error_msg);
+  }
+  return status;
+}
+
+    
+static int
+LUA_init_lua(void)
+{
+  int sf; /* Lua script "function" */
+  struct stat stat_buf;
+  char *script_fqn;
+  char *gp_lua_dir;
+
+  /*
+   * Close old Lua context and open a new one.
+    */
+  if (L)
+    lua_close(L);
+  L = lua_open();
+
+  luaL_openlibs(L); /* Load Lua libraries */
+  luaopen_debug(L);
+
+  gp_lua_dir = getenv("GNUPLOT_LUA_DIR");
+
+# if defined(_Windows)
+  if (!gp_lua_dir) {
+    int len;
+    /* retrieve path relative to the gnuplot executable whose path is in 
+     * szModuleName (winmain.c) */
+    gp_lua_dir = gp_alloc(strlen((char*) szPackageDir)
+                            + strlen(GNUPLOT_LUA_DIR) + 2, "luadir");
+    strcpy(gp_lua_dir, (char*) szPackageDir);
+    len = strlen(gp_lua_dir);
+    if (*gp_lua_dir && gp_lua_dir[len-1] != '\\' &&   gp_lua_dir[len-1] != '/')
+	strcat(gp_lua_dir, "\\");
+    /* GNUPLOT_LUA_DIR is _relative_ path */
+    strcat(gp_lua_dir, GNUPLOT_LUA_DIR);
+    }
+#else /* not _Windows */
+  if (!gp_lua_dir)
+    gp_lua_dir = GNUPLOT_LUA_DIR;
+#endif
+
+  if (stat(LUA_script, &stat_buf) || !S_ISREG(stat_buf.st_mode)) {
+    script_fqn = gp_alloc(strlen(gp_lua_dir) + strlen(LUA_script) + 2, "LUA_script path");
+    sprintf(script_fqn, "%s%c%s", gp_lua_dir, DIRSEP1, LUA_script);
+  } else {
+    script_fqn = gp_strdup(LUA_script);
+  }
+
+  /* Load the file containing the script we are going to run */
+  lua_term_status = luaL_loadfile(L, script_fqn);
+  if (lua_term_status) {
+    fprintf(stderr, "error: %s. Lua context closed.\n", lua_tostring(L, -1));
+    LUA_close();
+    free(script_fqn);
+    return(0);
+  }
+  free(script_fqn);
+
+  /* remember script "function" */
+  sf = lua_gettop(L);
+
+  /*  lua_settop(L, 0);*/ /* clear stack */
+  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
+  lua_getfield(L, -1, "traceback");
+  lua_remove(L, -2); /* rm debug */
+  tb = lua_gettop(L); /* store "traceback" */
+  /* create table `term' */
+  lua_newtable(L);
+  lua_setglobal(L, "term");
+  lua_getfield(L, LUA_GLOBALSINDEX, "term");
+  luaterm = lua_gettop(L); /* store `term' */
+
+  /* register gp functions */
+  LUA_register_gp_fnc();
+  
+  /* set terminal variables */
+  LUA_set_term_vars();
+  
+  /* put script "function" on top and call */
+  lua_pushvalue(L, sf);
+  LUA_call_report(lua_pcall(L, 0, LUA_MULTRET, tb));
+
+  return(1);
+}
+
+/* see color.h */
+static const char*
+LUA_get_colorstyle(int style) {
+  const char *style_str = "unknown";
+
+  switch(style) {
+    case TC_LT:       /* Use the color of linetype <n> */
+      style_str = "LT";
+      break;
+    case TC_LINESTYLE:/* Use the color of line style <n> (only for "internal" use or unsused?) */
+      style_str = "LINESTYLE";
+      break;
+    case TC_RGB:      /* Explicit RGB triple provided by user */
+      style_str = "RGB";
+      break;
+    case TC_CB:       /* "palette cb <value>" (only for "internal" use or unsused?) */
+      style_str = "CB";
+      break;
+    case TC_FRAC:     /* "palette frac <value>" */
+      style_str = "FRAC";
+      break;
+    case TC_Z:        /* "palette z" (only for "internal" use or unsused?) */
+      style_str = "Z";
+      break;
+    case TC_DEFAULT:  /* Use default color, set separately (only for "internal" use or unsused?) */
+      style_str = "DEFAULT";
+      break;
+  }
+  return(style_str);
+}
+
+/* see term_api.h */
+static const char*
+LUA_get_fillstyle(int style) {
+  const char *style_str = "unknown";
+
+  if (style == FS_OPAQUE) {
+    /* FIXME: not quite shure how to handle this, since it is only used by the
+      postscript terminal */
+    style_str = "OPAQUE";
+  } else {
+    switch (style & 0xf) {
+      case FS_EMPTY:
+        style_str = "EMPTY";
+        break;
+      case FS_SOLID:
+        style_str = "SOLID";
+        break;
+      case FS_PATTERN:
+        style_str = "PATTERN";
+        break;
+#ifdef GNUPLOT_LUA_4_3
+      case FS_TRANSPARENT_SOLID:
+        style_str = "TRANSPARENT_SOLID";
+        break;
+      case FS_TRANSPARENT_PATTERN:
+        style_str = "TRANSPARENT_PATTERN";
+        break;
+#endif
+      case FS_DEFAULT:
+        style_str = "DEFAULT";
+        break;
+    }
+  }
+  return(style_str);
+}
+
+
+
+
+/*
+ * Handle options
+ */
+
+TERM_PUBLIC void
+LUA_options()
+{
+
+  char *opt_str = NULL;
+  char *s;
+
+  int tc_off = c_token+1; /* token counter offset */
+  int need_init = 1;
+
+
+  /* 'set term tikz' is short for 'set term lua tikz' */
+  if (c_token == 3) {
+    if (almost_equals(2,"termop$tions"))
+      need_init = 0;
+    else if (equals(2,"tikz"))
+      c_token--;
+  }
+
+  if (!END_OF_COMMAND) {
+    opt_str = gp_input_line + token[c_token].start_index;
+    if (*opt_str == '"' || *opt_str == '\'') {
+      s = try_to_get_string();
+        gp_expand_tilde(&s);
+    } else {
+      s = gp_alloc(token_len(c_token)+strlen("gnuplot-.lua")+1, "LUA_script");
+      memcpy(s, "gnuplot-", 8);
+      memcpy(s+8, opt_str , token_len(c_token));
+      memcpy(s+8+token_len(c_token), ".lua\0", 5);
+      c_token++;
+    }
+    if (LUA_script) {
+      if (strcmp(LUA_script, s)) {
+        free(LUA_script);
+        LUA_script = s;
+        need_init = 1;
+      } else {
+        free(s);
+        need_init = 0;
+      }
+    } else {
+      LUA_script = s;
+    }
+    opt_str = gp_input_line + token[c_token].start_index;
+    c_token = num_tokens;
+  } else {
+    LUA_close();
+    int_error(NO_CARET, "No Lua driver name or file name given!");
+  }
+
+  /* init lua when opening the terminal or on script change */
+  if(need_init) {
+    if(!LUA_init_lua()) {
+      return;
+    }
+  }
+
+  if(LUA_init_luaterm_function("options")) {
+    lua_pushstring(L, opt_str);
+    lua_pushinteger(L, need_init);
+    lua_pushinteger(L, tc_off);
+    LUA_call_report(lua_pcall(L, 3, 1, tb));
+    lua_term_result = (int)lua_tointeger(L, -1);
+    lua_pop(L, 1);
+  }
+
+  LUA_get_term_vars();
+
+}
+
+
+TERM_PUBLIC void
+LUA_init()
+{
+  fseek(gpoutfile, 0, SEEK_SET);
+  ftruncate(fileno(gpoutfile),0);
+  
+  LUA_linetype(-1);
+  if(LUA_init_luaterm_function("init")) {
+    LUA_call_report(lua_pcall(L, 0, 1, tb));
+    lua_term_result = (int)lua_tointeger(L, -1);
+    lua_pop(L, 1);
+  }
+}
+
+TERM_PUBLIC void
+LUA_graphics()
+{
+  if(LUA_init_luaterm_function("graphics")) {
+    LUA_call_report(lua_pcall(L, 0, 1, tb));
+    lua_term_result = (int)lua_tointeger(L, -1);
+    lua_pop(L, 1);
+  }
+}
+
+
+TERM_PUBLIC void
+LUA_text()
+{
+  if(LUA_init_luaterm_function("text")) {
+    LUA_call_report(lua_pcall(L, 0, 1, tb));    
+    lua_term_result = (int)lua_tointeger(L, -1);
+    lua_pop(L, 1);
+  }
+}
+
+
+TERM_PUBLIC void
+LUA_linetype(int linetype)
+{
+  if(LUA_init_luaterm_function("linetype")) {
+    lua_pushinteger(L, linetype);
+    LUA_call_report(lua_pcall(L, 1, 1, tb));
+  	lua_term_result = (int)lua_tointeger(L, -1);
+	lua_pop(L, 1);
+  }
+}
+
+
+
+TERM_PUBLIC void
+LUA_move(unsigned int x, unsigned int y)
+{
+  if(LUA_init_luaterm_function("move")) {
+    lua_pushinteger(L, x);
+    lua_pushinteger(L, y);
+    LUA_call_report(lua_pcall(L, 2, 1, tb));
+  	lua_term_result = (int)lua_tointeger(L, -1);
+	lua_pop(L, 1);
+  }   
+}
+
+
+TERM_PUBLIC void
+LUA_point(unsigned int x, unsigned int y, int number)
+{
+
+  lua_term_result = 0;
+  
+  if(LUA_init_luaterm_function("point")) {
+    lua_pushinteger(L, x);
+    lua_pushinteger(L, y);
+    lua_pushinteger(L, number);
+    LUA_call_report(lua_pcall(L, 3, 1, tb));
+  	lua_term_result = (int)lua_tointeger(L, -1);
+	lua_pop(L, 1);
+  }
+  
+  if (!lua_term_result) do_point(x, y, number);
+
+}
+
+TERM_PUBLIC void
+LUA_pointsize(double ptsize)
+{
+  if(LUA_init_luaterm_function("pointsize")) {
+    lua_pushnumber(L, ptsize);
+    LUA_call_report(lua_pcall(L, 1, 1, tb));
+    lua_term_result = (int)lua_tointeger(L, -1);
+    lua_pop(L, 1);
+  }
+}
+
+TERM_PUBLIC void
+LUA_vector(unsigned int ux, unsigned int uy)
+{
+  if(LUA_init_luaterm_function("vector")) {
+    lua_pushinteger(L, ux);
+    lua_pushinteger(L, uy);
+    LUA_call_report(lua_pcall(L, 2, 1, tb));
+  	lua_term_result = (int)lua_tointeger(L, -1);
+	lua_pop(L, 1);
+  } 
+}
+
+TERM_PUBLIC void
+LUA_arrow(
+    unsigned int sx, unsigned int sy,
+    unsigned int ex, unsigned int ey,
+    int head)
+{
+
+  /* 
+    if the script does not provide an `arrow' functions
+    or if it returns `0' we fall back to `do_arrow'
+  */
+  lua_term_result = 0;
+
+  if(LUA_init_luaterm_function("arrow")) {
+    lua_pushinteger(L, sx);
+    lua_pushinteger(L, sy);
+    lua_pushinteger(L, ex);
+    lua_pushinteger(L, ey);
+    lua_pushinteger(L, head);
+    /*   additional vars  */
+    lua_pushinteger(L, curr_arrow_headlength);    /* access head length + angle (int) */
+    lua_pushnumber(L, curr_arrow_headangle);      /* angle in degrees (double)        */
+    lua_pushnumber(L, curr_arrow_headbackangle);  /* angle in degrees (double)        */
+    lua_pushinteger(L, curr_arrow_headfilled);    /* arrow head filled or not         */
+    LUA_call_report(lua_pcall(L, 9, 1, tb));
+    lua_term_result = (int)lua_tointeger(L, -1);
+    lua_pop(L, 1);
+  }
+  
+  if (!lua_term_result) do_arrow(sx, sy, ex, ey, head);
+
+}
+
+
+TERM_PUBLIC void
+LUA_put_text(unsigned int x, unsigned int y, const char str[])
+{
+  if(LUA_init_luaterm_function("put_text")) {
+    lua_pushinteger(L, x);
+    lua_pushinteger(L, y);
+    lua_pushstring(L, str);
+    LUA_call_report(lua_pcall(L, 3, 1, tb));
+    lua_term_result = (int)lua_tointeger(L, -1);
+    lua_pop(L, 1);
+  }
+}
+
+
+TERM_PUBLIC int
+LUA_justify_text(enum JUSTIFY mode)
+{
+  if(LUA_init_luaterm_function("justify_text")) {
+    const char *m;
+    switch (mode) {
+      case LEFT:
+        m = "left";
+        break;
+      case CENTRE:
+        m = "center";
+        break;
+      case RIGHT:
+        m = "right";
+        break;
+    }
+    lua_pushstring(L, m);
+    LUA_call_report(lua_pcall(L, 1, 1, tb));
+    lua_term_result = (int)lua_tointeger(L, -1);
+    lua_pop(L, 1);
+    return((lua_term_result ? TRUE : FALSE));
+  }
+  return(FALSE);
+}
+
+TERM_PUBLIC int
+LUA_text_angle(int ang)
+{
+  if(LUA_init_luaterm_function("text_angle")) {
+    lua_pushinteger(L, ang);
+    LUA_call_report(lua_pcall(L, 1, 1, tb));
+    lua_term_result = (int)lua_tointeger(L, -1);
+    lua_pop(L, 1);
+    return(((lua_term_result || !ang ) ? TRUE : FALSE));
+  }
+  return((ang ? FALSE : TRUE)); /* return TRUE if called with ang==0 */
+}
+
+TERM_PUBLIC int
+LUA_set_font(const char *font)
+{
+  if(LUA_init_luaterm_function("set_font")) {
+    lua_pushstring(L, font);
+    LUA_call_report(lua_pcall(L, 1, 1, tb));
+    lua_term_result = (int)lua_tointeger(L, -1);
+    lua_pop(L, 1);
+    return((lua_term_result ? TRUE : FALSE));
+  }
+  return(FALSE);
+}
+
+TERM_PUBLIC void
+LUA_boxfill (int style, unsigned int x1,
+    unsigned int y1, unsigned int width,
+    unsigned int height)
+{
+  
+  if(LUA_init_luaterm_function("boxfill")) {
+    lua_pushstring(L, LUA_get_fillstyle(style));
+    lua_pushinteger(L, style >> 4);
+    lua_pushinteger(L, x1);
+    lua_pushinteger(L, y1);
+    lua_pushinteger(L, width);
+    lua_pushinteger(L, height);
+    LUA_call_report(lua_pcall(L, 6, 1, tb));
+    lua_term_result = (int)lua_tointeger(L, -1);
+    lua_pop(L, 1);
+  }
+}
+
+TERM_PUBLIC void
+LUA_linewidth(double width)
+{
+  if(LUA_init_luaterm_function("linewidth")) {
+    lua_pushnumber(L, width);
+    LUA_call_report(lua_pcall(L, 1, 1, tb));
+    lua_term_result = (int)lua_tointeger(L, -1);
+    lua_pop(L, 1);
+  }
+}
+
+TERM_PUBLIC void
+LUA_previous_palette(void)
+{
+  if(LUA_init_luaterm_function("previous_palette")) {
+    LUA_call_report(lua_pcall(L, 0, 1, tb));
+    lua_term_result = (int)lua_tointeger(L, -1);
+    lua_pop(L, 1);
+  }
+}
+
+
+TERM_PUBLIC void
+LUA_reset(void)
+{
+  if(LUA_init_luaterm_function("reset")) {
+    LUA_call_report(lua_pcall(L, 0, 1, tb));
+    lua_term_result = (int)lua_tointeger(L, -1);
+    lua_pop(L, 1);
+  }
+}
+
+TERM_PUBLIC int
+LUA_make_palette (t_sm_palette *palette)
+{
+  if(LUA_init_luaterm_function("make_palette")) {
+    LUA_call_report(lua_pcall(L, 0, 1, tb));
+    lua_term_result = (int)lua_tointeger(L, -1);
+    lua_pop(L, 1);
+    return(lua_term_result);
+  }
+  return(0); /* continuous number of colours */
+}
+
+
+TERM_PUBLIC void
+LUA_set_color (t_colorspec *colorspec)
+{
+
+  double gray = colorspec->value;
+  rgb_color color;
+
+
+  if(LUA_init_luaterm_function("set_color")) {
+    if (colorspec->type == TC_FRAC) {
+      if (sm_palette.colors != 0) /* finite nb of colors explicitly requested */
+          gray = (gray >= ((double)(sm_palette.colors-1)) / sm_palette.colors) ?
+              1 : floor(gray * sm_palette.colors) / sm_palette.colors;
+      rgb1_from_gray( gray, &color );
+    } else if (colorspec->type == TC_RGB) {
+      color.r = (double)((colorspec->lt >> 16 ) & 255) / 255.;
+      color.g = (double)((colorspec->lt >> 8 ) & 255) / 255.;
+      color.b = (double)(colorspec->lt & 255) / 255.;
+    }
+
+    if (color.r < 1e-4) color.r = 0;
+    if (color.g < 1e-4) color.g = 0;
+    if (color.b < 1e-4) color.b = 0;
+
+    lua_pushstring(L, LUA_get_colorstyle(colorspec->type));
+    lua_pushinteger(L, colorspec->lt);
+    lua_pushnumber(L, colorspec->value);
+    lua_pushnumber(L, color.r);
+    lua_pushnumber(L, color.g);
+    lua_pushnumber(L, color.b);
+    LUA_call_report(lua_pcall(L, 6, 1, tb));
+    lua_term_result = (int)lua_tointeger(L, -1);
+    lua_pop(L, 1);
+  }
+}
+
+
+TERM_PUBLIC void
+LUA_filled_polygon (int points, gpiPoint *corners)
+{
+  
+  if(LUA_init_luaterm_function("filled_polygon")) {
+    int i;
+    lua_pushstring(L, LUA_get_fillstyle(corners->style));
+    lua_pushinteger(L, corners->style >> 4);
+    /* put all coords into a simple table */
+    lua_newtable(L);
+    for (i = 0; i < points; i++) {
+      lua_newtable(L);
+      lua_pushinteger(L, corners[i].x);
+      lua_rawseti(L, -2, 1);
+      lua_pushinteger(L, corners[i].y);
+      lua_rawseti(L, -2, 2);
+      lua_rawseti(L, -2 , i+1); /* add "subtable" */
+    }
+    LUA_call_report(lua_pcall(L, 3, 1, tb));
+    lua_term_result = (int)lua_tointeger(L, -1);
+    lua_pop(L, 1);
+  }
+}
+
+TERM_PUBLIC void
+LUA_layer (t_termlayer syncpoint)
+{
+  if(LUA_init_luaterm_function("layer")) {
+    const char *m;
+    switch (syncpoint) {
+      case TERM_LAYER_RESET:      /* Start of plot; reset flag */
+        m = "reset";
+        break;
+      case TERM_LAYER_BACKTEXT:   /* Start of "back" text layer */
+        m = "backtext";
+        break;
+      case TERM_LAYER_FRONTTEXT:  /* Start of "front" text layer */
+        m = "fronttext";
+        break;
+      case TERM_LAYER_END_TEXT:   /* Close off front or back macro before leaving */
+        m = "end_text";
+        break;
+#ifdef GNUPLOT_LUA_4_3
+      case TERM_LAYER_BEFORE_PLOT:  /* Close off front or back macro before leaving */
+        m = "before_plot";
+        break;
+      case TERM_LAYER_AFTER_PLOT:   /* Close off front or back macro before leaving */
+        m = "after_plot";
+        break;
+      case TERM_LAYER_BEGIN_GRID:
+        m = "begin_grid";
+        break;
+      case TERM_LAYER_END_GRID:
+        m = "end_grid";
+        break;
+#endif
+      default:
+        m = "";
+        break;
+    }
+    lua_pushstring(L, m);
+    LUA_call_report(lua_pcall(L, 1, 1, tb));
+    lua_term_result = (int)lua_tointeger(L, -1);
+    lua_pop(L, 1);
+  }
+}
+
+TERM_PUBLIC void
+LUA_path (int path)
+{
+  if(LUA_init_luaterm_function("path")) {
+    lua_pushinteger(L, path);
+    LUA_call_report(lua_pcall(L, 1, 1, tb));
+    lua_term_result = (int)lua_tointeger(L, -1);
+    lua_pop(L, 1);
+  }
+}
+/*
+  Lua table structure for the image pixel:
+  pixel = {{r,g,b}, {r,g,b}, ... , {r,g,b}}
+
+  FIXME: would be nice to optionally generate a PNG
+  for inclusion since libgd is linked anyway...
+
+*/
+TERM_PUBLIC void
+LUA_image (unsigned m, unsigned n, coordval *image, gpiPoint *corner, t_imagecolor color_mode) {
+  if(LUA_init_luaterm_function("image")) {
+    int i, is_rgb;
+    rgb_color rgb1;
+    
+    lua_pushinteger(L, m);
+    lua_pushinteger(L, n);
+
+    is_rgb = (color_mode == IC_RGB) ? 1 : 0;
+    lua_newtable(L); /* pixel table */
+    for (i = 0; i < m*n; i++) {
+      if (is_rgb) {
+        rgb1.r = *image++;
+        rgb1.g = *image++;
+        rgb1.b = *image++;
+      } else {
+        rgb1maxcolors_from_gray(*image++, &rgb1);
+      }
+      lua_newtable(L); /* pixel color */
+      lua_pushnumber(L, rgb1.r);
+      lua_rawseti(L, -2, 1);
+      lua_pushnumber(L, rgb1.g);
+      lua_rawseti(L, -2, 2);
+      lua_pushnumber(L, rgb1.b);
+      lua_rawseti(L, -2, 3);
+      lua_rawseti(L, -2, i+1); /* add "pixel" */
+    }
+    
+    lua_newtable(L); /* "corner" table */
+    for (i = 0; i < 4; i++) {
+      lua_newtable(L);
+      lua_pushinteger(L, corner[i].x);
+      lua_rawseti(L, -2, 1);
+      lua_pushinteger(L, corner[i].y);
+      lua_rawseti(L, -2, 2);
+      lua_rawseti(L, -2 , i+1); /* add "subtable" */
+    }
+    if (is_rgb)
+      lua_pushstring(L, "RGB");
+    else
+      lua_pushstring(L, "GRAY");
+    LUA_call_report(lua_pcall(L, 5, 1, tb));
+    lua_term_result = (int)lua_tointeger(L, -1);
+    lua_pop(L, 1);
+  }
+}
+
+
+#endif /* TERM_BODY */
+
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(lua_driver)
+    "lua", LUA_TERM_DESCRIPTION,
+    LUA_XMAX, LUA_YMAX, LUA_VCHAR, LUA_HCHAR,
+    LUA_VTIC, LUA_HTIC, LUA_options, LUA_init, LUA_reset,
+    LUA_text, null_scale, LUA_graphics, LUA_move, LUA_vector,
+    LUA_linetype, LUA_put_text, LUA_text_angle,
+    LUA_justify_text, LUA_point, LUA_arrow, LUA_set_font, LUA_pointsize,
+    TERM_BINARY /*flags*/, 0 /*suspend*/, 0 /*resume*/,
+    LUA_boxfill, LUA_linewidth
+#ifdef USE_MOUSE
+    , 0, 0, 0, 0, 0
+#endif
+    , LUA_make_palette, LUA_previous_palette,  LUA_set_color
+    , LUA_filled_polygon
+    , LUA_image
+   , 0, 0, 0
+   , LUA_layer
+   , LUA_path
+#ifdef GNUPLOT_LUA_4_3
+   , LUA_TSCALE
+#endif
+TERM_TABLE_END(lua_driver)
+
+#undef LAST_TERM
+#define LAST_TERM lua_driver
+
+TERM_TABLE_START(tikz_driver)
+    "tikz", "TeX TikZ graphics macros via the lua script driver",
+    LUA_XMAX, LUA_YMAX, LUA_VCHAR, LUA_HCHAR,
+    LUA_VTIC, LUA_HTIC, LUA_options, LUA_init, LUA_reset,
+    LUA_text, null_scale, LUA_graphics, LUA_move, LUA_vector,
+    LUA_linetype, LUA_put_text, LUA_text_angle,
+    LUA_justify_text, LUA_point, LUA_arrow, LUA_set_font, LUA_pointsize,
+    TERM_BINARY /*flags*/, 0 /*suspend*/, 0 /*resume*/,
+    LUA_boxfill, LUA_linewidth
+#ifdef USE_MOUSE
+    , 0, 0, 0, 0, 0
+#endif
+    , LUA_make_palette, LUA_previous_palette,  LUA_set_color
+    , LUA_filled_polygon
+    , LUA_image
+   , 0, 0, 0
+   , LUA_layer
+   , LUA_path
+#ifdef GNUPLOT_LUA_4_3
+   , LUA_TSCALE
+#endif
+TERM_TABLE_END(tikz_driver)
+
+#undef LAST_TERM
+#define LAST_TERM tikz_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(lua)
+"1 lua",
+"?commands set terminal lua",
+"?set terminal lua",
+"?set term lua",
+"?terminal lua",
+"?term lua",
+"?lua",
+" The `lua` generic terminal driver works in conjunction with an",
+" external Lua script to create a target-specific plot file.",
+" Currently the only supported target is TikZ -> pdflatex.",
+"",
+" Information about Lua is available at http://www.lua.org .",
+"",
+" Syntax:",
+"    set terminal lua <target name> | \"<file name>\"",
+"                        {<script_args> ...}",
+"                        {help}",
+"",
+" A 'target name' or 'file name' (in quotes) for a script is mandatory.",
+" If a 'target name' for the script is given, the terminal will look for",
+" \"gnuplot-<target name>.lua\" in the local directory and on failure in",
+" the environmental variable GNUPLOT_LUA_DIR.",
+"",
+" All arguments will be provided to the selected script for further",
+" evaluation. E.g. 'set term lua tikz help' will cause the script itself",
+" to print additional help on options and choices for the script.",
+#include "lua/gnuplot-tikz.help"
+""
+END_HELP(lua)
+START_HELP(tikz)
+"1 tikz",
+"?commands set terminal tikz",
+"?set terminal tikz",
+"?set term tikz",
+"?terminal tikz",
+"?term tikz",
+"?tikz",
+" This driver creates output for use with the TikZ package of graphics macros",
+" in TeX.  It is currently implemented via an external lua script, and ",
+" `set term tikz` is a short form of the command `set term lua tikz`.",
+" See `term lua` for more information.  Use the command `set term tikz help`",
+" to print terminal options."
+END_HELP(tikz)
+#endif /* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/mac.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/mac.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/mac.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/mac.trm.svn-base	2012-01-03 17:07:39.865360100 -0800
@@ -0,0 +1,171 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: mac.trm,v 1.10 2008/12/26 22:16:03 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT -- mac.trm */
+
+/* Macintosh graphics terminal */
+
+/*[
+ * Copyright 1986 - 1993, 1998, 2004   Thomas Williams, Colin Kelley
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+#ifndef GOT_DRIVER_H
+#include "driver.h"
+#endif
+
+#ifdef TERM_REGISTER
+register_term(mac)
+#endif
+
+/******************************************************************************
+*                                                                             *
+* struct TERMENTRY {                                                          *
+*     char *name;                                                             *
+*     char *description;                                                      *
+*     unsigned int xmax,ymax,v_char,h_char,v_tic,h_tic;                       *
+*                                                                             *
+*     void (*options) __PROTO((void));                                        *
+*     void (*init) __PROTO((void));                                           *
+*     void (*reset) __PROTO((void));                                          *
+*     void (*text) __PROTO((void));                                           *
+*     int (*scale) __PROTO((double, double));                                 *
+*     void (*graphics) __PROTO((void));                                       *
+*     void (*move) __PROTO((unsigned int, unsigned int));                     *
+*     void (*vector) __PROTO((unsigned int, unsigned int));                   *
+*     void (*linetype) __PROTO((int));                                        *
+*     void (*put_text) __PROTO((unsigned int, unsigned int,const char*));     *
+*     -- the following are optional. set term ensures they are not NULL       *
+*     int (*text_angle) __PROTO((int));                                       *
+*     int (*justify_text) __PROTO((enum JUSTIFY));                            *
+*     void (*point) __PROTO((unsigned int, unsigned int,int));                *
+*     void (*arrow) __PROTO((unsigned int, unsigned int, unsigned int, unsigned int,int)); *
+*     int (*set_font) __PROTO((const char *font));                            *
+*     void (*pointsize) __PROTO((double));                                    *
+*     int flags;                                                              *
+*     void (*suspend) __PROTO((void)); -- called after one plot of multiplot  *
+*     void (*resume) __PROTO((void));  -- called before plots of multiplot    *
+*     void (*fillbox) __PROTO((int style, unsigned int x1, unsigned int y1, unsigned)) -- clear in multiplot mode *
+*     void (*linewidth) __PROTO((double linewidth));                          *
+* };                                                                          *
+*                                                                             *
+******************************************************************************/
+
+
+
+#ifdef TERM_PROTO
+
+#define MAC_XMAX 494
+#define MAC_YMAX 274
+/*
+ * #define MAC_XOFFSET (497-MAC_XMAX)
+ *
+ * #define MAC_XLAST (MAC_XMAX - 1)
+ * #define MAC_YLAST (MAC_YMAX - 1)
+ */
+
+#define MAC_VCHAR 12	 /* monaco 9 point plain style */
+#define MAC_HCHAR 6
+#define MAC_VTIC 3
+#define MAC_HTIC 3
+
+void MAC_init __PROTO((void));
+void MAC_graphics __PROTO((void));
+void MAC_text __PROTO((void));
+void MAC_linetype __PROTO((int linetype));
+void MAC_move __PROTO((unsigned int x,unsigned int y));
+void MAC_vector __PROTO((unsigned int x,unsigned int y));
+void MAC_put_text __PROTO((unsigned int x,unsigned int y,const char *str));
+int  MAC_text_angle __PROTO((int angle));
+int  MAC_justify_text __PROTO((enum JUSTIFY just));
+void MAC_reset __PROTO((void));
+void MAC_options __PROTO((void));
+void MAC_suspend __PROTO((void));
+void MAC_resume __PROTO((void));
+int  MAC_setfont __PROTO((char *font));
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(mac_driver)
+    "macintosh", "Macintosh Graphic Window",
+    MAC_XMAX, MAC_YMAX, MAC_VCHAR+1, MAC_HCHAR,
+    MAC_VTIC, MAC_HTIC, MAC_options,MAC_init, MAC_reset,
+    MAC_text, null_scale, MAC_graphics, MAC_move, MAC_vector,
+    MAC_linetype, MAC_put_text, MAC_text_angle,
+    MAC_justify_text, do_point, do_arrow,
+    MAC_setfont, NULL, TERM_CAN_MULTIPLOT+TERM_BINARY,
+    MAC_suspend, MAC_resume
+TERM_TABLE_END(mac_driver)
+
+#undef LAST_TERM
+#define LAST_TERM mac_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(mac)
+"1 macintosh",
+"?set terminal macintosh",
+"?set term macintosh",
+"?terminal macintosh",
+"?term macintosh",
+"?macintosh",
+" Syntax:",
+"      set terminal macintosh {singlewin | multiwin} {vertical | novertical}",
+"                             {size <width>, <height> | default}",
+"",
+" 'singlewin' limits the output to a single window and is useful for animations.",
+" 'multiwin' allows multiple windows.",
+" 'vertical' is only valid under the gx option. With this option, rotated text",
+" will be drawn vertically. novertical turns this option off.",
+" size <width>, <height> overrides the graph size set in the preferences",
+" dialog until it is cleared with either 'set term mac size default'",
+" or 'set term mac default'.",
+"",
+" 'set term mac size default' sets the window size settings to those set in",
+" the preferences dialog.",
+"",
+" 'set term mac default' sets all options to their default values.",
+" Default values: nogx, multiwin, novertical.",
+"",
+" If you generate graphs under the multiwin option and then switch to singlewin,",
+" the next plot command will cause one more window to be created. This new",
+" window will be reused as long as singlewin is in effect. If you switch back",
+" to multiwin, generate some graphs, and then switch to singlewin again, the",
+" orginal 'singlewin' window will be resused if it is still open. Otherwise",
+" a new 'singlewin' window will be created. The 'singlewin' window is not numbered."
+END_HELP(mac)
+#endif /* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/metafont.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/metafont.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/metafont.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/metafont.trm.svn-base	2012-01-03 17:07:40.052846300 -0800
@@ -0,0 +1,640 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: metafont.trm,v 1.20 2006/07/21 02:35:47 sfeam Exp $
+ */
+
+/* GNUPLOT - metafont.trm */
+
+/*[
+ * Copyright 1986 - 1993, 1998, 2004   Thomas Williams, Colin Kelley
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ *			  GNUPLOT -- mf.trm
+ *
+ *		    This terminal driver supports:
+ *		       Metafont Plot Commands
+ *
+ * Written by : Pl Hedne
+ *		Trondheim, Norway
+ *		Pal.Hedne@termo.unit.no
+ */
+
+/*
+ * Improvements and bug fixes by Carsten Steger:
+ * - Set default plot size to 5 by 3 inches as in the latex- and eepic-
+ *   drivers
+ * - Fixed some bugs concerning resolution dependent output
+ * - Added MF_scale function
+ * - Added MF_justify_text function and modified MF_put_text function and
+ *   put_text macro accordingly
+ * - Modified MF_move and MF_vector to make output shorter and modified
+ *   MF_text accordingly
+ * - Added various linetypes by plotting dashed lines; had to modify
+ *   MF_linetype and MF_vector for this
+ * - Added MF_arrow function
+ * - All global variables and #define'd names begin with MF_ now
+ * As a consequence almost nothing of the original code by Pl Hedne remains
+ * but credit goes to him for the ingenious trick of storing the character
+ * images into picture variables, without which this driver would have been
+ * impossible for me to write.
+ *
+ * 10/03/95: Converted to new terminal layout by Carsten Steger.
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(mf)
+#endif
+
+#ifdef TERM_PROTO
+
+#define MF_DPI (300)
+/* resolution of printer we expect to use; the value itself is not
+ * particularly important... it is here only for compatibility to the
+ * LaTeX-driver and to get the spacing right. */
+
+/* 5 inches wide by 3 inches high (default) */
+#define MF_XSIZE 5.0
+#define MF_YSIZE 3.0
+#define MF_XMAX (MF_XSIZE*MF_DPI)
+#define MF_YMAX (MF_YSIZE*MF_DPI)
+
+#define MF_HTIC (5*MF_DPI/72)
+#define MF_VTIC (5*MF_DPI/72)
+#define MF_HCHAR (MF_DPI*53/10/72)
+#define MF_VCHAR (MF_DPI*11/72)
+
+TERM_PUBLIC void MF_init __PROTO((void));
+TERM_PUBLIC void MF_graphics __PROTO((void));
+TERM_PUBLIC void MF_text __PROTO((void));
+TERM_PUBLIC int MF_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC int MF_text_angle __PROTO((int ang));
+TERM_PUBLIC void MF_linetype __PROTO((int linetype));
+TERM_PUBLIC void MF_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void MF_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void MF_arrow __PROTO((unsigned int sx, unsigned int sy,
+				   unsigned int ex, unsigned int ey,
+				   int head));
+TERM_PUBLIC void MF_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC void MF_reset __PROTO((void));
+
+#define GOT_MF_PROTO
+
+#endif /* TERM_PROTO */
+
+
+#ifndef TERM_PROTO_ONLY
+
+#ifdef TERM_BODY
+
+
+/* Plot size in inches */
+static double MF_xsize = MF_XSIZE;
+static double MF_ysize = MF_YSIZE;
+static int MF_char_code;
+static int MF_ang;
+static int MF_line_type;
+static enum JUSTIFY MF_justify;
+static double MF_dist_left;
+static int MF_is_solid;
+static int MF_picked_up_pen;
+/*
+ * We keep track of where we are with respect to dashed lines by using
+ * the next five variables. MF_dash_index indicates which element of
+ * MF_lines[..].dashlen should be used. The MF_last.. variables keep
+ * track of the position of the pen.
+ */
+static int MF_dash_index;
+static unsigned int MF_last_x, MF_last_y;
+
+static struct {
+    int solid;			/* Is the line solid? */
+    float thickness;		/* Thickness of pen we are going to use */
+    int dashlen[4];		/* Length of individual segments; even: line; odd: gap */
+} MF_lines[10] =
+{
+    {
+	1, 1.5, { 0, 0, 0, 0 }
+    },
+    {
+	0, 1.0, { MF_DPI / 60, MF_DPI / 50, MF_DPI / 60, MF_DPI / 50 }
+    },
+    {
+	1, 1.5, { 0, 0, 0, 0 }
+    },
+    {
+	0, 1.5, { MF_DPI / 20, MF_DPI / 30, MF_DPI / 20, MF_DPI / 30 }
+    },
+    {
+	0, 1.5, { MF_DPI / 30, MF_DPI / 20, MF_DPI / 30, MF_DPI / 20 }
+    },
+    {
+	0, 1.5, { MF_DPI / 15, MF_DPI / 30, MF_DPI / 60, MF_DPI / 30 }
+    },
+    {
+	0, 1.5, { MF_DPI / 30, MF_DPI / 50, MF_DPI / 30, MF_DPI / 50 }
+    },
+    {
+	0, 1.5, { MF_DPI / 20, MF_DPI / 50, MF_DPI / 60, MF_DPI / 30 }
+    },
+    {
+	0, 1.5, { MF_DPI / 30, MF_DPI / 50, MF_DPI / 30, MF_DPI / 30 }
+    },
+    {
+	0, 1.5, { MF_DPI / 60, MF_DPI / 50, MF_DPI / 60, MF_DPI / 30 }
+    }
+    /* dash: line,     gap,      line,     gap      */
+};
+
+
+
+TERM_PUBLIC void
+MF_init()
+{
+    MF_char_code = 0;
+    MF_ang = 0;
+
+    fputs("\
+if unknown cmbase: input cmbase fi\n\n\
+tracingstats:=1;\n\
+picture r[];\n\
+\ndef openit = openwindow currentwindow\n\
+  from (0,0) to (400,800) at (-50,500) enddef;\n\
+\nmode_setup;\n", gpoutfile);
+
+    fputs("\
+\n%Include next eight lines if you have problems with the mode on your system..\n\
+%proofing:=0;\n\
+%fontmaking:=1;\n\
+%tracingtitles:=0;\n\
+%pixels_per_inch:=300;\n\
+%blacker:=0;\n\
+%fillin:=.2;\n\
+%o_correction:=.6;\n\
+%fix_units;\n", gpoutfile);
+
+    /* Next lines must be included if text support is needed (CM base used) */
+    fputs("\
+\ndef put_text(expr ts,xstart,ystart,rot,justification) =\n\
+  begingroup\n\
+    text_width:=0;text_height:=0;text_depth:=0;\n\
+    for ind:=0 step 1 until length(ts)-1:\n\
+      dec_num:=ASCII substring (ind,ind+1) of ts;\n\
+      if unknown r[dec_num]: dec_num:=32; fi\n\
+      if dec_num=32: \n\
+        text_width:=text_width+wd[65];\n\
+        text_height:=max(text_height,ht[65]);\n\
+        text_depth:=max(text_depth,dp[65]);\n\
+      elseif dec_num>=0: \n\
+        text_width:=text_width+wd[dec_num];\n\
+        text_height:=max(text_height,ht[dec_num]);\n\
+        text_depth:=max(text_depth,dp[dec_num]);\n\
+      fi\n\
+    endfor\n\
+    if rot=90:\n\
+      if justification=1: ynext:=ystart;\n\
+      elseif justification=2: ynext:=round(ystart-text_width/2);\n\
+      else: ynext:=round(ystart-text_width);\n\
+      fi\n\
+      xnext:=xstart+(text_height-text_depth)/2;\n\
+    else:\n\
+      if justification=1: xnext:=xstart;\n\
+      elseif justification=2: xnext:=round(xstart-text_width/2);\n\
+      else: xnext:=round(xstart-text_width);\n\
+      fi\n\
+      ynext:=ystart-(text_height-text_depth)/2;\n\
+    fi\n\
+    for ind:=0 step 1 until length(ts)-1:\n\
+      dec_num:=ASCII substring (ind,ind+1) of ts;\n\
+      if unknown r[dec_num]: dec_num:=32; fi\n\
+      if dec_num=32: \n\
+        xnext:=xnext+wd[65]*cosd rot;\n\
+        ynext:=ynext+wd[65]*sind rot;\n\
+      elseif dec_num>=0: \n\
+        currentpicture:=currentpicture+r[dec_num] shifted(xnext,ynext)\n\
+          rotatedaround ((xnext,ynext),rot); \n\
+        xnext:=xnext+wd[dec_num]*cosd rot;\n\
+        ynext:=ynext+wd[dec_num]*sind rot;\n\
+      fi\n\
+    endfor\n\
+  endgroup \n\
+enddef;\n", gpoutfile);
+
+    fputs("\
+\ndef endchar =\n\
+  r[charcode]:=currentpicture;\n\
+  wd[charcode]:=w;ht[charcode]:=h;dp[charcode]:=d;\n\
+  message \"Picture of charcode no.\" & decimal charcode;\n\
+  endgroup;\n\
+enddef;\n\
+let endchar_ = endchar;\n\
+let generate = relax;\n\
+let roman = relax;\n", gpoutfile);
+
+    fputs("\
+input cmr10.mf\n\
+if ligs>1: font_coding_scheme:=\"TeX text\";\n\
+  spanish_shriek=oct\"074\"; spanish_query=oct\"076\";\n\
+else: font_coding_scheme:=\n\
+  if ligs=0: \"TeX typewriter text\"\n\
+  else: \"TeX text without f-ligatures\" fi;\n\
+  spanish_shriek=oct\"016\"; spanish_query=oct\"017\"; fi\n\
+font_setup;\n\
+input romanu.mf %Roman uppercase.\n\
+input romanl.mf %Roman lowercase.\n\
+input greeku.mf %Greek uppercase.\n\
+input romand.mf %Numerals.\n\
+input romanp.mf %Ampersand, question marks, currency sign.\n\
+input romspl.mf %Lowercase specials (dotless \\i, ligature \\ae, etc.)\n\
+input romspu.mf %Uppercase specials (\\AE, \\OE, \\O)\n\
+input punct.mf %Punctuation symbols.\n\
+\nminus=ASCII\"-\"; cmchar \"Minus sign\";\n\
+ beginarithchar(minus); \n\
+  pickup rule.nib;\n\
+  lft x1=hround 1.5u-eps;\n\
+  x2=w-x1; y1=y2=math_axis;\n\
+  draw z1--z2;	 % bar\n\
+  labels(1,2); \n\
+endchar;\n", gpoutfile);
+
+    fputs("\
+\ncmchar \"Period\";\n\
+  numeric dot_diam#; dot_diam#:=if monospace: 5/4 fi\\ dot_size#;\n\
+  define_whole_blacker_pixels(dot_diam);\n\
+  beginchar(\".\",5u#,dot_diam#,0);\n\
+  adjust_fit(0,0); pickup fine.nib;\n\
+  pos1(dot_diam,0); pos2(dot_diam,90);\n\
+  lft x1l=hround(.5w-.5dot_diam); bot y2l=0; z1=z2; dot(1,2);	% dot\n\
+  penlabels(1,2);\n\
+endchar;\n", gpoutfile);
+
+    fputs("\
+\ndef endchar =\n\
+  % Next line should probably be removed if CM base is used\n\
+  l:=0; r:=w;\n\
+  %Include the next two lines if you want to\n\
+  %rotate the picture 90 deg.(Portrait to Landscape)\n\
+  %currentpicture:=currentpicture rotated 90 shifted (h,0);\n\
+  %tmp:=charht; charht:=charwd; charwd:=tmp;\n\
+  scantokens extra_endchar;\n\
+  if proofing>0: makebox(proofrule); fi\n\
+  chardx:=w;\n\
+  shipit;\n\
+  if displaying>0: makebox(screenrule); showit; fi\n\
+  endgroup \n\
+enddef;\n\
+let endchar_ = endchar;\n\
+let generate = input;\n\
+let roman = roman;\n", gpoutfile);
+
+    /* font_size must be bigger than em#/16 by METAFONT rules.
+     * Therefore make it pretty big so big figures will be
+     * handled correctly. Setting font_size to 72pt# lets us
+     * handle characters up to 15.94 by 15.94 inches. */
+    fputs("\
+\n\nfont_identifier:=\"GNUPLOT\";\n\
+font_size 72pt#;\n\
+th#=0.4pt#; define_whole_pixels(th);\n\
+\npath arrowhead;\n\
+arrowhead = (-7pt,-2pt){dir30}..(-6pt,0pt)..\
+{dir150}(-7pt,2pt) &\n\
+  (-7pt,2pt)--(0pt,0pt)--(-7pt,-2pt) & cycle;\n", gpoutfile);
+}
+
+
+TERM_PUBLIC void
+MF_graphics()
+{
+    register struct termentry *t = term;
+
+    fprintf(gpoutfile, "\n\nbeginchar(%d,%gin#,%gin#,0);\n",
+	    MF_char_code, MF_xsize, MF_ysize);
+    MF_char_code++;
+    fprintf(gpoutfile, "a:=w/%d;b:=h/%d;\n", t->xmax, t->ymax);
+    MF_picked_up_pen = 0;
+}
+
+
+TERM_PUBLIC void
+MF_text()
+{
+    fputs("endchar;\n", gpoutfile);
+}
+
+
+TERM_PUBLIC int
+MF_justify_text(enum JUSTIFY mode)
+{
+    MF_justify = mode;
+    return TRUE;
+}
+
+
+TERM_PUBLIC int
+MF_text_angle(int ang)
+{
+    if (ang > 0)
+	MF_ang = 90;
+    else
+	MF_ang = 0;
+    return TRUE;
+}
+
+
+TERM_PUBLIC void
+MF_linetype(int linetype)
+{
+    if (linetype >= 8)
+	linetype %= 8;
+    linetype += 2;
+    if (linetype < 0)
+	linetype = 0;
+    /* Only output change in pens if it actually affects the pen used */
+    if ((MF_lines[linetype].thickness != MF_lines[MF_line_type].thickness) ||
+	(!MF_picked_up_pen)) {
+	fprintf(gpoutfile, "pickup pencircle scaled %gth;\n",
+		MF_lines[linetype].thickness);
+	MF_picked_up_pen = 1;
+    }
+    MF_line_type = linetype;
+    MF_dash_index = 0;
+    MF_dist_left = MF_lines[MF_line_type].dashlen[MF_dash_index];
+    MF_is_solid = MF_lines[MF_line_type].solid;
+}
+
+
+TERM_PUBLIC void
+MF_move(unsigned int x, unsigned int y)
+{
+    MF_last_x = x;
+    MF_last_y = y;
+    MF_dash_index = 0;
+    MF_dist_left = MF_lines[MF_line_type].dashlen[MF_dash_index];
+}
+
+
+TERM_PUBLIC void
+MF_vector(unsigned int x, unsigned int y)
+{
+    if (MF_is_solid) {
+	if (x == MF_last_x && y == MF_last_y)
+	    fprintf(gpoutfile, "drawdot (%da,%db);\n", x, y);
+	else
+	    fprintf(gpoutfile, "draw (%da,%db)--(%da,%db);\n",
+		    MF_last_x, MF_last_y, x, y);
+    } else {
+	double dist_to_go, delta_x, delta_y, inc_x, inc_y;
+	double last_x_d, last_y_d, next_x_d, next_y_d;
+	unsigned int next_x, next_y;
+
+	if (x == MF_last_x && y == MF_last_y) {
+	    if (!(MF_dash_index & 1))
+		fprintf(gpoutfile, "drawdot (%da,%db);\n", x, y);
+	} else {
+	    last_x_d = MF_last_x;
+	    last_y_d = MF_last_y;
+	    delta_x = x - last_x_d;
+	    delta_y = y - last_y_d;
+	    dist_to_go = sqrt(delta_x * delta_x + delta_y * delta_y);
+	    inc_x = delta_x / dist_to_go;
+	    inc_y = delta_y / dist_to_go;
+	    while (MF_dist_left < dist_to_go) {
+		next_x_d = last_x_d + inc_x * MF_dist_left;
+		next_y_d = last_y_d + inc_y * MF_dist_left;
+		next_x = floor(next_x_d + 0.5);
+		next_y = floor(next_y_d + 0.5);
+		/* MF_dash_index & 1 == 0 means: draw a line; otherwise just move */
+		if (!(MF_dash_index & 1))
+		    fprintf(gpoutfile, "draw (%da,%db)--(%da,%db);\n",
+			    MF_last_x, MF_last_y, next_x, next_y);
+		MF_last_x = next_x;
+		MF_last_y = next_y;
+		last_x_d = next_x_d;
+		last_y_d = next_y_d;
+		dist_to_go -= MF_dist_left;
+		MF_dash_index = (MF_dash_index + 1) & 3;
+		MF_dist_left = MF_lines[MF_line_type].dashlen[MF_dash_index];
+	    }
+	    delta_x = x - last_x_d;
+	    delta_y = y - last_y_d;
+	    MF_dist_left -= sqrt(delta_x * delta_x + delta_y * delta_y);
+	    if (!(MF_dash_index & 1)) {
+		if (x == MF_last_x && y == MF_last_y)
+		    fprintf(gpoutfile, "drawdot (%da,%db);\n", x, y);
+		else
+		    fprintf(gpoutfile, "draw (%da,%db)--(%da,%db);\n",
+			    MF_last_x, MF_last_y, x, y);
+	    }
+	}
+    }
+    MF_last_x = x;
+    MF_last_y = y;
+}
+
+
+TERM_PUBLIC void
+MF_arrow(
+    unsigned int sx, unsigned int sy,
+    unsigned int ex, unsigned int ey,
+    int head)
+{
+    int delta_x, delta_y;
+
+    MF_move(sx, sy);
+    MF_vector(ex, ey);
+    if (head) {
+	delta_x = ex - sx;
+	delta_y = ey - sy;
+	fprintf(gpoutfile, "fill arrowhead rotated angle(%d,%d) shifted (%da,%db);\n",
+		delta_x, delta_y, ex, ey);
+    }
+}
+
+
+TERM_PUBLIC void
+MF_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    int i, j = 0;
+    char *text;
+
+    /* ignore empty strings */
+    if (!str || !*str)
+	return;
+
+    /* F***. why do drivers need to modify string args? */
+    text = gp_strdup(str);
+
+    for (i = 0; i < strlen(text); i++)
+	if (text[i] == '"')
+	    text[i] = '\'';	/* Replace " with ' */
+    switch (MF_justify) {
+    case LEFT:
+	j = 1;
+	break;
+    case CENTRE:
+	j = 2;
+	break;
+    case RIGHT:
+	j = 3;
+	break;
+    }
+    fprintf(gpoutfile, "put_text(\"%s\",%da,%db,%d,%d);\n",
+	    text, x, y, MF_ang, j);
+    free(text);
+}
+
+
+TERM_PUBLIC void
+MF_reset()
+{
+    fputs("end.\n", gpoutfile);
+}
+
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(mf_driver)
+    "mf", "Metafont plotting standard",
+    MF_XMAX, MF_YMAX, MF_VCHAR, MF_HCHAR,
+    MF_VTIC, MF_HTIC, options_null, MF_init, MF_reset,
+    MF_text, null_scale, MF_graphics, MF_move, MF_vector,
+    MF_linetype, MF_put_text, MF_text_angle,
+    MF_justify_text, line_and_point, MF_arrow, set_font_null
+TERM_TABLE_END(mf_driver)
+
+#undef LAST_TERM
+#define LAST_TERM mf_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+
+#ifdef TERM_HELP
+START_HELP(mf)
+"1 mf",
+"?commands set terminal mf",
+"?set terminal mf",
+"?set term mf",
+"?terminal mf",
+"?term mf",
+"?mf",
+"?metafont",
+" The `mf` terminal driver creates an input file to the METAFONT program.  Thus a",
+" figure may be used in the TeX document in the same way as is a character.",
+"",
+" To use a picture in a document, the METAFONT program must be run with the",
+" output file from `gnuplot` as input.  Thus, the user needs a basic knowledge",
+" of the font creating process and the procedure for including a new font in a",
+" document.  However, if the METAFONT program is set up properly at the local",
+" site, an unexperienced user could perform the operation without much trouble.",
+"",
+" The text support is based on a METAFONT character set.  Currently the",
+" Computer Modern Roman font set is input, but the user is in principal free to",
+" choose whatever fonts he or she needs.  The METAFONT source files for the",
+" chosen font must be available.  Each character is stored in a separate",
+" picture variable in METAFONT.  These variables may be manipulated (rotated,",
+" scaled etc.) when characters are needed.  The drawback is the interpretation",
+" time in the METAFONT program.  On some machines (i.e. PC) the limited amount",
+" of memory available may also cause problems if too many pictures are stored.",
+"",
+" The `mf` terminal has no options.",
+"2 METAFONT Instructions",
+"?commands set terminal mf detailed",
+"?set terminal mf detailed",
+"?set term mf detailed",
+"?mf detailed",
+"?metafont detailed",
+"",
+" - Set your terminal to METAFONT:",
+"   set terminal mf",
+" - Select an output-file, e.g.:",
+"   set output \"myfigures.mf\"",
+" - Create your pictures. Each picture will generate a separate character. Its",
+" default size will be 5*3 inches. You can change the size by saying `set size",
+" 0.5,0.5` or whatever fraction of the default size you want to have.",
+"",
+" - Quit `gnuplot`.",
+"",
+" - Generate a TFM and GF file by running METAFONT on the output of `gnuplot`.",
+" Since the picture is quite large (5*3 in), you will have to use a version of",
+" METAFONT that has a value of at least 150000 for memmax.  On Unix systems",
+" these are conventionally installed under the name bigmf.  For the following",
+" assume that the command virmf stands for a big version of METAFONT.  For",
+" example:",
+"",
+" - Invoke METAFONT:",
+"     virmf '&plain'",
+" - Select the output device: At the METAFONT prompt ('*') type:",
+"     \\mode:=CanonCX;     % or whatever printer you use",
+" - Optionally select a magnification:",
+"     mag:=1;             % or whatever you wish",
+" - Input the `gnuplot`-file:",
+"     input myfigures.mf",
+" On a typical Unix machine there will usually be a script called \"mf\" that",
+" executes virmf '&plain', so you probably can substitute mf for virmf &plain.",
+" This will generate two files: mfput.tfm and mfput.$$$gf (where $$$ indicates",
+" the resolution of your device).  The above can be conveniently achieved by",
+" typing everything on the command line, e.g.:",
+" virmf '&plain' '\\mode:=CanonCX; mag:=1; input myfigures.mf'",
+" In this case the output files will be named myfigures.tfm and",
+" myfigures.300gf.",
+"",
+" - Generate a PK file from the GF file using gftopk:",
+"   gftopk myfigures.300gf myfigures.300pk",
+" The name of the output file for gftopk depends on the DVI driver you use.",
+" Ask your local TeX administrator about the naming conventions.  Next, either",
+" install the TFM and PK files in the appropriate directories, or set your",
+" environment variables properly.  Usually this involves setting TEXFONTS to",
+" include the current directory and doing the same thing for the environment",
+" variable that your DVI driver uses (no standard name here...).  This step is",
+" necessary so that TeX will find the font metric file and your DVI driver will",
+" find the PK file.",
+"",
+" - To include your pictures in your document you have to tell TeX the font:",
+"   \\font\\gnufigs=myfigures",
+" Each picture you made is stored in a single character.  The first picture is",
+" character 0, the second is character 1, and so on...  After doing the above",
+" step, you can use the pictures just like any other characters.  Therefore, to",
+" place pictures 1 and 2 centered in your document, all you have to do is:",
+"   \\centerline{\\gnufigs\\char0}",
+"   \\centerline{\\gnufigs\\char1}",
+" in plain TeX.  For LaTeX you can, of course, use the picture environment and",
+" place the picture wherever you wish by using the \\makebox and \\put macros.",
+"",
+" This conversion saves you a lot of time once you have generated the font;",
+" TeX handles the pictures as characters and uses minimal time to place them,",
+" and the documents you make change more often than the pictures do.  It also",
+" saves a lot of TeX memory.  One last advantage of using the METAFONT driver",
+" is that the DVI file really remains device independent, because no \\special",
+" commands are used as in the eepic and tpic drivers."
+END_HELP(mf)
+#endif /* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/metapost.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/metapost.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/metapost.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/metapost.trm.svn-base	2012-01-03 17:07:40.318535300 -0800
@@ -0,0 +1,1176 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: metapost.trm,v 1.43 2008/05/31 15:05:29 sfeam Exp $
+ */
+
+/* GNUPLOT - metapost.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/* 1999/04/22
+ *			GNUPLOT -- metapost.trm
+ *
+ *			This terminal driver supports:
+ *		    		Metapost Commands
+ *
+ * Based on metafont.trm, written by
+ *		Pl Hedne
+ *		Trondheim, Norway
+ *		Pal.Hedne@termo.unit.no;
+ *		with improvements by Carsten Steger
+ *
+ * and pstricks.trm, written by
+ *		David Kotz and Raymond Toy
+ *
+ * Adapted to metapost by:
+ * 		Daniel H. Luecking <luecking@comp.uark.edu> and
+ * 	 	L Srinivasa Mohan <mohan@chemeng.iisc.ernet.in>
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(mp)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void MP_options __PROTO((void));
+TERM_PUBLIC void MP_init __PROTO((void));
+TERM_PUBLIC void MP_graphics __PROTO((void));
+TERM_PUBLIC void MP_text __PROTO((void));
+TERM_PUBLIC void MP_linetype __PROTO((int linetype));
+TERM_PUBLIC void MP_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void MP_point __PROTO((unsigned int x, unsigned int y, int number));
+TERM_PUBLIC void MP_pointsize __PROTO((double size));
+TERM_PUBLIC void MP_linewidth __PROTO((double width));
+TERM_PUBLIC void MP_vector __PROTO((unsigned int ux, unsigned int uy));
+TERM_PUBLIC void MP_arrow __PROTO((unsigned int sx, unsigned int sy,
+				   unsigned int ex, unsigned int ey,
+				   int head));
+TERM_PUBLIC void MP_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
+TERM_PUBLIC int MP_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC int MP_text_angle __PROTO((int ang));
+TERM_PUBLIC void MP_reset __PROTO((void));
+TERM_PUBLIC int MP_set_font __PROTO((const char *font));
+TERM_PUBLIC void MP_boxfill __PROTO((int style, unsigned int x1,
+				     unsigned int y1, unsigned int width,
+				     unsigned int height));
+TERM_PUBLIC int MP_make_palette __PROTO((t_sm_palette *));
+TERM_PUBLIC void MP_previous_palette __PROTO((void));
+TERM_PUBLIC void MP_set_color __PROTO((t_colorspec *));
+TERM_PUBLIC void MP_filled_polygon __PROTO((int, gpiPoint *));
+
+/* 5 inches wide by 3 inches high (default) */
+#define MP_XSIZE 5.0
+#define MP_YSIZE 3.0
+
+/* gnuplot units will be one pixel if printing device has this
+   resolution. Too small resolutions (like 300) can give rough
+   appearence to curves when user tries to smooth a curve by choosing
+   high sampling rate. */
+#define MP_DPI (2400)
+
+#define MP_XMAX (MP_XSIZE*MP_DPI)
+#define MP_YMAX (MP_YSIZE*MP_DPI)
+
+#define MP_HTIC (5*MP_DPI/72)	/* nominally 5pt   */
+#define MP_VTIC (5*MP_DPI/72)	/*    "      5pt   */
+#define MP_HCHAR (MP_DPI*53/10/72)	/*    "      5.3pt */
+#define MP_VCHAR (MP_DPI*11/72)	/*    "      11pt  */
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+static double MP_xsize = MP_XSIZE;
+static double MP_ysize = MP_YSIZE;
+/* static double MP_xmax = MP_XMAX;
+   static double MP_ymax = MP_YMAX;
+ * unused, for now
+ */
+static int MP_posx;
+static int MP_posy;
+static char MP_fontname[MAX_ID_LEN + 1];
+static double MP_fontsize;
+static double MP_textmag;
+static enum JUSTIFY MP_justify = LEFT;
+static int MP_ang = 0;
+static int MP_char_code = 0;
+
+/* number of nodes in an output line so far */
+static int MP_linecount = 1;
+
+/* Number of point types */
+#define MP_POINT_TYPES 10
+
+/* Number of line types */
+#define MP_LINE_TYPES 8
+
+/* are we in the middle of a MP path? */
+static TBOOLEAN MP_inline = FALSE;
+/* colored or dashed lines? */
+static TBOOLEAN MP_color = FALSE;
+static TBOOLEAN MP_solid = FALSE;
+
+/* compatability mode*/
+/* static TBOOLEAN MP_notex = FALSE; */
+#define MP_NO_TEX 0
+#define MP_TEX 1
+#define MP_LATEX 2
+static int MP_tex = MP_TEX;
+/* add usepackage instructions for PSNFSS ? */
+#define MP_PSNFSS_NONE 0
+#define MP_PSNFSS_7    1
+#define MP_PSNFSS_8    2
+static int MP_psnfss = MP_PSNFSS_NONE;
+/* should amstex packages be included? */
+static int MP_amstex = 0;
+/* add a4paper option to documentclass */
+static int MP_a4paper = 0;
+/* write a prologues line */
+static int MP_prologues = -1;
+
+/* has color changed? */
+static int MP_color_changed = 0;
+
+/* has a font change taken place? */
+static TBOOLEAN MP_fontchanged = FALSE;
+
+/* The old types */
+static int MP_oldline = -2;
+
+/* The old sizes */
+static double MP_oldptsize = 1.0;
+static double MP_oldpen = 1.0;
+
+/* terminate any path in progress */
+static void MP_endline __PROTO((void));
+
+/* max number of path nodes before a newline */
+#define MP_LINEMAX 5
+
+enum MP_id {
+    MP_OPT_MONOCHROME, MP_OPT_COLOUR,
+    MP_OPT_SOLID, MP_OPT_DASHED,
+    MP_OPT_NOTEX, MP_OPT_TEX, MP_OPT_LATEX,
+    MP_OPT_A4PAPER,
+    MP_OPT_PSNFSS, MP_OPT_PSNFSS_V7, MP_OPT_NOPSNFSS,
+    MP_OPT_AMSTEX,
+    MP_OPT_FONT, MP_OPT_FONTSIZE,
+    MP_OPT_PROLOGUES, MP_OPT_NOPROLOGUES,
+    MP_OPT_MAGNIFICATION, MP_OPT_OTHER
+};
+
+static struct gen_table MP_opts[] = {
+    { "mo$nochrome", MP_OPT_MONOCHROME },
+    { "c$olor", MP_OPT_COLOUR },
+    { "c$olour", MP_OPT_COLOUR },
+    { "s$olid", MP_OPT_SOLID },
+    { "da$shed", MP_OPT_DASHED },
+    { "n$otex", MP_OPT_NOTEX },
+    { "t$ex", MP_OPT_TEX },
+    { "la$tex", MP_OPT_LATEX },
+    { "a4$paper", MP_OPT_A4PAPER },
+    { "am$stex", MP_OPT_AMSTEX },
+    { "ps$nfss", MP_OPT_PSNFSS },
+    { "psnfss-v$ersion7", MP_OPT_PSNFSS_V7 },
+    { "nops$nfss", MP_OPT_NOPSNFSS },
+    { "pro$logues", MP_OPT_PROLOGUES },
+    { "nopro$logues", MP_OPT_NOPROLOGUES },
+    { "ma$gnification", MP_OPT_MAGNIFICATION },
+    { "fo$nt", MP_OPT_FONT },
+    { NULL, MP_OPT_OTHER }
+};
+
+TERM_PUBLIC void
+MP_options()
+{
+    struct value a;
+
+    /* Annoying hack to handle the case of 'set termoption' after */
+    /* we have already initialized the terminal.                  */
+    if (c_token != 2) {
+	MP_color = FALSE;
+	MP_solid = FALSE;
+	MP_tex = MP_TEX;
+	MP_a4paper = 0;
+	MP_amstex  = 0;
+	MP_psnfss = MP_PSNFSS_NONE;
+	MP_fontsize = 10.0;
+	MP_textmag = 1.0;
+	MP_prologues = -1;
+	strcpy(MP_fontname, "cmr10");
+    }
+
+    while (!END_OF_COMMAND) {
+	int option = lookup_table(&MP_opts[0], c_token);
+	switch (option) {
+	case MP_OPT_MONOCHROME:
+	    MP_color = FALSE;
+	    c_token++;
+	    break;
+	case MP_OPT_COLOUR:
+	    MP_color = TRUE;
+	    c_token++;
+	    break;
+	case MP_OPT_SOLID:
+	    MP_solid = TRUE;
+	    c_token++;
+	    break;
+	case MP_OPT_DASHED:
+	    MP_solid = FALSE;
+	    c_token++;
+	    break;
+	case MP_OPT_NOTEX:
+	    MP_tex = MP_NO_TEX;
+	    strcpy(MP_fontname, "pcrr8r");
+	    c_token++;
+	    break;
+	case MP_OPT_TEX:
+	    MP_tex = MP_TEX;
+	    c_token++;
+	    break;
+	case MP_OPT_LATEX:
+	    MP_tex = MP_LATEX;
+	    c_token++;
+	    break;
+	case MP_OPT_AMSTEX:
+	    MP_tex = MP_LATEX; /* only makes sense when using LaTeX */
+	    MP_amstex = 1;
+	    c_token++;
+	    break;
+	case MP_OPT_A4PAPER:
+	    MP_tex = MP_LATEX; /* only makes sense when using LaTeX */
+	    MP_a4paper = 1;
+	    c_token++;
+	    break;
+	case MP_OPT_PSNFSS:
+	    MP_tex = MP_LATEX;    /* only makes sense when using LaTeX */
+	    MP_psnfss = MP_PSNFSS_8;
+	    c_token++;
+	    break;
+	case MP_OPT_PSNFSS_V7:
+	    MP_tex = MP_LATEX; /* only makes sense when using LaTeX */
+	    MP_psnfss = MP_PSNFSS_7;
+	    c_token++;
+	    break;
+	case MP_OPT_NOPSNFSS:
+	    MP_psnfss = MP_PSNFSS_NONE;
+	    c_token++;
+	    break;
+	case MP_OPT_PROLOGUES:
+	    c_token++;
+	    if (!(END_OF_COMMAND)) {
+		int dummy_for_prologues;
+
+		if (sscanf(gp_input_line + token[c_token].start_index,
+			   "%d", &dummy_for_prologues) == 1) {
+		    MP_prologues = dummy_for_prologues;
+		}
+		c_token++;
+	    }
+	    break;
+	case MP_OPT_NOPROLOGUES:
+	    MP_prologues = -1;
+	    c_token++;
+	    break;
+	case MP_OPT_MAGNIFICATION:
+	    c_token++;
+	    if (!END_OF_COMMAND)	/* global text scaling */
+		MP_textmag = (double) real(const_express(&a));
+	    /* c_token++; */ /* Needed ??? */
+	    break;
+	case MP_OPT_FONT:
+	    c_token++;
+	case MP_OPT_OTHER:
+	default:
+	{
+	    char *s;
+	    if ((s = try_to_get_string())) {
+		int sep = strcspn(s,",");
+		if (sep > 0) {
+		    strncpy(MP_fontname, s, sizeof(MP_fontname));
+		    MP_fontname[sep] = '\0';
+		}
+		if (s[sep] == ',')
+		    sscanf(&s[sep+1],"%lf",&MP_fontsize);
+		free(s);
+	    } else if (option == MP_OPT_FONT) {
+		int_error(c_token,"expecting font name");
+	    } else if (!END_OF_COMMAND) {	/*font size */
+		MP_fontsize = (double) real(const_express(&a));
+		c_token++;
+	    }
+	    break;
+	}
+
+	}
+    }
+
+    /* minimal error recovery: */
+    if (MP_fontsize < 5.0)
+	MP_fontsize = 5.0;
+    if (MP_fontsize > 99.99)
+	MP_fontsize = 99.99;
+
+    term->v_char = (unsigned int) (MP_DPI * MP_fontsize * MP_textmag * 11 / 720);
+    if (MP_tex == MP_NO_TEX) {	/* Courier is a little wider than cmtt */
+	term->h_char = (unsigned int) (MP_DPI * MP_fontsize * MP_textmag * 6.0 / 720 + 0.5);
+    } else {
+	term->h_char = (unsigned int) (MP_DPI * MP_fontsize * MP_textmag * 5.3 / 720 + 0.5);
+    }
+
+    if (MP_psnfss == MP_PSNFSS_NONE) { /* using the normal font scheme */
+      sprintf(term_options,
+	    "%s %s %stex%s%s mag %.3f font \"%s\" %.2f %sprologues(%d)",
+	    MP_color ? "color" : "monochrome",
+	    MP_solid ? "solid" : "dashed",
+	    (MP_tex == MP_NO_TEX) ? "no" : (MP_tex == MP_LATEX) ? "la" : "",
+	    MP_a4paper ? " a4paper" : "",
+	    MP_amstex ? " amstex" : "",
+	    MP_textmag,
+	    MP_fontname, MP_fontsize,
+	    (MP_prologues > -1) ? "" : "no", MP_prologues );
+    } else { /* using postscript fonts */
+      sprintf(term_options,
+	    "%s %s %stex%s%s mag %.3f %s %sprologues(%d)",
+	    MP_color ? "color" : "monochrome",
+	    MP_solid ? "solid" : "dashed",
+	    (MP_tex == MP_NO_TEX) ? "no" : (MP_tex == MP_LATEX) ? "la" : "",
+	    MP_a4paper ? " a4paper" : "",
+	    MP_amstex ? " amstex" : "",
+	    MP_textmag,
+	    (MP_psnfss == MP_PSNFSS_7) ? "psnsfss(v7)" : "psnsfss",
+	    (MP_prologues > -1) ? "" : "no", MP_prologues );
+    };
+}
+
+TERM_PUBLIC void
+MP_init()
+{
+    time_t now;
+    time(&now);
+    MP_posx = MP_posy = 0;
+    fprintf(gpoutfile, "%%GNUPLOT Metapost output: %s\n", asctime(localtime(&now)));
+    if (MP_prologues > -1) {
+	fprintf(gpoutfile, "prologues:=%d;\n", MP_prologues);
+    }
+    if (MP_tex == MP_LATEX) {
+	fputs("\n\
+%% Add \\documentclass and \\begin{dcoument} for latex\n\
+%% NB you should set the environment variable TEX to the name of your\n\
+%% latex executable (normally latex) inorder for metapost to work\n\
+%% or run\n\
+%% mpost --tex=latex ...\n\
+\n\
+% BEGPRE\n\
+verbatimtex\n", gpoutfile);
+	if (MP_a4paper) {
+	    fputs("\\documentclass[a4paper]{article}\n", gpoutfile);
+	} else {
+	    fputs("\\documentclass{article}\n", gpoutfile);
+	}
+	switch (MP_psnfss) {
+	case MP_PSNFSS_7:{
+		fputs("\\usepackage[latin1]{inputenc}\n\
+\\usepackage[T1]{fontenc}\n\
+\\usepackage{times,mathptmx}\n\
+\\usepackage{helvet}\n\
+\\usepackage{courier}\n", gpoutfile);
+	    }
+	    break;
+	case MP_PSNFSS_8:{
+		fputs("\\usepackage[latin1]{inputenc}\n\
+\\usepackage[T1]{fontenc}\n\
+\\usepackage{textcomp}\n\
+\\usepackage{mathptmx}\n\
+\\usepackage[scaled=.92]{helvet}\n\
+\\usepackage{courier}\n\
+\\usepackage{latexsym}\n", gpoutfile);
+	    }
+	    break;
+	}
+	if (MP_amstex) {
+	  fputs("\\usepackage[intlimits]{amsmath}\n\
+\\usepackage{amsfonts}\n", gpoutfile);
+          };
+	fputs("\\begin{document}\n\
+etex\n% ENDPRE\n", gpoutfile);
+    }
+
+    fputs("\n\
+warningcheck:=0;\n\
+defaultmpt:=mpt:=4;\n\
+th:=.6;\n\
+%% Have nice sharp joins on our lines\n\
+linecap:=butt;\n\
+linejoin:=mitered;\n\
+\n\
+def scalepen expr n = pickup pencircle scaled (n*th) enddef;\n\
+def ptsize expr n = mpt:=n*defaultmpt enddef;\n\
+\n", gpoutfile);
+
+    fprintf(gpoutfile, "\ntextmag:=%6.3f;\n", MP_textmag);
+
+    fputs("\
+vardef makepic(expr str) =\n\
+  if picture str : str scaled textmag\n\
+  % otherwise a string\n\
+  else: str infont defaultfont scaled (defaultscale*textmag)\n\
+  fi\n\
+enddef;\n\
+\n\
+def infontsize(expr str, size) =\n\
+  infont str scaled (size / fontsize str)\n\
+enddef;\n", gpoutfile);
+
+    if (MP_tex == MP_NO_TEX) {
+	fprintf(gpoutfile, "\n\
+defaultfont:= \"%s\";\n\
+defaultscale := %6.3f/fontsize defaultfont;\n", MP_fontname, MP_fontsize);
+    } else {
+	if (MP_tex != MP_LATEX) {
+	    fputs("\n\
+%font changes\n\
+verbatimtex\n\
+\\def\\setfont#1#2{%.\n\
+  \\font\\gpfont=#1 at #2pt\n\
+\\gpfont}\n", gpoutfile);
+	    fprintf(gpoutfile, "\\setfont{%s}{%5.2f}\netex\n",
+		    MP_fontname, MP_fontsize);
+	}
+    }
+    fputs("\n\
+color currentcolor; currentcolor:=black;\n\
+color fillcolor;\n\
+boolean colorlines,dashedlines;\n", gpoutfile);
+    if (MP_color) {
+	fputs("colorlines:=true;\n", gpoutfile);
+    } else {
+	fputs("colorlines:=false;\n", gpoutfile);
+    }
+    if (MP_solid) {
+	fputs("dashedlines:=false;\n", gpoutfile);
+    } else {
+	fputs("dashedlines:=true;\n", gpoutfile);
+    }
+    fputs("\n\
+def _wc = withpen currentpen withcolor currentcolor enddef;\n\
+def _ac = addto currentpicture enddef;\n\
+def _sms = scaled mpt shifted enddef;\n\
+% drawing point-types\n\
+def gpdraw (expr n, x, y) =\n\
+  if n<0: _ac contour fullcircle _sms (x,y)\n\
+  elseif (n=1) or (n=3):\n\
+    _ac doublepath ptpath[n] _sms (x,y) _wc;\n\
+    _ac doublepath ptpath[n] rotated 90 _sms (x,y) _wc\n\
+  elseif n<6: _ac doublepath ptpath[n] _sms (x,y) _wc\n\
+  else: _ac contour ptpath[n] _sms (x,y) _wc\n\
+  fi\n\
+enddef;\n\
+\n\
+% the point shapes\n\
+path ptpath[];\n\
+%diamond\n\
+ptpath0 = ptpath6 = (-1/2,0)--(0,-1/2)--(1/2,0)--(0,1/2)--cycle;\n\
+% plus sign\n\
+ptpath1 = (-1/2,0)--(1/2,0);\n\
+% square\n\
+ptpath2 = ptpath7 = (-1/2,-1/2)--(1/2,-1/2)--(1/2,1/2)--(-1/2,1/2)--cycle;\n\
+% cross\n\
+ptpath3 := (-1/2,-1/2)--(1/2,1/2);\n\
+% circle:\n\
+ptpath4 = ptpath8:= fullcircle;\n\
+% triangle\n\
+ptpath5 = ptpath9 := (0,1/2)--(-1/2,-1/2)--(1/2,-1/2)--cycle;\n\
+\n\
+def linetype expr n =\n\
+  currentcolor:= if colorlines : col[n] else: black fi;\n\
+  if n = -1 :\n\
+      drawoptions(withcolor currentcolor withpen (currentpen scaled .5));\n\
+  elseif n < 1 :\n\
+    drawoptions(_wc);\n\
+  else :\n\
+    drawoptions( if dashedlines: dashed lt[n] fi _wc);\n\
+  fi\n\
+enddef;\n\
+\n\
+% dash patterns\n\
+picture lt[];\n\
+lt1=dashpattern(on 2 off 2); % dashes\n\
+lt2=dashpattern(on 2 off 2 on 0.2 off 2); %dash-dot\n\
+lt3=lt1 scaled 1.414;\n\
+lt4=lt2 scaled 1.414;\n\
+lt5=lt1 scaled 2;\n\
+lt6:=lt2 scaled 2;\n\
+lt7=dashpattern(on 0.2 off 2); %dots\n\
+\n\
+color col[],cyan, magenta, yellow;\n\
+cyan=blue+green; magenta=red+blue;yellow=green+red;\n\
+col[-2]:=col[-1]:=col0:=black;\n\
+col1:=red;\n\
+col2:=(.2,.2,1); %blue\n\
+col3:=(1,.66,0); %orange\n\
+col4:=.85*green;\n\
+col5:=.9*magenta;\n\
+col6:=0.85*cyan;\n\
+col7:=.85*yellow;\n\
+\n\
+%placing text\n\
+picture GPtext;\n\
+def put_text(expr pic, x, y, r, j) =\n\
+  GPtext:=makepic(pic);\n\
+  GPtext:=GPtext shifted\n\
+    if j = 1: (-(ulcorner GPtext + llcorner GPtext)/2)\n\
+    elseif j = 2: (-center GPtext)\n\
+    else: (-(urcorner GPtext + lrcorner GPtext)/2)\n\
+    fi\n\
+    rotated r;\n\
+  draw GPtext shifted (x,y)\n\
+enddef;\n", gpoutfile);
+}
+
+TERM_PUBLIC void
+MP_graphics()
+{
+    /* initialize "remembered" drawing parameters */
+    MP_oldline = -2;
+    MP_oldpen = 1.0;
+    MP_oldptsize = pointsize;
+    fprintf(gpoutfile, "\nbeginfig(%d);\nw:=%.3fin;h:=%.3fin;\n",
+	    MP_char_code, MP_xsize, MP_ysize);
+    /* MetaPost can only handle numbers up to 4096. When MP_DPI
+     * is larger than 819, this is exceeded by (term->xmax). So we
+     * scale it and all coordinates down by factor of 10.0. And
+     * compensate by scaling a and b up.
+     */
+    fprintf(gpoutfile, "a:=w/%.1f;b:=h/%.1f;\n",
+	    (term->xmax) / 10.0, (term->ymax) / 10.0);
+    fprintf(gpoutfile, "scalepen 1; ptsize %.3f;linetype -2;\n", pointsize);
+    MP_char_code++;
+    /* reset MP_color_changed */
+    MP_color_changed = 0;
+}
+
+TERM_PUBLIC void
+MP_text()
+{
+    if (MP_inline)
+	MP_endline();
+    fputs("endfig;\n", gpoutfile);
+}
+
+TERM_PUBLIC void
+MP_linetype(int lt)
+{
+    int linetype = lt;
+
+    if (linetype >= MP_LINE_TYPES)
+	linetype %= MP_LINE_TYPES;
+    if (MP_inline)
+	MP_endline();
+    /* reset the color in case it has been changed in MP_set_color() */
+    if (MP_color_changed) {
+	MP_oldline = linetype + 1;
+	MP_color_changed = 0;
+    }
+    if (MP_oldline != linetype) {
+	fprintf(gpoutfile, "linetype %d;\n", linetype);
+	MP_oldline = linetype;
+    }
+}
+
+TERM_PUBLIC void
+MP_move(unsigned int x, unsigned int y)
+{
+    if ((x != MP_posx) || (y != MP_posy)) {
+	if (MP_inline)
+	    MP_endline();
+	MP_posx = x;
+	MP_posy = y;
+    }				/* else we seem to be there already */
+}
+
+TERM_PUBLIC void
+MP_point(unsigned int x, unsigned int y, int pt)
+{
+    int pointtype = pt;
+    if (MP_inline)
+	MP_endline();
+
+    /* Print the shape defined by 'number'; number < 0 means
+       to use a dot, otherwise one of the defined points. */
+
+    if (pointtype >= MP_POINT_TYPES)
+	pointtype %= MP_POINT_TYPES;
+/* Change %d to %f, divide x,y by 10 */
+    fprintf(gpoutfile, "gpdraw(%d,%.1fa,%.1fb);\n", pointtype, x / 10.0, y / 10.0);
+}
+
+TERM_PUBLIC void
+MP_pointsize(double ps)
+{
+    if (ps < 0)
+	ps = 1;
+    if (MP_oldptsize != ps) {
+	if (MP_inline)
+	    MP_endline();
+	fprintf(gpoutfile, "ptsize %.3f;\n", ps);
+	MP_oldptsize = ps;
+    }
+}
+
+
+TERM_PUBLIC void
+MP_linewidth(double lw)
+{
+    if (MP_oldpen != lw) {
+	if (MP_inline)
+	    MP_endline();
+	fprintf(gpoutfile, "scalepen %.3f;\n", lw);
+	MP_oldpen = lw;
+    }
+}
+
+
+TERM_PUBLIC void
+MP_vector(unsigned int ux, unsigned int uy)
+{
+    if ((ux == MP_posx) && (uy == MP_posy))
+	return;			/* Zero length line */
+
+    if (MP_inline) {
+	if (MP_linecount++ >= MP_LINEMAX) {
+	    fputs("\n", gpoutfile);
+	    MP_linecount = 1;
+	}
+    } else {
+	MP_inline = TRUE;
+	fprintf(gpoutfile, "draw (%.1fa,%.1fb)", MP_posx / 10.0, MP_posy / 10.0);
+	MP_linecount = 2;
+    }
+    MP_posx = ux;
+    MP_posy = uy;
+    fprintf(gpoutfile, "--(%.1fa,%.1fb)", MP_posx / 10.0, MP_posy / 10.0);
+}
+
+static void
+MP_endline()
+{
+    MP_inline = FALSE;
+    fprintf(gpoutfile, ";\n");
+}
+
+TERM_PUBLIC void
+MP_arrow(unsigned int sx, unsigned int sy, unsigned int ex, unsigned int ey, int head)
+{
+    MP_move(sx, sy);
+    if (head) {
+	fprintf(gpoutfile, "%s (%.1fa,%.1fb)--(%.1fa,%.1fb);\n",
+		head == 1 ? "drawarrow" : "drawdblarrow",
+		sx / 10.0, sy / 10.0, ex / 10.0, ey / 10.0);
+    } else if ((sx != ex) || (sy != ey)) {
+	fprintf(gpoutfile, "draw (%.1fa,%.1fb)--(%.1fa,%.1fb);\n",
+		sx / 10.0, sy / 10.0, ex / 10.0, ey / 10.0);
+    }	/* else: arrow with no length and no head = sound of one hand clapping? */
+    MP_posx = ex;
+    MP_posy = ey;
+
+}
+
+TERM_PUBLIC void
+MP_put_text(unsigned int x, unsigned int y, const char str[])
+{
+    int i, j = 0;
+    char *text;
+
+    /* ignore empty strings */
+    if (!str || !*str)
+	return;
+
+    /* F***. why do drivers need to modify string args? */
+    text = gp_strdup(str);
+
+    if (MP_inline)
+	MP_endline();
+
+
+    switch (MP_justify) {
+    case LEFT:
+	j = 1;
+	break;
+    case CENTRE:
+	j = 2;
+	break;
+    case RIGHT:
+	j = 3;
+	break;
+    }
+    if (MP_tex == MP_NO_TEX) {
+	for (i = 0; i < strlen(text); i++)
+	    if (text[i] == '"')
+		text[i] = '\'';	/* Replace " with ' */
+	if (MP_fontchanged) {
+	    fprintf(gpoutfile, "\
+put_text(\"%s\" infontsize(\"%s\",%5.2f), %.1fa, %.1fb, %d, %d);\n",
+		    text, MP_fontname, MP_fontsize,
+		    x / 10.0, y / 10.0, MP_ang, j);
+	} else {
+	    fprintf(gpoutfile, "put_text(\"%s\", %.1fa, %.1fb, %d, %d);\n",
+		    text, x / 10.0, y / 10.0, MP_ang, j);
+	}
+    } else if (MP_fontchanged) {
+	if (MP_tex != MP_LATEX) {
+	    fprintf(gpoutfile, "\
+put_text( btex \\setfont{%s}{%5.2f} %s etex, %.1fa, %.1fb, %d, %d);\n",
+		    MP_fontname, MP_fontsize, text,
+		    x / 10.0, y / 10.0, MP_ang, j);
+	} else {
+	    fprintf(gpoutfile, "put_text( btex %s etex, %.1fa, %.1fb, %d, %d);\n",
+		    text, x / 10.0, y / 10.0, MP_ang, j);
+	}
+    } else {
+	fprintf(gpoutfile, "put_text( btex %s etex, %.1fa, %.1fb, %d, %d);\n",
+		text, x / 10.0, y / 10.0, MP_ang, j);
+    }
+
+    free(text);
+}
+
+TERM_PUBLIC int
+MP_justify_text(enum JUSTIFY mode)
+{
+    MP_justify = mode;
+    return (TRUE);
+}
+
+TERM_PUBLIC int
+MP_text_angle(int ang)
+{
+    /* Metapost code does the conversion */
+    MP_ang = ang;
+    return (TRUE);
+}
+
+TERM_PUBLIC int
+MP_set_font(const char *font)
+{
+    if (*font) {
+	size_t sep = strcspn(font, ",");
+	if (sep < sizeof(MP_fontname))
+	    strncpy(MP_fontname, font, sizeof(MP_fontname));
+	sscanf(&(font[sep + 1]), "%lf", &MP_fontsize);
+	if (MP_fontsize < 5)
+	    MP_fontsize = 5.0;
+	if (MP_fontsize >= 100)
+	    MP_fontsize = 99.99;
+	/*  */
+	MP_fontchanged = TRUE;
+    } else {
+	MP_fontchanged = FALSE;
+    }
+    return TRUE;
+}
+
+
+TERM_PUBLIC void
+MP_reset()
+{
+    if (MP_tex == MP_LATEX) {
+	fputs("% BEGPOST\n",gpoutfile);
+	fputs("verbatimtex\n",gpoutfile);
+	fputs(" \\end{document}\n",gpoutfile);
+	fputs("etex\n",gpoutfile);
+	fputs("% ENDPOST\n",gpoutfile);
+    };
+    fputs("end.\n", gpoutfile);
+}
+
+TERM_PUBLIC void
+MP_boxfill(
+    int style,
+    unsigned int x1, unsigned int y1,
+    unsigned int wd, unsigned int ht)
+{
+
+    /* fillpar:
+     * - solid   : 0 - 100% intensity
+     * - pattern : 0 - n    pattern number
+     */
+    int fillpar = style >> 4;
+    style &= 0xf;
+
+    if (MP_inline)
+	MP_endline();
+
+    switch (style) {
+
+	case FS_EMPTY: /* fill with background color */
+	    fprintf(gpoutfile, "\
+fill (%.1fa,%.1fb)--(%.1fa,%.1fb)--(%.1fa,%.1fb)--(%.1fa,%.1fb)--cycle withcolor background;\n",
+		x1 / 10.0, y1 / 10.0, (x1 + wd) / 10.0, y1 / 10.0,
+		(x1 + wd) / 10.0, (y1 + ht) / 10.0, x1 / 10.0,
+		(y1 + ht) / 10.0);
+	    break;
+
+	case FS_PATTERN: /* pattern fill */
+	case FS_TRANSPARENT_PATTERN:
+	    /* FIXME: not yet implemented, dummy it up as fill density */
+	    fillpar *= 12;
+
+	default:
+	case FS_SOLID: /* solid fill */
+	case FS_TRANSPARENT_SOLID:
+	    if (fillpar < 100) {
+		double density = (100-fillpar) * 0.01;
+		fprintf(gpoutfile,"fillcolor:=currentcolor*%.2f+background*%.2f;\n",
+		    1.0-density, density);
+		MP_color_changed = 1;
+	    } else
+		fprintf(gpoutfile,"fillcolor:=currentcolor;\n");
+	    fprintf(gpoutfile, "\
+fill (%.1fa,%.1fb)--(%.1fa,%.1fb)--(%.1fa,%.1fb)--(%.1fa,%.1fb)--cycle withpen (pencircle scaled 0pt) withcolor fillcolor;\n",
+	    x1 / 10.0, y1 / 10.0, (x1 + wd) / 10.0, y1 / 10.0,
+	    (x1 + wd) / 10.0, (y1 + ht) / 10.0, x1 / 10.0,
+	    (y1 + ht) / 10.0);
+	    break;
+
+    }
+
+}
+
+TERM_PUBLIC int
+MP_make_palette(t_sm_palette *palette)
+{
+    /* metapost can do continuous number of colours */
+    return 0;
+}
+
+
+TERM_PUBLIC void
+MP_set_color(t_colorspec *colorspec)
+{
+    double gray = colorspec->value;
+    rgb_color color;
+
+    /* remeber that we changed the color, needed to reset color in MP_linetype()*/
+    MP_color_changed = 1;
+
+    if (MP_inline)
+	MP_endline();
+
+    if (!MP_color) {		/* gray mode */
+	if (gray < 1e-3) gray = 0;
+	fprintf(gpoutfile, "currentcolor:=%.3gwhite;\n", gray);
+    } else {			/* color mode */
+	if (colorspec->type == TC_LT) {
+	    int linecolor = colorspec->lt;
+	    if (linecolor >= MP_LINE_TYPES)
+		linecolor %= MP_LINE_TYPES;
+	    if (linecolor == -1)
+		fprintf(gpoutfile, "currentcolor:=black;\n");
+	    else if (linecolor >= 0)
+		fprintf(gpoutfile, "currentcolor:=col%d;\n",linecolor);
+	}
+	if (colorspec->type == TC_FRAC) {
+	    if (sm_palette.colors != 0) /* finite nb of colors explicitly requested */
+		gray = (gray >= ((double)(sm_palette.colors-1)) / sm_palette.colors) ?
+		    1 : floor(gray * sm_palette.colors) / sm_palette.colors;
+	    rgb1_from_gray( gray, &color );
+	} else if (colorspec->type == TC_RGB) {
+	    color.r = (double)((colorspec->lt >> 16 ) & 255) / 255.;
+	    color.g = (double)((colorspec->lt >> 8 ) & 255) / 255.;
+	    color.b = (double)(colorspec->lt & 255) / 255.;
+	} else
+	    return;
+
+	if (color.r < 1e-4) color.r = 0;
+	if (color.g < 1e-4) color.g = 0;
+	if (color.b < 1e-4) color.b = 0;
+	fprintf(gpoutfile, "currentcolor:=%.4g*red+%.4g*green+%.4g*blue;\n",
+		color.r, color.g, color.b);
+    }
+    return;
+}
+
+TERM_PUBLIC void
+MP_filled_polygon(int points, gpiPoint *corners)
+{
+    int i;
+    int fillpar = corners->style >> 4;
+    int style = corners->style & 0xf;
+
+    if (MP_inline)
+	MP_endline();
+
+    switch (style) {
+	case FS_EMPTY:	/* fill with background color */
+		fprintf(gpoutfile,"fillcolor:=background;\n");
+		break;
+	case FS_PATTERN: /* pattern fill implemented as partial density */
+	case FS_TRANSPARENT_PATTERN:
+		fillpar *= 12;
+	case FS_SOLID:	/* solid fill */
+	case FS_TRANSPARENT_SOLID:
+		if (fillpar < 100) {
+		    double density = (100-fillpar) * 0.01;
+		    fprintf(gpoutfile,"fillcolor:=currentcolor*%.2f+background*%.2f;\n",
+		        1.0-density, density);
+		} else {
+		    fprintf(gpoutfile,"fillcolor:=currentcolor;\n");
+		}
+	default:
+		break;
+    }
+
+    fprintf(gpoutfile, "fill ");
+    for (i = 0; i < points; i++)
+	fprintf(gpoutfile, "(%.1fa,%.1fb)%s",
+		corners[i].x / 10.0, corners[i].y / 10.0,
+		(i < points - 1 && (i + 1) % MP_LINEMAX == 0) ? "\n--" : "--");
+    fprintf(gpoutfile, "cycle withcolor fillcolor;\n");
+}
+
+TERM_PUBLIC void
+MP_previous_palette()
+{
+    return;
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(mp_driver)
+    "mp", "MetaPost plotting standard",
+    MP_XMAX, MP_YMAX, MP_VCHAR, MP_HCHAR,
+    MP_VTIC, MP_HTIC, MP_options, MP_init, MP_reset,
+    MP_text, null_scale, MP_graphics, MP_move, MP_vector,
+    MP_linetype, MP_put_text, MP_text_angle,
+    MP_justify_text, MP_point, MP_arrow, MP_set_font, MP_pointsize,
+    TERM_BINARY|TERM_CAN_CLIP|TERM_CAN_DASH,	/*flags*/ 
+    0, 0, MP_boxfill, MP_linewidth
+#ifdef USE_MOUSE
+    , 0, 0, 0, 0, 0		/* no mouse support for metapost */
+#endif
+    , MP_make_palette,
+    MP_previous_palette,	/* write grestore */
+    MP_set_color,
+    MP_filled_polygon
+TERM_TABLE_END(mp_driver)
+#undef LAST_TERM
+#define LAST_TERM mp_driver
+
+#endif				/* TERM_TABLE */
+#endif				/* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(mp)
+"1 mp",
+"?commands set terminal mpost",
+"?set terminal mp",
+"?set term mp",
+"?terminal mp",
+"?term mp",
+"?mp",
+"?metapost",
+"",
+" The `mp` driver produces output intended to be input to the Metapost program.",
+" Running Metapost on the file creates EPS files containing the plots. By",
+" default, Metapost passes all text through TeX.  This has the advantage of",
+" allowing essentially  any TeX symbols in titles and labels.",
+"",
+" Syntax:",
+"    set term mp {color | colour | monochrome}",
+"                {solid | dashed}",
+"                {notex | tex | latex}",
+"                {magnification <magsize>}",
+"                {psnfss | psnfss-version7 | nopsnfss}",
+"                {prologues <value>}",
+"                {a4paper}",
+"                {amstex}",
+"                {\"<fontname>\"} {<fontsize>}",
+"",
+" The option `color` causes lines to be drawn in color (on a printer or display",
+" that supports it), `monochrome` (or nothing) selects black lines.  The option",
+" `solid` draws solid lines, while `dashed` (or nothing) selects lines with",
+" different patterns of dashes.  If `solid` is selected but `color` is not,",
+" nearly all lines will be identical.  This may occasionally be useful, so it is",
+" allowed.",
+"",
+" The option `notex` bypasses TeX entirely, therefore no TeX code can be used in",
+" labels under this option.  This is intended for use on old plot files or files",
+" that make frequent use of common characters like `$` and `%` that require",
+" special handling in TeX.",
+"",
+" The option `tex` sets the terminal to output its text for TeX to process.",
+"",
+" The option `latex` sets the terminal to output its text for processing by",
+" LaTeX. This allows things like \\frac for fractions which LaTeX knows about",
+" but TeX does not.  Note that you must set the environment variable TEX to the",
+" name of your LaTeX executable (normally latex) if you use this option or use",
+" `mpost --tex=<name of LaTeX executable> ...`. Otherwise metapost will try and",
+" use TeX to process the text and it won't work.",
+"",
+" Changing font sizes in TeX has no effect on the size of mathematics, and there",
+" is no foolproof way to make such a change, except by globally  setting a",
+" magnification factor. This is the purpose of the `magnification` option. It",
+" must be followed by a scaling factor. All text (NOT the graphs) will be scaled",
+" by this factor. Use this if you have math that you want at some size other",
+" than the default 10pt. Unfortunately, all math will be the same size, but see",
+" the discussion below on editing the MP output. `mag` will also work under",
+" `notex` but there seems no point in using it as the font size option (below)",
+" works as well.",
+"",
+" The option `psnfss` uses postscript fonts in combination with LaTeX. Since",
+" this option only makes sense, if LaTeX is being used, the `latex` option is selected",
+" automatically. This option includes the following packages for LaTeX:",
+" inputenc(latin1), fontenc(T1), mathptmx, helvet(scaled=09.2), courier, latexsym ",
+" and textcomp.",
+"",
+" The option `psnfss-version7` uses also postscript fonts in LaTeX (option `latex`",
+" is also automatically selected), but uses the following packages with LaTeX:",
+" inputenc(latin1), fontenc(T1), times, mathptmx, helvet and courier.",
+"",
+" The option `nopsnfss` is the default and uses the standard font (cmr10 if not",
+" otherwise specified).",
+"",
+" The option `prologues` takes a value as an additional argument and adds the line",
+" `prologues:=<value>` to the metapost file. If a value of `2` is specified metapost",
+" uses postscript fonts to generate the eps-file, so that the result can be viewed",
+" using e.g. ghostscript. Normally the output of metapost uses TeX fonts and therefore",
+" has to be included in a (La)TeX file before you can look at it.",
+"",
+" The option `noprologues` is the default. No additional line specifying the prologue",
+" will be added.",
+"",
+" The option `a4paper` adds a `[a4paper]` to the documentclass. Normally letter paper",
+" is used (default). Since this option is only used in case of LaTeX, the `latex` option",
+" is selected automatically.",
+"",
+" The option `amstex` automatically selects the `latex` option and includes the following",
+" LaTeX packages: amsfonts, amsmath(intlimits). By default these packages are not",
+" included.",
+"",
+" A name in quotes selects the font that will be used when no explicit font is",
+" given in a `set label` or `set title`.  A name recognized by TeX (a TFM file",
+" exists) must be used.  The default is \"cmr10\" unless `notex` is selected,",
+" then it is \"pcrr8r\" (Courier).  Even under `notex`, a TFM file is needed by",
+" Metapost. The file `pcrr8r.tfm` is the name given to Courier in LaTeX's psnfss",
+" package.  If you change the font from the `notex` default, choose a font that",
+" matches the ASCII encoding at least in the range 32-126.  `cmtt10` almost",
+" works, but it has a nonblank character in position 32 (space).",
+"",
+" The size can be any number between 5.0 and 99.99.  If it is omitted, 10.0 is",
+" used.  It is advisable to use `magstep` sizes: 10 times an integer or",
+" half-integer power of 1.2, rounded to two decimals, because those are the most",
+" available sizes of fonts in TeX systems.",
+"",
+" All the options are optional.  If font information is given, it must be at the",
+" end, with size (if present) last.  The size is needed to select a size for the",
+" font, even if the font name includes size information.  For example,",
+" `set term mp \"cmtt12\"` selects cmtt12 shrunk to the default size 10.  This",
+" is probably not what you want or you would have used cmtt10.",
+"",
+" The following common ascii characters need special treatment in TeX:",
+"    $, &, #, %, _;  |, <, >;  ^, ~,  \\, {, and }",
+" The five characters $, #, &, _, and % can simply be escaped, e.g., `\\$`.",
+" The three characters <, >, and | can be wrapped in math mode, e.g., `$<$`.",
+" The remainder require some TeX work-arounds.  Any good book on TeX will give",
+" some guidance.",
+"",
+" If you type your labels inside double quotes, backslashes in TeX code need to",
+" be escaped (doubled). Using single quotes will avoid having to do this, but",
+" then you cannot use `\\n` for line breaks.  As of this writing, version 3.7 of",
+" gnuplot processes titles given in a `plot` command differently than in other",
+" places, and backslashes in TeX commands need to be doubled regardless of the",
+" style of quotes.",
+"",
+" Metapost pictures are typically used in TeX documents.  Metapost deals with",
+" fonts pretty much the same way TeX does, which is different from most other",
+" document preparation programs.  If the picture is included in a LaTeX document",
+" using the graphics package, or in a plainTeX document via epsf.tex, and then",
+" converted to PostScript with dvips (or other dvi-to-ps converter), the text in",
+" the plot will usually be handled correctly.  However, the text may not appear",
+" if you send the Metapost output as-is to a PostScript interpreter.",
+"",
+"2 Metapost Instructions",
+"?commands set terminal mp detailed",
+"?set terminal mp detailed",
+"?set term mp detailed",
+"?mp detailed",
+"?metapost detailed",
+"",
+" - Set your terminal to Metapost, e.g.:",
+"    set terminal mp mono \"cmtt12\" 12",
+"",
+" - Select an output-file, e.g.:",
+"    set output \"figure.mp\"",
+"",
+" - Create your pictures.  Each plot (or multiplot group) will generate a",
+" separate Metapost beginfig...endfig group.  Its default size will be 5 by 3",
+" inches.  You can change the size by saying `set size 0.5,0.5` or whatever",
+" fraction of the default size you want to have.",
+"",
+" - Quit gnuplot.",
+"",
+" - Generate EPS files by running Metapost on the output of gnuplot:",
+"    mpost figure.mp  OR  mp figure.mp",
+" The name of the Metapost program depends on the system, typically `mpost` for",
+" a Unix machine and `mp` on many others.  Metapost will generate one EPS file",
+" for each picture.",
+"",
+" - To include your pictures in your document you can use the graphics package",
+" in LaTeX or epsf.tex in plainTeX:",
+"    \\usepackage{graphics} % LaTeX",
+"    \\input epsf.tex       % plainTeX",
+" If you use a driver other than dvips for converting TeX DVI output to PS, you",
+" may need to add the following line in your LaTeX document:",
+"    \\DeclareGraphicsRule{*}{eps}{*}{}",
+" Each picture you made is in a separate file.  The first picture is in, e.g.,",
+" figure.0, the second in figure.1, and so on....  To place the third picture in",
+" your document, for example, all you have to do is:",
+"    \\includegraphics{figure.2} % LaTeX",
+"    \\epsfbox{figure.2}         % plainTeX",
+"",
+" The advantage, if any, of the mp terminal over a postscript terminal is",
+" editable output.  Considerable effort went into making this output as clean as",
+" possible.  For those knowledgeable in the Metapost language, the default line",
+" types and colors can be changed by editing the arrays `lt[]` and `col[]`.",
+" The choice of solid vs dashed lines, and color vs black lines can be change by",
+" changing the values assigned to the booleans `dashedlines` and `colorlines`.",
+" If the default `tex` option was in effect, global changes to the text of",
+" labels can be achieved by editing the `vebatimtex...etex` block.  In",
+" particular, a LaTeX preamble can be added if desired, and then LaTeX's",
+" built-in size changing commands can be used for maximum flexibility. Be sure",
+" to set the appropriate MP configuration variable to force Metapost to run",
+" LaTeX instead of plainTeX."
+END_HELP(mp)
+#endif				/* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/mgr.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/mgr.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/mgr.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/mgr.trm.svn-base	2012-01-03 17:07:40.519055300 -0800
@@ -0,0 +1,244 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: mgr.trm,v 1.11 2006/07/21 02:35:47 sfeam Exp $
+ */
+
+/* GNUPLOT - mgr.trm */
+
+/*[
+ * Copyright 1986 - 1993, 1998, 2004   Thomas Williams, Colin Kelley
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *  Mgr window system, color display
+ *
+ * AUTHOR
+ *  Vincent Broman, broman@nosc.mil
+ */
+/*
+ * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(mgr)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void MGR_init __PROTO((void));
+TERM_PUBLIC void MGR_graphics __PROTO((void));
+TERM_PUBLIC void MGR_text __PROTO((void));
+TERM_PUBLIC void MGR_linetype __PROTO((int linetype));
+TERM_PUBLIC void MGR_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void MGR_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void MGR_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC void MGR_reset __PROTO((void));
+#define MGR_XMAX 640
+#define MGR_YMAX 400
+#define MGR_VCHAR 16
+#define MGR_HCHAR 8
+#define MGR_VTIC 4
+#define MGR_HTIC 4
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+#undef ESC
+#include <term.h>		/* from Mgr, not gnuplot */
+
+
+
+static int MGR_border = 5;
+static int MGR_winnbr = 0;
+
+static int MGR_rowcount = 24;
+static int MGR_winwidth = MGR_XMAX;
+static int MGR_winheight = MGR_YMAX;
+static int MGR_vchar = MGR_VCHAR;
+static int MGR_hchar = MGR_HCHAR;
+
+
+TERM_PUBLIC void
+MGR_init()
+{
+    char res[300];
+    int winnbr;
+    int w, h, bor;
+
+    m_setup(0);
+    m_ttyset();
+
+    m_getinfo(G_SYSTEM);
+    if (m_gets(res) && sscanf(res, "%*s%d%d%d", &w, &h, &bor) == 3)
+	MGR_border = bor;
+
+    m_newwin(0, 0, MGR_winwidth + 2 * MGR_border,
+	     MGR_winheight + 2 * MGR_border);
+
+    if (m_gets(res) && sscanf(res, "%d", &winnbr) == 1)
+	MGR_winnbr = winnbr;
+
+    /* if no alt window is created, then the main window is used
+     * and if size is different, term_tbl updated later */
+    m_selectwin(MGR_winnbr);
+    m_setmode(M_ABS);
+
+    m_getinfo(G_FONT);
+    if (m_gets(res) && sscanf(res, "%d %d", &w, &h) == 2) {
+	MGR_vchar = h;
+	MGR_hchar = w;
+    }
+    m_ttyreset();
+
+    term->v_char = MGR_vchar;
+    term->h_char = MGR_hchar;
+    term->v_tic = MGR_vchar / 4;
+    term->h_tic = MGR_hchar / 2;
+
+    m_selectwin(0);
+    m_flush();
+}
+
+
+TERM_PUBLIC void
+MGR_graphics()
+{
+    char res[32];
+    int c, r, w, h;
+
+    m_selectwin(MGR_winnbr);
+    m_setmode(M_ACTIVATE);
+    m_clear();
+
+    /* we permit the user to reshape the window arbitrarily.
+       do_plot calls boundary to recheck the term_tbl for each plot */
+    m_ttyset();
+    m_getinfo(G_WINSIZE);
+    if (m_gets(res) && sscanf(res, "%d %d", &c, &r) == 2)
+	MGR_rowcount = r;
+    m_getinfo(G_COORDS);
+    if (m_gets(res) && sscanf(res, "%d %d %d %d", &c, &r, &w, &h) == 4) {
+	term->xmax = MGR_winwidth = w;
+	term->ymax = MGR_winheight = h;
+    }
+    m_ttyreset();
+    m_flush();
+}
+
+
+TERM_PUBLIC void
+MGR_text()
+{
+    m_go(0, 0);
+    m_aligntext();
+    if (MGR_winnbr == 0)
+	m_move(0, MGR_rowcount - 1);
+    m_selectwin(0);
+    m_flush();
+}
+
+
+TERM_PUBLIC void
+MGR_linetype(int linetype)
+{
+/*
+ * this mapping of colors is intended for a color sun on which
+ * colors 0-23 are defined, 0 is white, 1 is black.
+ */
+    m_linecolor(B_SRC, (linetype < 0) ? 1 : (2 + (linetype % 22)));
+}
+
+
+TERM_PUBLIC void
+MGR_move(unsigned int x, unsigned int y)
+{
+    m_go(x, MGR_winheight - 1 - y);
+}
+
+
+TERM_PUBLIC void
+MGR_vector(unsigned int x, unsigned int y)
+{
+    m_draw(x, MGR_winheight - 1 - y);
+}
+
+
+TERM_PUBLIC void
+MGR_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    MGR_move(x, y - MGR_vchar / 2);
+    m_aligntext();
+    m_printstr(str);
+}
+
+
+TERM_PUBLIC void
+MGR_reset()
+{
+    m_destroywin(MGR_winnbr);
+    MGR_winnbr = 0;
+    m_setmode(M_ACTIVATE);
+    m_flush();
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(mgr_driver)
+    "mgr", "Mgr window system",
+    /* dimensions nominal, replaced during MGR_graphics call */
+    MGR_XMAX, MGR_YMAX, MGR_VCHAR, MGR_HCHAR,
+    MGR_VTIC, MGR_HTIC, options_null, MGR_init, MGR_reset,
+    MGR_text, null_scale, MGR_graphics, MGR_move, MGR_vector,
+    MGR_linetype, MGR_put_text, null_text_angle,
+    null_justify_text, do_point, do_arrow, set_font_null
+TERM_TABLE_END(mgr_driver)
+
+#undef LAST_TERM
+#define LAST_TERM mgr_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(mgr)
+"1 mgr",
+"?commands set terminal mgr",
+"?set terminal mgr",
+"?set term mgr",
+"?terminal mgr",
+"?term mgr",
+"?mgr",
+" The `mgr` terminal driver supports the Mgr Window system.  It has no options."
+END_HELP(mgr)
+#endif
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/mif.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/mif.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/mif.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/mif.trm.svn-base	2012-01-03 17:07:40.695512900 -0800
@@ -0,0 +1,1000 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: mif.trm,v 1.33 2006/07/21 02:35:47 sfeam Exp $
+ */
+
+/* GNUPLOT -- mif.trm */
+
+/*[
+ * Copyright 1992, 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver was developed for
+ *      gnuplot for unix version 3.0 (patchlevel 1)
+ *      gnuplot for unix version 3.2 (patchlevel 2)
+ *
+ * This terminal driver supports:
+ *      Frame Maker MIF format version 3.00
+ *
+ * Options for this terminal driver (set terminal mif [options]):
+ *      colour /        Draw primitives with line types >= 0 in colour (sep. 2-7)
+ *      monochrome      Draw primitives in black (sep. 0)
+ *
+ *      polyline /      Draw lines as continuous curves
+ *      vectors         Draw lines as collections of vectors
+ *
+ *      help / ?        Print short usage description on stderr
+ *
+ * Properties for this terminal driver:
+ *     -Gnuplot size of worksheet:              MIF_XMAX * MIF_YMAX
+ *     -Unit in MIF output:                     cm
+ *     -Plot primitives with the same pen will
+ *      be grouped in the same MIF group.
+ *     -Plot primitives with line types >= 0
+ *      will as default be drawn in colour.
+ *     -Lines are plotted as collections of
+ *      vectors, or as continuous lines (default)
+ *     -Plot primitives in a plot will be in a
+ *      Frame in MIF. Several plot Frames will
+ *      be collected in one large Frame.
+ *     -Point size of MIF output characters:    MIF_PSIZE
+ *     -Used font for MIF output characters:    Times
+ *     -Supports vertical text
+ *     -points and dots as characters
+ *     -character formats for TextLines
+ *
+ * AUTHORS:
+ *      Olof Franksson, Physics IV, KTH, S-100 44 Stockholm, Sweden
+ *
+ * NEW TERMINAL FORMAT:  David C. Schooley
+
+ * COMMENTS:
+ *      Send comments and/or suggestions to olof@fysik4.kth.se
+ *
+ * CHANGES:
+ *	Changed to new terminal format 9/29/95		schooley@ee.gatech.edu
+ *      Changed order of routine declarations.          olof@fysik4.kth.se
+ *      Changed mechanism for pen pattern selection.    kssingvo@immd4.informatik.uni-erlangen.de
+ *      Support for vertical text.                      kssingvo@immd4.informatik.uni-erlangen.de
+ *      Fixed plot bug for "set size XS,YS", XS/YS > 1. olof@fysik4.kth.se
+ *	Support colored text				merritt@u.washington.edu
+ *	Support box fill and pattern fill		merritt@u.washington.edu
+ *
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(mif)
+#endif
+
+
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void MIF_init __PROTO((void));
+TERM_PUBLIC void MIF_graphics __PROTO((void));
+TERM_PUBLIC void MIF_text __PROTO((void));
+TERM_PUBLIC void MIF_linetype __PROTO((int linetype));
+TERM_PUBLIC void MIF_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void MIF_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void MIF_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC int MIF_text_angle __PROTO((int ang));
+TERM_PUBLIC void MIF_reset __PROTO((void));
+TERM_PUBLIC void MIF_options __PROTO((void));
+TERM_PUBLIC int MIF_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC void MIF_point __PROTO((unsigned int x, unsigned int y, int number));
+TERM_PUBLIC void MIF_boxfill __PROTO((int style, unsigned int x1, unsigned int y1,
+	    unsigned int width, unsigned int height));
+TERM_PUBLIC void MIF_filled_polygon __PROTO((int points, gpiPoint* corners));
+
+/** Coordinates **/
+/* The cast to float is not necessary because we are dividing by a float */
+/* On OSK the cast to a float is not allowed in a constant expression wich */
+/* is used by the declaration and initialization of mif_line */
+/* Converts gnuplot units to MIF units */
+#define GNP_TO_MIF(P)   ((P) / 1000.0)
+/* Basic unit: 0.01 mm (15cm -> 15*10*100=15000) */
+#define MIF_XMAX 15000
+/* Basic unit: 0.01 mm (10cm -> 10*10*100=10000) */
+#define MIF_YMAX 10000
+
+#define MIF_XLAST (MIF_XMAX - 1)
+#define MIF_YLAST (MIF_YMAX - 1)
+
+static int insert_mif_line __PROTO((double fx, double fy));
+static int proc_group_id __PROTO((int group_id));
+static void free_mif_line __PROTO((void));
+static void put_mif_line __PROTO((void));
+static void MIF_set_font __PROTO((const char *));
+static void mif_put_point __PROTO((unsigned int x, unsigned int y, int np));
+
+#endif
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+#ifndef cfree
+# define cfree free
+#endif
+
+static struct mif_line {	/* Line point structure specification */
+    float fpos_x;		/* Line point X coordinate */
+    float fpos_y;		/*            Y coordinate */
+    struct mif_line *next;	/* Pointer to next line point */
+    struct mif_line *prev;	/* Pointer to previous line point */
+} mif_line =
+{				/* Current position structure. Adjust for orign. Local for this file. */
+    GNP_TO_MIF(0),
+	GNP_TO_MIF(MIF_YLAST),
+	&mif_line,
+	&mif_line
+};
+
+/** Characters **/
+#define MIF_PSIZE 9		/* Point size of used characters */
+
+#define MIF_VCHAR (MIF_YMAX/31)	/* Distance between rows (a guess) */
+#define MIF_HCHAR (MIF_XMAX/95)	/* Distance between characters (a guess) */
+
+/** Scale marks **/
+#define MIF_VTIC  (MIF_YMAX/150)	/* Size of scale mark (vert) */
+#define MIF_HTIC  (MIF_XMAX/225)	/* Size of scale mark (hor) */
+
+/** Drawing properties **/
+static char mif_justify[64];	/* How to justify the used text */
+static char mif_pen[64], mif_pen_width[64], mif_separation[64];		/* How to plot */
+static char mif_textcolor[64];	/* EAM parallels separation */
+
+static int mif_text_ang = 0;		/* Rotation angle of text */
+
+static int mif_fill_patterns[] = {7,12,3,0,9,8,14,13};
+#define MIF_FILL_SOLID  0
+#define MIF_FILL_NONE  15
+
+#define MIF_NPENS 16		/* Number of MIF pen types */
+static int mif_pentype = 0;	/* Pen type to use. Also used to create groups for graphics */
+#define MIF_PEN_TO_GROUP(P)     ( 1 + (P) )	/* Map pen type to group number. Must be >= 1 */
+
+static int mif_pattern_table[MIF_NPENS] =
+{ /* Table, which pattern should be used for drawing */
+    0,				/* border  */
+    1,				/* not used */
+    2, 3, 4, 8, 12, 13,		/* other lines: functions, data, ... (5 is used for grid; 6,7 is (nearly) invisible) */
+    5,				/* grid */
+    9, 10, 11, 12, 13, 14, 15	/* not used */
+};
+
+/** MIF groups administration **/
+#define MIF_NGROUP_ID           20
+static struct mif_group_id {
+    int group_existance;
+/* This group id should generate a MIF group */
+#define MIF_GROUP_EXISTS        1
+/* This group id should not generate a MIF group */
+#define MIF_GROUP_NOT_EXISTS    0
+
+    int group_id;
+#define MIF_INVALID_GROUP_ID    0	/* An invalid MIF group ID */
+
+} mif_group_id[MIF_NGROUP_ID];	/* List of used group ID:s and corresponding MIF groups existance */
+
+/** Semaphores **/
+static int mif_initialized = 0;	/* != 0 when output is active */
+static int mif_in_frame = 0;	/* != 0 when inside a plot frame */
+static int mif_frameno = -1;	/* Current frame number */
+static int mif_colour = TRUE;	/* == TRUE when colour should be used */
+static int mif_polyline = TRUE;	/* == TRUE when lines are drawn as continuous curves */
+
+struct mpt {			/* point definition structure */
+    int chr;			/* character for point */
+    float x_offset, y_offset;	/* offset for vertical positioning */
+    char *font;			/* font */
+};
+
+static char zgnuplot[] = "ZGnuplot"; /* character formats */
+static char zgnuplotp[] = "ZGnuplotP";
+static char zgnuplotd[] = "ZGnuplotD";
+static const char *mif_font = NULL; /* actual character format */
+
+static struct mpt mpt[POINT_TYPES + 1] =
+{				/* point definition data */
+    {'.', 0.000, 0.005, zgnuplotd, /* dot */ },
+
+    {'G', 0.002, 0.084, zgnuplotp, /* diamond */ },
+    {';', 0.002, 0.084, zgnuplotp, /* plus */ },
+    {'n', 0.002, 0.084, zgnuplotp, /* box */ },
+    {'5', 0.002, 0.084, zgnuplotp, /* X */ },
+    {'s', 0.002, 0.062, zgnuplotp, /* triangle */ },
+    {'K', 0.005, 0.075, zgnuplotp, /* star */ },
+};
+
+/* diamond is offset 0, dot is offset -1 */
+static struct mpt *mif_point = &(mpt[1]);
+
+
+/** Declaration of routine/s for internal use **/
+static int insert_mif_line __PROTO((double fx, double fy));
+static int proc_group_id __PROTO((int group_id));
+
+enum MIF_id {
+    MIF_MONOCHROME, MIF_COLOR, MIF_VECTORS, MIF_POLYLINE, MIF_HELP,
+    MIF_OTHER
+};
+
+static struct gen_table MIF_opts[] =
+{
+    { "m$onochrome", MIF_MONOCHROME },
+    { "c$olor", MIF_COLOR },
+    { "c$olour", MIF_COLOR },
+    { "v$ectors", MIF_VECTORS },
+    { "p$olyline", MIF_POLYLINE },
+    { "h$elp", MIF_HELP },
+    { "?$", MIF_HELP },
+    { NULL, MIF_OTHER }
+};
+
+/** Routine/s **/
+
+/* Called when this terminal type is set in order to parse options */
+TERM_PUBLIC void
+MIF_options()
+{
+    while (!END_OF_COMMAND) {
+	switch(lookup_table(&MIF_opts[0],c_token)) {
+	/* Colour options */
+	case MIF_MONOCHROME:
+	    mif_colour = FALSE;
+	    c_token++;
+	    break;
+	case MIF_COLOR:
+	    mif_colour = TRUE;
+	    c_token++;
+	    break;
+	/* Curve options */
+	case MIF_VECTORS:
+	    mif_polyline = FALSE;
+	    c_token++;
+	    break;
+	case MIF_POLYLINE:
+	    mif_polyline = TRUE;
+	    c_token++;
+	    break;
+	/* Short help */
+	case MIF_HELP:
+	case MIF_OTHER:
+	default:
+	    fprintf(stderr, "\
+Usage: set terminal mif [options]\n\
+\toptions:\n\
+\t\tcolour /        Draw primitives with line types >= 0 in colour (sep. 2-7)\n\
+\t\tmonochrome      Draw primitives in black (sep. 0)\n\n\
+\t\tpolyline /      Draw lines as continuous curves\n\
+\t\tvectors         Draw lines as collections of vectors\n\n\
+\t\thelp / ?        Print short usage description on stderr\n");
+	    c_token++;
+	    break;
+	}
+    }
+    sprintf(term_options, "%s %s",
+	    (mif_colour == TRUE) ? "colour" : "monochrome",
+	    (mif_polyline == TRUE) ? "polyline" : "vectors");
+}
+
+/* Deallocate the used line structure elements */
+static void
+free_mif_line()
+{
+    struct mif_line *tline;
+
+    while (mif_line.prev != &mif_line) {
+	/* Unlink */
+	tline = mif_line.prev;
+	mif_line.prev = mif_line.prev->prev;
+	mif_line.prev->next = &mif_line;
+
+	/* Deallocate */
+	free(tline);
+    }
+
+    /* Make sure that the list will be empty */
+    mif_line.prev = &mif_line;
+    mif_line.next = &mif_line;
+}
+
+/* Draw the pending line. Change current position. */
+static void
+put_mif_line()
+{
+    int np, i;
+    struct mif_line *tline;
+
+    /* Process if inside a Frame */
+    if (mif_initialized != 0 && mif_in_frame != 0) {
+
+	/* Count the number of available points */
+	for (tline = mif_line.next, np = 1; tline != &mif_line; tline = tline->next, np++);
+
+	/* Draw line (at least two points) */
+	if (np >= 2) {
+
+	    /* Line preamble */
+	    fprintf(gpoutfile, "\t<PolyLine <GroupID %d> %s %s %s <Fill 15>\n",
+		    MIF_PEN_TO_GROUP(mif_pentype), mif_pen, mif_pen_width, mif_separation);
+
+	    /* Draw the line elements */
+	    fprintf(gpoutfile, "\t\t<NumPoints %d> ", np);
+	    for (i = 0, tline = &mif_line; i < np; i++, tline = tline->next) {
+		if (i % 4 == 0)
+		    fputs("\n\t\t", gpoutfile);
+		fprintf(gpoutfile, "<Point  %.3f %.3f> ",
+			tline->fpos_x, tline->fpos_y);
+	    }
+
+	    /* Line post amble */
+	    fputs("\n\t>\n", gpoutfile);
+
+	    /* Register the used group ID */
+	    proc_group_id(MIF_PEN_TO_GROUP(mif_pentype));
+
+	    /* Avoid to redraw this. The MIF system should remember it. */
+	    mif_pen[0] = '\0';
+	    mif_pen_width[0] = '\0';
+	    mif_separation[0] = '\0';
+
+	    /* Move current position to end of line */
+	    mif_line.fpos_x = mif_line.prev->fpos_x;
+	    mif_line.fpos_y = mif_line.prev->fpos_y;
+
+	    /* Restore the line */
+	    free_mif_line();
+	}
+    }				/* Line processed */
+}
+
+/* Filled box support - Ethan Merritt <merritt@u.washington.edu> */
+TERM_PUBLIC void
+MIF_boxfill(int style, unsigned int x1, unsigned int y1,
+	    unsigned int width, unsigned int height)
+{
+    int fill_pattern;
+
+    int fillpar = style >> 4;
+    style &= 0xf;
+    switch (style) {
+	default:
+	case FS_EMPTY:	fill_pattern = 7;
+			break;
+	case FS_SOLID:	fill_pattern = MIF_FILL_SOLID;
+			break;
+	case FS_PATTERN:fill_pattern = mif_fill_patterns[fillpar % 8];
+			break;
+    }
+
+    /* Object preamble */
+    fprintf(gpoutfile, "\t<Rectangle <GroupID %d> %s\n",
+	    MIF_PEN_TO_GROUP(mif_pentype), mif_separation);
+
+    /* Set fill type */
+    fprintf(gpoutfile, "\t\t<Fill %d>\n", fill_pattern);
+
+    /* Draw the box */
+    fprintf(gpoutfile, "\t\t<ShapeRect %.3f %.3f %.3f %.3f>\n",
+	GNP_TO_MIF(x1), GNP_TO_MIF(MIF_YLAST - (y1+height)),
+	GNP_TO_MIF(width), GNP_TO_MIF(height));
+
+    /* End of object */
+    fputs("\n\t>\n", gpoutfile);
+
+    /* Register the used group ID */
+    proc_group_id(MIF_PEN_TO_GROUP(mif_pentype));
+
+}
+
+/* Filled polygon. Ethan Merritt <merritt@u.washington.edu> */
+TERM_PUBLIC void
+MIF_filled_polygon(int points, gpiPoint* corners)
+{
+    int i;
+
+    /* Object preamble */
+    fprintf(gpoutfile, "\t<Polygon <GroupID %d>\n",
+	    MIF_PEN_TO_GROUP(mif_pentype));
+
+    /* Set fill type */
+    fprintf(gpoutfile, "\t\t<Fill %d>\n", MIF_FILL_SOLID);
+
+    /* Draw the line elements */
+    fprintf(gpoutfile, "\t\t<NumPoints %d> ", points);
+    for (i=0; i<points; i++) {
+	fprintf(gpoutfile, "<Point  %.3f %.3f> ",
+		GNP_TO_MIF(corners[i].x),
+		GNP_TO_MIF(MIF_YLAST - corners[i].y));
+    }
+
+    /* End of object */
+    fputs("\n\t>\n", gpoutfile);
+
+    /* Register the used group ID */
+    proc_group_id(MIF_PEN_TO_GROUP(mif_pentype));
+
+}
+
+/* Draw a point */
+static void
+mif_put_point(unsigned int x, unsigned int y, int np)
+{
+    /* Process if inside a Frame */
+    if (mif_initialized != 0 && mif_in_frame != 0) {
+
+	/* Draw pending line */
+	if (mif_polyline == TRUE)
+	    put_mif_line();
+
+	/* Adjust current position for text-graphics alignment */
+	MIF_move(x, y);
+
+	/* center text */
+	MIF_justify_text(CENTRE);
+
+	/* Draw the point */
+	fprintf(gpoutfile, "\t<TextLine <GroupID %d> %s\n",
+		MIF_PEN_TO_GROUP(mif_pentype),
+		mif_textcolor);
+
+	MIF_set_font(mif_point[np].font);
+
+	fprintf(gpoutfile, "\t\t<TLOrigin  %.3f %.3f> %s <String `%c'>\n",
+		mif_line.fpos_x + mif_point[np].x_offset,
+		mif_line.fpos_y + mif_point[np].y_offset,
+		mif_justify,
+		mif_point[np].chr);
+	fputs("\t>\n", gpoutfile);
+
+	/* Register the used group ID */
+	proc_group_id(MIF_PEN_TO_GROUP(mif_pentype));
+
+	/* Avoid to redraw this. The MIF system should remember it. */
+	mif_justify[0] = '\0';
+
+    }				/* Point processed */
+}
+
+
+/*
+ *  draw points
+ */
+TERM_PUBLIC void
+MIF_point(unsigned int x, unsigned int y, int number)
+{
+    if (number < 0) {		/* dot */
+	number = -1;
+    } else {			/* point */
+	number %= POINT_TYPES;
+    }
+    mif_put_point(x, y, number);
+}
+
+
+/* Set up a MIF output file */
+TERM_PUBLIC void
+MIF_init()
+{
+    int i;
+
+    /* Process if not inside a MIF file and Frame */
+    if (mif_initialized == 0 && mif_in_frame == 0) {
+	/* Tell this terminal driver that the output is initialized and
+	 * no current frames are processed */
+	mif_initialized = 1;
+	mif_in_frame = 0;
+
+	/* Reset internal position */
+	free_mif_line();
+	mif_line.fpos_x = GNP_TO_MIF(0);
+	mif_line.fpos_y = GNP_TO_MIF(MIF_YLAST);
+
+	/* Reset drawing properties strings */
+	mif_pen[0] = '\0';
+	mif_pen_width[0] = '\0';
+	mif_separation[0] = '\0';
+
+	MIF_justify_text(LEFT);
+
+	/* Reset group ID generator */
+	for (i = 0; i < MIF_NGROUP_ID; i++) {
+	    mif_group_id[i].group_id = MIF_INVALID_GROUP_ID;
+	    mif_group_id[i].group_existance = MIF_GROUP_NOT_EXISTS;
+	}
+
+	/* Identify ourselves */
+	/*bs show borders */
+	/* Setup a default environment to use */
+	fprintf(gpoutfile, "\
+<MIFFile 3.00> # Generated by gnuplot version %s patchlevel %s; identifies this as a MIF file\n\
+#\n\
+# show borders\n\
+<Document\n<DBordersOn Yes>\n>\n\
+# Set a default pen pattern, pen width, unit and font for subsequent objects\n\
+<Pen 0>\n\
+<Fill 15>\n\
+<PenWidth 0.5 pt>\n\
+<Separation 0>\n\
+<Units Ucm>\n\
+<FontCatalog\n\
+\t<Font <FTag `%s'><FFamily `Times'><FSize %d><FPlain Yes>>\n\
+\t<Font <FTag `%s'><FFamily `ZapfDingbats'><FSize 7.0 pt><FPlain Yes>>\n\
+\t<Font <FTag `%s'><FFamily `Symbol'><FSize 5.0 pt><FPlain Yes>>\n\
+>\n\
+#\n",
+		gnuplot_version, gnuplot_patchlevel,
+		zgnuplot, MIF_PSIZE,
+		zgnuplotp,
+		zgnuplotd);
+    }				/* MIF file created */
+}
+
+/* Finish of a MIF output file */
+TERM_PUBLIC void
+MIF_reset()
+{
+    /* Process if inside a MIF file and not inside a Frame */
+    if (mif_initialized != 0 && mif_in_frame == 0) {
+	/* Finish off the MIF file */
+	fputs("\
+#\n\
+# End of MIFFile\n", gpoutfile);
+
+	/* Tell this terminal driver that the output is finished */
+	mif_initialized = 0;
+
+	/* bs: reset frame number */
+	mif_frameno = -1;
+
+    }				/* MIF file finished */
+}
+
+/* Start plotting a Frame (-> graphics mode) */
+TERM_PUBLIC void
+MIF_graphics()
+{
+    int i;
+
+    /* Process if not inside a Frame */
+    if (mif_initialized != 0 && mif_in_frame == 0) {
+	/* Tell that this terminal driver is working with a plot frame */
+	mif_in_frame = 1;
+
+	/* Update frame number */
+	mif_frameno++;
+
+	/* Set current position */
+	free_mif_line();
+	mif_line.fpos_x = GNP_TO_MIF(0);
+	mif_line.fpos_y = GNP_TO_MIF(MIF_YLAST);
+
+	/* Set drawing properties */
+	mif_pen[0] = '\0';
+	mif_pen_width[0] = '\0';
+	mif_separation[0] = '\0';
+
+	MIF_justify_text(LEFT);
+
+	/* Reset group ID generator */
+	for (i = 0; i < MIF_NGROUP_ID; i++) {
+	    mif_group_id[i].group_id = MIF_INVALID_GROUP_ID;
+	    mif_group_id[i].group_existance = MIF_GROUP_NOT_EXISTS;
+	}
+
+	/* Frame preamble */
+	fprintf(gpoutfile, "\
+#\n\
+# Frame number %d with plot of graphics\n\
+<Frame\n\
+\t<Pen 15>\n\
+\t<Fill 15>\n\
+\t<PenWidth  0.5 pt>\n\
+\t<Separation 0>\n\
+\t<BRect 2.000 %.3f %.3f %.3f>\n\
+\t<NSOffset  0.000>\n\
+\t<BLOffset  0.000>\n",
+	    mif_frameno,
+	    ((float) mif_frameno) * GNP_TO_MIF(MIF_YMAX + 100),
+	    GNP_TO_MIF(MIF_XMAX), GNP_TO_MIF(MIF_YMAX));
+    }				/* Frame created */
+}
+
+/* Stop plotting a Frame (-> text mode) */
+TERM_PUBLIC void
+MIF_text()
+{
+    int i;
+
+    /* Process if inside a Frame */
+    if (mif_initialized != 0 && mif_in_frame != 0) {
+
+	/* Draw pending line */
+	if (mif_polyline == TRUE)
+	    put_mif_line();
+
+	/* Group the used plot primitives */
+	fputs("\
+\t#\n\
+\t# Group the the objects in groups to make the chart easier to manipulate\n\
+\t# after it's imported into FrameMaker.\n", gpoutfile);
+
+	for (i = 0; i < MIF_NGROUP_ID; i++) {
+	    if (mif_group_id[i].group_id != MIF_INVALID_GROUP_ID &&
+		mif_group_id[i].group_existance == MIF_GROUP_EXISTS) {
+		fprintf(gpoutfile, "\
+\t<Group\n\
+\t\t<ID %d>\n\
+\t>\n", mif_group_id[i].group_id);
+	    }
+	}
+
+	/* Frame post amble */
+	fprintf(gpoutfile, "\
+>\n\
+# End of Frame number %d\n\
+#\n",
+		mif_frameno);
+
+	/* Tell that this terminal driver is not working with a plot frame */
+	mif_in_frame = 0;
+    }				/* Frame finshed */
+}
+
+/* Select type of line in grapics */
+/* NOTE: actually written to output the first time a primitive
+ * is drawn AFTER this call */
+/* -2=border, -1=X/Y-axis, 0-13=lines, and 14-=mapped back */
+TERM_PUBLIC void
+MIF_linetype(int linetype)
+{
+    /* Process if inside a Frame */
+    if (mif_initialized != 0 && mif_in_frame != 0) {
+
+	/* Draw pending line */
+	if (mif_polyline == TRUE)
+	    put_mif_line();
+
+	/* Translate gnuplot pen types to MIF pen types */
+	if (linetype < 0) {	/* Special lines */
+	    if (linetype == LT_AXIS) {
+		mif_pentype = 8 + MIF_NPENS;	/* -1 */
+		if (mif_colour == TRUE)
+		    sprintf(mif_separation, " <Separation 0> ");
+	    } else {
+		mif_pentype = 0 + MIF_NPENS;	/* -2 or less */
+		if (mif_colour == TRUE)
+		    sprintf(mif_separation, " <Separation 0> ");
+	    }
+	    sprintf(mif_pen_width, " <PenWidth 1.0 pt> ");
+	    /* EAM - set text color to black */
+	    sprintf(mif_textcolor, " <Font <FSeparation 0>> ");
+	} else {		/* Normal lines */
+	    mif_pentype = (linetype) % MIF_NPENS;	/* 0-(MIF_NPENS-1) */
+	    sprintf(mif_pen_width, " <PenWidth 0.1 pt> ");
+	    if (mif_colour == TRUE)
+		sprintf(mif_separation, " <Separation %d> ",
+			2 + (mif_pentype % 6));	/* 2-7 */
+	    /* EAM - set text color also */
+	    if (mif_colour == TRUE)
+		sprintf(mif_textcolor, " <Font <FSeparation %d>> ",
+			2 + (mif_pentype % 6));	/* 2-7 */
+	}
+
+	/* Set pen type */
+	sprintf(mif_pen, " <Pen %d> ",
+		mif_pattern_table[mif_pentype % MIF_NPENS]);
+
+    }				/* Primitive processed */
+}
+
+/* Allow arbitrary text rotation */
+TERM_PUBLIC int
+MIF_text_angle(int ang)
+{
+    mif_text_ang = ang;
+    return (TRUE);
+}
+
+/* Justify following text lines (MIF_put_text()) relative to the
+ * insertion point
+ * NOTE: actually written to output in text primitives which are
+ * drawn AFTER this call */
+TERM_PUBLIC int
+MIF_justify_text(enum JUSTIFY mode)
+{
+    int rval = TRUE;
+
+    /* Process if inside a Frame */
+    if (mif_initialized != 0 && mif_in_frame != 0) {
+	switch (mode) {
+	case LEFT:
+	    sprintf(mif_justify, " <TLAlignment Left> ");
+	    break;
+	case CENTRE:
+	    sprintf(mif_justify, " <TLAlignment Center> ");
+	    break;
+	case RIGHT:
+	    sprintf(mif_justify, " <TLAlignment Right> ");
+	    break;
+	default:
+	    rval = FALSE;
+	    break;
+	}
+
+    }
+    /* Primitive processed */
+    else {
+	rval = FALSE;
+    }
+
+    return (rval);
+}
+
+/* Draw a vector from current position to (x, y) and change current position.
+ * NOTE: actually written to output the first time another primitive
+ * is called AFTER this call */
+TERM_PUBLIC void
+MIF_vector(unsigned int x, unsigned int y)
+{
+    /* Process if inside a Frame */
+    if (mif_initialized != 0 && mif_in_frame != 0) {
+
+	/* Setup the vector as a part of the line */
+	insert_mif_line(GNP_TO_MIF(x), GNP_TO_MIF(MIF_YLAST - (int) y));
+
+	/* Draw pending line -> vector */
+	if (mif_polyline == FALSE)
+	    put_mif_line();
+
+    }				/* Vector processed */
+}
+
+/* Move current position */
+TERM_PUBLIC void
+MIF_move(unsigned int x, unsigned int y)
+{
+    /* Process if inside a Frame */
+    if (mif_initialized != 0 && mif_in_frame != 0) {
+
+	/* Draw pending line */
+	if (mif_polyline == TRUE)
+	    put_mif_line();
+
+	mif_line.fpos_x = GNP_TO_MIF(x);
+	mif_line.fpos_y = GNP_TO_MIF(MIF_YLAST - (int) y);
+    }
+}
+
+
+/* set font */
+static void
+MIF_set_font(const char *font)
+{
+    if (font != mif_font) {
+	fprintf(gpoutfile, "\t\t<Font\n\t\t\t<FTag `%s'>\n\t\t>\n", font);
+	mif_font = font;
+    }
+}
+
+
+/* Draw the text string str at (x, y). Adjust according to MIF_justify_text().
+ * Change current position. */
+TERM_PUBLIC void
+MIF_put_text(unsigned int x, unsigned int y, const char str[])
+{
+    /* Process if inside a Frame */
+    if (mif_initialized != 0 && mif_in_frame != 0) {
+
+	/* Draw pending line */
+	if (mif_polyline == TRUE)
+	    put_mif_line();
+
+	/* Adjust current position for text-graphics alignment */
+	MIF_move(x, y - MIF_VCHAR / 5);
+
+	if (strlen(str) > 0) {
+
+	    /* Draw the text */
+	    fprintf(gpoutfile, "\t<TextLine <GroupID %d> %s %s %s %s\n",
+		    MIF_PEN_TO_GROUP(mif_pentype), mif_pen,
+		    mif_pen_width, mif_separation, mif_textcolor);
+
+	    MIF_set_font(zgnuplot);
+
+	    fprintf(gpoutfile, "\
+\t\t<TLOrigin  %.3f %.3f> %s <Angle %d> <String `%s'>\n\
+\t>\n",
+		    mif_line.fpos_x, mif_line.fpos_y, mif_justify,
+		    mif_text_ang, str);
+
+	    /* Register the used group ID */
+	    proc_group_id(MIF_PEN_TO_GROUP(mif_pentype));
+
+	    /* Avoid to redraw this. The MIF system should remember it. */
+	    mif_pen[0] = '\0';
+	    mif_pen_width[0] = '\0';
+	    mif_separation[0] = '\0';
+
+	    mif_justify[0] = '\0';	/* Independent of linetype */
+	}
+    }				/* Text processed */
+}
+
+
+/* Insert one point in the line */
+static int
+insert_mif_line(double fx, double fy)
+{
+    int rval = TRUE;
+
+    if ((mif_line.prev->next = (struct mif_line *) gp_alloc(sizeof(struct mif_line),
+	"MIF driver")) != (struct mif_line *) NULL) {
+	/* Link */
+	mif_line.prev->next->next = &mif_line;
+	mif_line.prev->next->prev = mif_line.prev;
+	mif_line.prev = mif_line.prev->next;
+
+	/* Fill */
+	mif_line.prev->fpos_x = fx;
+	mif_line.prev->fpos_y = fy;
+
+	rval = TRUE;
+    } else {			/* Failed to allocate */
+	/* Relink */
+	mif_line.prev->next = &mif_line;
+
+	rval = FALSE;
+    }
+
+    return (rval);
+}
+
+/* Register group ID. Update group ID existance. */
+/* Returns:     1       group_id belongs to a MIF group
+		0       group_id does not belong to a MIF group
+	       -1       not inside a Frame
+	       -2       group ID list is full
+ */
+static int
+proc_group_id(int group_id)
+{
+    int i, rval = 0;
+
+    /* Process if inside a Frame */
+    if (mif_initialized != 0 && mif_in_frame != 0) {
+
+	/* Find out the group ID, or a free group ID slot index. */
+	for (i = 0; i < MIF_NGROUP_ID &&
+	     mif_group_id[i].group_id != MIF_INVALID_GROUP_ID &&
+	     mif_group_id[i].group_id != group_id;
+	     i++) {
+	    /* Don't check the group_existance variable */
+	}
+
+	if (i < MIF_NGROUP_ID) {
+	    if (mif_group_id[i].group_id == MIF_INVALID_GROUP_ID) {
+		/* Register as new group ID for eventual use as MIF group */
+		mif_group_id[i].group_id = group_id;
+		mif_group_id[i].group_existance = MIF_GROUP_NOT_EXISTS;
+	    } else {
+		/* If second use of this group ID -> create a new MIF group */
+		if (mif_group_id[i].group_id == group_id) {
+		    mif_group_id[i].group_existance = MIF_GROUP_EXISTS;
+		    /* NOTE: a group MUST have at least two members. */
+		    rval = 1;
+		}
+	    }
+	} else {
+	    rval = -2;		/* No place for this group ID in the list */
+	}
+
+    }
+    /* Group ID processed */
+    else {
+	rval = -1;		/* Not inside a Frame */
+    }
+
+    /* Return MIF group status */
+    return (rval);
+}
+
+
+#endif
+
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(mif_driver)
+    "mif", "Frame maker MIF 3.00 format",
+    MIF_XMAX, MIF_YMAX, MIF_VCHAR, MIF_HCHAR,
+    MIF_VTIC, MIF_HTIC, MIF_options, MIF_init, MIF_reset,
+    MIF_text, null_scale, MIF_graphics, MIF_move, MIF_vector,
+    MIF_linetype, MIF_put_text, MIF_text_angle,
+    MIF_justify_text, MIF_point, do_arrow, set_font_null,
+    0, /* pointsize */
+    0, /* flags */
+    0, 0, /* suspend, resume */
+    MIF_boxfill,
+    0  /* linewidth */
+#ifdef USE_MOUSE
+    , 0, 0, 0, 0, 0
+#endif
+    ,0 /* make_palette */
+    ,0 /* previous_palette */
+    ,0 /* set_color */
+    ,MIF_filled_polygon /* filled_polygon */
+TERM_TABLE_END(mif_driver)
+
+#undef LAST_TERM
+#define LAST_TERM mif_driver
+
+#endif
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(mif)
+"1 mif",
+"?commands set terminal mif",
+"?set terminal mif",
+"?set term mif",
+"?terminal mif",
+"?term mif",
+"?mif",
+" The `mif` terminal driver produces Frame Maker MIF format version 3.00.  It",
+" plots in MIF Frames with the size 15*10 cm, and plot primitives with the same",
+" pen will be grouped in the same MIF group.  Plot primitives in a `gnuplot`",
+" page will be plotted in a MIF Frame, and several MIF Frames are collected in",
+" one large MIF Frame.  The MIF font used for text is \"Times\".",
+"",
+" Several options may be set in the MIF 3.00 driver.",
+"",
+" Syntax:",
+"       set terminal mif {color | colour | monochrome} {polyline | vectors}",
+"                        {help | ?}",
+"",
+" `colour` plots lines with line types >= 0 in colour (MIF sep. 2--7) and",
+" `monochrome` plots all line types in black (MIF sep. 0).",
+" `polyline` plots curves as continuous curves and `vectors` plots curves as",
+" collections of vectors.",
+" `help` and `?` print online help on standard error output---both print a",
+" short description of the usage; `help` also lists the options.",
+"",
+" Examples:",
+"       set term mif colour polylines    # defaults",
+"       set term mif                     # defaults",
+"       set term mif vectors",
+"       set term mif help"
+END_HELP(mif)
+#endif /* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/next.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/next.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/next.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/next.trm.svn-base	2012-01-03 17:07:40.881996500 -0800
@@ -0,0 +1,1537 @@
+/* Hello, Emacs, this is -*- objc -*-
+ * $Id: next.trm,v 1.27 2006/07/21 02:35:47 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - next.trm */
+
+/*[
+ * Copyright 1991 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c via ../term.h.
+ *
+ * This terminal driver supports:
+ *     next
+ *
+ * AUTHORS
+ *  Robert Lutwak from Russell Lang's post.trm
+ *  'old' option invokes Nick Strobel's original, single viewport terminal
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ * This terminal attempts to connect, via the NeXTstep Distributed
+ * Objects system, to the "gnuplotServer."  If there is no such
+ * service registered with the OS, the terminal attempts to fire
+ * up GnuTerm.app.  If the user has not set the environment variable
+ * GNUTERMPATH, the terminal uses the users ApplicationPaths Workspace
+ * dwrite to search for GnuTerm.app (Note:  this is usually something
+ * like ~/Apps, ~/LocalApps, ~/NextApps, etc.).
+ * In order to use this filter, you MUST have GnuTerm.app installed
+ * on your system.
+ *
+ * Once connected to the server, this filter is basically Russell Lang's
+ * Postscript filter, except that the resultant postscript code
+ * is sent, via the D.O. system, to GnuTerm.app, which manages
+ * the windows which produce the postscript output on the screen.
+ *
+ *
+ * Defaults are
+ * 'set term next new dashed auto "Helvetica" 14'
+ *
+ * To change font to Times-Roman and font size to 20pts use
+ * 'set term next "Times-Roman" 20'.
+ *
+ * to choose window by title
+ * 'set term next title "Window title"
+ *
+ * Monitor Options:
+ * monochrome, color
+ *
+ * To invoke Nick Strobel's old terminal
+ * 'set term next old'
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(next)
+#endif
+
+#ifdef TERM_PROTO
+
+/* whether or not to compile support for the old (self-contained)
+   NeXT terminal */
+/* #define NEXT_OLDTERMINAL	1 */
+
+#import <appkit/appkit.h>
+#import <remote/NXProxy.h>	/* setProtocolForProxy */
+#import <remote/NXConnection.h>	/* setProtocolForProxy */
+#import <machkit/NXNetNameServer.h>
+#import <machkit/senderIsInvalid.h>
+#import <stdarg.h>
+
+
+#ifdef NEXT_OLDTERMINAL
+static void window_create __PROTO((void));
+@interface EpsViewer:Application
+{
+    id theNewWin;
+}
+
+-windowCreate:(NXCoord)
+width Height:(NXCoord) height;
+-(NXRect *) nextRectForWidth:(NXCoord)
+width Height:(NXCoord) height;
+@end
+#endif /* NEXT_OLDTERMINAL */
+
+
+TERM_PUBLIC void NEXT_options __PROTO((void));
+TERM_PUBLIC void NEXT_common_init __PROTO((int uses_fonts, unsigned int xoff, unsigned int yoff, unsigned int xsize, unsigned int ysize, char **dict));
+TERM_PUBLIC void NEXT_init __PROTO((void));
+TERM_PUBLIC void NEXT_graphics __PROTO((void));
+TERM_PUBLIC void NEXT_text __PROTO((void));
+TERM_PUBLIC void NEXT_reset __PROTO((void));
+TERM_PUBLIC void NEXT_linetype __PROTO((int linetype));
+TERM_PUBLIC void NEXT_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void NEXT_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void NEXT_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC int NEXT_text_angle __PROTO((int ang));
+TERM_PUBLIC int NEXT_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC void NEXT_point __PROTO((unsigned int x, unsigned int y, int number));
+TERM_PUBLIC int NEXT_set_font __PROTO((const char *font));
+TERM_PUBLIC char *NEXT_RememberFont __PROTO((char *fname));
+TERM_PUBLIC void NEXT_set_pointsize __PROTO((double size));
+
+
+#define NEXT_POINT_TYPES 8	/* div */
+#define NEXT_XOFF	1	/* page offset in pts */
+#define NEXT_YOFF	1
+#define NEXT_XMAX 6400
+#define NEXT_YMAX 4800
+#define NEXT_XLAST (NEXT_XMAX - 1)
+#define NEXT_YLAST (NEXT_YMAX - 1)
+#define NEXT_VTIC (NEXT_YMAX/80)
+#define NEXT_HTIC (NEXT_YMAX/80)
+#define NEXT_SC (10)		/* scale is 1pt = 10 units */
+#define	NEXT_LW (0.5*NEXT_SC)	/* linewidth = 0.5 pts */
+#define NEXT_VCHAR (14*NEXT_SC)	/* default is 14 point characters */
+#define NEXT_HCHAR (14*NEXT_SC*6/10)
+
+#define GOT_NEXT_PROTO
+#endif
+
+
+#ifndef TERM_PROTO_ONLY
+
+#ifdef TERM_BODY
+
+@interface GnuTermDriver:Object < NXSenderIsInvalid >
+{
+    id server;
+}
+
+-senderIsInvalid:(id) sender;
+-plot:(char *) PSstr;
+-init;
+@end
+
+
+#define DEFAULTNEXTSIZE 10000
+
+static id gnuTermAccess;	/* local object manages the D.O. connection */
+
+static char *NEXTBuffer, *NEXTBufAt, *NEXTBufEnd;
+static int NEXTsize;
+static char NEXTTmpBuf[1000];
+static void NEXTPrintf(char *,...);
+static TBOOLEAN NEXT_oldterminal = FALSE;
+/*static TBOOLEAN NEXT_colordetect();*/
+
+static char NEXT_title[MAX_LINE_LEN + 1];	/* name of font */
+
+static char NEXT_font[MAX_LINE_LEN + 1] = "Helvetica";	/* name of font */
+static int NEXT_fontsize = 14;	/* size of font in pts */
+static int NEXT_default_font[MAX_ID_LEN+1] = {'\0'};
+static TBOOLEAN NEXT_color = FALSE;
+static TBOOLEAN NEXT_solid = FALSE;	/*  use dashed lines */
+static int NEXT_path_count = 0;	/* count of lines in path */
+static int NEXT_ang = 0;	/* text angle */
+static enum JUSTIFY NEXT_justify = LEFT;	/* text is flush left */
+
+static TBOOLEAN NEXT_duplex_state = FALSE;
+static TBOOLEAN NEXT_duplex_option = FALSE;
+
+static char GPFAR *GPFAR NEXT_header[] =
+{
+    "/M {moveto} bind def\n",
+    "/L {lineto} bind def\n",
+    "/R {rmoveto} bind def\n",
+    "/V {rlineto} bind def\n",
+    "/vpt2 vpt 2 mul def\n",
+    "/hpt2 hpt 2 mul def\n",
+/* flush left show */
+    "/Lshow { currentpoint stroke M\n",
+    "  0 vshift R show } def\n",
+/* flush right show */
+    "/Rshow { currentpoint stroke M\n",
+    "  dup stringwidth pop neg vshift R show } def\n",
+/* centred show */
+    "/Cshow { currentpoint stroke M\n",
+    "  dup stringwidth pop -2 div vshift R show } def\n",
+/* Dash or Color Line */
+    "/DL { Color {setrgbcolor Solid {pop []} if 0 setdash }\n",
+    " {pop pop pop Solid {pop []} if 0 setdash} ifelse } def\n",
+/* Border Lines */
+    "/BL { stroke gnulinewidth 2 mul setlinewidth } def\n",
+/* Axes Lines */
+    "/AL { stroke gnulinewidth 2 div setlinewidth } def\n",
+/* Plot Lines */
+    "/PL { stroke gnulinewidth setlinewidth } def\n",
+/* Line Types */
+    "/LTb { BL [] 0 0 0 DL } def\n",	/* border */
+    "/LTa { AL [1 dl 2 dl] 0 setdash 0 0 0 setrgbcolor } def\n",	/* axes */
+    "/LT0 { PL [] 0 1 0 DL } def\n",
+    "/LT1 { PL [4 dl 2 dl] 0 0 1 DL } def\n",
+    "/LT2 { PL [2 dl 3 dl] 1 0 0 DL } def\n",
+    "/LT3 { PL [1 dl 1.5 dl] 1 0 1 DL } def\n",
+    "/LT4 { PL [5 dl 2 dl 1 dl 2 dl] 0 1 1 DL } def\n",
+    "/LT5 { PL [4 dl 3 dl 1 dl 3 dl] 1 1 0 DL } def\n",
+    "/LT6 { PL [2 dl 2 dl 2 dl 4 dl] 0 0 0 DL } def\n",
+    "/LT7 { PL [2 dl 2 dl 2 dl 2 dl 2 dl 4 dl] 1 0.3 0 DL } def\n",
+    "/LT8 { PL [2 dl 2 dl 2 dl 2 dl 2 dl 2 dl 2 dl 4 dl] 0.5 0.5 0.5 DL } def\n",
+/* Point (Round) */ /* Matt Heffron make it round */
+    "/Pnt { stroke [] 0 setdash\n",
+    "   gsave 1 setlinecap M 0 0 V stroke grestore } def\n",
+
+/* Diamond */
+    "/Dia { stroke [] 0 setdash 2 copy vpt add M\n",
+    "  hpt neg vpt neg V hpt vpt neg V\n",
+    "  hpt vpt V hpt neg vpt V closepath stroke\n",
+    "  Pnt } def\n",
+
+/* Plus */
+    "/Pls { stroke [] 0 setdash vpt sub M 0 vpt2 V\n",
+    "  currentpoint stroke M\n",
+    "  hpt neg vpt neg R hpt2 0 V stroke\n",
+    "  } def\n",
+
+/* Box */
+    "/Box { stroke [] 0 setdash 2 copy exch hpt sub exch vpt add M\n",
+    "  0 vpt2 neg V hpt2 0 V 0 vpt2 V\n",
+    "  hpt2 neg 0 V closepath stroke\n",
+    "  Pnt } def\n",
+
+/* Cross (X) */
+    "/Crs { stroke [] 0 setdash exch hpt sub exch vpt add M\n",
+    "  hpt2 vpt2 neg V currentpoint stroke M\n",
+    "  hpt2 neg 0 R hpt2 vpt2 V stroke } def\n",
+
+/* Triangle Up*/
+    "/TriU { stroke [] 0 setdash 2 copy vpt 1.12 mul add M\n",
+    "  hpt neg vpt -1.62 mul V\n",
+    "  hpt 2 mul 0 V\n",
+    "  hpt neg vpt 1.62 mul V closepath stroke\n",
+    "  Pnt  } def\n",
+
+/* Star */
+    "/Star { 2 copy Pls Crs } def\n",
+
+/* div added filed box */
+/* Filled Box */
+    "/BoxF { stroke [] 0 setdash exch hpt sub exch vpt add M\n",
+    "  0 vpt2 neg V  hpt2 0 V  0 vpt2 V\n",
+    "  hpt2 neg 0 V  closepath fill } def\n",
+
+/* div added filled triangle */
+/* Triangle Up, Filled */
+    "/TriUF { stroke [] 0 setdash vpt 1.12 mul add M\n",
+    "  hpt neg vpt -1.62 mul V\n",
+    "  hpt 2 mul 0 V\n",
+    "  hpt neg vpt 1.62 mul V closepath fill } def\n",
+
+/* Matt Heffron: added a few more types */
+/* Triangle Down */
+    "/TriD { stroke [] 0 setdash 2 copy vpt 1.12 mul sub M\n",
+    "  hpt neg vpt 1.62 mul V\n",
+    "  hpt 2 mul 0 V\n",
+    "  hpt neg vpt -1.62 mul V closepath stroke\n",
+    "  Pnt  } def\n",
+
+/* Triangle Down, Filled*/
+    "/TriDF { stroke [] 0 setdash vpt 1.12 mul sub M\n",
+    "  hpt neg vpt 1.62 mul V\n",
+    "  hpt 2 mul 0 V\n",
+    "  hpt neg vpt -1.62 mul V closepath fill} def\n",
+
+/* Diamond, Filled */
+    "/DiaF { stroke [] 0 setdash vpt add M\n",
+    "  hpt neg vpt neg V hpt vpt neg V\n",
+    "  hpt vpt V hpt neg vpt V closepath fill } def\n",
+
+/* Pentagon */
+    "/Pent { stroke [] 0 setdash 2 copy gsave\n",
+    "  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat\n",
+    "  closepath stroke grestore Pnt } def\n",
+
+/* Pentagon, Filled */
+    "/PentF { stroke [] 0 setdash gsave\n",
+    "  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat\n",
+    "  closepath fill grestore } def\n",
+
+/* Circle */
+    "/Circle { stroke [] 0 setdash 2 copy\n",
+    "  hpt 0 360 arc stroke Pnt } def\n",
+
+/* Circle,Filled */
+    "/CircleF { stroke [] 0 setdash hpt 0 360 arc fill } def\n",
+/* 16 differently filled circles */
+    "/C0 { BL [] 0 setdash 2 copy moveto vpt 90 450  arc } bind def\n",
+    "/C1 { BL [] 0 setdash 2 copy        moveto\n",
+    "       2 copy  vpt 0 90 arc closepath fill\n",
+    "               vpt 0 360 arc closepath } bind def\n",
+    "/C2 { BL [] 0 setdash 2 copy moveto\n",
+    "       2 copy  vpt 90 180 arc closepath fill\n",
+    "               vpt 0 360 arc closepath } bind def\n",
+    "/C3 { BL [] 0 setdash 2 copy moveto\n",
+    "       2 copy  vpt 0 180 arc closepath fill\n",
+    "               vpt 0 360 arc closepath } bind def\n",
+    "/C4 { BL [] 0 setdash 2 copy moveto\n",
+    "       2 copy  vpt 180 270 arc closepath fill\n",
+    "               vpt 0 360 arc closepath } bind def\n",
+    "/C5 { BL [] 0 setdash 2 copy moveto\n",
+    "       2 copy  vpt 0 90 arc\n",
+    "       2 copy moveto\n",
+    "       2 copy  vpt 180 270 arc closepath fill\n",
+    "               vpt 0 360 arc } bind def\n",
+    "/C6 { BL [] 0 setdash 2 copy moveto\n",
+    "      2 copy  vpt 90 270 arc closepath fill\n",
+    "              vpt 0 360 arc closepath } bind def\n",
+    "/C7 { BL [] 0 setdash 2 copy moveto\n",
+    "      2 copy  vpt 0 270 arc closepath fill\n",
+    "              vpt 0 360 arc closepath } bind def\n",
+    "/C8 { BL [] 0 setdash 2 copy moveto\n",
+    "      2 copy vpt 270 360 arc closepath fill\n",
+    "              vpt 0 360 arc closepath } bind def\n",
+    "/C9 { BL [] 0 setdash 2 copy moveto\n",
+    "      2 copy  vpt 270 450 arc closepath fill\n",
+    "              vpt 0 360 arc closepath } bind def\n",
+    "/C10 { BL [] 0 setdash 2 copy 2 copy moveto vpt 270 360 arc closepath fill\n",
+    "       2 copy moveto\n",
+    "       2 copy vpt 90 180 arc closepath fill\n",
+    "               vpt 0 360 arc closepath } bind def\n",
+    "/C11 { BL [] 0 setdash 2 copy moveto\n",
+    "       2 copy  vpt 0 90 arc closepath fill\n",
+    "       2 copy moveto\n",
+    "       2 copy  vpt 180 360 arc closepath fill\n",
+    "               vpt 0 360 arc closepath } bind def\n",
+    "/C12 { BL [] 0 setdash 2 copy moveto\n",
+    "       2 copy  vpt 180 360 arc closepath fill\n",
+    "               vpt 0 360 arc closepath } bind def\n",
+    "/C13 { BL [] 0 setdash  2 copy moveto\n",
+    "       2 copy  vpt 0 90 arc closepath fill\n",
+    "       2 copy moveto\n",
+    "       2 copy  vpt 180 360 arc closepath fill\n",
+    "               vpt 0 360 arc closepath } bind def\n",
+    "/C14 { BL [] 0 setdash 2 copy moveto\n",
+    "       2 copy  vpt 90 360 arc closepath fill\n",
+    "               vpt 0 360 arc } bind def\n",
+    "/C15 { BL [] 0 setdash 2 copy vpt 0 360 arc closepath fill\n",
+    "               vpt 0 360 arc closepath } bind def\n",
+
+/* Auxiliary definitions for rectangles */
+
+    "/Rec   { newpath 4 2 roll moveto 1 index 0 rlineto 0 exch rlineto\n",
+    "       neg 0 rlineto closepath } bind def\n",
+    "/Square { dup Rec } bind def\n",
+    "/Bsquare { vpt sub exch vpt sub exch vpt2 Square } bind def\n",
+
+/* 16 differently filled squares */
+
+    "/S0 { BL [] 0 setdash 2 copy moveto 0 vpt rlineto BL Bsquare } bind def\n",
+    "/S1 { BL [] 0 setdash 2 copy vpt Square fill Bsquare } bind def\n",
+    "/S2 { BL [] 0 setdash 2 copy exch vpt sub exch vpt Square fill Bsquare } bind def\n",
+    "/S3 { BL [] 0 setdash 2 copy exch vpt sub exch vpt2 vpt Rec fill Bsquare } bind def\n",
+    "/S4 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt Square fill Bsquare } bind def\n",
+    "/S5 { BL [] 0 setdash 2 copy 2 copy vpt Square fill\n",
+    "       exch vpt sub exch vpt sub vpt Square fill Bsquare } bind def\n",
+    "/S6 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill Bsquare } bind def\n",
+    "/S7 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill\n",
+    "       2 copy vpt Square fill\n",
+    "       Bsquare } bind def\n",
+    "/S8 { BL [] 0 setdash 2 copy vpt sub vpt Square fill Bsquare } bind def\n",
+    "/S9 { BL [] 0 setdash 2 copy vpt sub vpt vpt2 Rec fill Bsquare } bind def\n",
+    "/S10 { BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt Square fill\n",
+    "       Bsquare } bind def\n",
+    "/S11 { 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt2 vpt Rec fill\n",
+    "       Bsquare } bind def\n",
+    "/S12 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill Bsquare } bind def\n",
+    "/S13 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill\n",
+    "       2 copy vpt Square fill Bsquare } bind def\n",
+    "/S14 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill\n",
+    "       2 copy exch vpt sub exch vpt Square fill Bsquare } bind def\n",
+    "/S15 { BL [] 0 setdash 2 copy Bsquare fill Bsquare } bind def\n",
+
+/* 16 different diamonds (actually just rotated squares) */
+
+    "/D0 { gsave translate 45 rotate 0 0 Box stroke grestore } bind def\n",
+    "/D1 { gsave translate 45 rotate 0 0 S1 stroke grestore } bind def\n",
+    "/D2 { gsave translate 45 rotate 0 0 S2 stroke grestore } bind def\n",
+    "/D3 { gsave translate 45 rotate 0 0 S3 stroke grestore } bind def\n",
+    "/D4 { gsave translate 45 rotate 0 0 S4 stroke grestore } bind def\n",
+    "/D5 { gsave translate 45 rotate 0 0 S5 stroke grestore } bind def\n",
+    "/D6 { gsave translate 45 rotate 0 0 S6 stroke grestore } bind def\n",
+    "/D7 { gsave translate 45 rotate 0 0 S7 stroke grestore } bind def\n",
+    "/D8 { gsave translate 45 rotate 0 0 S8 stroke grestore } bind def\n",
+    "/D9 { gsave translate 45 rotate 0 0 S9 stroke grestore } bind def\n",
+    "/D10 { gsave translate 45 rotate 0 0 S10 stroke grestore } bind def\n",
+    "/D11 { gsave translate 45 rotate 0 0 S11 stroke grestore } bind def\n",
+    "/D12 { gsave translate 45 rotate 0 0 S12 stroke grestore } bind def\n",
+    "/D13 { gsave translate 45 rotate 0 0 S13 stroke grestore } bind def\n",
+    "/D14 { gsave translate 45 rotate 0 0 S14 stroke grestore } bind def\n",
+    "/D15 { gsave translate 45 rotate 0 0 S15 stroke grestore } bind def\n",
+
+    NULL
+};
+
+static char GPFAR *GPFAR ENHNEXT_header[] =
+{
+/* For MFshow and MFwidth the tos is an array with the string and font info:  */
+/*	[<fontname (a string)> <fontsize> <vertical offset> <width significant?> <text string>]  */
+
+    "/MFshow {{dup dup 0 get findfont exch 1 get scalefont setfont\n",
+    "     [ currentpoint ] exch dup 2 get 0 exch rmoveto dup 4 get show dup\n",
+    "     3 get {2 get neg 0 exch rmoveto pop} {pop aload pop moveto}ifelse} forall} bind def\n",
+    "/MFwidth {0 exch {dup 3 get{dup dup 0 get findfont exch 1 get scalefont setfont\n",
+    "      4 get stringwidth pop add}\n",
+    "    {pop} ifelse} forall} bind def\n",
+
+/* flush left show */
+    "/MLshow { currentpoint stroke M\n",
+    "  0 exch R MFshow } bind def\n",
+
+/* flush right show */
+    "/MRshow { currentpoint stroke M\n",
+    "  exch dup MFwidth neg 3 -1 roll R MFshow } def\n",
+
+/* centred show */
+    "/MCshow { currentpoint stroke M\n",
+    "  exch dup MFwidth -2 div 3 -1 roll R MFshow } def\n",
+    NULL
+};
+
+/* added to post by Matt Heffron <heffron@falstaff.css.beckman.com> */
+/* moved to post.trm by drd */
+
+struct NEXT_FontName {
+    char *name;
+    struct NEXT_FontName *next;
+} *NEXT_DocFonts = NULL;
+
+enum NEXT_id {
+    NEXT_DEFAULT, NEXT_MONOCHROME, NEXT_COLOR,
+    NEXT_SOLID, NEXT_DASHED,
+    NEXT_SIMPLEX, NEXT_DUPLEX, NEXT_DEFAULTPLEX,
+    NEXT_OLD, NEXT_NEW, NEXT_TITLE,
+    NEXT_OTHER
+};
+
+static struct gen_table NEXT_opts[] =
+{
+    { "d$efault", NEXT_DEFAULT },
+    { "mono$chrome", NEXT_MONOCHROME },
+    { "col$or", NEXT_COLOR },
+    { "col$our", NEXT_COLOR },
+    { "so$lid", NEXT_SOLID },
+    { "da$shed", NEXT_DASHED },
+    { "si$mplex", NEXT_SIMPLEX },
+    { "du$plex", NEXT_DUPLEX },
+    { "defaultp$lex", NEXT_DEFAULTPLEX },
+    { "old", NEXT_OLD },
+    { "new", NEXT_NEW },
+    { "ti$tle", NEXT_TITLE },
+    { NULL, NEXT_OTHER }
+};
+
+TERM_PUBLIC void
+NEXT_options()
+{
+    char buf[40];
+    struct value a;
+
+    while (!END_OF_COMMAND) {
+	switch(lookup_table(&NEXT_opts[0],c_token)) {
+	case NEXT_DEFAULT:
+	    NEXT_oldterminal = FALSE;
+	    /*NEXT_color=NEXT_colordetect(); */
+	    NEXT_color = FALSE;
+	    NEXT_solid = FALSE;
+	    NEXT_duplex_option = FALSE;
+	    strcpy(NEXT_font, "Helvetica");
+	    NEXT_fontsize = 14;
+	    term->v_char = (unsigned int) (NEXT_fontsize * NEXT_SC);
+	    term->h_char = (unsigned int) (NEXT_fontsize * NEXT_SC * 6 / 10);
+	    term->put_text = NEXT_put_text;
+	    c_token++;
+	    break;
+	case NEXT_MONOCHROME:
+	    NEXT_color = FALSE;
+	    c_token++;
+	    break;
+	case NEXT_COLOR:
+	    NEXT_color = TRUE;
+	    c_token++;
+	    break;
+	case NEXT_SOLID:
+	    NEXT_solid = TRUE;
+	    c_token++;
+	    break;
+	case NEXT_DASHED:
+	    NEXT_solid = FALSE;
+	    c_token++;
+	    break;
+	case NEXT_SIMPLEX:
+	    NEXT_duplex_state = FALSE;
+	    NEXT_duplex_option = TRUE;
+	    c_token++;
+	    break;
+	case NEXT_DUPLEX:
+	    NEXT_duplex_state = TRUE;
+	    NEXT_duplex_option = TRUE;
+	    c_token++;
+	    break;
+	case NEXT_DEFAULTPLEX:
+	    NEXT_duplex_option = FALSE;
+	    c_token++;
+	    break;
+	case NEXT_OLD:
+	    NEXT_oldterminal = TRUE;
+	    c_token++;
+	    break;
+	case NEXT_NEW:
+	    NEXT_oldterminal = FALSE;
+	    c_token++;
+	    break;
+	case NEXT_TITLE:
+	    c_token++;
+	    if (!isstring(c_token)) {
+		fprintf(stderr, "usage:  set term next title \"newtitle\"\n");
+	    }
+	    quote_str(NEXT_title, c_token, MAX_LINE_LEN + 1);
+	    break;
+	case NEXT_OTHER:
+	default:
+	    if (isstring(c_token)) {
+		quote_str(NEXT_font, c_token, MAX_LINE_LEN + 1);
+
+		/* We must have font size specified */
+		NEXT_fontsize = (int) real(const_express(&a));
+		term->v_char = (unsigned int) (NEXT_fontsize * NEXT_SC);
+		term->h_char = (unsigned int) (NEXT_fontsize * NEXT_SC * 6 / 10);
+		sprintf(NEXT_default_font, "%s,%d", NEXT_font, NEXT_fontsize);
+	    }
+	    break;
+	}
+    }
+
+    sprintf(term_options, "%s %s %s %s \"%s\" %d title \"%s\"",
+	    NEXT_oldterminal ? "old" : "new",
+	    NEXT_color ? "color" : "monochrome",
+	    NEXT_solid ? "solid" : "dashed",
+	    NEXT_duplex_option ? (NEXT_duplex_state ? "duplex" : "simplex")
+	    : "defaultplex",
+	    NEXT_font,
+	    NEXT_fontsize,
+	    NEXT_title);
+}
+
+
+TERM_PUBLIC char *
+NEXT_RememberFont(char *fname)
+{
+    struct NEXT_FontName *fnp;
+
+    for (fnp = NEXT_DocFonts; fnp && strcmp(fnp->name, fname); fnp = fnp->next);
+    if (fnp)
+	return fnp->name;	/* we must have found it in the list */
+
+    if (encoding == S_ENC_ISO8859_1) {
+	NEXTPrintf("/%s reencodeISO def\n", fname);
+    }
+    fnp = (struct NEXT_FontName *) gp_alloc(sizeof(struct NEXT_FontName), "PostScript Font record");
+    fnp->name = gp_alloc(1 + strlen(fname), "PostScript Font name");
+    strcpy(fnp->name, fname);
+    fnp->next = NEXT_DocFonts;
+    NEXT_DocFonts = fnp;
+    return fnp->name;
+}
+
+int NEXT_pen_x, NEXT_pen_y;
+int NEXT_taken;
+int NEXT_linetype_last;
+TBOOLEAN NEXT_relative_ok;
+
+/* store settings passed to common_init() for use in NEXT_graphics()
+ * are reserved for storing the term options
+ */
+static int NEXT_common_uses_fonts;
+static unsigned int NEXT_common_xoff, NEXT_common_yoff;
+
+
+TERM_PUBLIC void
+NEXT_common_init(
+    int uses_fonts,		/* 0 for NEXT(la)tex */
+    unsigned int xoff, unsigned int yoff, /* offset  - 50 for /post, 0 for NEXT(la)tex */
+    unsigned int width, unsigned int height, /* for bounding box */
+    char **dict)		/* extra entries for the dictionary */
+{
+    static char GPFAR NEXTi1[] = "%%%%Creator: gnuplot\n\
+%%%%DocumentFonts: %s\n";
+    static char GPFAR NEXTi2[] = "%%%%EndComments\n\
+/gnudict 120 dict def\ngnudict begin\n\
+/Color %s def\n\
+/Solid %s def\n\
+/gnulinewidth %.3f def\n\
+/vshift %d def\n\
+/dl {%d mul} def\n\
+/hpt %.1f def\n\
+/vpt %.1f def\n";
+    static char GPFAR *NEXT_iso_8859_1_encoding[] =
+    {
+	"/reencodeISO {\n",
+	"dup dup findfont dup length dict begin\n",
+	"{ 1 index /FID ne { def }{ pop pop } ifelse } forall\n",
+	"/Encoding ISOLatin1Encoding def\n",
+	"currentdict end definefont\n",
+	"} def\n",
+	"/ISOLatin1Encoding [\n",
+	"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+	"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+	"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+	"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+	"/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright\n",
+	"/parenleft/parenright/asterisk/plus/comma/minus/period/slash\n",
+	"/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon\n",
+	"/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N\n",
+	"/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright\n",
+	"/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m\n",
+	"/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde\n",
+	"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+	"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+	"/.notdef/dotlessi/grave/acute/circumflex/tilde/macron/breve\n",
+	"/dotaccent/dieresis/.notdef/ring/cedilla/.notdef/hungarumlaut\n",
+	"/ogonek/caron/space/exclamdown/cent/sterling/currency/yen/brokenbar\n",
+	"/section/dieresis/copyright/ordfeminine/guillemotleft/logicalnot\n",
+	"/hyphen/registered/macron/degree/plusminus/twosuperior/threesuperior\n",
+	"/acute/mu/paragraph/periodcentered/cedilla/onesuperior/ordmasculine\n",
+	"/guillemotright/onequarter/onehalf/threequarters/questiondown\n",
+	"/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/AE/Ccedilla\n",
+	"/Egrave/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex\n",
+	"/Idieresis/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis\n",
+	"/multiply/Oslash/Ugrave/Uacute/Ucircumflex/Udieresis/Yacute\n",
+	"/Thorn/germandbls/agrave/aacute/acircumflex/atilde/adieresis\n",
+	"/aring/ae/ccedilla/egrave/eacute/ecircumflex/edieresis/igrave\n",
+	"/iacute/icircumflex/idieresis/eth/ntilde/ograve/oacute/ocircumflex\n",
+	"/otilde/odieresis/divide/oslash/ugrave/uacute/ucircumflex/udieresis\n",
+	"/yacute/thorn/ydieresis\n",
+	"] def\n",
+	NULL};
+
+
+    struct termentry *t = term;
+    int i;
+
+    NEXT_common_uses_fonts = uses_fonts;
+    NEXT_common_xoff = xoff;
+    NEXT_common_yoff = yoff;
+
+
+    NEXTPrintf("%%!NEXT-Adobe-2.0\n");
+
+    NEXTPrintf(NEXTi1, uses_fonts ? "(atend)" : "");
+
+    NEXTPrintf("%%%%BoundingBox: %d %d %d %d\n", xoff, yoff,
+	       (int) (xsize * width / NEXT_SC + 0.5 + xoff),
+	       (int) (ysize * height / NEXT_SC + 0.5 + yoff));
+
+    NEXTPrintf(NEXTi2,
+	       NEXT_color ? "true" : "false",
+	       NEXT_solid ? "true" : "false",
+	       NEXT_LW,		/* line width */
+	       (int) (t->v_char) / (-3),	/* shift for vertical centring */
+	       NEXT_SC,		/* dash length */
+	       NEXT_HTIC / 2.0,	/* half point width */
+	       NEXT_VTIC / 2.0);	/* half point height */
+
+    if (uses_fonts && (encoding == S_ENC_ISO8859_1)) {
+	for (i = 0; NEXT_iso_8859_1_encoding[i] != NULL; i++) {
+	    NEXTPrintf("%s", NEXT_iso_8859_1_encoding[i]);
+	}
+    }
+    for (i = 0; NEXT_header[i] != NULL; i++)
+	NEXTPrintf("%s", NEXT_header[i]);
+    if (NEXT_duplex_option)
+	NEXTPrintf("statusdict begin %s setduplexmode end\n",
+		   NEXT_duplex_state ? "true" : "false");
+    NEXT_RememberFont(NEXT_font);
+
+    if (dict)
+	while (*dict)
+	    NEXTPrintf("%s", *(dict++));
+
+    NEXTPrintf("end\n%%%%EndProlog\n");
+}
+
+/* the init fn for the NeXT Terminal driver */
+TERM_PUBLIC void
+NEXT_init()
+{
+
+    /* Initialize output string */
+    NEXTsize = DEFAULTNEXTSIZE;
+    if ((NEXTBuffer = malloc(NEXTsize)) == NULL) {
+	printf("Malloc error in next filter init\n");
+	exit(1);
+    }
+    NEXTBufEnd = NEXTBuffer + NEXTsize;
+    NEXTBufAt = NEXTBuffer;
+
+
+    term->xmax = NEXT_XMAX;
+    term->ymax = NEXT_YMAX;
+
+#ifdef NEXT_OLDTERMINAL
+    if (NEXT_oldterminal)
+	window_create();
+    else
+	gnuTermAccess =[[GnuTermDriver alloc] init];
+#else
+    gnuTermAccess =[[GnuTermDriver alloc] init];
+#endif
+
+
+
+}
+
+
+TERM_PUBLIC void
+NEXT_graphics()
+{
+    static char GPFAR NEXTg1[] = "0 setgray\nnewpath\n";
+    struct termentry *t = term;
+
+    *NEXTBuffer = 0;
+    NEXTBufAt = NEXTBuffer;
+
+    NEXT_common_init(1, NEXT_XOFF, NEXT_YOFF, term->xmax, term->ymax,
+		     ENHNEXT_header);
+
+    NEXTPrintf("gnudict begin\ngsave\n");
+    NEXTPrintf("%d %d translate\n", NEXT_common_xoff, NEXT_common_yoff);
+    NEXTPrintf("%.3f %.3f scale\n", 1.0 / NEXT_SC, 1.0 / NEXT_SC);
+
+
+    NEXTPrintf(NEXTg1);
+    if (NEXT_common_uses_fonts)
+	NEXTPrintf("(%s) findfont %d scalefont setfont\n", NEXT_font, (t->v_char));
+    NEXT_path_count = 0;
+    NEXT_relative_ok = FALSE;
+    NEXT_pen_x = NEXT_pen_y = -4000;
+    NEXT_taken = 0;
+    NEXT_linetype_last = LT_UNDEFINED;
+
+#ifdef NEXT_OLDTERMINAL
+    if (NEXT_oldterminal) {
+	/* Fill window with white */
+	NEXTPrintf("1 setgray\n");
+	NEXTPrintf("0 0 %d %d rectfill\n", NEXT_XMAX, NEXT_YMAX);
+	NEXTPrintf("0 setgray\n");
+    }
+#endif
+
+
+}
+
+
+TERM_PUBLIC void
+NEXT_text()
+{
+    static DPSContext d;
+
+    NEXT_path_count = 0;
+    NEXTPrintf("stroke\ngrestore\nend\n");
+
+    /* Terminate string */
+    *NEXTBufAt = 0;
+
+    if (NEXT_oldterminal) {
+	d = DPSGetCurrentContext();
+	DPSPrintf(d, NEXTBuffer);
+	DPSFlushContext(d);
+    } else {
+	/* Here's the call that dumps the string to the server */
+      [gnuTermAccess plot:NEXTBuffer];
+
+    }
+
+}
+
+
+TERM_PUBLIC void
+NEXT_reset()
+{
+    NEXTPrintf("%%%%Trailer\n");
+    if (!NEXT_common_uses_fonts) {
+	NEXTPrintf("%%%%DocumentFonts: ");
+	while (NEXT_DocFonts) {
+	    struct NEXT_FontName *fnp;
+	    fnp = NEXT_DocFonts->next;
+	    NEXTPrintf("%s%s", NEXT_DocFonts->name, fnp ? ", " : "\n");
+	    free(NEXT_DocFonts->name);
+	    free(NEXT_DocFonts);
+	    NEXT_DocFonts = fnp;
+	}
+    }
+}
+
+
+TERM_PUBLIC void
+NEXT_linetype(int linetype)
+{
+    linetype = (linetype % 9) + 2;
+    if (linetype < 0)
+	linetype = 0;
+    NEXT_relative_ok = FALSE;
+    if (NEXT_linetype_last == linetype)
+	return;
+    NEXT_linetype_last = linetype;
+    NEXTPrintf("LT%c\n", "ba012345678"[linetype]);
+    NEXT_path_count = 0;
+}
+
+
+TERM_PUBLIC void
+NEXT_move(unsigned int x, unsigned int y)
+{
+    int dx, dy;
+    char abso[20], rel[20];
+    dx = x - NEXT_pen_x;
+    dy = y - NEXT_pen_y;
+    /* can't cancel all null moves--need a move after stroke'ing */
+    if (dx == 0 && dy == 0 && NEXT_relative_ok)
+	return;
+    sprintf(abso, "%d %d M\n", x, y);
+    sprintf(rel, "%d %d R\n", dx, dy);
+    if (strlen(rel) < strlen(abso) && NEXT_relative_ok) {
+	NEXTPrintf("%s", rel);
+	NEXT_taken++;
+    } else
+	NEXTPrintf("%s", abso);
+    NEXT_relative_ok = TRUE;
+    NEXT_path_count += 1;
+
+    NEXT_pen_x = x;
+    NEXT_pen_y = y;
+}
+
+TERM_PUBLIC void
+NEXT_vector(unsigned int x, unsigned int y)
+{
+    int dx, dy;
+    char abso[20], rel[20];
+    dx = x - NEXT_pen_x;
+    dy = y - NEXT_pen_y;
+    if (dx == 0 && dy == 0)
+	return;
+    sprintf(abso, "%d %d L\n", x, y);
+    sprintf(rel, "%d %d V\n", dx, dy);
+    if (strlen(rel) < strlen(abso) && NEXT_relative_ok) {
+	NEXTPrintf("%s", rel);
+	NEXT_taken++;
+    } else
+	NEXTPrintf("%s", abso);
+    NEXT_relative_ok = TRUE;
+    NEXT_path_count += 1;
+    NEXT_pen_x = x;
+    NEXT_pen_y = y;
+    if (NEXT_path_count >= 400) {
+	NEXTPrintf("currentpoint stroke M\n");
+	NEXT_path_count = 0;
+    }
+}
+
+
+
+
+TERM_PUBLIC int
+NEXT_text_angle(int ang)
+{
+    NEXT_ang = ang;
+    return TRUE;
+}
+
+
+TERM_PUBLIC int
+NEXT_justify_text(enum JUSTIFY mode)
+{
+    NEXT_justify = mode;
+    return TRUE;
+}
+
+
+TERM_PUBLIC int
+NEXT_set_font(const char *font)
+{
+    char name[32];
+    int size, sep;
+
+    if (!font || !(*font))
+	font = NEXT_default_font;
+    sep = strcspn(font, ",");
+    strncpy(name, font, sep);
+    name[sep] = NUL;
+    size = NEXT_fontsize;
+    if (font[set] == ',')
+	sscanf(&(font[sep + 1]), "%d", &size);
+    NEXTPrintf("/%s findfont %d scalefont setfont\n", name, size * NEXT_SC);
+    NEXT_RememberFont(name);
+    term->v_char = (unsigned int) (size * NEXT_SC);
+    term->h_char = (unsigned int) (size * NEXT_SC * 6 / 10);
+    return TRUE;
+}
+
+
+/* postscript point routines */
+
+TERM_PUBLIC void
+NEXT_set_pointsize(double size)
+{
+    NEXTPrintf("/vpt %.1f def /hpt %.1f def /vpt2 vpt 2 mul def /hpt2 hpt 2 mul def\n",
+	       pointsize * NEXT_VTIC * 0.5, pointsize * NEXT_HTIC * 0.5);
+}
+
+TERM_PUBLIC void
+NEXT_point(unsigned int x, unsigned int y, int number)
+{
+    static char *pointFNS[] =
+    {"Pnt", "Pls", "Crs", "Star",
+     "Box", "BoxF", "Circle", "CircleF",
+     "TriU", "TriUF", "TriD", "TriDF",
+     "Dia", "DiaF", "Pent", "PentF",
+     "C0", "C1", "C2", "C3",
+     "C4", "C5", "C6", "C7",
+     "C8", "C9", "C10", "C11",
+     "C12", "C13", "C14", "C15",
+     "S0", "S1", "S2", "S3",
+     "S4", "S5", "S6", "S7",
+     "S8", "S9", "S10", "S11",
+     "S12", "S13", "S14", "S15",
+     "D0", "D1", "D2", "D3",
+     "D4", "D5", "D6", "D7",
+     "D8", "D9", "D10", "D11",
+     "D12", "D13", "D14", "D15"
+    };
+    if (number < 0)
+	number = -1;		/* negative types are all 'dot' */
+    else
+	number %= sizeof(pointFNS) / sizeof(pointFNS[0]) - 1;
+    NEXTPrintf("%d %d %s\n", x, y, pointFNS[number + 1]);
+
+    NEXT_relative_ok = 0;
+    NEXT_path_count = 0;
+    NEXT_linetype_last = LT_UNDEFINED;	/* force next linetype change */
+}
+
+
+
+
+/* All lifted from the enhanced postscript driver */
+
+
+
+static TBOOLEAN NEXT_opened_string;	/* try to cut out empty ()'s */
+
+/* used in determining height of processed text */
+
+static float NEXT_max_height, NEXT_min_height;
+
+
+/* process a bit of string, and return the last character used.
+ * p is start of string
+ * brace is TRUE to keep processing to }, FALSE for do one character
+ * fontname & fontsize are obvious
+ * base is the current baseline
+ * widthflag is TRUE if the width of this should count,
+ *              FALSE for zero width boxes
+ */
+
+static char *
+NEXT_recurse(
+    char *p,
+    TBOOLEAN brace,
+    char *fontname,
+    double fontsize, double base,
+    TBOOLEAN widthflag)
+{
+
+/* close a postscript string if it has been opened */
+#define NEXT_FLUSH      \
+{	if (NEXT_opened_string)  \
+	{	NEXTPrintf("%s", ")]\n");   \
+		NEXT_opened_string = FALSE; \
+	}                         \
+}
+
+#define NEXT_OPEN	\
+{	if (!NEXT_opened_string) \
+	{ NEXTPrintf( "[(%s) %.1f %.1f %s (",  \
+		  fontname, fontsize, base, \
+		  widthflag ? "true" : "false");  \
+	  NEXT_opened_string = TRUE; \
+	}	\
+}
+
+
+    /* Start each recursion with a clean string */
+    NEXT_FLUSH;
+
+	if (base + fontsize > NEXT_max_height) {
+	NEXT_max_height = base + fontsize;
+    }
+    if (base < NEXT_min_height) {
+	NEXT_min_height = base;
+    }
+    for (; *p; ++p) {
+	float shift;
+	float f = 0;		/* used for getting new font size */
+	char *localfontname, ch;
+
+	switch (*p) {
+	case '}':
+	    if (brace)
+		return (p);
+
+	    fprintf(stderr, "next driver - spurious }\n");
+	    break;
+
+	case '_':
+	case '^':
+	    shift = (*p == '^') ? 0.5 : -0.3;
+
+	    NEXT_FLUSH;
+
+		p = NEXT_recurse(p + 1, FALSE, fontname, fontsize * 0.8,
+				 base + shift * fontsize, widthflag);
+
+	    break;
+
+	case '{':
+	    /*{{{  recurse (possibly with a new font) */
+
+	    if (*++p == '/') {	/* then parse a fontname, optional fontsize */
+		while (*++p == ' ');
+		localfontname = p;
+		while ((ch = *p) > ' ' && ch != '=')
+		    ++p;
+		if (ch == '=') {
+		    *p++ = '\0';
+		    /*{{{  get optional font size */
+		    f = (float) strtod(p, &p);
+
+		    if (f)
+			f *= NEXT_SC;	/* remember the scaling */
+		    else
+			f = fontsize;
+
+		    /*}}} */
+		} else {
+		    *p++ = '\0';
+		    f = fontsize;
+		}
+
+		while (*p == ' ')
+		    ++p;
+		if (*localfontname)
+		    localfontname = NEXT_RememberFont(localfontname);
+		else
+		    localfontname = fontname;
+	    } else {
+		localfontname = fontname;
+		f = fontsize;
+	    }
+	    /*}}} */
+
+
+	    p = NEXT_recurse(p, TRUE, localfontname, f, base, widthflag);
+
+
+	    NEXT_FLUSH
+
+		break;
+
+	case '@':
+	    /*{{{  phantom box - prints next 'char', then restores currentpoint */
+
+	    NEXT_FLUSH
+
+		p = NEXT_recurse(++p, FALSE, fontname, fontsize, base, FALSE);
+
+	    break;
+	    /*}}} */
+
+	case '(':
+	case ')':
+	    /* special cases */
+	    NEXT_OPEN
+		NEXTPrintf("\\");
+	    NEXTPrintf("%c", *p);
+	    break;
+	    /*}}} */
+
+	case '\\':
+	    /*{{{  is it an escape */
+	    /* special cases */
+
+	    if (p[1] == '\\' || p[1] == '(' || p[1] == ')') {
+		NEXT_OPEN
+		    NEXTPrintf("%c", '\\');
+	    } else if ((ch = p[1]) >= '0' && ch <= '7') {
+		/* up to 3 octal digits */
+		NEXT_OPEN
+		    NEXTPrintf("%c", '\\');
+		NEXTPrintf("%c", ch);
+		++p;
+		if ((ch = p[1]) >= '0' && ch <= '7') {
+		    NEXTPrintf("%c", ch);
+		    ++p;
+		    if ((ch = p[1]) >= '0' && ch <= '7') {
+			NEXTPrintf("%c", ch);
+			++p;
+		    }
+		}
+		break;
+	    }
+	    ++p;
+	    /* just go and print it (fall into the 'default' case) */
+
+	    /*}}} */
+	default:
+	    NEXT_OPEN
+
+		NEXTPrintf("%c", *p);
+	}
+
+	/* like TeX, we only do one character in a recursion, unless it's
+	 * in braces
+	 */
+
+	if (!brace) {
+	    NEXT_FLUSH
+		return (p);	/* the ++p in the outer copy will increment us */
+	}
+    }
+    NEXT_FLUSH
+	return p;
+}
+
+
+TERM_PUBLIC void
+NEXT_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    /* flush any pending graphics (all the XShow routines do this...) */
+
+    if (!strlen(str))
+	return;
+
+    if (NEXT_path_count) {
+	NEXTPrintf(" stroke\n");
+	NEXT_path_count = 0;
+	NEXT_relative_ok = FALSE;
+    }
+    NEXT_move(x, y);
+
+    if (NEXT_ang != 0)
+	NEXTPrintf("currentpoint gsave translate %d rotate 0 0 moveto\n",
+		   NEXT_ang);
+
+    NEXTPrintf("[ ");
+
+    /* set up the globals */
+
+    NEXT_opened_string = FALSE;
+    NEXT_max_height = -1000;
+    NEXT_min_height = 1000;
+
+    while (*(str = NEXT_recurse(str, TRUE, NEXT_font,
+				(double) term->v_char,
+				0.0, TRUE)));
+
+    NEXT_max_height += NEXT_min_height;
+
+    NEXTPrintf("] %.1f ", -NEXT_max_height / 3);
+
+    switch (NEXT_justify) {
+    case LEFT:
+	NEXTPrintf("MLshow\n");
+	break;
+    case CENTRE:
+	NEXTPrintf("MCshow\n");
+	break;
+    case RIGHT:
+	NEXTPrintf("MRshow\n");
+	break;
+    }
+
+    if (NEXT_ang != 0)
+	NEXTPrintf("grestore\n");
+    NEXT_path_count = 0;
+    NEXT_relative_ok = FALSE;
+}
+
+
+
+/*
+static TBOOLEAN
+NEXT_colordetect()
+{
+	NXScreen * mainscreen;
+
+	mainscreen = [Application mainScreen];
+	if (mainscreen->depth == NX_TwoBitGrayDepth) return(FALSE);
+	return(TRUE);
+}
+*/
+
+	/* This just packs all the postscript into one (possibly huge) string
+	 * which will be passed (as a fake pointer) via D.O. to the server
+	 */
+
+void
+NEXTPrintf(char *fmt,...)
+{
+    va_list ap;
+    char *pb;
+    int NEXToff;
+
+    /* Process formatting instructions */
+    va_start(ap, fmt);
+    vsprintf(NEXTTmpBuf, fmt, ap);
+    va_end(ap);
+
+    /* Add to buffer */
+    for (pb = NEXTTmpBuf; (*pb != 0); ++pb, ++NEXTBufAt) {
+	/* reallocate if necessary */
+	if (NEXTBufAt >= NEXTBufEnd) {
+	    NEXToff = NEXTBufAt - NEXTBuffer;
+	    NEXTsize *= 2;
+	    NEXTBuffer = realloc(NEXTBuffer, NEXTsize);
+	    NEXTBufEnd = NEXTBuffer + NEXTsize;
+	    NEXTBufAt = NEXTBuffer + NEXToff;
+	}
+	*NEXTBufAt = *pb;
+    }
+
+    return;
+
+}
+
+/*  This next section implements the GnuTermDriver object which manages
+	the D.O. connection and interface to OBjC
+*/
+
+
+@protocol GnuTermServerMethods
+/*- (oneway) executePScode:(in char *)PStext termTitle:(in char *)title;*/
+- executePScode:(in char *)
+PStext termTitle:(in char *) title;
+@end
+
+
+@implementation GnuTermDriver
+
+- init
+{
+    NXConnection *myConnection;
+    char serverpath[100], *envstring;
+    int GnuTermPathSet = 0;
+
+
+    /* Ask OS for connection to server */
+  server =[NXConnection connectToName:"gnuplotServer"];
+
+    /* Server is running ready to go */
+    if (server)			/*printf("Connected to server\n") */
+	;
+
+    /* Server isn't running, we must fire it up */
+    else {
+	/*printf("Launching GnuTerm\n"); */
+	*serverpath = 0;
+
+	/* Check for path set in environment */
+	if ((envstring = getenv("GNUTERMPATH")) != (char *) NULL) {
+	    sprintf(serverpath, "%s/GnuTerm.app/GnuTerm", envstring);
+	    GnuTermPathSet = 1;
+	}
+	/* Not in environment */
+	else
+	    strcpy(serverpath, "GnuTerm");
+
+	/* Try to launch application */
+      if ([[Application workspace] launchApplication:serverpath] == NO) {
+	    printf("Failed to launch %s.\n", serverpath);
+	    /* Offer a little advice */
+	    if (GnuTermPathSet) {
+		printf("You must have setenv GNUTERMPATH to something wrong\n");
+		printf("I recommend you exit gnuplot and fix this.\n");
+	    } else {
+		printf("It must be located in ~/Apps or /LocalApps\n");
+		printf("I recommend that you either\n");
+		printf("- move GnuTerm.app to one of these locations\n");
+		printf("- set GNUTERMPATH with host%%  setenv GNUTERMPATH /directory/containing_GnuTerm.app\n");
+		printf("- start GnuTerm ahead of the first plot command\n");
+#ifdef NEXT_OLDTERMINAL
+		printf("- use the old driver version (set term next old)\n");
+#endif
+	    }
+	}
+	/* I wish the gnuplot terminal interface would
+	   let me return an error here.
+	 */
+
+	/* Application is launching */
+	else {
+	    /* Wait for it to register Server methods with OS */
+	    do {
+	      server =[NXConnection connectToName:"gnuplotServer"];
+	    } while (!server);	/* This could result in a hang,
+				   but I've never seen it fail */
+	}
+    }
+
+
+    /* By limiting ourselves to known protocol
+     * we speed up the messaging
+     */
+  [server setProtocolForProxy:@protocol(GnuTermServerMethods)];
+
+    myConnection =[server connectionForProxy];
+
+    /* If the server dies we want to know about it */
+  [myConnection registerForInvalidationNotification:self];
+    /* In fact, we'll worry about it */
+    [NXPort worryAboutPortInvalidation];
+
+    return self;
+}
+
+
+-plot:(char *) PSstr;
+{
+    /* If server has become invalid, re-initialize */
+    if (!server)
+	[self init];
+
+    /* This is where we send the huge postscript string to the server
+       Note:
+       The D.O. system doesn't actually give this pointer to the server.
+       The pointer is dereferenced on the client side and the
+       resulting data is sent to the server. On the server side,
+       space for the data is automatically allocated, and a pointer to
+       the local data is received.
+       For details check out:
+       /NextLibrary/Documentation/NextDev/GeneralRef/06_DistributedObjects/IntroDistObjects.rtf
+     */
+
+    /*printf("Calling server..."); */
+  [server executePScode: PSstr termTitle:NEXT_title];
+    /*printf("returned\n"); */
+    *NEXT_title = 0;
+
+    return self;
+}
+
+							/* This gets called by OS if server goes down */
+-senderIsInvalid:(id) sender
+{
+    server = 0;
+}
+
+@end
+
+#ifdef NEXT_OLDTERMINAL
+
+static void
+window_create()
+{
+    float width, height;
+
+    width = (xsize * (NEXT_XMAX) / NEXT_SC + 0.5 + NEXT_XOFF);
+    height = (ysize * (NEXT_YMAX) / NEXT_SC + 0.5 + NEXT_YOFF);
+
+    NXApp =[EpsViewer new];
+  [NXApp windowCreate: width Height:height];
+}
+
+@implementation EpsViewer
+
+- windowCreate:(NXCoord)
+width Height:(NXCoord) height
+{
+
+    /* create the new window, in a good place */
+    theNewWin =[Window
+  newContent: [self nextRectForWidth: width Height:height]
+  style:	NX_TITLEDSTYLE
+  backing:	NX_RETAINED
+  buttonMask:	(NX_CLOSEBUTTONMASK | NX_MINIATURIZEBUTTONMASK)
+  defer:	NO];
+    /* we need to receive windowDidBecomeMain: and windowDidResignMain: */
+  [theNewWin setDelegate:self];
+    /*
+     * create a new View, make it the contentView of our new window,
+     * and destroy the window's old contentView
+     */
+  [[theNewWin setContentView:[[View alloc] init]] free];
+    /* display the window, and bring it forth */
+    [theNewWin display];
+  [theNewWin makeKeyAndOrderFront:self];
+/*	[theNewWin orderBack:self];			*/
+    /* show the frame */
+    return self;
+}
+
+/***************************************************************************/
+/* nextRectForWidth:Height: - return the next good content rectangle       */
+/*  from Carl F. Sutter's wonderful ViewGif2 'Controller' method...        */
+/***************************************************************************/
+/* nextTopLeft - return the next good top left window position		   */
+/***************************************************************************/
+
+-(NXRect *) nextRectForWidth:(NXCoord)
+width Height:(NXCoord) height
+{
+#define OFFSET 10.0
+#define MAX_STEPS 20
+#define INITIAL_X 356.0
+#define INITIAL_Y 241.0
+    NXPoint nxpTopLeft;
+    NXRect nxrTemp;		/* used to find window height    */
+    NXRect nxrWinHeight;	/* bounds of enclosing window    */
+    NXSize nxsScreen;		/* size of screen                */
+    static NXRect nxrResult;	/* the Answer!                   */
+    static int nCurStep = 0;
+
+    /* find a good top-left coord */
+    nxpTopLeft.x = INITIAL_X + nCurStep * OFFSET;
+    nxpTopLeft.y = INITIAL_Y + nCurStep * OFFSET;
+    if (++nCurStep > MAX_STEPS)
+	nCurStep = 0;
+    /* find window height using nxrTemp */
+    nxrTemp.size.width = width;
+    nxrTemp.size.height = height;
+    nxrTemp.origin.x = nxrTemp.origin.y = 0;
+  [Window getFrameRect: &nxrWinHeight forContentRect:&nxrTemp
+  style:NX_TITLEDSTYLE];
+  [NXApp getScreenSize:&nxsScreen];
+    /* find the lower-left coord */
+    nxrResult.origin.x = nxpTopLeft.x;
+    nxrResult.origin.y = nxsScreen.height - nxrWinHeight.size.height - nxpTopLeft.y;
+    nxrResult.size.width = width;
+    nxrResult.size.height = height;
+    return (&nxrResult);
+}
+
+@end
+#endif /* NEXT_OLDTERMINAL */
+
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+
+TERM_TABLE_START(next_driver)
+    "next",
+    "Interface to GnuTerm.app under NeXTstep",
+    NEXT_XMAX, NEXT_YMAX, NEXT_VCHAR, NEXT_HCHAR,
+    NEXT_VTIC, NEXT_HTIC, NEXT_options, NEXT_init, NEXT_reset,
+    NEXT_text, null_scale, NEXT_graphics, NEXT_move, NEXT_vector,
+    NEXT_linetype, NEXT_put_text, NEXT_text_angle,
+    NEXT_justify_text, NEXT_point, do_arrow, NEXT_set_font,
+    NEXT_set_pointsize
+TERM_TABLE_END(next_driver)
+
+#undef LAST_TERM
+#define LAST_TERM next_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+
+#define TERM_HELP_NEXT
+
+#ifdef TERM_HELP
+START_HELP(next)
+"1 next",
+"?commands set terminal next",
+"?set terminal next",
+"?set term next",
+"?terminal next",
+"?term next",
+"?next",
+"?NeXT",
+" Several options may be set in the next driver.",
+"",
+" Syntax:",
+"       set terminal next {<mode>} {<type> } {<color>} {<dashed>}",
+"                  {\"<fontname>\"} {<fontsize>} title {\"<newtitle>\"}",
+"",
+" where <mode> is  `default`, which sets all options to their defaults;",
+" <type> is either `new` or `old`, where `old` invokes the old single window;",
+" <color> is either `color` or `monochrome`;",
+" <dashed> is either `solid` or `dashed`;",
+" \"<fontname>\" is the name of a valid PostScript font;",
+" <fontsize> is the size of the font in PostScript points; and",
+" <title> is the title for the GnuTerm window.",
+" Defaults are  `new`, `monochrome`, `dashed`, \"Helvetica\", 14pt.",
+"",
+" Examples:",
+"       set term next default",
+"       set term next 22",
+"       set term next color \"Times-Roman\" 14",
+"       set term next color \"Helvetica\" 12 title \"MyPlot\"",
+"       set term next old",
+"",
+" Pointsizes may be changed with `set linestyle`."
+END_HELP(next)
+#endif /* TERM_HELP */
+
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/object.h.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/object.h.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/object.h.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/object.h.svn-base	2012-01-03 17:07:41.090537300 -0800
@@ -0,0 +1,419 @@
+/*
+ * FIG : Facility for Interactive Generation of figures
+ * Copyright (c) 1985 by Supoj Sutanthavibul
+ * Parts Copyright (c) 1994 by Brian V. Smith
+ * Parts Copyright (c) 1991 by Paul King
+ *
+ * The X Consortium, and any party obtaining a copy of these files from
+ * the X Consortium, directly or indirectly, is granted, free of charge, a
+ * full and unrestricted irrevocable, world-wide, paid up, royalty-free,
+ * nonexclusive right and license to deal in this software and
+ * documentation files (the "Software"), including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons who receive
+ * copies from any such party to do so, with the only requirement being
+ * that this copyright notice remain intact.  This license includes without
+ * limitation a license to do the foregoing actions under any patents of
+ * the party supplying this software to the X Consortium.
+ */
+
+/* This file has been modified for use with Gnuplot 3.6 by
+ * Ian MacPhedran.
+ */
+
+/* DEFAULT is used for many things - font, color etc */
+
+#define		DEFAULT		      (-1)
+#define		SOLID_LINE		0
+#define		DASH_LINE		1
+#define		DOTTED_LINE		2
+#define		RUBBER_LINE		3
+#define		PANEL_LINE		4
+
+#define		Color			int
+
+#define		BLACK			0
+#define		BLUE			1
+#define		GREEN			2
+#define		CYAN			3
+#define		RED			4
+#define		MAGENTA			5
+#define		YELLOW			6
+#define		WHITE			7
+
+/** VERY IMPORTANT:  The f_line, f_spline and f_arc objects all must have the
+		components up to and including the arrows in the same order.
+		This is for the get/put_generic_arrows() in e_edit.c.
+**/
+
+typedef struct f_point {
+    int		    x, y;
+}
+		F_point;
+
+typedef struct f_pos {
+    int		    x, y;
+}
+		F_pos;
+
+#define DEF_ARROW_WID (4 * ZOOM_FACTOR)
+#define DEF_ARROW_HT (8 * ZOOM_FACTOR)
+
+typedef struct f_arrow {
+    int		    type;
+    int		    style;
+    float	    thickness;
+    float	    wid;
+    float	    ht;
+}
+		F_arrow;
+
+typedef struct f_ellipse {
+    int		    tagged;
+    int		    distrib;
+    int		    type;
+#define					T_ELLIPSE_BY_RAD	1
+#define					T_ELLIPSE_BY_DIA	2
+#define					T_CIRCLE_BY_RAD		3
+#define					T_CIRCLE_BY_DIA		4
+    int		    style;
+    int		    thickness;
+    Color	    pen_color;
+    Color	    fill_color;
+    int		    fill_style;
+    int		    depth;
+    float	    style_val;
+    int		    pen_style;
+    float	    angle;
+    int		    direction;
+#define					UNFILLED	-1
+    struct f_pos    center;
+    struct f_pos    radiuses;
+    struct f_pos    start;
+    struct f_pos    end;
+    struct f_ellipse *next;
+}
+		F_ellipse;
+
+/* SEE NOTE AT TOP BEFORE CHANGING ANYTHING IN THE f_arc STRUCTURE */
+
+typedef struct f_arc {
+    int		    tagged;
+    int		    distrib;
+    int		    type;
+				/* note: these arc types are the internal values */
+				/* in the file, they are open=1, wedge=2 */
+#define					T_OPEN_ARC		0
+#define					T_PIE_WEDGE_ARC		1
+    int		    style;
+    int		    thickness;
+    Color	    pen_color;
+    Color	    fill_color;
+    int		    fill_style;
+    int		    depth;
+    int		    pen_style;
+    struct f_arrow *for_arrow;
+    struct f_arrow *back_arrow;
+/* THE PRECEDING VARS MUST BE IN THE SAME ORDER IN f_arc, f_line and f_spline */
+    int		    cap_style;
+    float	    style_val;
+    int		    direction;
+    struct {
+	float		x, y;
+    }		    center;
+    struct f_pos    point[3];
+    struct f_arc   *next;
+}
+		F_arc;
+
+#define		CLOSED_PATH		0
+#define		OPEN_PATH		1
+#define		DEF_BOXRADIUS		7
+#define		DEF_DASHLENGTH		4
+#define		DEF_DOTGAP		3
+
+typedef struct f_pic {
+#ifndef PATH_MAX
+#define PATH_MAX 128
+#endif
+    char	    file[PATH_MAX];
+    int		    subtype;
+#define T_PIC_EPS	1
+#define T_PIC_BITMAP	2
+#define T_PIC_PIXMAP	3
+#define T_PIC_GIF	4
+#define FileInvalid	-2
+    int		    flipped;
+    unsigned char   *bitmap;
+    int		    numcols;		/* number of colors in cmap */
+    float	    hw_ratio;
+    int		    size_x, size_y;	/* fig units */
+    struct f_pos    bit_size;		/* pixels */
+    Color	    color;		/* only used for XBM */
+    int		    pix_rotation, pix_width, pix_height, pix_flipped;
+}
+		F_pic;
+
+extern char	EMPTY_PIC[];
+
+/* SEE NOTE AT TOP BEFORE CHANGING ANYTHING IN THE f_line STRUCTURE */
+
+typedef struct f_line {
+    int		    tagged;
+    int		    distrib;
+    int		    type;
+#define					T_POLYLINE	1
+#define					T_BOX		2
+#define					T_POLYGON	3
+#define					T_ARC_BOX	4
+#define					T_PIC_BOX	5
+    int		    style;
+    int		    thickness;
+    Color	    pen_color;
+    Color	    fill_color;
+    int		    fill_style;
+    int		    depth;
+    int		    pen_style;
+    struct f_arrow *for_arrow;
+    struct f_arrow *back_arrow;
+/* THE PRECEDING VARS MUST BE IN THE SAME ORDER IN f_arc, f_line and f_spline */
+    int		    cap_style;		/* line cap style - Butt, Round, Bevel */
+#define					CAP_BUTT	0
+#define					CAP_ROUND	1
+#define					CAP_PROJECT	2
+    struct f_point *points;	/* this must immediately follow cap_style */
+    int		    join_style;		/* join style - Miter, Round, Bevel */
+#define					JOIN_MITER	0
+#define					JOIN_ROUND	1
+#define					JOIN_BEVEL	2
+    float	    style_val;
+    int		    radius;		/* corner radius for T_ARC_BOX */
+    struct f_pic   *pic;
+    struct f_line  *next;
+}
+		F_line;
+
+typedef struct f_text {
+    int		    tagged;
+    int		    distrib;
+    int		    type;
+#define					T_LEFT_JUSTIFIED	0
+#define					T_CENTER_JUSTIFIED	1
+#define					T_RIGHT_JUSTIFIED	2
+    int		    font;
+/*    PIX_FONT	    fontstruct; */
+    int		    size;	/* point size */
+    Color	    color;
+    int		    depth;
+    float	    angle;	/* in radians */
+
+    int		    flags;
+#define					RIGID_TEXT		1
+#define					SPECIAL_TEXT		2
+#define					PSFONT_TEXT		4
+#define					HIDDEN_TEXT		8
+
+    int		    ascent;	/* Fig units */
+    int		    length;	/* Fig units */
+    int		    descent;	/* from XTextExtents(), not in file */
+    int		    base_x;
+    int		    base_y;
+    int		    pen_style;
+    char	   *cstring;
+    struct f_text  *next;
+}
+		F_text;
+
+#define MAXFONT(T) (psfont_text(T) ? NUM_FONTS : NUM_LATEX_FONTS)
+
+#define		rigid_text(t) \
+			(t->flags == DEFAULT \
+				|| (t->flags & RIGID_TEXT))
+
+#define		special_text(t) \
+			((t->flags != DEFAULT \
+				&& (t->flags & SPECIAL_TEXT)))
+
+#define		psfont_text(t) \
+			(t->flags != DEFAULT \
+				&& (t->flags & PSFONT_TEXT))
+
+#define		hidden_text(t) \
+			(t->flags != DEFAULT \
+				&& (t->flags & HIDDEN_TEXT))
+
+#define		text_length(t) \
+			(hidden_text(t) ? hidden_text_length : t->length)
+
+#define		using_ps	(cur_textflags & PSFONT_TEXT)
+
+typedef struct f_control {
+    float	    lx, ly, rx, ry;
+    struct f_control *next;
+}
+		F_control;
+
+/* SEE NOTE AT TOP BEFORE CHANGING ANYTHING IN THE f_spline STRUCTURE */
+
+#define		int_spline(s)		(s->type & 0x2)
+#define		normal_spline(s)	(!(s->type & 0x2))
+#define		closed_spline(s)	(s->type & 0x1)
+#define		open_spline(s)		(!(s->type & 0x1))
+
+typedef struct f_spline {
+    int		    tagged;
+    int		    distrib;
+    int		    type;
+#define					T_OPEN_NORMAL	0
+#define					T_CLOSED_NORMAL 1
+#define					T_OPEN_INTERP	2
+#define					T_CLOSED_INTERP 3
+    int		    style;
+    int		    thickness;
+    Color	    pen_color;
+    Color	    fill_color;
+    int		    fill_style;
+    int		    depth;
+    int		    pen_style;
+    struct f_arrow *for_arrow;
+    struct f_arrow *back_arrow;
+/* THE PRECEDING VARS MUST BE IN THE SAME ORDER IN f_arc, f_line and f_spline */
+    int		    cap_style;
+    /*
+     * For T_OPEN_NORMAL and T_CLOSED_NORMAL points are control points while
+     * they are knots for T_OPEN_INTERP and T_CLOSED_INTERP whose control
+     * points are stored in controls.
+     */
+    struct f_point *points;	/* this must immediately follow cap_style */
+    float	    style_val;
+    struct f_control *controls;
+    struct f_spline *next;
+}
+		F_spline;
+
+typedef struct f_compound {
+    int		    tagged;
+    int		    distrib;
+    struct f_pos    nwcorner;
+    struct f_pos    secorner;
+    struct f_line  *lines;
+    struct f_ellipse *ellipses;
+    struct f_spline *splines;
+    struct f_text  *texts;
+    struct f_arc   *arcs;
+    struct f_compound *compounds;
+    struct f_compound *next;
+}
+		F_compound;
+
+typedef struct f_linkinfo {
+    struct f_line  *line;
+    struct f_point *endpt;
+    struct f_point *prevpt;
+    int		    two_pts;
+    struct f_linkinfo *next;
+}
+		F_linkinfo;
+
+/* separate the "type" and the "style" from the cur_arrowtype */
+#define		ARROW_TYPE(x)	((x)==0? 0 : ((x)+1)/2)
+#define		ARROW_STYLE(x)	((x)==0? 0 : ((x)+1)%2)
+
+#define		ARROW_SIZE	sizeof(struct f_arrow)
+#define		POINT_SIZE	sizeof(struct f_point)
+#define		CONTROL_SIZE	sizeof(struct f_control)
+#define		ELLOBJ_SIZE	sizeof(struct f_ellipse)
+#define		ARCOBJ_SIZE	sizeof(struct f_arc)
+#define		LINOBJ_SIZE	sizeof(struct f_line)
+#define		TEXOBJ_SIZE	sizeof(struct f_text)
+#define		SPLOBJ_SIZE	sizeof(struct f_spline)
+#define		COMOBJ_SIZE	sizeof(struct f_compound)
+#define		PIC_SIZE	sizeof(struct f_pic)
+#define		LINKINFO_SIZE	sizeof(struct f_linkinfo)
+
+/**********************  object codes  **********************/
+
+#define		O_COLOR_DEF	0
+#define		O_ELLIPSE	1
+#define		O_POLYLINE	2
+#define		O_SPLINE	3
+/* HBB 990329: quick hack: 'O_TEXT' is in use by <fcntl.h> header
+ * on DOS/Windows platforms. Renamed to OBJ_TEXT */
+#define         OBJ_TEXT          4
+#define		O_ARC		5
+#define		O_COMPOUND	6
+#define		O_END_COMPOUND	-O_COMPOUND
+#define		O_ALL_OBJECT	99
+
+/********************* object masks for update  ************************/
+
+#define M_NONE			0x000
+#define M_POLYLINE_POLYGON	0x001
+#define M_POLYLINE_LINE		0x002
+#define M_POLYLINE_BOX		0x004	/* includes ARCBOX */
+#define M_SPLINE_O_NORMAL	0x008
+#define M_SPLINE_C_NORMAL	0x010
+#define M_SPLINE_O_INTERP	0x020
+#define M_SPLINE_C_INTERP	0x040
+#define M_TEXT_NORMAL		0x080
+#define M_TEXT_HIDDEN		0x100
+#define M_ARC			0x200
+#define M_ELLIPSE		0x400
+#define M_COMPOUND		0x800
+
+#define M_TEXT		(M_TEXT_HIDDEN | M_TEXT_NORMAL)
+#define M_SPLINE_O	(M_SPLINE_O_NORMAL | M_SPLINE_O_INTERP)
+#define M_SPLINE_C	(M_SPLINE_C_NORMAL | M_SPLINE_C_INTERP)
+#define M_SPLINE_NORMAL (M_SPLINE_O_NORMAL | M_SPLINE_C_NORMAL)
+#define M_SPLINE_INTERP (M_SPLINE_O_INTERP | M_SPLINE_C_INTERP)
+#define M_SPLINE	(M_SPLINE_NORMAL | M_SPLINE_INTERP)
+#define M_POLYLINE	(M_POLYLINE_LINE | M_POLYLINE_POLYGON | M_POLYLINE_BOX)
+#define M_VARPTS_OBJECT (M_POLYLINE_LINE | M_POLYLINE_POLYGON | M_SPLINE)
+#define M_OPEN_OBJECT	(M_POLYLINE_LINE | M_SPLINE_O | M_ARC)
+#define M_ROTATE_ANGLE	(M_VARPTS_OBJECT | M_ARC | M_TEXT | M_COMPOUND | M_ELLIPSE)
+#define M_ELLTEXTANGLE	(M_ELLIPSE | M_TEXT)
+#define M_OBJECT	(M_ELLIPSE | M_POLYLINE | M_SPLINE | M_TEXT | M_ARC)
+#define M_NO_TEXT	(M_ELLIPSE | M_POLYLINE | M_SPLINE | M_COMPOUND | M_ARC)
+#define M_ALL		(M_OBJECT | M_COMPOUND)
+
+/************************  Objects  **********************/
+
+extern F_compound objects;
+
+/************  global working pointers ************/
+
+extern F_line		*cur_l, *new_l, *old_l;
+extern F_arc		*cur_a, *new_a, *old_a;
+extern F_ellipse	*cur_e, *new_e, *old_e;
+extern F_text		*cur_t, *new_t, *old_t;
+extern F_spline		*cur_s, *new_s, *old_s;
+extern F_compound	*cur_c, *new_c, *old_c;
+extern F_point		*first_point, *cur_point;
+extern F_linkinfo	*cur_links;
+
+/*************** object attribute settings ***********/
+
+/*  Lines  */
+extern int	cur_linewidth;
+extern int	cur_linestyle;
+extern int	cur_joinstyle;
+extern int	cur_capstyle;
+extern float	cur_dashlength;
+extern float	cur_dotgap;
+extern float	cur_styleval;
+extern Color	cur_fillcolor, cur_pencolor;
+extern int	cur_fillstyle, cur_penstyle;
+extern int	cur_boxradius;
+extern int	cur_arrowmode;
+extern int	cur_arrowtype;
+extern int	cur_arctype;
+
+/* Text */
+extern int	cur_fontsize;	/* font size */
+extern int	cur_latex_font;
+extern int	cur_ps_font;
+extern int	cur_textjust;
+extern int	cur_textflags;
+
+/* Misc */
+extern float	cur_elltextangle;
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/openstep.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/openstep.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/openstep.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/openstep.trm.svn-base	2012-01-03 17:07:41.306096300 -0800
@@ -0,0 +1,1418 @@
+/* -*- objc -*-
+ * $Id: openstep.trm,v 1.18 2006/07/21 02:35:47 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - openstep.trm */
+
+/*[
+ * Copyright 1991 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * Name changed from "next" to "openstep" to distinguish the two different
+ * drivers. Also avoids duplications in the complete gnuplot documentation.
+ * (March 2003)
+ */
+
+/*
+ * This file is included by ../term.c via ../term.h.
+ *
+ * This terminal driver supports:
+ *     openstep
+ *
+ * AUTHORS
+ *  Robert Lutwak from Russell Lang's post.trm
+ *  'old' option invokes Nick Strobel's original, single viewport terminal
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ * This terminal attempts to connect, via the NeXTstep Distributed
+ * Objects system, to the "gnuplotServer."  If there is no such
+ * service registered with the OS, the terminal attempts to fire
+ * up GnuTerm.app.  If the user has not set the environment variable
+ * GNUTERMPATH, the terminal uses the users ApplicationPaths Workspace
+ * dwrite to search for GnuTerm.app (Note:  this is usually something
+ * like ~/Apps, ~/LocalApps, ~/NextApps, etc.).
+ * In order to use this filter, you MUST have GnuTerm.app installed
+ * on your system.
+ *
+ * Once connected to the server, this filter is basically Russell Lang's
+ * Postscript filter, except that the resultant postscript code
+ * is sent, via the D.O. system, to GnuTerm.app, which manages
+ * the windows which produce the postscript output on the screen.
+ *
+ *
+ * Defaults are
+ * 'set term openstep new dashed auto "Helvetica" 14'
+ *
+ * To change font to Times-Roman and font size to 20pts use
+ * 'set term openstep "Times-Roman" 20'.
+ *
+ * to choose window by title
+ * 'set term openstep title "Window title"
+ *
+ * Monitor Options:
+ * monochrome, color
+ *
+ * To invoke Nick Strobel's old terminal
+ * 'set term openstep old'
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(openstep)
+#endif
+
+#ifdef TERM_PROTO
+
+#import <Foundation/Foundation.h>
+#import <AppKit/AppKit.h>
+#import <stdarg.h>
+
+
+TERM_PUBLIC void NEXT_options __PROTO((void));
+TERM_PUBLIC void NEXT_common_init __PROTO((int uses_fonts, unsigned int xoff, unsigned int yoff, unsigned int xsize, unsigned int ysize, char **dict));
+TERM_PUBLIC void NEXT_init __PROTO((void));
+TERM_PUBLIC void NEXT_graphics __PROTO((void));
+TERM_PUBLIC void NEXT_text __PROTO((void));
+TERM_PUBLIC void NEXT_reset __PROTO((void));
+TERM_PUBLIC void NEXT_linetype __PROTO((int linetype));
+TERM_PUBLIC void NEXT_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void NEXT_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void NEXT_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC int NEXT_text_angle __PROTO((int ang));
+TERM_PUBLIC int NEXT_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC void NEXT_point __PROTO((unsigned int x, unsigned int y, int number));
+TERM_PUBLIC int NEXT_set_font __PROTO((const char *font));
+TERM_PUBLIC char *NEXT_RememberFont __PROTO((char *fname));
+TERM_PUBLIC void NEXT_set_pointsize __PROTO((double size));
+
+
+#define NEXT_POINT_TYPES 8	/* div */
+#define NEXT_XOFF	1	/* page offset in pts */
+#define NEXT_YOFF	1
+#define NEXT_XMAX 6400
+#define NEXT_YMAX 4800
+#define NEXT_XLAST (NEXT_XMAX - 1)
+#define NEXT_YLAST (NEXT_YMAX - 1)
+#define NEXT_VTIC (NEXT_YMAX/80)
+#define NEXT_HTIC (NEXT_YMAX/80)
+#define NEXT_SC (10)		/* scale is 1pt = 10 units */
+#define	NEXT_LW (0.5*NEXT_SC)	/* linewidth = 0.5 pts */
+#define NEXT_VCHAR (14*NEXT_SC)	/* default is 14 point characters */
+#define NEXT_HCHAR (14*NEXT_SC*6/10)
+
+#define GOT_NEXT_PROTO
+#endif
+
+
+#ifndef TERM_PROTO_ONLY
+
+#ifdef TERM_BODY
+
+@interface GnuTermDriver:NSObject
+{
+    id server;
+}
+
+- (void)senderIsInvalid:(NSNotification *)sender;
+- (void)plot:(char *)PSstr;
+-init;
+@end
+
+
+#define DEFAULTNEXTSIZE 10000
+
+static NSAutoreleasePool *arpool;  /* our autorelease pool */
+static id gnuTermAccess;	/* local object manages the D.O. connection */
+
+static char *NEXTBuffer, *NEXTBufAt, *NEXTBufEnd;
+static int NEXTsize;
+static char NEXTTmpBuf[1000];
+static void NEXTPrintf(char *,...);
+static TBOOLEAN NEXT_oldterminal = FALSE;
+/*static TBOOLEAN NEXT_colordetect();*/
+
+static char NEXT_title[MAX_LINE_LEN + 1];	/* name of font */
+
+static char NEXT_font[MAX_LINE_LEN + 1] = "Helvetica";	/* name of font */
+static int NEXT_fontsize = 14;	/* size of font in pts */
+static int NEXT_default_font[MAX_ID_LEN+1] = {'\0'};
+static TBOOLEAN NEXT_color = FALSE;
+static TBOOLEAN NEXT_solid = FALSE;	/*  use dashed lines */
+static int NEXT_path_count = 0;	/* count of lines in path */
+static int NEXT_ang = 0;	/* text angle */
+static enum JUSTIFY NEXT_justify = LEFT;	/* text is flush left */
+
+static TBOOLEAN NEXT_duplex_state = FALSE;
+static TBOOLEAN NEXT_duplex_option = FALSE;
+
+static char GPFAR *GPFAR NEXT_header[] =
+{
+    "/M {moveto} bind def\n",
+    "/L {lineto} bind def\n",
+    "/R {rmoveto} bind def\n",
+    "/V {rlineto} bind def\n",
+    "/vpt2 vpt 2 mul def\n",
+    "/hpt2 hpt 2 mul def\n",
+/* flush left show */
+    "/Lshow { currentpoint stroke M\n",
+    "  0 vshift R show } def\n",
+/* flush right show */
+    "/Rshow { currentpoint stroke M\n",
+    "  dup stringwidth pop neg vshift R show } def\n",
+/* centred show */
+    "/Cshow { currentpoint stroke M\n",
+    "  dup stringwidth pop -2 div vshift R show } def\n",
+/* Dash or Color Line */
+    "/DL { Color {setrgbcolor Solid {pop []} if 0 setdash }\n",
+    " {pop pop pop Solid {pop []} if 0 setdash} ifelse } def\n",
+/* Border Lines */
+    "/BL { stroke gnulinewidth 2 mul setlinewidth } def\n",
+/* Axes Lines */
+    "/AL { stroke gnulinewidth 2 div setlinewidth } def\n",
+/* Plot Lines */
+    "/PL { stroke gnulinewidth setlinewidth } def\n",
+/* Line Types */
+    "/LTb { BL [] 0 0 0 DL } def\n",	/* border */
+    "/LTa { AL [1 dl 2 dl] 0 setdash 0 0 0 setrgbcolor } def\n",	/* axes */
+    "/LT0 { PL [] 0 1 0 DL } def\n",
+    "/LT1 { PL [4 dl 2 dl] 0 0 1 DL } def\n",
+    "/LT2 { PL [2 dl 3 dl] 1 0 0 DL } def\n",
+    "/LT3 { PL [1 dl 1.5 dl] 1 0 1 DL } def\n",
+    "/LT4 { PL [5 dl 2 dl 1 dl 2 dl] 0 1 1 DL } def\n",
+    "/LT5 { PL [4 dl 3 dl 1 dl 3 dl] 1 1 0 DL } def\n",
+    "/LT6 { PL [2 dl 2 dl 2 dl 4 dl] 0 0 0 DL } def\n",
+    "/LT7 { PL [2 dl 2 dl 2 dl 2 dl 2 dl 4 dl] 1 0.3 0 DL } def\n",
+    "/LT8 { PL [2 dl 2 dl 2 dl 2 dl 2 dl 2 dl 2 dl 4 dl] 0.5 0.5 0.5 DL } def\n",
+/* Point (Round) */ /* Matt Heffron make it round */
+    "/Pnt { stroke [] 0 setdash\n",
+    "   gsave 1 setlinecap M 0 0 V stroke grestore } def\n",
+
+/* Diamond */
+    "/Dia { stroke [] 0 setdash 2 copy vpt add M\n",
+    "  hpt neg vpt neg V hpt vpt neg V\n",
+    "  hpt vpt V hpt neg vpt V closepath stroke\n",
+    "  Pnt } def\n",
+
+/* Plus */
+    "/Pls { stroke [] 0 setdash vpt sub M 0 vpt2 V\n",
+    "  currentpoint stroke M\n",
+    "  hpt neg vpt neg R hpt2 0 V stroke\n",
+    "  } def\n",
+
+/* Box */
+    "/Box { stroke [] 0 setdash 2 copy exch hpt sub exch vpt add M\n",
+    "  0 vpt2 neg V hpt2 0 V 0 vpt2 V\n",
+    "  hpt2 neg 0 V closepath stroke\n",
+    "  Pnt } def\n",
+
+/* Cross (X) */
+    "/Crs { stroke [] 0 setdash exch hpt sub exch vpt add M\n",
+    "  hpt2 vpt2 neg V currentpoint stroke M\n",
+    "  hpt2 neg 0 R hpt2 vpt2 V stroke } def\n",
+
+/* Triangle Up*/
+    "/TriU { stroke [] 0 setdash 2 copy vpt 1.12 mul add M\n",
+    "  hpt neg vpt -1.62 mul V\n",
+    "  hpt 2 mul 0 V\n",
+    "  hpt neg vpt 1.62 mul V closepath stroke\n",
+    "  Pnt  } def\n",
+
+/* Star */
+    "/Star { 2 copy Pls Crs } def\n",
+
+/* div added filed box */
+/* Filled Box */
+    "/BoxF { stroke [] 0 setdash exch hpt sub exch vpt add M\n",
+    "  0 vpt2 neg V  hpt2 0 V  0 vpt2 V\n",
+    "  hpt2 neg 0 V  closepath fill } def\n",
+
+/* div added filled triangle */
+/* Triangle Up, Filled */
+    "/TriUF { stroke [] 0 setdash vpt 1.12 mul add M\n",
+    "  hpt neg vpt -1.62 mul V\n",
+    "  hpt 2 mul 0 V\n",
+    "  hpt neg vpt 1.62 mul V closepath fill } def\n",
+
+/* Matt Heffron: added a few more types */
+/* Triangle Down */
+    "/TriD { stroke [] 0 setdash 2 copy vpt 1.12 mul sub M\n",
+    "  hpt neg vpt 1.62 mul V\n",
+    "  hpt 2 mul 0 V\n",
+    "  hpt neg vpt -1.62 mul V closepath stroke\n",
+    "  Pnt  } def\n",
+
+/* Triangle Down, Filled*/
+    "/TriDF { stroke [] 0 setdash vpt 1.12 mul sub M\n",
+    "  hpt neg vpt 1.62 mul V\n",
+    "  hpt 2 mul 0 V\n",
+    "  hpt neg vpt -1.62 mul V closepath fill} def\n",
+
+/* Diamond, Filled */
+    "/DiaF { stroke [] 0 setdash vpt add M\n",
+    "  hpt neg vpt neg V hpt vpt neg V\n",
+    "  hpt vpt V hpt neg vpt V closepath fill } def\n",
+
+/* Pentagon */
+    "/Pent { stroke [] 0 setdash 2 copy gsave\n",
+    "  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat\n",
+    "  closepath stroke grestore Pnt } def\n",
+
+/* Pentagon, Filled */
+    "/PentF { stroke [] 0 setdash gsave\n",
+    "  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat\n",
+    "  closepath fill grestore } def\n",
+
+/* Circle */
+    "/Circle { stroke [] 0 setdash 2 copy\n",
+    "  hpt 0 360 arc stroke Pnt } def\n",
+
+/* Circle,Filled */
+    "/CircleF { stroke [] 0 setdash hpt 0 360 arc fill } def\n",
+/* 16 differently filled circles */
+    "/C0 { BL [] 0 setdash 2 copy moveto vpt 90 450  arc } bind def\n",
+    "/C1 { BL [] 0 setdash 2 copy        moveto\n",
+    "       2 copy  vpt 0 90 arc closepath fill\n",
+    "               vpt 0 360 arc closepath } bind def\n",
+    "/C2 { BL [] 0 setdash 2 copy moveto\n",
+    "       2 copy  vpt 90 180 arc closepath fill\n",
+    "               vpt 0 360 arc closepath } bind def\n",
+    "/C3 { BL [] 0 setdash 2 copy moveto\n",
+    "       2 copy  vpt 0 180 arc closepath fill\n",
+    "               vpt 0 360 arc closepath } bind def\n",
+    "/C4 { BL [] 0 setdash 2 copy moveto\n",
+    "       2 copy  vpt 180 270 arc closepath fill\n",
+    "               vpt 0 360 arc closepath } bind def\n",
+    "/C5 { BL [] 0 setdash 2 copy moveto\n",
+    "       2 copy  vpt 0 90 arc\n",
+    "       2 copy moveto\n",
+    "       2 copy  vpt 180 270 arc closepath fill\n",
+    "               vpt 0 360 arc } bind def\n",
+    "/C6 { BL [] 0 setdash 2 copy moveto\n",
+    "      2 copy  vpt 90 270 arc closepath fill\n",
+    "              vpt 0 360 arc closepath } bind def\n",
+    "/C7 { BL [] 0 setdash 2 copy moveto\n",
+    "      2 copy  vpt 0 270 arc closepath fill\n",
+    "              vpt 0 360 arc closepath } bind def\n",
+    "/C8 { BL [] 0 setdash 2 copy moveto\n",
+    "      2 copy vpt 270 360 arc closepath fill\n",
+    "              vpt 0 360 arc closepath } bind def\n",
+    "/C9 { BL [] 0 setdash 2 copy moveto\n",
+    "      2 copy  vpt 270 450 arc closepath fill\n",
+    "              vpt 0 360 arc closepath } bind def\n",
+    "/C10 { BL [] 0 setdash 2 copy 2 copy moveto vpt 270 360 arc closepath fill\n",
+    "       2 copy moveto\n",
+    "       2 copy vpt 90 180 arc closepath fill\n",
+    "               vpt 0 360 arc closepath } bind def\n",
+    "/C11 { BL [] 0 setdash 2 copy moveto\n",
+    "       2 copy  vpt 0 90 arc closepath fill\n",
+    "       2 copy moveto\n",
+    "       2 copy  vpt 180 360 arc closepath fill\n",
+    "               vpt 0 360 arc closepath } bind def\n",
+    "/C12 { BL [] 0 setdash 2 copy moveto\n",
+    "       2 copy  vpt 180 360 arc closepath fill\n",
+    "               vpt 0 360 arc closepath } bind def\n",
+    "/C13 { BL [] 0 setdash  2 copy moveto\n",
+    "       2 copy  vpt 0 90 arc closepath fill\n",
+    "       2 copy moveto\n",
+    "       2 copy  vpt 180 360 arc closepath fill\n",
+    "               vpt 0 360 arc closepath } bind def\n",
+    "/C14 { BL [] 0 setdash 2 copy moveto\n",
+    "       2 copy  vpt 90 360 arc closepath fill\n",
+    "               vpt 0 360 arc } bind def\n",
+    "/C15 { BL [] 0 setdash 2 copy vpt 0 360 arc closepath fill\n",
+    "               vpt 0 360 arc closepath } bind def\n",
+
+/* Auxiliary definitions for rectangles */
+
+    "/Rec   { newpath 4 2 roll moveto 1 index 0 rlineto 0 exch rlineto\n",
+    "       neg 0 rlineto closepath } bind def\n",
+    "/Square { dup Rec } bind def\n",
+    "/Bsquare { vpt sub exch vpt sub exch vpt2 Square } bind def\n",
+
+/* 16 differently filled squares */
+
+    "/S0 { BL [] 0 setdash 2 copy moveto 0 vpt rlineto BL Bsquare } bind def\n",
+    "/S1 { BL [] 0 setdash 2 copy vpt Square fill Bsquare } bind def\n",
+    "/S2 { BL [] 0 setdash 2 copy exch vpt sub exch vpt Square fill Bsquare } bind def\n",
+    "/S3 { BL [] 0 setdash 2 copy exch vpt sub exch vpt2 vpt Rec fill Bsquare } bind def\n",
+    "/S4 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt Square fill Bsquare } bind def\n",
+    "/S5 { BL [] 0 setdash 2 copy 2 copy vpt Square fill\n",
+    "       exch vpt sub exch vpt sub vpt Square fill Bsquare } bind def\n",
+    "/S6 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill Bsquare } bind def\n",
+    "/S7 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill\n",
+    "       2 copy vpt Square fill\n",
+    "       Bsquare } bind def\n",
+    "/S8 { BL [] 0 setdash 2 copy vpt sub vpt Square fill Bsquare } bind def\n",
+    "/S9 { BL [] 0 setdash 2 copy vpt sub vpt vpt2 Rec fill Bsquare } bind def\n",
+    "/S10 { BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt Square fill\n",
+    "       Bsquare } bind def\n",
+    "/S11 { 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt2 vpt Rec fill\n",
+    "       Bsquare } bind def\n",
+    "/S12 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill Bsquare } bind def\n",
+    "/S13 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill\n",
+    "       2 copy vpt Square fill Bsquare } bind def\n",
+    "/S14 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill\n",
+    "       2 copy exch vpt sub exch vpt Square fill Bsquare } bind def\n",
+    "/S15 { BL [] 0 setdash 2 copy Bsquare fill Bsquare } bind def\n",
+
+/* 16 different diamonds (actually just rotated squares) */
+
+    "/D0 { gsave translate 45 rotate 0 0 Box stroke grestore } bind def\n",
+    "/D1 { gsave translate 45 rotate 0 0 S1 stroke grestore } bind def\n",
+    "/D2 { gsave translate 45 rotate 0 0 S2 stroke grestore } bind def\n",
+    "/D3 { gsave translate 45 rotate 0 0 S3 stroke grestore } bind def\n",
+    "/D4 { gsave translate 45 rotate 0 0 S4 stroke grestore } bind def\n",
+    "/D5 { gsave translate 45 rotate 0 0 S5 stroke grestore } bind def\n",
+    "/D6 { gsave translate 45 rotate 0 0 S6 stroke grestore } bind def\n",
+    "/D7 { gsave translate 45 rotate 0 0 S7 stroke grestore } bind def\n",
+    "/D8 { gsave translate 45 rotate 0 0 S8 stroke grestore } bind def\n",
+    "/D9 { gsave translate 45 rotate 0 0 S9 stroke grestore } bind def\n",
+    "/D10 { gsave translate 45 rotate 0 0 S10 stroke grestore } bind def\n",
+    "/D11 { gsave translate 45 rotate 0 0 S11 stroke grestore } bind def\n",
+    "/D12 { gsave translate 45 rotate 0 0 S12 stroke grestore } bind def\n",
+    "/D13 { gsave translate 45 rotate 0 0 S13 stroke grestore } bind def\n",
+    "/D14 { gsave translate 45 rotate 0 0 S14 stroke grestore } bind def\n",
+    "/D15 { gsave translate 45 rotate 0 0 S15 stroke grestore } bind def\n",
+
+    NULL
+};
+
+static char GPFAR *GPFAR ENHNEXT_header[] =
+{
+/* For MFshow and MFwidth the tos is an array with the string and font info:  */
+/*	[<fontname (a string)> <fontsize> <vertical offset> <width significant?> <text string>]  */
+
+    "/MFshow {{dup dup 0 get findfont exch 1 get scalefont setfont\n",
+    "     [ currentpoint ] exch dup 2 get 0 exch rmoveto dup 4 get show dup\n",
+    "     3 get {2 get neg 0 exch rmoveto pop} {pop aload pop moveto}ifelse} forall} bind def\n",
+    "/MFwidth {0 exch {dup 3 get{dup dup 0 get findfont exch 1 get scalefont setfont\n",
+    "      4 get stringwidth pop add}\n",
+    "    {pop} ifelse} forall} bind def\n",
+
+/* flush left show */
+    "/MLshow { currentpoint stroke M\n",
+    "  0 exch R MFshow } bind def\n",
+
+/* flush right show */
+    "/MRshow { currentpoint stroke M\n",
+    "  exch dup MFwidth neg 3 -1 roll R MFshow } def\n",
+
+/* centred show */
+    "/MCshow { currentpoint stroke M\n",
+    "  exch dup MFwidth -2 div 3 -1 roll R MFshow } def\n",
+    NULL
+};
+
+/* added to post by Matt Heffron <heffron@falstaff.css.beckman.com> */
+/* moved to post.trm by drd */
+
+struct NEXT_FontName {
+    char *name;
+    struct NEXT_FontName *next;
+} *NEXT_DocFonts = NULL;
+
+enum NEXT_id {
+    NEXT_DEFAULT, NEXT_MONOCHROME, NEXT_COLOR,
+    NEXT_SOLID, NEXT_DASHED,
+    NEXT_SIMPLEX, NEXT_DUPLEX, NEXT_DEFAULTPLEX,
+    NEXT_OLD, NEXT_NEW, NEXT_TITLE,
+    NEXT_OTHER
+};
+
+static struct gen_table NEXT_opts[] =
+{
+    { "d$efault", NEXT_DEFAULT },
+    { "mono$chrome", NEXT_MONOCHROME },
+    { "col$or", NEXT_COLOR },
+    { "col$our", NEXT_COLOR },
+    { "so$lid", NEXT_SOLID },
+    { "da$shed", NEXT_DASHED },
+    { "si$mplex", NEXT_SIMPLEX },
+    { "du$plex", NEXT_DUPLEX },
+    { "defaultp$lex", NEXT_DEFAULTPLEX },
+    { "old", NEXT_OLD },
+    { "new", NEXT_NEW },
+    { "ti$tle", NEXT_TITLE },
+    { NULL, NEXT_OTHER }
+};
+
+TERM_PUBLIC void
+NEXT_options()
+{
+    char buf[40];
+    struct value a;
+
+    while (!END_OF_COMMAND) {
+	switch(lookup_table(&NEXT_opts[0],c_token)) {
+	case NEXT_DEFAULT:
+	    NEXT_oldterminal = FALSE;
+	    /*NEXT_color=NEXT_colordetect(); */
+	    NEXT_color = FALSE;
+	    NEXT_solid = FALSE;
+	    NEXT_duplex_option = FALSE;
+	    strcpy(NEXT_font, "Helvetica");
+	    NEXT_fontsize = 14;
+	    term->v_char = (unsigned int) (NEXT_fontsize * NEXT_SC);
+	    term->h_char = (unsigned int) (NEXT_fontsize * NEXT_SC * 6 / 10);
+	    term->put_text = NEXT_put_text;
+	    c_token++;
+	    break;
+	case NEXT_MONOCHROME:
+	    NEXT_color = FALSE;
+	    c_token++;
+	    break;
+	case NEXT_COLOR:
+	    NEXT_color = TRUE;
+	    c_token++;
+	    break;
+	case NEXT_SOLID:
+	    NEXT_solid = TRUE;
+	    c_token++;
+	    break;
+	case NEXT_DASHED:
+	    NEXT_solid = FALSE;
+	    c_token++;
+	    break;
+	case NEXT_SIMPLEX:
+	    NEXT_duplex_state = FALSE;
+	    NEXT_duplex_option = TRUE;
+	    c_token++;
+	    break;
+	case NEXT_DUPLEX:
+	    NEXT_duplex_state = TRUE;
+	    NEXT_duplex_option = TRUE;
+	    c_token++;
+	    break;
+	case NEXT_DEFAULTPLEX:
+	    NEXT_duplex_option = FALSE;
+	    c_token++;
+	    break;
+	case NEXT_OLD:
+	    NEXT_oldterminal = TRUE;
+	    c_token++;
+	    break;
+	case NEXT_NEW:
+	    NEXT_oldterminal = FALSE;
+	    c_token++;
+	    break;
+	case NEXT_TITLE:
+	    c_token++;
+	    if (!isstring(c_token)) {
+		fprintf(stderr, "usage:  set term openstep title \"newtitle\"\n");
+	    }
+	    quote_str(NEXT_title, c_token, MAX_LINE_LEN + 1);
+	    break;
+	case NEXT_OTHER:
+	default:
+	    if (isstring(c_token)) {
+		quote_str(NEXT_font, c_token, MAX_LINE_LEN + 1);
+
+		/* We must have font size specified */
+		NEXT_fontsize = (int) real(const_express(&a));
+		term->v_char = (unsigned int) (NEXT_fontsize * NEXT_SC);
+		term->h_char = (unsigned int) (NEXT_fontsize * NEXT_SC * 6 / 10);
+		sprintf(NEXT_default_font, "%s,%d", NEXT_font, NEXT_fontsize);
+	    }
+	    break;
+	}
+    }
+
+    sprintf(term_options, "%s %s %s %s \"%s\" %d title \"%s\"",
+	    NEXT_oldterminal ? "old" : "new",
+	    NEXT_color ? "color" : "monochrome",
+	    NEXT_solid ? "solid" : "dashed",
+	    NEXT_duplex_option ? (NEXT_duplex_state ? "duplex" : "simplex")
+	    : "defaultplex",
+	    NEXT_font,
+	    NEXT_fontsize,
+	    NEXT_title);
+}
+
+
+TERM_PUBLIC char *
+NEXT_RememberFont(char *fname)
+{
+    struct NEXT_FontName *fnp;
+
+    for (fnp = NEXT_DocFonts; fnp && strcmp(fnp->name, fname); fnp = fnp->next);
+    if (fnp)
+	return fnp->name;	/* we must have found it in the list */
+
+    if (encoding == S_ENC_ISO8859_1) {
+	NEXTPrintf("/%s reencodeISO def\n", fname);
+    }
+    fnp = (struct NEXT_FontName *) gp_alloc(sizeof(struct NEXT_FontName), "PostScript Font record");
+    fnp->name = gp_alloc(1 + strlen(fname), "PostScript Font name");
+    strcpy(fnp->name, fname);
+    fnp->next = NEXT_DocFonts;
+    NEXT_DocFonts = fnp;
+    return fnp->name;
+}
+
+int NEXT_pen_x, NEXT_pen_y;
+int NEXT_taken;
+int NEXT_linetype_last;
+TBOOLEAN NEXT_relative_ok;
+
+
+/* store settings passed to common_init() for use in NEXT_graphics()
+ * are reserved for storing the term options
+ */
+static int NEXT_common_uses_fonts;
+static unsigned int NEXT_common_xoff, NEXT_common_yoff;
+
+
+TERM_PUBLIC void
+NEXT_common_init(
+    int uses_fonts,		/* 0 for NEXT(la)tex */
+    unsigned int xoff, unsigned int yoff, /* offset  - 50 for /post, 0 for NEXT(la)tex */
+    unsigned int width, unsigned int height, /* for bounding box */
+    char **dict)		/* extra entries for the dictionary */
+{
+    static char GPFAR NEXTi1[] = "%%%%Creator: gnuplot\n\
+%%%%DocumentFonts: %s\n";
+    static char GPFAR NEXTi2[] = "%%%%EndComments\n\
+/gnudict 120 dict def\ngnudict begin\n\
+/Color %s def\n\
+/Solid %s def\n\
+/gnulinewidth %.3f def\n\
+/vshift %d def\n\
+/dl {%d mul} def\n\
+/hpt %.1f def\n\
+/vpt %.1f def\n";
+    static char GPFAR *NEXT_iso_8859_1_encoding[] =
+    {
+	"/reencodeISO {\n",
+	"dup dup findfont dup length dict begin\n",
+	"{ 1 index /FID ne { def }{ pop pop } ifelse } forall\n",
+	"/Encoding ISOLatin1Encoding def\n",
+	"currentdict end definefont\n",
+	"} def\n",
+	"/ISOLatin1Encoding [\n",
+	"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+	"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+	"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+	"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+	"/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright\n",
+	"/parenleft/parenright/asterisk/plus/comma/minus/period/slash\n",
+	"/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon\n",
+	"/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N\n",
+	"/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright\n",
+	"/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m\n",
+	"/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde\n",
+	"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+	"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+	"/.notdef/dotlessi/grave/acute/circumflex/tilde/macron/breve\n",
+	"/dotaccent/dieresis/.notdef/ring/cedilla/.notdef/hungarumlaut\n",
+	"/ogonek/caron/space/exclamdown/cent/sterling/currency/yen/brokenbar\n",
+	"/section/dieresis/copyright/ordfeminine/guillemotleft/logicalnot\n",
+	"/hyphen/registered/macron/degree/plusminus/twosuperior/threesuperior\n",
+	"/acute/mu/paragraph/periodcentered/cedilla/onesuperior/ordmasculine\n",
+	"/guillemotright/onequarter/onehalf/threequarters/questiondown\n",
+	"/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/AE/Ccedilla\n",
+	"/Egrave/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex\n",
+	"/Idieresis/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis\n",
+	"/multiply/Oslash/Ugrave/Uacute/Ucircumflex/Udieresis/Yacute\n",
+	"/Thorn/germandbls/agrave/aacute/acircumflex/atilde/adieresis\n",
+	"/aring/ae/ccedilla/egrave/eacute/ecircumflex/edieresis/igrave\n",
+	"/iacute/icircumflex/idieresis/eth/ntilde/ograve/oacute/ocircumflex\n",
+	"/otilde/odieresis/divide/oslash/ugrave/uacute/ucircumflex/udieresis\n",
+	"/yacute/thorn/ydieresis\n",
+	"] def\n",
+	NULL};
+
+
+    struct termentry *t = term;
+    int i;
+
+    NEXT_common_uses_fonts = uses_fonts;
+    NEXT_common_xoff = xoff;
+    NEXT_common_yoff = yoff;
+
+
+    NEXTPrintf("%%!NEXT-Adobe-2.0\n");
+
+    NEXTPrintf(NEXTi1, uses_fonts ? "(atend)" : "");
+
+    NEXTPrintf("%%%%BoundingBox: %d %d %d %d\n", xoff, yoff,
+	       (int) (xsize * width / NEXT_SC + 0.5 + xoff),
+	       (int) (ysize * height / NEXT_SC + 0.5 + yoff));
+
+    NEXTPrintf(NEXTi2,
+	       NEXT_color ? "true" : "false",
+	       NEXT_solid ? "true" : "false",
+	       NEXT_LW,		/* line width */
+	       (int) (t->v_char) / (-3),	/* shift for vertical centring */
+	       NEXT_SC,		/* dash length */
+	       NEXT_HTIC / 2.0,	/* half point width */
+	       NEXT_VTIC / 2.0);	/* half point height */
+
+    if (uses_fonts && (encoding == S_ENC_ISO8859_1)) {
+	for (i = 0; NEXT_iso_8859_1_encoding[i] != NULL; i++) {
+	    NEXTPrintf("%s", NEXT_iso_8859_1_encoding[i]);
+	}
+    }
+    for (i = 0; NEXT_header[i] != NULL; i++)
+	NEXTPrintf("%s", NEXT_header[i]);
+    if (NEXT_duplex_option)
+	NEXTPrintf("statusdict begin %s setduplexmode end\n",
+		   NEXT_duplex_state ? "true" : "false");
+    NEXT_RememberFont(NEXT_font);
+
+    if (dict)
+	while (*dict)
+	    NEXTPrintf("%s", *(dict++));
+
+    NEXTPrintf("end\n%%%%EndProlog\n");
+}
+
+/* the init fn for the NeXT Terminal driver */
+TERM_PUBLIC void
+NEXT_init()
+{
+    /* is this called more than once? */
+    arpool = [[NSAutoreleasePool alloc] init];
+
+    /* Initialize output string */
+    NEXTsize = DEFAULTNEXTSIZE;
+    if ((NEXTBuffer = malloc(NEXTsize)) == NULL) {
+	printf("Malloc error in openstep filter init\n");
+	exit(1);
+    }
+    NEXTBufEnd = NEXTBuffer + NEXTsize;
+    NEXTBufAt = NEXTBuffer;
+
+
+    term->xmax = NEXT_XMAX;
+    term->ymax = NEXT_YMAX;
+
+    gnuTermAccess = [[GnuTermDriver alloc] init];
+    /* [gnuTermAccess retain];	-- since we hold it privately. */
+}
+
+
+TERM_PUBLIC void
+NEXT_graphics()
+{
+    static char GPFAR NEXTg1[] = "0 setgray\nnewpath\n";
+    struct termentry *t = term;
+
+    *NEXTBuffer = 0;
+    NEXTBufAt = NEXTBuffer;
+
+    NEXT_common_init(1, NEXT_XOFF, NEXT_YOFF, term->xmax, term->ymax,
+		     ENHNEXT_header);
+
+    NEXTPrintf("gnudict begin\ngsave\n");
+    NEXTPrintf("%d %d translate\n", NEXT_common_xoff, NEXT_common_yoff);
+    NEXTPrintf("%.3f %.3f scale\n", 1.0 / NEXT_SC, 1.0 / NEXT_SC);
+
+
+    NEXTPrintf(NEXTg1);
+    if (NEXT_common_uses_fonts)
+	NEXTPrintf("(%s) findfont %d scalefont setfont\n", NEXT_font, (t->v_char));
+    NEXT_path_count = 0;
+    NEXT_relative_ok = FALSE;
+    NEXT_pen_x = NEXT_pen_y = -4000;
+    NEXT_taken = 0;
+    NEXT_linetype_last = LT_UNDEFINED;
+}
+
+
+TERM_PUBLIC voidNEXT_text()
+{
+    static DPSContext d;
+
+    NEXT_path_count = 0;
+    NEXTPrintf("stroke\ngrestore\nend\n");
+
+    /* Terminate string */
+    *NEXTBufAt = 0;
+
+    if (NEXT_oldterminal) {
+      d = DPSGetCurrentContext();
+      DPSPrintf(d, NEXTBuffer);
+      DPSFlushContext(d);
+    }
+    else {
+      /* Here's the call that dumps the string to the server */
+      [gnuTermAccess plot:NEXTBuffer];
+    }
+}
+
+
+TERM_PUBLIC void
+NEXT_reset()
+{
+    NEXTPrintf("%%%%Trailer\n");
+    if (!NEXT_common_uses_fonts) {
+	NEXTPrintf("%%%%DocumentFonts: ");
+	while (NEXT_DocFonts) {
+	    struct NEXT_FontName *fnp;
+	    fnp = NEXT_DocFonts->next;
+	    NEXTPrintf("%s%s", NEXT_DocFonts->name, fnp ? ", " : "\n");
+	    free(NEXT_DocFonts->name);
+	    free(NEXT_DocFonts);
+	    NEXT_DocFonts = fnp;
+	}
+    }
+}
+
+
+TERM_PUBLIC void
+NEXT_linetype(int linetype)
+{
+    linetype = (linetype % 9) + 2;
+    if (linetype < 0)
+	linetype = 0;
+    NEXT_relative_ok = FALSE;
+    if (NEXT_linetype_last == linetype)
+	return;
+    NEXT_linetype_last = linetype;
+    NEXTPrintf("LT%c\n", "ba012345678"[linetype]);
+    NEXT_path_count = 0;
+}
+
+
+TERM_PUBLIC void
+NEXT_move(unsigned int x, unsigned int y)
+{
+    int dx, dy;
+    char abso[20], rel[20];
+    dx = x - NEXT_pen_x;
+    dy = y - NEXT_pen_y;
+    /* can't cancel all null moves--need a move after stroke'ing */
+    if (dx == 0 && dy == 0 && NEXT_relative_ok)
+	return;
+    sprintf(abso, "%d %d M\n", x, y);
+    sprintf(rel, "%d %d R\n", dx, dy);
+    if (strlen(rel) < strlen(abso) && NEXT_relative_ok) {
+	NEXTPrintf("%s", rel);
+	NEXT_taken++;
+    } else
+	NEXTPrintf("%s", abso);
+    NEXT_relative_ok = TRUE;
+    NEXT_path_count += 1;
+
+    NEXT_pen_x = x;
+    NEXT_pen_y = y;
+}
+
+TERM_PUBLIC void
+NEXT_vector(unsigned int x, unsigned int y)
+{
+    int dx, dy;
+    char abso[20], rel[20];
+    dx = x - NEXT_pen_x;
+    dy = y - NEXT_pen_y;
+    if (dx == 0 && dy == 0)
+	return;
+    sprintf(abso, "%d %d L\n", x, y);
+    sprintf(rel, "%d %d V\n", dx, dy);
+    if (strlen(rel) < strlen(abso) && NEXT_relative_ok) {
+	NEXTPrintf("%s", rel);
+	NEXT_taken++;
+    } else
+	NEXTPrintf("%s", abso);
+    NEXT_relative_ok = TRUE;
+    NEXT_path_count += 1;
+    NEXT_pen_x = x;
+    NEXT_pen_y = y;
+    if (NEXT_path_count >= 400) {
+	NEXTPrintf("currentpoint stroke M\n");
+	NEXT_path_count = 0;
+    }
+}
+
+
+
+
+TERM_PUBLIC int
+NEXT_text_angle(int ang)
+{
+    NEXT_ang = ang;
+    return TRUE;
+}
+
+
+TERM_PUBLIC int
+NEXT_justify_text(enum JUSTIFY mode)
+{
+    NEXT_justify = mode;
+    return TRUE;
+}
+
+
+TERM_PUBLIC int
+NEXT_set_font(const char *font)
+{
+    char name[32];
+    int size, sep;
+
+    if (!font || !(*font))
+	font = NEXT_default_font;
+    sep = strcspn(font, ",");
+    strncpy(name, font, sep);
+    name[sep] = NUL;
+    size = NEXT_fontsize;
+    if (font[sep] == ',')
+	sscanf(&(font[sep + 1]), "%d", &size);
+    NEXTPrintf("/%s findfont %d scalefont setfont\n", name, size * NEXT_SC);
+    NEXT_RememberFont(name);
+    term->v_char = (unsigned int) (size * NEXT_SC);
+    term->h_char = (unsigned int) (size * NEXT_SC * 6 / 10);
+    return TRUE;
+}
+
+
+/* postscript point routines */
+
+TERM_PUBLIC void
+NEXT_set_pointsize(double size)
+{
+    NEXTPrintf("/vpt %.1f def /hpt %.1f def /vpt2 vpt 2 mul def /hpt2 hpt 2 mul def\n",
+	       pointsize * NEXT_VTIC * 0.5, pointsize * NEXT_HTIC * 0.5);
+}
+
+TERM_PUBLIC void
+NEXT_point(unsigned int x, unsigned int y, int number)
+{
+    static char *pointFNS[] =
+    {"Pnt", "Pls", "Crs", "Star",
+     "Box", "BoxF", "Circle", "CircleF",
+     "TriU", "TriUF", "TriD", "TriDF",
+     "Dia", "DiaF", "Pent", "PentF",
+     "C0", "C1", "C2", "C3",
+     "C4", "C5", "C6", "C7",
+     "C8", "C9", "C10", "C11",
+     "C12", "C13", "C14", "C15",
+     "S0", "S1", "S2", "S3",
+     "S4", "S5", "S6", "S7",
+     "S8", "S9", "S10", "S11",
+     "S12", "S13", "S14", "S15",
+     "D0", "D1", "D2", "D3",
+     "D4", "D5", "D6", "D7",
+     "D8", "D9", "D10", "D11",
+     "D12", "D13", "D14", "D15"
+    };
+    if (number < 0)
+	number = -1;		/* negative types are all 'dot' */
+    else
+	number %= sizeof(pointFNS) / sizeof(pointFNS[0]) - 1;
+    NEXTPrintf("%d %d %s\n", x, y, pointFNS[number + 1]);
+
+    NEXT_relative_ok = 0;
+    NEXT_path_count = 0;
+    NEXT_linetype_last = LT_UNDEFINED;	/* force next linetype change */
+}
+
+/* All lifted from the enhanced postscript driver */
+
+static TBOOLEAN NEXT_opened_string;	/* try to cut out empty ()'s */
+
+/* used in determining height of processed text */
+
+static float NEXT_max_height, NEXT_min_height;
+
+
+/* process a bit of string, and return the last character used.
+ * p is start of string
+ * brace is TRUE to keep processing to }, FALSE for do one character
+ * fontname & fontsize are obvious
+ * base is the current baseline
+ * widthflag is TRUE if the width of this should count,
+ *              FALSE for zero width boxes
+ */
+
+static char *
+NEXT_recurse(
+    char *p,
+    TBOOLEAN brace,
+    char *fontname,
+    double fontsize, double basem,
+    TBOOLEAN widthflag)
+{
+
+/* close a postscript string if it has been opened */
+#define NEXT_FLUSH      \
+{	if (NEXT_opened_string)  \
+	{	NEXTPrintf("%s", ")]\n");   \
+		NEXT_opened_string = FALSE; \
+	}                         \
+}
+
+#define NEXT_OPEN	\
+{	if (!NEXT_opened_string) \
+	{ NEXTPrintf( "[(%s) %.1f %.1f %s (",  \
+		  fontname, fontsize, base, \
+		  widthflag ? "true" : "false");  \
+	  NEXT_opened_string = TRUE; \
+	}	\
+}
+
+
+    /* Start each recursion with a clean string */
+    NEXT_FLUSH
+
+	if (base + fontsize > NEXT_max_height) {
+	NEXT_max_height = base + fontsize;
+    }
+    if (base < NEXT_min_height) {
+	NEXT_min_height = base;
+    }
+    for (; *p; ++p) {
+	float shift;
+	float f = 0;		/* used for getting new font size */
+	char *localfontname, ch;
+
+	switch (*p) {
+	case '}':
+	    if (brace)
+		return (p);
+
+	    fprintf(stderr, "openstep driver - spurious }\n");
+	    break;
+
+	case '_':
+	case '^':
+	    shift = (*p == '^') ? 0.5 : -0.3;
+
+	    NEXT_FLUSH
+
+		p = NEXT_recurse(p + 1, FALSE, fontname, fontsize * 0.8, base + shift * fontsize, widthflag);
+
+	    break;
+
+	case '{':
+	    /*{{{  recurse (possibly with a new font) */
+
+	    if (*++p == '/') {	/* then parse a fontname, optional fontsize */
+		while (*++p == ' ');
+		localfontname = p;
+		while ((ch = *p) > ' ' && ch != '=')
+		    ++p;
+		if (ch == '=') {
+		    *p++ = '\0';
+		    /*{{{  get optional font size */
+		    f = (float) strtod(p, &p);
+
+		    if (f)
+			f *= NEXT_SC;	/* remember the scaling */
+		    else
+			f = fontsize;
+
+		    /*}}} */
+		} else {
+		    *p++ = '\0';
+		    f = fontsize;
+		}
+
+		while (*p == ' ')
+		    ++p;
+		if (*localfontname)
+		    localfontname = NEXT_RememberFont(localfontname);
+		else
+		    localfontname = fontname;
+	    } else {
+		localfontname = fontname;
+		f = fontsize;
+	    }
+	    /*}}} */
+
+
+	    p = NEXT_recurse(p, TRUE, localfontname, f, base, widthflag);
+
+
+	    NEXT_FLUSH
+
+		break;
+
+	case '@':
+	    /*{{{  phantom box - prints next 'char', then restores currentpoint */
+
+	    NEXT_FLUSH
+
+		p = NEXT_recurse(++p, FALSE, fontname, fontsize, base, FALSE);
+
+	    break;
+	    /*}}} */
+
+	case '(':
+	case ')':
+	    /* special cases */
+	    NEXT_OPEN
+		NEXTPrintf("\\");
+	    NEXTPrintf("%c", *p);
+	    break;
+	    /*}}} */
+
+	case '\\':
+	    /*{{{  is it an escape */
+	    /* special cases */
+
+	    if (p[1] == '\\' || p[1] == '(' || p[1] == ')') {
+		NEXT_OPEN
+		    NEXTPrintf("%c", '\\');
+	    } else if ((ch = p[1]) >= '0' && ch <= '7') {
+		/* up to 3 octal digits */
+		NEXT_OPEN
+		    NEXTPrintf("%c", '\\');
+		NEXTPrintf("%c", ch);
+		++p;
+		if ((ch = p[1]) >= '0' && ch <= '7') {
+		    NEXTPrintf("%c", ch);
+		    ++p;
+		    if ((ch = p[1]) >= '0' && ch <= '7') {
+			NEXTPrintf("%c", ch);
+			++p;
+		    }
+		}
+		break;
+	    }
+	    ++p;
+	    /* just go and print it (fall into the 'default' case) */
+
+	    /*}}} */
+	default:
+	    NEXT_OPEN
+
+		NEXTPrintf("%c", *p);
+	}
+
+	/* like TeX, we only do one character in a recursion, unless it's
+	 * in braces
+	 */
+
+	if (!brace) {
+	    NEXT_FLUSH
+		return (p);	/* the ++p in the outer copy will increment us */
+	}
+    }
+    NEXT_FLUSH
+	return p;
+}
+
+
+TERM_PUBLIC void
+NEXT_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    /* flush any pending graphics (all the XShow routines do this...) */
+
+    if (!strlen(str))
+	return;
+
+    if (NEXT_path_count) {
+	NEXTPrintf(" stroke\n");
+	NEXT_path_count = 0;
+	NEXT_relative_ok = FALSE;
+    }
+    NEXT_move(x, y);
+
+    if (NEXT_ang != 0)
+	NEXTPrintf("currentpoint gsave translate %d rotate 0 0 moveto\n",
+		   NEXT_ang);
+
+    NEXTPrintf("[ ");
+
+    /* set up the globals */
+
+    NEXT_opened_string = FALSE;
+    NEXT_max_height = -1000;
+    NEXT_min_height = 1000;
+
+    while (*(str = NEXT_recurse(str, TRUE, NEXT_font,
+				(double) term->v_char,
+				0.0, TRUE)));
+
+    NEXT_max_height += NEXT_min_height;
+
+    NEXTPrintf("] %.1f ", -NEXT_max_height / 3);
+
+    switch (NEXT_justify) {
+    case LEFT:
+	NEXTPrintf("MLshow\n");
+	break;
+    case CENTRE:
+	NEXTPrintf("MCshow\n");
+	break;
+    case RIGHT:
+	NEXTPrintf("MRshow\n");
+	break;
+    }
+
+    if (NEXT_ang != 0)
+	NEXTPrintf("grestore\n");
+    NEXT_path_count = 0;
+    NEXT_relative_ok = FALSE;
+}
+
+
+
+/*
+static TBOOLEAN
+NEXT_colordetect()
+{
+	NXScreen * mainscreen;
+
+	mainscreen = [Application mainScreen];
+	if (mainscreen->depth == NX_TwoBitGrayDepth) return(FALSE);
+	return(TRUE);
+}
+*/
+
+	/* This just packs all the postscript into one (possibly huge) string
+	 * which will be passed (as a fake pointer) via D.O. to the server
+	 */
+
+void
+NEXTPrintf(char *fmt,...)
+{
+    va_list ap;
+    char *pb;
+    int NEXToff;
+
+    /* Process formatting instructions */
+    va_start(ap, fmt);
+    vsprintf(NEXTTmpBuf, fmt, ap);
+    va_end(ap);
+
+    /* Add to buffer */
+    for (pb = NEXTTmpBuf; (*pb != 0); ++pb, ++NEXTBufAt) {
+	/* reallocate if necessary */
+	if (NEXTBufAt >= NEXTBufEnd) {
+	    NEXToff = NEXTBufAt - NEXTBuffer;
+	    NEXTsize *= 2;
+	    NEXTBuffer = realloc(NEXTBuffer, NEXTsize);
+	    NEXTBufEnd = NEXTBuffer + NEXTsize;
+	    NEXTBufAt = NEXTBuffer + NEXToff;
+	}
+	*NEXTBufAt = *pb;
+    }
+
+    return;
+
+}
+
+/*  This next section implements the GnuTermDriver object which manages
+	the D.O. connection and interface to Obj-C
+*/
+
+
+@protocol GnuTermServerMethods
+/*- (oneway) executePScode:(in char *)PStext termTitle:(in char *)title;*/
+- (void) executePScode:(NSString *) PStext termTitle:(NSString *) title;
+@end
+
+
+@implementation GnuTermDriver
+
+- init
+{
+    NSConnection *myConnection;
+    char serverpath[100], *envstring;
+    int GnuTermPathSet = 0;
+
+
+    /* Ask OS for connection to server */
+    server = [NSConnection rootProxyForConnectionWithRegisteredName: @"gnuplotServer" host:nil];
+
+    [server retain];
+
+    /* Server is running ready to go */
+    if (server)			printf("Connected to server\n")
+	;
+
+    /* Server isn't running, we must fire it up */
+    else {
+	printf("Launching GnuTerm\n");
+	*serverpath = 0;
+
+	/* Check for path set in environment */
+	if ((envstring = getenv("GNUTERMPATH")) != (char *) NULL) {
+	    sprintf(serverpath, "%s/GnuTerm.app/GnuTerm", envstring);
+	    GnuTermPathSet = 1;
+	}
+	/* Not in environment */
+	else
+	    strcpy(serverpath, "GnuTerm");
+
+	/* Try to launch application */
+      if ([[NSWorkspace sharedWorkspace] launchApplication:[NSString stringWithCString:serverpath]] == NO) {
+	    printf("Failed to launch %s.\n", serverpath);
+	    /* Offer a little advice */
+	    if (GnuTermPathSet) {
+		printf("You must have setenv GNUTERMPATH to something wrong\n");
+		printf("I recommend you exit gnuplot and fix this.\n");
+	    } else {
+		printf("It must be located in ~/Apps or /LocalApps\n");
+		printf("I recommend that you either\n");
+		printf("- move GnuTerm.app to one of these locations\n");
+		printf("- set GNUTERMPATH with host%%  setenv GNUTERMPATH /directory/containing_GnuTerm.app\n");
+		printf("- start GnuTerm ahead of the first plot command\n");
+	    }
+	}
+	/* I wish the gnuplot terminal interface would
+	   let me return an error here.
+	 */
+
+	/* Application is launching */
+	else {
+	    /* Wait for it to register Server methods with OS */
+	    do {
+	      server =[[NSConnection
+			 rootProxyForConnectionWithRegisteredName: @"gnuplotServer" host:nil] retain];
+	    } while (!server);	/* This could result in a hang,
+				   but I've never seen it fail */
+	}
+    }
+
+
+    /* By limiting ourselves to known protocol
+     * we speed up the messaging
+     */
+    [server setProtocolForProxy:@protocol(GnuTermServerMethods)];
+
+    myConnection = [server connectionForProxy];
+
+    /* If the server dies we want to know about it */
+    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(senderIsInvalid:) name:NSConnectionDidDieNotification  object:myConnection];
+    /* In fact, we'll worry about it */
+    ;
+
+    return self;
+}
+
+
+- (void) plot:(char *)PSstr;
+{
+    /* If server has become invalid, re-initialize */
+    if (!server)
+	[self init];
+
+    /* This is where we send the huge postscript string to the server
+       Note:
+       The D.O. system doesn't actually give this pointer to the server.
+       The pointer is dereferenced on the client side and the
+       resulting data is sent to the server. On the server side,
+       space for the data is automatically allocated, and a pointer to
+       the local data is received.
+       For details check out:
+       /NextLibrary/Documentation/NextDev/GeneralRef/06_DistributedObjects/IntroDistObjects.rtf
+     */
+
+    printf("Calling server...");
+    [server executePScode: [NSString stringWithCString: PSstr]
+	    termTitle: [NSString stringWithCString: NEXT_title]];
+    printf("returned\n");
+    *NEXT_title = 0;
+}
+
+/* This gets called by OS if server goes down */
+- (void) senderIsInvalid: (NSNotification *) sender
+{
+    server = 0;
+}
+
+@end
+
+
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+
+TERM_TABLE_START(openstep_driver)
+    "openstep",
+    "Interface to GnuTerm.app under OpenStep",
+    NEXT_XMAX, NEXT_YMAX, NEXT_VCHAR, NEXT_HCHAR,
+    NEXT_VTIC, NEXT_HTIC, NEXT_options, NEXT_init, NEXT_reset,
+    NEXT_text, null_scale, NEXT_graphics, NEXT_move, NEXT_vector,
+    NEXT_linetype, NEXT_put_text, NEXT_text_angle,
+    NEXT_justify_text, NEXT_point, do_arrow, NEXT_set_font,
+    NEXT_set_pointsize
+TERM_TABLE_END(openstep_driver)
+
+#undef LAST_TERM
+#define LAST_TERM openstep_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+
+
+#ifdef TERM_HELP
+START_HELP(openstep)
+"1 Openstep (next)",
+#ifndef TERM_HELP_OPENSTEP
+"?commands set terminal openstep",
+"?set terminal openstep",
+"?set term openstep",
+"?terminal openstep",
+"?term openstep",
+"?openstep",
+"?OpenStep",
+"?Openstep",
+/*
+"?next",
+"?NeXT",
+*/
+#endif
+" Several options may be set in the openstep (next) driver.",
+"",
+" Syntax:",
+"       set terminal openstep {<mode>} {<type> } {<color>} {<dashed>}",
+"                  {\"<fontname>\"} {<fontsize>} title {\"<newtitle>\"}",
+"",
+" where <mode> is  `default`, which sets all options to their defaults;",
+" <type> is either `new` or `old`, where `old` invokes the old single window;",
+" <color> is either `color` or `monochrome`;",
+" <dashed> is either `solid` or `dashed`;",
+" \"<fontname>\" is the name of a valid PostScript font;",
+" <fontsize> is the size of the font in PostScript points; and",
+" <title> is the title for the GnuTerm window.",
+" Defaults are  `new`, `monochrome`, `dashed`, \"Helvetica\", 14pt.",
+"",
+" Examples:",
+"       set term openstep default",
+"       set term openstep 22",
+"       set term openstep color \"Times-Roman\" 14",
+"       set term openstep color \"Helvetica\" 12 title \"MyPlot\"",
+"       set term openstep old",
+"",
+" Pointsizes may be changed with `set linestyle`."
+END_HELP(openstep)
+#endif /* TERM_HELP */
+
+
+
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/pbm.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/pbm.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/pbm.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/pbm.trm.svn-base	2012-01-03 17:07:41.528673500 -0800
@@ -0,0 +1,516 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: pbm.trm,v 1.29.2.1 2009/08/26 19:16:13 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - pbm.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *  pbm
+ *
+ * AUTHORS
+ *  Russell Lang
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+
+/* The following pbmplus drivers use the generic bit mapped graphics
+   routines from bitmap.c to build up a bit map in memory.  The driver
+   interchanges colomns and lines in order to access entire lines
+   easily and returns the lines to get bits in the right order :
+   (x,y) -> (y,XMAX-1-x). */
+/* This interchange is done by calling b_makebitmap() with reversed
+   xmax and ymax, and then setting b_rastermode to TRUE.  b_setpixel()
+   will then perform the interchange before each pixel is plotted */
+/* See Jef Poskanzer's excellent PBMplus package for more details of
+   the Portable BitMap format and for programs to convert PBM files
+   to other bitmap formats. */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(pbm_driver)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void PBM_options __PROTO((void));
+TERM_PUBLIC void PBM_init __PROTO((void));
+TERM_PUBLIC void PBM_reset __PROTO((void));
+TERM_PUBLIC void PBM_setfont __PROTO((void));
+TERM_PUBLIC void PBM_graphics __PROTO((void));
+TERM_PUBLIC void PBM_monotext __PROTO((void));
+TERM_PUBLIC void PBM_graytext __PROTO((void));
+TERM_PUBLIC void PBM_colortext __PROTO((void));
+TERM_PUBLIC void PBM_text __PROTO((void));
+TERM_PUBLIC void PBM_linetype __PROTO((int linetype));
+TERM_PUBLIC void PBM_point __PROTO((unsigned int x, unsigned int y, int point));
+#endif /* TERM_PROTO */
+
+/* make XMAX and YMAX a multiple of 8 */
+#define PBM_XMAX (640)
+#define PBM_YMAX (480)
+#define PBM_VCHAR (FNT5X9_VCHAR)
+#define PBM_HCHAR (FNT5X9_VCHAR)
+#define PBM_VTIC FNT5X9_HBITS
+#define PBM_HTIC FNT5X9_HBITS
+
+#ifdef TERM_BODY
+
+static int pbm_font = 1;	/* small font */
+static int pbm_mode = 0;	/* 0:monochrome 1:gray 2:color */
+
+/* Only needed for dubious backwards compatibility with 'set size'
+ * in pre-4.2 versions that didn't support 'set term size'
+ */
+static TBOOLEAN PBM_explicit_size = FALSE;
+
+/* 7=black, 0=white */
+static int pgm_gray[] = { 7, 1, 6, 5, 4, 3, 2, 1, 7 };	/* grays  */
+/* bit3=!intensify, bit2=!red, bit1=!green, bit0=!blue */
+static int ppm_color[] ={ 15, 8, 3, 5, 6, 2, 4, 1, 11, 13, 14 };  /* colors */
+
+enum PBM_id {
+    PBM_SMALL, PBM_MEDIUM, PBM_LARGE,
+    PBM_MONOCHROME, PBM_GRAY, PBM_COLOR, PBM_SIZE,
+    PBM_OTHER
+};
+
+static struct gen_table PBM_opts[] =
+{
+    { "s$mall", PBM_SMALL },
+    { "me$dium", PBM_MEDIUM },
+    { "l$arge", PBM_LARGE },
+    { "mo$nochrome", PBM_MONOCHROME },
+    { "g$ray", PBM_GRAY },
+    { "c$olor", PBM_COLOR },
+    { "c$olour", PBM_COLOR },
+    { "size", PBM_SIZE },
+    { NULL, PBM_OTHER }
+};
+
+TERM_PUBLIC void
+PBM_options()
+{
+    int xpixels = PBM_XMAX;
+    int ypixels = PBM_YMAX;
+    struct value a;
+    pbm_font = 1;
+    pbm_mode = 0;
+
+    term_options[0] = NUL;
+
+    while (!END_OF_COMMAND) {
+	switch(lookup_table(&PBM_opts[0],c_token)) {
+	case PBM_SMALL:
+	    pbm_font = 1;
+	    c_token++;
+	    break;
+	case PBM_MEDIUM:
+	    pbm_font = 2;
+	    c_token++;
+	    break;
+	case PBM_LARGE:
+	    pbm_font = 3;
+	    c_token++;
+	    break;
+	case PBM_MONOCHROME:
+	    pbm_mode = 0;
+	    term->flags |= TERM_MONOCHROME;
+	    c_token++;
+	    break;
+	case PBM_GRAY:
+	    pbm_mode = 1;
+	    c_token++;
+	    break;
+	case PBM_COLOR:
+	    pbm_mode = 2;
+	    term->flags &= ~TERM_MONOCHROME;
+	    c_token++;
+	    break;
+	case PBM_SIZE:
+	    c_token++;
+	    if (END_OF_COMMAND) {
+		term->xmax = PBM_XMAX;
+		term->ymax = PBM_YMAX;
+		PBM_explicit_size = FALSE;
+	    } else {
+		xpixels = real(const_express(&a));
+		if (equals(c_token, ",")) {
+		    c_token++;
+		    ypixels = real(const_express(&a));
+		}
+		PBM_explicit_size = TRUE;
+	    }
+	    if (xpixels > 0)
+		term->xmax = xpixels;
+	    if (ypixels > 0)
+		term->ymax = ypixels;
+	    break;
+	case PBM_OTHER:
+	default:
+	    /* reset to default, since term is already set */
+	    pbm_font = 1;
+	    pbm_mode = 0;
+	    int_error(c_token, "expecting: {small, medium, large} and {monochrome, gray, color}");
+	    break;
+	}
+    }
+
+    term->v_tic = (term->xmax < term->ymax) ? term->xmax/100 : term->ymax/100;
+    if (term->v_tic < 1)
+        term->v_tic = 1;
+    term->h_tic = term->v_tic;
+
+    /* setup options string */
+
+    switch (pbm_font) {
+    case 1:
+	strcat(term_options, "small");
+	break;
+    case 2:
+	strcat(term_options, "medium");
+	break;
+    case 3:
+	strcat(term_options, "large");
+	break;
+    }
+
+    switch (pbm_mode) {
+    case 0:
+	strcat(term_options, " monochrome");
+	break;
+    case 1:
+	strcat(term_options, " gray");
+	break;
+    case 2:
+	strcat(term_options, " color");
+	break;
+    }
+
+    if (PBM_explicit_size)
+	sprintf(term_options + strlen(term_options), " size %d,%d",
+	    term->xmax, term->ymax);
+}
+
+
+TERM_PUBLIC void
+PBM_init()
+{
+    PBM_setfont();		/* HBB 980226: call it here! */
+}
+
+
+TERM_PUBLIC void
+PBM_reset()
+{
+#ifdef VMS
+    fflush_binary();
+#endif /* VMS */
+}
+
+
+TERM_PUBLIC void
+PBM_setfont()
+{
+    switch (pbm_font) {
+    case 1:
+	b_charsize(FNT5X9);
+	term->v_char = FNT5X9_VCHAR;
+	term->h_char = FNT5X9_HCHAR;
+	break;
+    case 2:
+	b_charsize(FNT9X17);
+	term->v_char = FNT9X17_VCHAR;
+	term->h_char = FNT9X17_HCHAR;
+	break;
+    case 3:
+	b_charsize(FNT13X25);
+	term->v_char = FNT13X25_VCHAR;
+	term->h_char = FNT13X25_HCHAR;
+	break;
+    }
+}
+
+
+TERM_PUBLIC void
+PBM_graphics()
+{
+    int numplanes = 1;
+    unsigned int xpixels = term->xmax;
+    unsigned int ypixels = term->ymax;
+
+    /* 'set size' should not affect the size of the canvas in pixels,
+     * but versions prior to 4.2 did not have a separate 'set term size'
+     */
+    if (!PBM_explicit_size) {
+ 	xpixels *= xsize;
+	ypixels *= ysize;
+    }
+
+    switch (pbm_mode) {
+    case 1:
+	numplanes = 3;
+	break;
+    case 2:
+	numplanes = 4;
+	break;
+    }
+
+    /* HBB 980226: this is not the right place to do this: setfont() influences
+     * fields of the termtable entry, and therefore must be called by init()
+     * already. */
+    /* PBMsetfont(); */
+    /* rotate plot -90 degrees by reversing XMAX and YMAX and by
+       setting b_rastermode to TRUE */
+    b_makebitmap(ypixels, xpixels, numplanes);
+    b_rastermode = TRUE;
+
+    if (pbm_mode != 0)
+	b_setlinetype(0);	/* solid lines */
+}
+
+
+static void
+PBM_monotext()
+{
+    register int x, j, row;
+
+    fputs("P4\n", gpoutfile);
+    fprintf(gpoutfile, "%u %u\n", b_ysize, b_xsize);
+
+    /* dump bitmap in raster mode */
+    for (x = b_xsize - 1; x >= 0; x--) {
+	row = (b_ysize / 8) - 1;
+	for (j = row; j >= 0; j--) {
+	    (void) fputc((char) (*((*b_p)[j] + x)), gpoutfile);
+	}
+    }
+
+    b_freebitmap();
+}
+
+static void
+PBM_graytext()
+{
+    register int x, j, row;
+    register int i, value;
+    int mask, plane1, plane2, plane3;
+
+    fprintf(gpoutfile, "\
+P5\n\
+%u %u\n\
+%u\n",
+	    b_ysize, b_xsize,
+	    255);
+
+    /* dump bitmap in raster mode */
+    for (x = b_xsize - 1; x >= 0; x--) {
+	row = (b_ysize / 8) - 1;
+	for (j = row; j >= 0; j--) {
+	    mask = 0x80;
+	    plane1 = (*((*b_p)[j] + x));
+	    plane2 = (*((*b_p)[j + b_psize] + x));
+	    plane3 = (*((*b_p)[j + b_psize + b_psize] + x));
+	    for (i = 0; i < 8; i++) {
+		/* HBB: The values below are set to span the full range
+		 * from 0 up to 255 in 7 steps: */
+		value = 255;
+		if (plane1 & mask)
+		    value -= 36;
+		if (plane2 & mask)
+		    value -= 73;
+		if (plane3 & mask)
+		    value -= 146;
+		(void) fputc((char) (value), gpoutfile);
+		mask >>= 1;
+	    }
+	}
+    }
+
+    b_freebitmap();
+}
+
+static void
+PBM_colortext()
+{
+    register int x, j, row;
+    register int i;
+    int mask, plane1, plane2, plane3, plane4;
+    int red, green, blue;
+
+    fprintf(gpoutfile, "P6\n\
+%u %u\n\
+%u\n",
+	    b_ysize, b_xsize,
+	    255);
+
+    /* dump bitmap in raster mode */
+    for (x = b_xsize - 1; x >= 0; x--) {
+	row = (b_ysize / 8) - 1;
+	for (j = row; j >= 0; j--) {
+	    mask = 0x80;
+	    plane1 = (*((*b_p)[j] + x));
+	    plane2 = (*((*b_p)[j + b_psize] + x));
+	    plane3 = (*((*b_p)[j + b_psize + b_psize] + x));
+	    plane4 = (*((*b_p)[j + b_psize + b_psize + b_psize] + x));
+	    for (i = 0; i < 8; i++) {
+		red = (plane3 & mask) ? 1 : 3;
+		green = (plane2 & mask) ? 1 : 3;
+		blue = (plane1 & mask) ? 1 : 3;
+		if (plane4 & mask) {
+		    red--;
+		    green--;
+		    blue--;
+		}
+		/* HBB: '85' is exactly 255/3, so this spans the full
+		 * range of colors in three steps: */
+		(void) fputc((char) (red * 85), gpoutfile);
+		(void) fputc((char) (green * 85), gpoutfile);
+		(void) fputc((char) (blue * 85), gpoutfile);
+		mask >>= 1;
+	    }
+	}
+    }
+
+    b_freebitmap();
+}
+
+TERM_PUBLIC void
+PBM_text()
+{
+    switch (pbm_mode) {
+    case 0:
+	PBM_monotext();
+	break;
+    case 1:
+	PBM_graytext();
+	break;
+    case 2:
+	PBM_colortext();
+	break;
+    }
+}
+
+
+TERM_PUBLIC void
+PBM_linetype(int linetype)
+{
+    if (linetype < -2)
+	linetype = LT_BLACK;
+
+    switch (pbm_mode) {
+    case 0:
+	b_setlinetype(linetype);
+	break;
+    case 1:
+	if (linetype >= 7)
+	    linetype %= 7;
+	b_setvalue(pgm_gray[linetype + 2]);
+	break;
+    case 2:
+	if (linetype >= 9)
+	    linetype %= 9;
+	b_setvalue(ppm_color[linetype + 2]);
+	break;
+    }
+}
+
+TERM_PUBLIC void
+PBM_point(unsigned int x, unsigned int y, int point)
+{
+    if (pbm_mode == 0)
+	line_and_point(x, y, point);
+    else
+	do_point(x, y, point);
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(pbm_driver)
+    "pbm", "Portable bitmap [small medium large] [monochrome gray color]",
+    PBM_XMAX, PBM_YMAX, PBM_VCHAR,
+    PBM_HCHAR, PBM_VTIC, PBM_HTIC, PBM_options,
+    PBM_init, PBM_reset, PBM_text, null_scale,
+    PBM_graphics, b_move, b_vector, PBM_linetype,
+    b_put_text, b_text_angle, null_justify_text, PBM_point,
+    do_arrow, set_font_null,
+    0,				/* pointsize */
+    TERM_CAN_MULTIPLOT | TERM_BINARY,
+    0, 0, b_boxfill
+TERM_TABLE_END(pbm_driver)
+
+#undef LAST_TERM
+#define LAST_TERM pbm_driver
+
+#endif /* TERM_TABLE */
+
+
+#ifdef TERM_HELP
+START_HELP(pbm)
+"1 pbm",
+"?commands set terminal pbm",
+"?set terminal pbm",
+"?set term pbm",
+"?terminal pbm",
+"?term pbm",
+"?pbm",
+" Syntax:",
+"       set terminal pbm {<fontsize>} {<mode>} {size <x>,<y>}",
+"",
+" where <fontsize> is `small`, `medium`, or `large` and <mode> is `monochrome`,",
+" `gray` or `color`.  The default plot size is 640 pixels wide and 480 pixels",
+" high. The output size is white-space padded to the nearest multiple of",
+" 8 pixels on both x and y. This empty space may be cropped later if needed.",
+"",
+" The output of the `pbm` driver depends upon <mode>: `monochrome` produces a",
+" portable bitmap (one bit per pixel), `gray` a portable graymap (three bits",
+" per pixel) and `color` a portable pixmap (color, four bits per pixel).",
+"",
+" The output of this driver can be used with various image conversion and",
+" manipulation utilities provided by NETPBM.  Based on Jef Poskanzer's",
+" PBMPLUS package, NETPBM provides programs to convert the above PBM formats",
+" to GIF, TIFF, MacPaint, Macintosh PICT, PCX, X11 bitmap and many others.",
+" Complete information is available at http://netpbm.sourceforge.net/.",
+"",
+" Examples:",
+"       set terminal pbm small monochrome                # defaults",
+"       set terminal pbm color medium size 800,600",
+"       set output '| pnmrotate 45 | pnmtopng > tilted.png'  # uses NETPBM"
+END_HELP(pbm)
+#endif /* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/pc.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/pc.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/pc.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/pc.trm.svn-base	2012-01-03 17:07:41.789349500 -0800
@@ -0,0 +1,560 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: pc.trm,v 1.23 2006/07/21 02:35:47 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - pc.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *  Under Microsoft C
+ *      cga, egabios, egalib, vgabios, hercules, corona325, att
+ *  Under Turboc C
+ *      cga, ega/vga, vgamono, svga, mcga, hercules, att
+ *  Under Watcom C
+ *      cga, ega/vga, vgamono, svga, mcga, hercules, ???
+ *
+ * AUTHORS
+ *  Colin Kelley, Thomas Williams, William Wilson, Russell Lang
+ *  modified by David J. Liu (liu@csb.yale.edu) for version 3.6
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ * Because only one compiler is used to generate gnuplot.exe
+ * and the type of the single graphics board is auto-detected,
+ * we can combine all these parts into one terminal type: PC
+ * and let the computer take care of the rest.  -- DJL
+ *
+ * Since I don't have MicroSoft C, I assume it would define MSC.
+ * Please correct it if you are using MS C.  Thank you.  -- DJL
+ *
+ */
+
+/*
+ * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(dospc)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void PC_text __PROTO((void));
+TERM_PUBLIC void PC_reset __PROTO((void));
+TERM_PUBLIC void PC_init __PROTO((void));
+TERM_PUBLIC void PC_graphics __PROTO((void));
+TERM_PUBLIC void PC_linetype __PROTO((int linetype));
+TERM_PUBLIC void PC_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void PC_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void PC_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC int PC_text_angle __PROTO((int ang));
+TERM_PUBLIC int PC_justify_text __PROTO((enum JUSTIFY ang));
+
+#define PC_HCHAR FNT5X9_HCHAR
+#define PC_VCHAR FNT5X9_VCHAR
+#define PC_HTIC 5
+#define PC_VTIC 4
+#define PC_XMAX 100		/* These two entries are just place holders. */
+#define PC_YMAX 100		/* The actual values will be found in init.  */
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+#ifdef __TURBOC__
+static int huge detect_svga __PROTO((void));
+#endif /* __TURBOC__ */
+
+#include <string.h>
+#include <stdlib.h>
+#ifdef __TURBOC__
+#include <graphics.h>
+#include <conio.h>
+#include <dos.h>
+#endif /* __TURBOC__ */
+#ifdef __WATCOMC__
+# include <conio.h>		/* for getch() */
+# include <graph.h>
+#endif /* WATCOMC */
+#ifdef MSC
+#include "mcega.h"
+#endif /* MSC */
+
+static unsigned int pattern[] ={ 0xffff, 0x0f0f, 0xffff, 0xaaaa, 0x3333, 0x3f3f, 0x0f0f };
+static int vga_color[] ={ 7, 8, 2, 3, 4, 5, 9, 14, 12, 15, 13, 10, 11, 1, 6 };
+
+static int pc_driver, pc_mode;
+static int graphics_on = FALSE, pc_graphics = FALSE;
+static int startx, starty, pc_lastx, pc_lasty, pc_colors;
+static int pc_angle, pc_hjustify, pc_vjustify, pc_text_size, pc_text_dir, pc_corscreen = -1;
+
+
+#ifdef __TURBOC__
+extern int far _Cdecl SVGA_driver_far[];
+#endif /* __TURBOC__ */
+
+#ifdef __WATCOMC__
+enum {
+    HORIZ_DIR, VERT_DIR
+};
+static void
+_settextang(int ang)
+{
+    if (ang == HORIZ_DIR) {
+	_settextorient(1, 0);
+    } else {
+	_settextorient(0, 1);
+    }
+}
+#endif /* WATCOMC */
+
+static int huge
+detect_svga()
+{
+    return 0;			/* the default mode, just a place holder */
+}
+
+void
+PC_setup()
+{				/* called from the beginning of main() */
+    int i, t, x, y;
+    char pc_modename[9];
+#ifdef __WATCOMC__
+    struct videoconfig VC;
+#endif /* WATCOMC */
+
+    /* First link all BRI dribers, then detect the display card. */
+    /* If environment PCTRM is set, try initiate the card/mode.  */
+
+    /* special instruction on mode */
+    safe_strncpy(pc_modename, getenv("PCTRM"), 8);
+
+#ifdef __TURBOC__
+    /* Some of this code including BGI drivers are copyright Borland Intl. */
+    registerfarbgidriver(EGAVGA_driver_far);
+    registerfarbgidriver(CGA_driver_far);
+    registerfarbgidriver(Herc_driver_far);
+    registerfarbgidriver(ATT_driver_far);
+    registerfarbgidriver(PC3270_driver_far);
+    pc_driver = DETECT;
+    detectgraph(&pc_driver, &pc_mode);
+    if (graphresult()) {
+	fputs("Unable to initialize graphics.\n", stderr);
+	return;
+    }
+#ifdef BGI_NAME
+/* the highest standard pc_driver value, see graphics.h */
+#define LAST_BGI 10
+/* the last mode of the SVGA.BGI */
+#define LAST_SVGA_MODE 6
+    /* test SVGA if we have VGA */
+    if ((pc_driver == VGA) && (pc_modename[0] == 'S')) {
+	installuserdriver(BGI_NAME, &detect_svga);
+	registerfarbgidriver(SVGA_driver_far);
+	pc_driver = DETECT;
+	initgraph(&pc_driver, &pc_mode, "");
+        /* The following code, which is independent of the actual SVGA.BGI
+	 * used, tries to find a mode of width defined in the environment
+	 * variable PCTRM */
+	if (pc_driver > LAST_BGI) {	/* success */
+	    sscanf(pc_modename, "S%d", &t);
+	    switch (t) {
+	    case 800:
+		break;		/* S800  */
+	    case 1024:
+		break;		/* S1024 */
+	    case 1280:
+		break;		/* S1280 */
+	    default:
+		t = 640;	/* 640x480 */
+	    }
+	    for (i = 0; i <= LAST_SVGA_MODE; i++) {
+		setgraphmode(i);
+		if ((getmaxx() + 1 == t) && (getmaxcolor() > 14))
+		    pc_mode = i;
+	    }
+	    setgraphmode(pc_mode);
+	    if (graphresult()) {	/* error, go back to VGA */
+		pc_driver = VGA;
+		pc_mode = 4;
+	    }
+	}
+    }				/* SVGA tested */
+    if (pc_driver <= LAST_BGI)
+#endif /* BGI_NAME */
+	initgraph(&pc_driver, &pc_mode, "");
+    pc_colors = getmaxcolor() + 1;
+    pc_lastx = getmaxx();
+    pc_lasty = getmaxy();
+    restorecrtmode();
+    clrscr();
+#endif /* __TURBOC__ */
+#ifdef __WATCOMC__
+    _getvideoconfig(&VC);
+    if ((pc_driver = VC.adapter) == 0) {
+	fprintf(stderr, "Unable to initialize graphics.\n");
+	return;
+    }
+    switch (pc_driver = VC.adapter) {
+    case _HERCULES:
+	pc_mode = _HERCMONO;
+	break;
+    case _CGA:
+	pc_mode = _HRESBW;
+	break;
+    case _MCGA:
+	pc_mode = _MRES256COLOR;
+	break;
+    case _EGA:
+	pc_mode = (VC.monitor == _MONO ? _ERESCOLOR : _ERESNOCOLOR);
+	break;
+    case _VGA:
+	pc_mode = _VRES16COLOR;
+	break;
+    case _SVGA:
+	if (pc_modename[0] == 'S') {	/* test SVGA resolution */
+	    sscanf(pc_modename, "S%d", &t);
+	    switch (t) {
+	    case 800:
+		pc_mode = _SVRES256COLOR;
+		break;		/* S800  */
+	    case 1024:
+		pc_mode = _XRES256COLOR;
+		break;		/* S1024 */
+	    case 1280:
+		pc_mode = _XRES256COLOR + 2;
+		break;		/* S1280 */
+		/* Someone help me, who knows, how a newer Watcom calls that */
+	    default:
+		t = 640;
+		pc_mode = _VRES256COLOR;	/* 640x480 */
+	    }
+	    while (_setvideomode(pc_mode) == 0)
+		pc_mode--;
+	}
+	break;
+    default:
+	fputs("Unable to initialize graphics.\n", stderr);
+	return;
+    }
+    _setvideomode(pc_mode);
+    _getvideoconfig(&VC);
+    pc_lastx = VC.numxpixels - 1;
+    pc_lasty = VC.numypixels - 1;
+    pc_colors = VC.numcolors;
+    _setvideomode(_DEFAULTMODE);
+#endif /* WATCOMC */
+    x = pc_lastx + 1;
+    y = pc_lasty + 1;
+    fprintf(stderr, "\tScreen of %d x %d pixels and %d colors.\n",
+	    x, y, pc_colors);
+    pc_graphics = TRUE;
+}
+
+TERM_PUBLIC void
+PC_init()
+{
+    char *pathp;
+#ifdef __WATCOMC__
+    struct _fontinfo fi;
+#endif
+
+    if (!pc_graphics) {
+	fputs("Unable to initialize graphics.\n", stderr);
+	term = 0;
+	return;
+    }
+    /* Double the tic/font sizes. */
+    pc_text_size = (pc_lasty > 590) ? 2 : 1;
+    term->h_char = PC_HCHAR;
+    term->v_char = PC_VCHAR;
+    term->h_tic = PC_HTIC * pc_text_size;
+    term->v_tic = PC_VTIC * pc_text_size;
+    term->xmax = pc_lastx + 1;
+    term->ymax = pc_lasty + 1;
+#ifdef __TURBOC__
+    setgraphmode(pc_mode);
+    settextstyle(DEFAULT_FONT, HORIZ_DIR, pc_text_size);
+    settextjustify(pc_hjustify, pc_vjustify);
+    term->h_char = textheight("X");	/* overriding the default */
+    term->v_char = textwidth("X");	/* overriding the default */
+#endif /* __TURBOC__ */
+#ifdef __WATCOMC__
+    _setvideomode(pc_mode);
+    _settextang(HORIZ_DIR);
+    _settextalign(pc_hjustify, pc_vjustify);
+    _setcharsize(pc_text_size * PC_HCHAR, pc_text_size * PC_VCHAR);
+    _getfontinfo(&fi);
+    term->h_char = fi.avgwidth;
+    term->v_char = fi.pixheight * 1.5;
+#endif /* WATCOMC */
+#ifdef MSC
+#endif /* MSC */
+}
+
+TERM_PUBLIC void
+PC_graphics()
+{
+    graphics_on = TRUE;
+#ifdef __TURBOC__
+    setgraphmode(pc_mode);
+#endif /* __TURBOC__ */
+#ifdef __WATCOMC__
+    _setvideomode(pc_mode);
+#endif /* WATCOMC */
+#ifdef MSC
+    if (pc_corscreen == -1)
+	Vmode(18);		/* VGA */
+    else {
+	grinit(corscreen);
+	grandtx();
+    }				/* corolla */
+#endif /* MSC */
+}
+
+TERM_PUBLIC void
+PC_linetype(int linetype)
+{
+    if (linetype < -2)
+	linetype = LT_BLACK;
+
+    if (pc_colors > 14) {	/* 16 or more colors */
+	if (linetype >= 13)
+	    linetype %= 13;
+#ifdef __TURBOC__
+	setcolor(vga_color[linetype + 2]);
+#endif /* __TURBOC__ */
+#ifdef __WATCOMC__
+	_setcolor(vga_color[linetype + 2]);
+#endif /* WATCOMC */
+#ifdef MSC
+#endif /* MSC */
+    } else {			/* MONO */
+	if (linetype >= 5)
+	    linetype %= 5;
+#ifdef __TURBOC__
+	setlinestyle(4, pattern[linetype + 2], 1);
+#endif /* __TURBOC__ */
+#ifdef __WATCOMC__
+	_setlinestyle(pattern[linetype + 2]);
+#endif /* WATCOMC */
+#ifdef MSC
+	if (pc_corscreen != -1)
+	    Cor_mask(pattern[linetype + 2]);
+#endif /* MSC */
+    }
+}
+
+TERM_PUBLIC void
+PC_move(unsigned int x, unsigned int y)
+{
+#ifdef __TURBOC__
+    moveto(x, pc_lasty - y);
+#endif /* __TURBOC__ */
+#ifdef __WATCOMC__
+    _moveto(x, pc_lasty - y);
+#endif /* WATCOMC */
+#ifdef MSC
+#endif /* MSC */
+    startx = x;
+    starty = y;
+}
+
+TERM_PUBLIC void
+PC_vector(unsigned int x, unsigned int y)
+{
+#ifdef __TURBOC__
+    lineto(x, pc_lasty - y);
+#endif /* __TURBOC__ */
+#ifdef __WATCOMC__
+    _lineto(x, pc_lasty - y);
+#endif /* WATCOMC */
+#ifdef MSC
+    if (pc_corscreen != -1)
+	Cor_line(startx, COR_YLAST - starty, x, COR_YLAST - y);
+#endif /* MSC */
+    startx = x;
+    starty = y;
+}
+
+TERM_PUBLIC void
+PC_reset()
+{
+    graphics_on = FALSE;
+#ifdef __TURBOC__
+    restorecrtmode();
+    clrscr();
+#endif /* __TURBOC__ */
+#ifdef __WATCOMC__
+    _setvideomode(_DEFAULTMODE);
+#endif /* WATCOMC */
+#ifdef MSC
+    Vmode(3);
+#endif /* MSC */
+}
+
+TERM_PUBLIC void
+PC_text()
+{
+    if (graphics_on) {
+	graphics_on = FALSE;
+	(void) getch();
+#ifdef __TURBOC__
+	restorecrtmode();
+	clrscr();
+#endif /* __TURBOC__ */
+#ifdef __WATCOMC__
+	_setvideomode(_DEFAULTMODE);
+#endif /* WATCOMC */
+#ifdef MSC
+	if (pc_corscreen != -1) {
+	    grreset();
+	    txonly();
+	}
+	Vmode(3);
+#endif /* MSC */
+    }
+}
+
+TERM_PUBLIC int
+PC_text_angle(int ang)
+{
+    switch (ang) {
+    case 0:
+	pc_text_dir = HORIZ_DIR;
+	break;
+    default:
+    case 1:
+	pc_text_dir = VERT_DIR;
+	break;
+    }
+    return TRUE;
+}
+
+TERM_PUBLIC int
+PC_justify_text(enum JUSTIFY just)
+{
+#if defined(__TURBOC__)
+    switch (just) {
+    case LEFT:
+	pc_hjustify = LEFT_TEXT;
+	pc_vjustify = CENTER_TEXT;
+	break;
+    case CENTRE:
+	pc_hjustify = CENTER_TEXT;
+	pc_vjustify = CENTER_TEXT;
+	break;
+    case RIGHT:
+	pc_hjustify = RIGHT_TEXT;
+	pc_vjustify = CENTER_TEXT;
+	break;
+    }
+    settextjustify(pc_hjustify, pc_vjustify);
+    return 1;
+#elif defined(__WATCOMC__)
+    switch (just) {
+    case LEFT:
+	pc_hjustify = _LEFT;
+	pc_vjustify = _HALF;
+	break;
+    case CENTRE:
+	pc_hjustify = _CENTER;
+	pc_vjustify = _HALF;
+	break;
+    case RIGHT:
+	pc_hjustify = _RIGHT;
+	pc_vjustify = _HALF;
+	break;
+    }
+    _settextalign(pc_hjustify, pc_vjustify);
+    return 1;
+#else
+    return (just == LEFT);
+#endif
+}
+
+TERM_PUBLIC void
+PC_put_text(unsigned int x, unsigned int y, const char *str)
+{
+#ifdef __TURBOC__
+    settextstyle(DEFAULT_FONT, pc_text_dir, pc_text_size);
+    settextjustify(pc_hjustify, pc_vjustify);
+    outtextxy(x, pc_lasty - y, str);
+#endif /* __TURBOC__ */
+#ifdef __WATCOMC__
+    _setcharsize(pc_text_size * PC_VCHAR, pc_text_size * PC_HCHAR);
+    _settextang(pc_text_dir);
+    _settextalign(pc_hjustify, pc_vjustify);
+    _grtext(x, pc_lasty - y, str);
+#endif /* WATCOMC */
+#ifdef MSC
+#endif /* MSC */
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(dospc_driver)
+    "dospc", "IBM PC/Clone running DOS",
+    PC_XMAX, PC_YMAX, PC_VCHAR, PC_HCHAR,
+    PC_VTIC, PC_HTIC, options_null, PC_init, PC_reset,
+    PC_text, null_scale, PC_graphics, PC_move, PC_vector,
+    PC_linetype, PC_put_text, PC_text_angle,
+    PC_justify_text, line_and_point, do_arrow, set_font_null
+TERM_TABLE_END(dospc_driver)
+
+#undef LAST_TERM
+#define LAST_TERM dospc_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(dospc)
+"1 dospc",
+"?commands set terminal dospc",
+"?set terminal dospc",
+"?set term dospc",
+"?terminal dospc",
+"?term dospc",
+"?dospc",
+" The `dospc` terminal driver supports PCs with arbitrary graphics boards,",
+" which will be automatically detected.  It should be used only if you are",
+" not using the gcc or Zortec C/C++ compilers."
+END_HELP(dospc)
+#endif /* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/pdf.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/pdf.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/pdf.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/pdf.trm.svn-base	2012-01-03 17:07:42.003905900 -0800
@@ -0,0 +1,1753 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: pdf.trm,v 1.83.2.4 2010/03/04 07:15:48 sfeam Exp $
+ */
+
+/*------------------------------
+	GNUPLOT - pdf.trm
+
+	This file is included by ../term.c.
+
+	This driver uses PDFlib from www.pdflib.com
+
+	Author:
+
+		Hans-Bernhard Br"oker
+		broeker@physik.rwth-aachen.de
+
+	Licence: see the gnuplot copyright (to be merged into here...)
+
+	Options: can #define PDF_DONT_COMPRESS to avoid PDF output
+	generated being compressed (by the 'deflate' algorithm as used
+	in 'zip' or 'gzip'). That helps in debugging.
+
+------------------------------*/
+
+/* CODEME: Add patterned lines (?). */
+
+/* PM3D support by Johannes Zellner <johannes@zellner.org>, May-15-2002 */
+/* set_color fixes by Petr Mikulik <mikulik@physics.muni.cz>, June-10-2002 */
+/* image support by Ethan A Merritt <merritt@u.washington.edu>, March 2003 */
+
+/* Text rotation 24-Jul-2002 Ethan A Merritt <merritt@u.washington.edu> */
+/* Revised fill patterns 02-Apr-2003 Ethan A Merritt */
+/* Enhanced text mode support November 2003 Ethan A Merritt */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(pdf)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void PDF_options __PROTO ((void));
+TERM_PUBLIC void PDF_init __PROTO ((void));
+TERM_PUBLIC void PDF_graphics __PROTO ((void));
+TERM_PUBLIC void PDF_text __PROTO ((void));
+TERM_PUBLIC void PDF_linetype __PROTO ((int linetype));
+TERM_PUBLIC void PDF_move __PROTO ((unsigned int x, unsigned int y));
+TERM_PUBLIC void PDF_vector __PROTO ((unsigned int x, unsigned int y));
+TERM_PUBLIC void PDF_put_text __PROTO ((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC void PDF_reset __PROTO ((void));
+TERM_PUBLIC int PDF_justify_text __PROTO ((enum JUSTIFY mode));
+TERM_PUBLIC int PDF_text_angle __PROTO ((int ang));
+TERM_PUBLIC void PDF_point __PROTO ((unsigned int x, unsigned int y, int pointstyle));
+TERM_PUBLIC int PDF_set_font __PROTO ((const char *font));
+TERM_PUBLIC void PDF_boxfill __PROTO((int style, unsigned int x1, unsigned int y1, unsigned int width, unsigned int height));
+TERM_PUBLIC void PDF_linewidth __PROTO ((double linewidth));
+TERM_PUBLIC int PDF_make_palette __PROTO((t_sm_palette *));
+TERM_PUBLIC void PDF_previous_palette __PROTO((void));
+TERM_PUBLIC void PDF_set_color __PROTO((t_colorspec *));
+TERM_PUBLIC void PDF_image __PROTO((unsigned int, unsigned int, coordval *, gpiPoint *, t_imagecolor));
+
+TERM_PUBLIC void PDF_filled_polygon __PROTO((int, gpiPoint *));
+
+/* To support "set term png enhanced" */
+TERM_PUBLIC void ENHPDF_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC void ENHPDF_OPEN __PROTO((char * fontname, double fontsize,
+			double base, TBOOLEAN widthflag, TBOOLEAN showflag,
+			int overprint));
+TERM_PUBLIC void ENHPDF_FLUSH __PROTO((void));
+
+#define PDF_NUM_POINTTYPES 75	/* number of point symbol types not counting the dot */
+
+#define PDF_RESOLUTION  (20)	/* number of terminal pixels per pt */
+#define PDF_XMAX	(5*72*PDF_RESOLUTION) /* 5 inches, 72 pt/inch */
+#define PDF_YMAX	(3*72*PDF_RESOLUTION) /* 3 inches, 72 pt/inch */
+
+static TBOOLEAN pdf_explicit_size = FALSE;
+static size_units pdf_explicit_units = INCHES;
+
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+#include <pdflib.h>
+
+static PDF *myPDF = NULL;
+
+static unsigned int PDF_xLast = UINT_MAX; /* current pen horizontal position*/
+static unsigned int PDF_yLast = UINT_MAX; /* current pen vertical position*/
+
+static int PDF_LineType = LT_UNDEFINED;		/* current line type*/
+static int PDF_LineCap = 0;			/* Butt ends */
+static double PDF_LineWidth = 1.0;		/* current line width*/
+static int PDF_TextAngle = 0;			/* current text orientation*/
+static enum JUSTIFY PDF_TextJust = LEFT;	/* current text justification*/
+static double PDF_linewidth_factor = 1.0;	/* multiplier for line width */
+static double PDF_dashlength_factor = 1.0;	/* multiplier for dash length */
+static TBOOLEAN PDF_dashedlines = FALSE;	/* solid or dashed? */
+static TBOOLEAN PDF_monochrome = FALSE;		/* default all linetypes to black */
+static rgb_color PDF_current_rgb = {0.,0.,0.};	/* Last color set */
+static double PDF_current_gray = 0.0;		/* Last color set (mono version) */
+
+/* default text font family: */
+static char PDF_fontNameDef[MAX_ID_LEN + 1] = "Helvetica";
+static double PDF_fontSizeDef = 6;	/* default text size*/
+/* current text font family: */
+static char PDF_fontNameCur[MAX_ID_LEN + 1] = "Helvetica";
+static double PDF_fontSizeCur = 6; /* current text size*/
+
+static TBOOLEAN PDF_pageIsOpen = FALSE; /* already started a page ?? */
+static TBOOLEAN PDF_pathIsOpen = FALSE; /* open path flag*/
+
+static int PDF_fontAscent = 0;	/* estimated current font ascent*/
+static int PDF_fontDescent = 0;	/* estimated current font descent*/
+static int PDF_fontLeading = 0;	/* estimated current font leading*/
+static int PDF_fontAvWidth = 0;	/* estimated current font char average width*/
+static int PDF_currentFontHandle; /* Needed for exhanced text mode */
+
+static short PDF_Pen_RealID __PROTO ((int));
+static void PDF_PathOpen __PROTO ((void));
+static void PDF_PathClose __PROTO ((void));
+static void PDF_SetFont __PROTO ((void));
+static void PDF_DefinePatterns __PROTO((void));
+enum { PDF_patterns = 7 };
+static int PDF_patternHandles[PDF_patterns];
+
+#ifndef HAVE_NODASH_LIBPDF
+/* Description of dash patterns (same as those in post.trm) */
+static int dash1[] = {8, 8};
+static int dash2[] = {4, 6};
+static int dash3[] = {2, 3};
+static int dash4[] = {12, 4, 2, 4};
+static int dash5[] = {6, 6, 2, 6};
+static int dash6[] = {4, 4, 4, 12};
+static int dash7[] = {1, 4, 12, 4, 1, 4};
+#endif
+
+/*------------------------ helper functions -------------------*/
+
+static short
+PDF_Pen_RealID (int inPenCode)
+{
+    if (inPenCode >= 12)
+	inPenCode %= 12;	/* normalize pen code*/
+    if (inPenCode <= LT_NODRAW)
+	inPenCode = LT_NODRAW;
+
+    return (inPenCode + 2);
+}
+
+/* Functions to ensure that as many move() and vector() calls as
+ * possible get converted into a single long 'path', before closing it
+ * with a stroke or similar command. */
+static void
+PDF_PathOpen ()
+{
+    PDF_pathIsOpen = TRUE;
+}
+
+static void
+PDF_PathClose ()
+{
+    if (PDF_pathIsOpen) {
+	PDF_stroke(myPDF);
+
+	PDF_pathIsOpen = FALSE;
+    }
+}
+
+/* Helper function to deal with switching over to a newly selected font.
+ * For now, this does not try to embed fonts into the PDF file.
+ * We would like to allow UTF-8 fonts via
+	font_handle = PDF_findfont(myPDF, PDF_fontNameCur, "unicode", 0);
+ * but this is not supported by the free-as-in-beer PDFlib Lite.
+ */
+static void
+PDF_SetFont ()
+{
+    int font_handle;
+    const char *pdfenc = "host";
+
+    /* Allow graceful failure */
+    PDF_set_parameter(myPDF, "fontwarning", "false");
+
+    /* LCB : Symbol and ZapfDingbats should use "builtin" encoding */
+    if ( (strcmp(PDF_fontNameCur,"Symbol") == 0) ||
+	 (strcmp(PDF_fontNameCur,"ZapfDingbats") == 0) ) {
+	pdfenc = "builtin";
+    } else if (encoding == S_ENC_ISO8859_1) {
+        pdfenc = "iso8859-1";
+    } else if (encoding == S_ENC_ISO8859_2) {
+        pdfenc = "iso8859-2";
+    } else if (encoding == S_ENC_ISO8859_9) {
+        pdfenc = "iso8859-9";
+    } else if (encoding == S_ENC_ISO8859_15) {
+        pdfenc = "iso8859-15";
+    } else if (encoding == S_ENC_CP1250) {
+        pdfenc = "cp1250";
+    }
+        
+    font_handle = PDF_findfont(myPDF, PDF_fontNameCur, pdfenc, 0);
+    
+    if (font_handle == -1 && strcmp(pdfenc, "host")) {
+        fprintf(stderr,"Couldn't find font %s in encoding %s, trying \"host\"\n", 
+	        PDF_fontNameCur, pdfenc);
+	font_handle = PDF_findfont(myPDF, PDF_fontNameCur, "host", 0);
+    }
+
+    if (font_handle == -1) {
+	font_handle = PDF_findfont(myPDF, "Times-Roman", "host", 0);
+	fprintf(stderr,"Couldn't find font %s, falling back to Times-Roman\n", PDF_fontNameCur);
+    }
+
+    PDF_setfont(myPDF, font_handle, PDF_fontSizeCur * PDF_RESOLUTION);
+
+    /* Ask PDFlib for the actual numbers */
+    PDF_fontAscent = (int) (PDF_RESOLUTION * PDF_fontSizeCur * PDF_get_value(myPDF, "ascender", 0));
+    PDF_fontDescent = (int) (- PDF_RESOLUTION * PDF_fontSizeCur * PDF_get_value(myPDF, "descender", 0));
+    PDF_fontLeading = (int) (PDF_RESOLUTION * PDF_fontSizeCur * 0.25);
+
+    /* Assume this particular string is a somewhat reasonable typical
+     * output, for getting at the average character width */
+    PDF_fontAvWidth = (int)
+	(PDF_RESOLUTION * PDF_stringwidth(myPDF, "01234567890123456789",
+					  font_handle, PDF_fontSizeCur)
+	 / 20.0);
+    PDF_currentFontHandle = font_handle;
+
+}
+
+#if !HAVE_OLD_LIBPDF
+static void
+PDF_DefinePatterns()
+{
+    int i;
+
+    /* EAM April 2003 - Rearrange patterns to maximize contrast in mono.
+     * Because of the finite linewidth, each pattern must include line
+     * fragments at the "empty" corners.
+     */
+    for (i=0; i<PDF_patterns; i++) {
+	PDF_patternHandles[i] = PDF_begin_pattern(myPDF, 8, 8, 8, 8, 2);
+	PDF_setlinewidth(myPDF, 0.25);
+	PDF_setlinecap(myPDF, 2); /* square ends */
+	switch (i) {
+	case 0:	PDF_moveto(myPDF, 0, 8);
+		PDF_lineto(myPDF, 8, 0);
+		PDF_moveto(myPDF, 0, 0);
+		PDF_lineto(myPDF, 8, 8);
+		PDF_stroke(myPDF);
+		break;
+	case 1:	PDF_moveto(myPDF, 0, 8);
+		PDF_lineto(myPDF, 8, 0);
+		PDF_moveto(myPDF, 0, 0);
+		PDF_lineto(myPDF, 8, 8);
+		PDF_moveto(myPDF, 4, 0);
+		PDF_lineto(myPDF, 8, 4);
+		PDF_lineto(myPDF, 4, 8);
+		PDF_lineto(myPDF, 0, 4);
+		PDF_lineto(myPDF, 4, 0);
+		PDF_stroke(myPDF);
+		break;
+	case 2:	PDF_moveto(myPDF, 0, 0);
+		PDF_lineto(myPDF, 0, 8);
+		PDF_lineto(myPDF, 8, 8);
+		PDF_lineto(myPDF, 8, 0);
+		PDF_lineto(myPDF, 0, 0);
+		PDF_fill(myPDF);
+		break;
+	case 3:	PDF_moveto(myPDF, 0, 4);
+		PDF_lineto(myPDF, 4, 0);
+		PDF_moveto(myPDF, 4, 8);
+		PDF_lineto(myPDF, 8, 4);
+		PDF_stroke(myPDF);
+		break;
+	case 4:	PDF_moveto(myPDF, 0, 4);
+		PDF_lineto(myPDF, 4, 8);
+		PDF_moveto(myPDF, 4, 0);
+		PDF_lineto(myPDF, 8, 4);
+		PDF_stroke(myPDF);
+		break;
+	case 5:	PDF_moveto(myPDF, 0, 4);
+		PDF_lineto(myPDF, 2, 0);
+		PDF_moveto(myPDF, 2, 8);
+		PDF_lineto(myPDF, 6, 0);
+		PDF_moveto(myPDF, 6, 8);
+		PDF_lineto(myPDF, 8, 4);
+		PDF_stroke(myPDF);
+		break;
+	case 6:	PDF_moveto(myPDF, 0, 4);
+		PDF_lineto(myPDF, 2, 8);
+		PDF_moveto(myPDF, 2, 0);
+		PDF_lineto(myPDF, 6, 8);
+		PDF_moveto(myPDF, 6, 0);
+		PDF_lineto(myPDF, 8, 4);
+		PDF_stroke(myPDF);
+		break;
+	case 7:	/* not used */
+		PDF_moveto(myPDF, 4, 0);
+		PDF_lineto(myPDF, 0, 2);
+		PDF_moveto(myPDF, 8, 2);
+		PDF_lineto(myPDF, 0, 6);
+		PDF_moveto(myPDF, 8, 6);
+		PDF_lineto(myPDF, 4, 8);
+		PDF_stroke(myPDF);
+		break;
+	case 8:	/* not used */
+		PDF_moveto(myPDF, 4, 0);
+		PDF_lineto(myPDF, 8, 2);
+		PDF_moveto(myPDF, 0, 2);
+		PDF_lineto(myPDF, 8, 6);
+		PDF_moveto(myPDF, 0, 6);
+		PDF_lineto(myPDF, 4, 8);
+		PDF_stroke(myPDF);
+		break;
+	}
+	PDF_end_pattern(myPDF);
+    }
+}
+#endif
+
+/*------------------- the terminal entry functions --------------------*/
+
+
+TERM_PUBLIC void
+PDF_options ()
+{
+    /* Annoying hack to handle the case of 'set termoption' after */
+    /* we have already initialized the terminal.                  */
+    if (c_token != 2)
+	pdf_explicit_size = FALSE;
+
+    while (!END_OF_COMMAND) {
+
+	if (almost_equals(c_token, "enh$anced")) {
+	    c_token++;
+	    term->put_text = ENHPDF_put_text;
+	    term->flags |= TERM_ENHANCED_TEXT;
+	    continue;
+	} else if (almost_equals(c_token, "noenh$anced")) {
+	    c_token++;
+	    term->put_text = PDF_put_text;
+	    term->flags &= ~TERM_ENHANCED_TEXT;
+	    continue;
+	}
+
+	if (almost_equals(c_token, "fn$ame") || almost_equals(c_token, "font"))  {
+	    char *s, *comma;
+	    c_token++;
+
+	    if (!(s = try_to_get_string()))
+		int_error(c_token,"fname: expecting font name");
+	    comma = strrchr(s,',');
+	    if (comma && (1 == sscanf(comma+1,"%lf",&PDF_fontSizeDef)))
+		*comma = '\0';
+	    if (*s)
+		strncpy(PDF_fontNameDef, s, sizeof(PDF_fontNameDef));
+	    free(s);
+	    continue;
+	}
+
+	if (almost_equals(c_token, "fs$ize")) {
+	    c_token++;
+
+	    if (END_OF_COMMAND)
+		int_error(c_token,"fsize: expecting font size");
+	    PDF_fontSizeDef = real_expression();
+	    continue;
+	}
+
+	if (equals(c_token, "lw") || almost_equals(c_token, "linew$idth")) {
+	    c_token++;
+
+	    if (END_OF_COMMAND)
+		int_error(c_token, "expecting line width");
+	    PDF_linewidth_factor = real_expression();
+	    if (PDF_linewidth_factor <= 0)
+		PDF_linewidth_factor = 0.1;
+	    continue;
+	}
+
+	if (almost_equals(c_token, "rou$nded")) {
+	    c_token++;
+	    PDF_LineCap = 1;
+	    continue;
+	}
+
+	if (equals(c_token, "butt")) {
+	    PDF_LineCap = 0;
+	    continue;
+	}
+
+	if (equals(c_token, "color") || almost_equals(c_token, "col$our")) {
+	    c_token++;
+	    PDF_monochrome = FALSE;
+	    term->flags &= ~TERM_MONOCHROME;
+	    continue;
+	}   
+
+	if (almost_equals(c_token, "mono$chrome")) {
+	    c_token++;
+	    PDF_monochrome = TRUE;
+	    term->flags |= TERM_MONOCHROME;
+	    continue;
+	}   
+
+	if (equals(c_token, "dl") || almost_equals(c_token, "dashl$ength")) {
+	    c_token++;
+	    if (END_OF_COMMAND)
+		int_error(c_token, "expecting dashlength multiplier");
+	    PDF_dashlength_factor = real_expression();
+	    if (PDF_dashlength_factor < 0.0)
+		PDF_dashlength_factor = 1.0;
+	    continue;
+	}
+
+	if (equals(c_token, "solid")) {
+	    c_token++;
+	    PDF_dashedlines = FALSE;
+	    continue;
+	}
+
+	if (equals(c_token, "size")) {
+	    float xmax_t, ymax_t;
+	    c_token++;
+	    pdf_explicit_size = TRUE;
+	    pdf_explicit_units = parse_term_size(&xmax_t, &ymax_t, INCHES);
+	    term->xmax = xmax_t*PDF_RESOLUTION*72./gp_resolution;
+	    term->ymax = ymax_t*PDF_RESOLUTION*72./gp_resolution;
+	    continue;
+	}
+
+#ifdef HAVE_NODASH_LIBPDF
+	int_warn(NO_CARET,"gnuplot was linked against a version of pdflib with no dash or pattern support");
+#else
+	if (almost_equals(c_token, "dash$ed")) {
+	    c_token++;
+	    PDF_dashedlines = TRUE;
+	    continue;
+	}
+#endif
+
+	int_error(c_token, "unexpected text at end of command");
+
+    }
+
+    /* Save options back into options string in normalized format */
+    sprintf(term_options, "%s%s fname '%s'  fsize %g linewidth %3.1f %s ",
+	    PDF_monochrome ? "monochrome " : " ",
+	    term->put_text == ENHPDF_put_text ? "enhanced" : "noenhanced",
+	    PDF_fontNameDef, PDF_fontSizeDef, PDF_linewidth_factor,
+	    PDF_LineCap == 1 ? "rounded" : "");
+    if (PDF_dashedlines)
+	sprintf(&(term_options[strlen(term_options)]), "dashed dl %3.1f",
+		PDF_dashlength_factor);
+    if (pdf_explicit_size) {
+	if (pdf_explicit_units == CM)
+	    sprintf(&(term_options[strlen(term_options)]), "size %.2fcm, %.2fcm ", 
+		2.54*(float)term->xmax/(72.*PDF_RESOLUTION),
+		2.54*(float)term->ymax/(72.*PDF_RESOLUTION));
+	else
+	    sprintf(&(term_options[strlen(term_options)]), "size %.2fin, %.2fin ", 
+		(float)term->xmax/(72.*PDF_RESOLUTION),
+		(float)term->ymax/(72.*PDF_RESOLUTION));
+    }
+}
+
+
+TERM_PUBLIC void
+PDF_init ()
+{
+    static TBOOLEAN PDFlib_booted = FALSE;
+    char *gpversionstring;
+    char *username;
+    char *timedate;
+    time_t now;
+
+    if (!PDFlib_booted) {
+	PDF_boot();
+	PDFlib_booted = TRUE;
+    }
+
+    if (!myPDF)
+	myPDF = PDF_new();
+
+    /*open new PDF file */
+#ifdef HAVE_LIBPDF_OPEN_FILE
+    if (PDF_open_file(myPDF, outstr) == -1)
+#else
+    if (PDF_begin_document(myPDF, outstr?outstr:"-", 0,
+			   "compatibility=1.4") == -1)
+#endif /* HAVE_LIBPDF_OPEN_FILE */
+	int_error(NO_CARET, "Error:cannot open PDF file .\n");
+
+#ifdef PDF_DONT_COMPRESS
+    /* for easier debugging of the output, turn off PDF stream
+     * compression */
+    PDF_set_value(myPDF, "compress", 0);
+#endif
+
+    gpversionstring = gp_alloc(20 + strlen(gnuplot_version) + 
+			       strlen(gnuplot_patchlevel) + 1, "PDF_init");
+    sprintf(gpversionstring,"gnuplot %s patchlevel %s",
+	    gnuplot_version, gnuplot_patchlevel);
+
+    time(&now);
+    timedate=asctime(localtime(&now));
+    timedate[strlen(timedate)-1]='\0';
+
+    PDF_set_info(myPDF,"Creator",gpversionstring);
+
+    username=getusername();
+    if (username) {
+	PDF_set_info(myPDF,"Author",username);
+	free(username);
+    }
+
+    if (outstr)
+	PDF_set_info(myPDF,"Title",outstr); /* FIXME: use 'set title', if any? */
+    PDF_set_info(myPDF,"Subject","gnuplot plot");
+
+    if (gpversionstring)
+	free(gpversionstring);
+
+    PDF_LineType = LT_UNDEFINED;
+
+    /* set current font to default */
+    strcpy(PDF_fontNameCur, PDF_fontNameDef);
+    PDF_fontSizeCur = PDF_fontSizeDef;
+
+#if !HAVE_OLD_LIBPDF
+    PDF_DefinePatterns();
+#endif
+
+    /* Have to start the first page now, in order to know the actual
+     * size of the selected font */
+    PDF_graphics();
+
+    /* set h_char, v_char*/
+    term->h_char = PDF_fontAvWidth;
+    term->v_char = (PDF_fontAscent + PDF_fontDescent + PDF_fontLeading);
+
+    /* set h_tic, v_tic*/
+    term->h_tic = term->v_tic = 3 * PDF_RESOLUTION;
+
+    /* initialize terminal's pointsize from "set pointsize" value */
+    term_pointsize = pointsize;
+
+    /* Initialize other default settings */
+    PDF_setlinecap(myPDF, PDF_LineCap);
+    PDF_setlinejoin(myPDF, PDF_LineCap);	/* round+round or butt+mitre */
+}
+
+
+TERM_PUBLIC void
+PDF_graphics ()
+{
+    if (PDF_pageIsOpen)
+	return;			/* already open --> nothing to do */
+
+    PDF_pathIsOpen = FALSE;
+    PDF_xLast = PDF_yLast = UINT_MAX;
+
+    /* set size of canvas */
+    if (!pdf_explicit_size) {
+	term->xmax = PDF_XMAX;
+	term->ymax = PDF_YMAX;
+    }
+
+    PDF_begin_page(myPDF, (double)term->xmax / PDF_RESOLUTION,
+		   (double)term->ymax / PDF_RESOLUTION);
+    PDF_scale(myPDF, 1.0/PDF_RESOLUTION, 1.0/PDF_RESOLUTION);
+    if (title.text && title.text[0])
+	/* a title has been set --> use it as the bookmark name, too */
+	PDF_add_bookmark(myPDF, title.text, 0, 1);
+    PDF_pageIsOpen = TRUE;
+
+    PDF_SetFont();
+}
+
+
+TERM_PUBLIC void
+PDF_text ()
+{
+    PDF_PathClose();
+    PDF_end_page(myPDF);
+    PDF_pageIsOpen = FALSE;
+}
+
+
+TERM_PUBLIC void
+PDF_reset ()
+{
+    assert(PDF_pageIsOpen == FALSE);
+#ifdef HAVE_LIBPDF_OPEN_FILE
+    PDF_close(myPDF);
+#else
+    PDF_end_document(myPDF, "");
+#endif /* HAVE_LIBPDF_OPEN_FILE */
+    PDF_delete(myPDF);
+    myPDF = NULL;
+}
+
+
+TERM_PUBLIC void
+PDF_linetype (int linetype)
+{
+    int dash = linetype % 8;
+
+    linetype = PDF_Pen_RealID(linetype);
+    if (linetype == PDF_LineType)
+	return;
+	
+    PDF_PathClose ();
+    PDF_LineType = linetype;
+
+    if (PDF_monochrome) {
+	PDF_current_gray = 0.0;
+	PDF_setgray(myPDF, PDF_current_gray);
+    } else {
+	unsigned int irgb = pm3d_color_names_tbl[1+linetype].value;
+	PDF_current_rgb.r = (double)((irgb >> 16) & 0xff) / 255.;
+	PDF_current_rgb.g = (double)((irgb >>  8) & 0xff) / 255.;
+	PDF_current_rgb.b = (double)((irgb      ) & 0xff) / 255.;
+	PDF_setrgbcolor(myPDF, PDF_current_rgb.r, PDF_current_rgb.g, PDF_current_rgb.b);
+    }
+
+#ifndef HAVE_NODASH_LIBPDF
+	if (PDF_dashedlines) {
+	    char dashtype[64];
+	    float dl = 8.0 * PDF_dashlength_factor;
+
+	    switch (dash) {
+	    default:
+	    case 0:	PDF_setdash(myPDF, 0.0, 0.0);
+			return;
+	    case 1:	sprintf(dashtype,"dasharray={%4.1f %4.1f}",
+			dl*dash1[0],dl*dash1[1]);
+			break;
+	    case 2:	sprintf(dashtype,"dasharray={%4.1f %4.1f}",
+			dl*dash2[0],dl*dash2[1]);
+			break;
+	    case 3:	sprintf(dashtype,"dasharray={%4.1f %4.1f}",
+			dl*dash3[0],dl*dash3[1]);
+			break;
+	    case 4:	sprintf(dashtype,"dasharray={%4.1f %4.1f %4.1f %4.1f}",
+			dl*dash4[0],dl*dash4[1],dl*dash4[2],dl*dash4[3]);
+			break;
+	    case 5:	sprintf(dashtype,"dasharray={%4.1f %4.1f %4.1f %4.1f}",
+			dl*dash5[0],dl*dash5[1],dl*dash5[2],dl*dash5[3]);
+			break;
+	    case 6:	sprintf(dashtype,"dasharray={%4.1f %4.1f %4.1f %4.1f}",
+			dl*dash6[0],dl*dash6[1],dl*dash6[2],dl*dash6[3]);
+			break;
+	    case 7:	sprintf(dashtype,"dasharray={%4.1f %4.1f %4.1f %4.1f %4.1f %4.1f}",
+			dl*dash7[0],dl*dash7[1],dl*dash7[2],dl*dash7[3],dl*dash7[4],dl*dash7[5]);
+			break;
+	    }
+	    PDF_setdashpattern(myPDF,dashtype);
+	}
+#endif
+	
+}
+
+
+TERM_PUBLIC void
+PDF_linewidth (double linewidth)
+{
+    PDF_PathClose();
+    PDF_LineWidth = PDF_RESOLUTION * PDF_linewidth_factor * linewidth / 4.0;
+    if (PDF_LineWidth < 0.1)
+	PDF_LineWidth = 0.1;
+    PDF_setlinewidth(myPDF, PDF_LineWidth);
+}
+
+
+TERM_PUBLIC void
+PDF_move (unsigned int x, unsigned int y)
+{
+    if (PDF_pathIsOpen && x == PDF_xLast && y == PDF_yLast)
+	return;
+
+    PDF_PathOpen ();
+    PDF_moveto(myPDF, x, y);
+
+    PDF_xLast = x;
+    PDF_yLast = y;
+}
+
+
+TERM_PUBLIC void
+PDF_vector (unsigned int x, unsigned int y)
+{
+    if (PDF_pathIsOpen && x == PDF_xLast && y == PDF_yLast)
+	return;
+
+    if (!PDF_pathIsOpen) {
+	PDF_PathOpen ();
+	PDF_moveto(myPDF, PDF_xLast, PDF_yLast);
+    }
+
+    PDF_lineto(myPDF, x, y);
+
+    PDF_xLast = x;
+    PDF_yLast = y;
+}
+
+/* Helper function. Many symbols have an additional dot in their
+ * center, so isolate its drawing into a separate function. */
+static GP_INLINE void
+PDF_dot (unsigned int x, unsigned int y)
+{
+    /* Imitate PS's way of creating a small dot by a zero-length line
+     * segment with rounded endpoints */
+    PDF_setlinecap(myPDF, 1); /* rounded ends */
+    PDF_moveto(myPDF, x, y);
+    PDF_lineto(myPDF, x, y);
+    PDF_stroke(myPDF);
+    PDF_setlinecap(myPDF, PDF_LineCap); /* restore ends */
+}
+
+
+TERM_PUBLIC void
+PDF_point (unsigned int x, unsigned int y, int number)
+{
+    PDF_PathClose ();
+    PDF_save(myPDF);
+
+    if (number < 0) {
+	/* Treat all negative point sizes as  dots */
+	PDF_dot(x, y);
+    } else {
+	/* Change coordinate system so the point symbols themselves
+	 * can be drawn without depending on position or size (-->
+	 * better compression and less coding for gnuplot) */
+	/* NB: I use the do_pointsize() default implementation, which
+	 * just stores the last set pointsize into `term_pointsize',
+	 * to avoid introducing another static driver-local variable
+	 * */
+	PDF_translate(myPDF, x, y);
+	PDF_scale(myPDF, term->h_tic / 2.0 * term_pointsize,
+		  term->v_tic / 2.0 * term_pointsize);
+	/* Correct linewidth to counter the scaling effect --- assume
+	 * h_tic is usable, to avoid having to average h_ and v_tic */
+	PDF_setlinewidth(myPDF,
+			 PDF_LineWidth / (term->h_tic / 2.0 * term_pointsize));
+	switch (number %= PDF_NUM_POINTTYPES) {
+	case 0:			/* Plus */
+	    PDF_moveto(myPDF, -1, 0);
+	    PDF_lineto(myPDF, 1, 0);
+	    PDF_moveto(myPDF, 0, -1);
+	    PDF_lineto(myPDF, 0, 1);
+	    PDF_stroke(myPDF);
+	    break;
+	case 2:			/* Star */
+	    PDF_moveto(myPDF, -1, 0);
+	    PDF_lineto(myPDF, 1, 0);
+	    PDF_moveto(myPDF, 0, -1);
+	    PDF_lineto(myPDF, 0, 1);
+	    /* FALLTHROUGH */
+	case 1:			/* Cross */
+	    PDF_moveto(myPDF, -1, -1);
+	    PDF_lineto(myPDF, 1, 1);
+	    PDF_moveto(myPDF, 1, -1);
+	    PDF_lineto(myPDF, -1, 1);
+	    PDF_stroke(myPDF);
+	    break;
+
+/* For each x = 0..5, 4 shapes are defined:
+ * 3 + 2*x --> hollow symbol with a dot at its center
+ * 4 + 2*x --> solid symbol filled in linetype's color
+ * 63 + x  --> hollow symbol without the center dot
+ * 69 + x  --> symbol filled with white --> opaque symbol */
+
+	case 63+0:		/* BoxEmpty */
+	case 3+2*0:		/* Box */
+	    PDF_moveto(myPDF, -1, -1);
+	    PDF_lineto(myPDF, 1, -1);
+	    PDF_lineto(myPDF, 1, 1);
+	    PDF_lineto(myPDF, -1, 1);
+	    PDF_closepath_stroke(myPDF);
+	    if (number == 3) PDF_dot(0,0);
+	    break;
+	case 69+0:		/* BoxWhitefilled */
+	    PDF_setgray_fill(myPDF, 1);
+	    /* FALLTHROUGH */
+	case 4+2*0:		/* BoxFilled */
+	    PDF_moveto(myPDF, -1, -1);
+	    PDF_lineto(myPDF, 1, -1);
+	    PDF_lineto(myPDF, 1, 1);
+	    PDF_lineto(myPDF, -1, 1);
+	    PDF_closepath_fill_stroke(myPDF);
+	    break;
+
+	case 63+1:		/* CircleEmpty */
+	case 3+2*1:		/* Circle */
+	    PDF_circle(myPDF, 0, 0, 1);
+	    PDF_stroke(myPDF);
+	    if (number == 5) PDF_dot(0,0);
+	    break;
+	case 69+1:		/* CircleWhitefilled */
+	    PDF_setgray_fill(myPDF, 1);
+	    /* FALLTHROUGH */
+	case 4+2*1:		/* CircleFilled */
+	    PDF_circle(myPDF, 0, 0, 1);
+	    PDF_fill_stroke(myPDF);
+	    break;
+
+	case 63+2:		/* TriangleUpEmpty */
+	case 3+2*2:		/* TriangleUp */
+	    PDF_moveto(myPDF, 0, 1.12);
+	    PDF_lineto(myPDF, -1, -0.5);
+	    PDF_lineto(myPDF, 1, -0.5);
+	    PDF_closepath_stroke(myPDF);
+	    if (number == 7) PDF_dot(0,0);
+	    break;
+	case 69+2:		/* TriangleUpWhitefilled */
+	    PDF_setgray_fill(myPDF, 1);
+	    /* FALLTHROUGH */
+	case 4+2*2:			/* TriangleUpFilled */
+	    PDF_moveto(myPDF, 0, 1.12);
+	    PDF_lineto(myPDF, -1, -0.5);
+	    PDF_lineto(myPDF, 1, -0.5);
+	    PDF_closepath_fill_stroke(myPDF);
+	    break;
+
+	case 63+3:		/* TriangleDownEmpty */
+	case 3+2*3:		/* TriangleDown */
+	    PDF_moveto(myPDF, 0, -1.12);
+	    PDF_lineto(myPDF, -1, 0.5);
+	    PDF_lineto(myPDF, 1, 0.5);
+	    PDF_closepath_stroke(myPDF);
+	    if (number == 9) PDF_dot(0,0);
+	    break;
+	case 69+3:		/* TriangleDownWhitefilled */
+	    PDF_setgray_fill(myPDF, 1);
+	    /* FALLTHROUGH */
+	case 4+2*3:		/* TriangleDownFilled */
+	    PDF_moveto(myPDF, 0, -1.12);
+	    PDF_lineto(myPDF, -1, 0.5);
+	    PDF_lineto(myPDF, 1, 0.5);
+	    PDF_closepath_fill_stroke(myPDF);
+	    break;
+
+	case 63+4:		/* DiamondEmpty */
+	case 3+2*4:		/* Diamond */
+	    PDF_moveto(myPDF, 0, -1);
+	    PDF_lineto(myPDF, 1, 0);
+	    PDF_lineto(myPDF, 0, 1);
+	    PDF_lineto(myPDF, -1, 0);
+	    PDF_closepath_stroke(myPDF);
+	    if (number == 11) PDF_dot(0,0);
+	    break;
+	case 69+4:		/* DiamondWhitefilled */
+	    PDF_setgray_fill(myPDF, 1);
+	    /* FALLTHROUGH */
+	case 4+2*4:		/* DiamondFilled */
+	    PDF_moveto(myPDF, 0, -1);
+	    PDF_lineto(myPDF, 1, 0);
+	    PDF_lineto(myPDF, 0, 1);
+	    PDF_lineto(myPDF, -1, 0);
+	    PDF_closepath_fill_stroke(myPDF);
+	    break;
+
+	case 63+5:		/* PentagonEmpty */
+	case 3+2*5:		/* Pentagon */
+	    PDF_moveto(myPDF, 0, 1);
+	    PDF_lineto(myPDF, -0.95, 0.31);
+	    PDF_lineto(myPDF, -0.58, -0.81);
+	    PDF_lineto(myPDF, +0.58, -0.81);
+	    PDF_lineto(myPDF, +0.95, 0.31);
+	    PDF_closepath_stroke(myPDF);
+	    if (number == 13) PDF_dot(0,0);
+	    break;
+	case 69+5:		/* PentagonWhitefilled */
+	    PDF_setgray_fill(myPDF, 1);
+	    /* FALLTHROUGH */
+	case 4+2*5:		/* PentagonFilled */
+	    PDF_moveto(myPDF, 0, 1);
+	    PDF_lineto(myPDF, -0.95, 0.31);
+	    PDF_lineto(myPDF, -0.58, -0.81);
+	    PDF_lineto(myPDF, +0.58, -0.81);
+	    PDF_lineto(myPDF, +0.95, 0.31);
+	    PDF_closepath_fill_stroke(myPDF);
+	    break;
+
+/* 15 + (0..15): circles with varying parts of'em filled. The added
+ * number is a bit-pattern of the 4 quadrants: 1 signals a quadrant
+ * filled */
+	case 15+0:
+	    PDF_moveto(myPDF, 0, 0);
+	    PDF_lineto(myPDF, 0, 1);
+	    PDF_arc(myPDF, 0, 0, 1, 90, 360+90);
+	    PDF_closepath_stroke(myPDF);
+	    break;
+
+/* Generalize common code into a macro... */
+#define CIRCLE_SINGLE_PIESLICE(x, y, angle1, angle2)		\
+	    PDF_moveto(myPDF, 0, 0);				\
+	    PDF_lineto(myPDF, (x), (y));			\
+	    PDF_arc(myPDF, 0, 0, 1, (angle1), (angle2));	\
+	    PDF_lineto(myPDF, 0, 0);				\
+	    PDF_closepath(myPDF);				\
+	    PDF_fill_stroke(myPDF);				\
+	    PDF_arc(myPDF, 0, 0, 1, (angle2), (angle1) + 360);	\
+	    PDF_stroke(myPDF);					\
+	    break;
+
+#define CIRCLE_SINGLE_QUADRANT(x, y, angle)			\
+	    CIRCLE_SINGLE_PIESLICE(x, y, angle, angle+90);
+	case 15+1:
+	    CIRCLE_SINGLE_QUADRANT(1, 0, 0);
+	case 15+2:
+	    CIRCLE_SINGLE_QUADRANT(0, 1, 90);
+	case 15+4:
+	    CIRCLE_SINGLE_QUADRANT(-1, 0, 180);
+	case 15+8:
+	    CIRCLE_SINGLE_QUADRANT(0, -1, 270);
+#undef CIRCLE_SINGLE_QUADRANT
+
+#define CIRCLE_TWO_NEIGHBOR_QUADRANTS(x, y, angle)		\
+	    CIRCLE_SINGLE_PIESLICE(x, y, angle, angle+180)
+	case 15+3:
+	    CIRCLE_TWO_NEIGHBOR_QUADRANTS(1, 0, 0);
+	case 15+6:
+	    CIRCLE_TWO_NEIGHBOR_QUADRANTS(0, 1, 90);
+	case 15+12:
+	    CIRCLE_TWO_NEIGHBOR_QUADRANTS(-1, 0, 180);
+	case 15+9:
+	    CIRCLE_TWO_NEIGHBOR_QUADRANTS(0, -1, 270);
+#undef CIRCLE_TWO_NEIGHBOR_QUADRANTS
+
+#define CIRCLE_TWO_OPPOSING_QUADRANTS(x, y, angle)		\
+	    PDF_moveto(myPDF, 0, 0);				\
+	    PDF_lineto(myPDF, x, y);				\
+	    PDF_arc(myPDF, 0, 0, 1, angle, angle + 90);		\
+	    PDF_lineto(myPDF, 0, 0);				\
+	    PDF_fill_stroke(myPDF);				\
+	    PDF_moveto(myPDF, 0, 0);				\
+	    PDF_lineto(myPDF, -x, -y);				\
+	    PDF_arc(myPDF, 0, 0, 1, angle + 180, angle + 270);	\
+	    PDF_lineto(myPDF, 0, 0);				\
+	    PDF_fill_stroke(myPDF);				\
+	    PDF_arc(myPDF, 0, 0, 1, angle + 90, angle + 360);	\
+	    PDF_stroke(myPDF);					\
+	    break;
+	case 15+5:
+	    CIRCLE_TWO_OPPOSING_QUADRANTS(1, 0, 0);
+	case 15+10:
+	    CIRCLE_TWO_OPPOSING_QUADRANTS(0, 1, 90);
+#undef CIRCLE_TWO_OPPOSING_QUADRANTS
+
+#define CIRCLE_THREE_QUADRANTS(x, y, angle)			\
+	    CIRCLE_SINGLE_PIESLICE(x, y, angle, angle+270)
+	case 15+7:
+	    CIRCLE_THREE_QUADRANTS(1, 0, 0);
+	case 15+14:
+	    CIRCLE_THREE_QUADRANTS(0, 1, 90);
+	case 15+13:
+	    CIRCLE_THREE_QUADRANTS(-1, 0, 180);
+	case 15+11:
+	    CIRCLE_THREE_QUADRANTS(0, -1, 270);
+#undef CIRCLE_THREE_QUADRANTS
+#undef CIRCLE_SINGLE_PIESLICE
+
+	case 15+15:
+	    PDF_circle(myPDF, 0, 0, 1);
+	    PDF_closepath_fill_stroke(myPDF);
+	    break;
+
+
+/*************************************************************************/
+/* 31 + (0..15): squares with different quadrants of them filled in. */
+/*************************************************************************/
+/*************************************************************************/
+/* 47 + (0..15): diamonds with filled quadrants as given by bit pattern  */
+/*   Diamonds are drawn as squares rotated by 45 degrees, so can use
+ * fall-through from diamond to squares, and re-use some macros. */
+/*************************************************************************/
+	case 47+0:
+	    PDF_rotate(myPDF, 45);
+	    /* FALLTHROUGH */
+	case 31+0:
+	    PDF_moveto(myPDF, 0, 0);
+	    PDF_lineto(myPDF, 0, 1);
+	    PDF_lineto(myPDF, -1, 1);
+	    PDF_lineto(myPDF, -1, -1);
+	    PDF_lineto(myPDF, 1, -1);
+	    PDF_lineto(myPDF, 1, 1);
+	    PDF_lineto(myPDF, 0, 1);
+	    PDF_stroke(myPDF);
+	    break;
+
+	case 47+15:
+	    PDF_rotate(myPDF, 45);
+	    /* FALLTHROUGH */
+	case 31+15:
+	    PDF_moveto(myPDF, -1, 1);
+	    PDF_lineto(myPDF, -1, -1);
+	    PDF_lineto(myPDF, 1, -1);
+	    PDF_lineto(myPDF, 1, 1);
+	    PDF_closepath_fill_stroke(myPDF);
+	    break;
+
+/* macros defining shapes of the partly filled symbols. Done by
+ * rotating the starting point (x0, y0) by 90 degrees or 45 degrees
+ * (with length adjustment).  The rotations can be done without
+ * trigonometric function calls, since their values are known:
+ * cos(90)=0, sin(90)=1, cos(45)=sin(45)=1/sqrt(2).  A good compiler
+ * should be able to optimize away all the local variables and
+ * loops...  */
+
+#define SQUARE_SINGLE_PIESLICE(x0, y0, quadrants)			\
+	    {								\
+		int quadrant = 0;					\
+		int x= x0, y=y0;					\
+		PDF_moveto(myPDF, 0, 0);				\
+		PDF_lineto(myPDF, x, y);				\
+		/* poor man's rotation by 45 and 90 degrees around the	\
+		 * square's outline. */					\
+		while (quadrant++ < quadrants) {			\
+		    int dummy;						\
+		    PDF_lineto(myPDF, x-y, x+y);			\
+		    dummy = x; x = -y; y = dummy;			\
+		}							\
+		PDF_lineto(myPDF, x, y);				\
+		PDF_closepath_fill_stroke(myPDF);			\
+		PDF_moveto(myPDF, x, y);				\
+		while (quadrant++ <= 4) {				\
+		    int dummy;						\
+		    PDF_lineto(myPDF, x-y, x+y);			\
+		    dummy = x; x = -y; y = dummy;			\
+		}							\
+		PDF_lineto(myPDF, x, y);				\
+		PDF_stroke(myPDF);					\
+	    }								\
+	    break;
+
+#define SQUARE_TWO_OPPOSING_QUADRANTS(x0, y0, angle)	\
+	    {						\
+		int x = x0, y = y0, dummy;		\
+		int counter = 0;			\
+							\
+		while (counter++ < 2) {			\
+		    PDF_moveto(myPDF, 0, 0);		\
+		    PDF_lineto(myPDF, x, y);		\
+		    PDF_lineto(myPDF, x-y, x+y);	\
+		    dummy = x; x = -y; y = dummy;	\
+		    PDF_lineto(myPDF, x, y);		\
+		    PDF_closepath_fill_stroke(myPDF);	\
+							\
+		    PDF_moveto(myPDF, x, y);		\
+		    PDF_lineto(myPDF, x-y, x+y);	\
+		    dummy = x; x = -y; y = dummy;	\
+		    PDF_lineto(myPDF, x, y);		\
+		    PDF_stroke(myPDF);			\
+		}					\
+		break;					\
+	    }
+
+/* Macros for diamonds just prepend the rotation and then call those
+ * for squares: */
+#define DIAMOND_SINGLE_PIESLICE(x, y, quadrants)	\
+	    PDF_rotate(myPDF, 45);			\
+	    SQUARE_SINGLE_PIESLICE(x, y, quadrants);
+#define DIAMOND_TWO_OPPOSING_QUADRANTS(x, y, angle)	\
+	    PDF_rotate(myPDF, 45);			\
+	    SQUARE_TWO_OPPOSING_QUADRANTS(x, y, angle);
+
+/* ... and now all the individual cases. The 'angle' arguments' are
+ * purely for the sake of easing cut'n'paste with the circle case */
+#define SQUARE_SINGLE_QUADRANT(x, y, angle)			\
+	    SQUARE_SINGLE_PIESLICE(x, y, 1);
+	case 31+1:
+	    SQUARE_SINGLE_QUADRANT(1, 0, 0);
+	case 31+2:
+	    SQUARE_SINGLE_QUADRANT(0, 1, 90);
+	case 31+4:
+	    SQUARE_SINGLE_QUADRANT(-1, 0, 180);
+	case 31+8:
+	    SQUARE_SINGLE_QUADRANT(0, -1, 270);
+#undef SQUARE_SINGLE_QUADRANT
+
+#define SQUARE_TWO_NEIGHBOR_QUADRANTS(x, y, angle)		\
+	    SQUARE_SINGLE_PIESLICE(x, y, 2)
+	case 31+3:
+	    SQUARE_TWO_NEIGHBOR_QUADRANTS(1, 0, 0);
+	case 31+6:
+	    SQUARE_TWO_NEIGHBOR_QUADRANTS(0, 1, 90);
+	case 31+12:
+	    SQUARE_TWO_NEIGHBOR_QUADRANTS(-1, 0, 180);
+	case 31+9:
+	    SQUARE_TWO_NEIGHBOR_QUADRANTS(0, -1, 270);
+#undef SQUARE_TWO_NEIGHBOR_QUADRANTS
+
+	case 31+5:
+	    SQUARE_TWO_OPPOSING_QUADRANTS(1, 0, 0);
+	case 31+10:
+	    SQUARE_TWO_OPPOSING_QUADRANTS(0, 1, 90);
+
+#define SQUARE_THREE_QUADRANTS(x, y, angle)			\
+	    SQUARE_SINGLE_PIESLICE(x, y, 3)
+	case 31+7:
+	    SQUARE_THREE_QUADRANTS(1, 0, 0);
+	case 31+14:
+	    SQUARE_THREE_QUADRANTS(0, 1, 90);
+	case 31+13:
+	    SQUARE_THREE_QUADRANTS(-1, 0, 180);
+	case 31+11:
+	    SQUARE_THREE_QUADRANTS(0, -1, 270);
+#undef SQUARE_THREE_QUADRANTS
+
+#define DIAMOND_SINGLE_QUADRANT(x, y, angle)			\
+	    DIAMOND_SINGLE_PIESLICE(x, y, 1)
+	case 47+1:
+	    DIAMOND_SINGLE_QUADRANT(1, 0, 0);
+	case 47+2:
+	    DIAMOND_SINGLE_QUADRANT(0, 1, 90);
+	case 47+4:
+	    DIAMOND_SINGLE_QUADRANT(-1, 0, 180);
+	case 47+8:
+	    DIAMOND_SINGLE_QUADRANT(0, -1, 270);
+#undef DIAMOND_SINGLE_QUADRANT
+
+#define DIAMOND_TWO_NEIGHBOR_QUADRANTS(x, y, angle)		\
+	    DIAMOND_SINGLE_PIESLICE(x, y, 2)
+	case 47+3:
+	    DIAMOND_TWO_NEIGHBOR_QUADRANTS(1, 0, 0);
+	case 47+6:
+	    DIAMOND_TWO_NEIGHBOR_QUADRANTS(0, 1, 90);
+	case 47+12:
+	    DIAMOND_TWO_NEIGHBOR_QUADRANTS(-1, 0, 180);
+	case 47+9:
+	    DIAMOND_TWO_NEIGHBOR_QUADRANTS(0, -1, 270);
+#undef DIAMOND_TWO_NEIGHBOR_QUADRANTS
+
+
+	case 47+5:
+	    DIAMOND_TWO_OPPOSING_QUADRANTS(1, 0, 0);
+	case 47+10:
+	    DIAMOND_TWO_OPPOSING_QUADRANTS(0, 1, 90);
+#undef DIAMOND_TWO_OPPOSING_QUADRANTS
+#undef SQUARE_TWO_OPPOSING_QUADRANTS
+
+#define DIAMOND_THREE_QUADRANTS(x, y, angle)			\
+	    DIAMOND_SINGLE_PIESLICE(x, y, 3)
+	case 47+7:
+	    DIAMOND_THREE_QUADRANTS(1, 0, 0);
+	case 47+14:
+	    DIAMOND_THREE_QUADRANTS(0, 1, 90);
+	case 47+13:
+	    DIAMOND_THREE_QUADRANTS(-1, 0, 180);
+	case 47+11:
+	    DIAMOND_THREE_QUADRANTS(0, -1, 270);
+#undef DIAMOND_THREE_QUADRANTS
+#undef DIAMOND_SINGLE_PIESLICE
+#undef SQUARE_SINGLE_PIESLICE
+
+	default:
+	    int_warn(NO_CARET, "PDF: unknown point type number %d", number);
+	}
+    }
+
+    PDF_restore(myPDF);
+    PDF_xLast = x;
+    PDF_yLast = y;
+}
+
+
+TERM_PUBLIC int
+PDF_justify_text (enum JUSTIFY mode)
+{
+    PDF_TextJust = mode;
+    return (TRUE);
+}
+
+
+TERM_PUBLIC int
+PDF_text_angle (int ang)
+{
+    PDF_TextAngle = ang;
+    return (TRUE);
+}
+
+
+TERM_PUBLIC void
+PDF_put_text (unsigned int x, unsigned int y, const char *str)
+{
+    char *alignment = NULL;
+    double h = x, v = y;
+
+    PDF_PathClose ();
+
+    /* horizontal justification*/
+    switch (PDF_TextJust) {
+    case LEFT:
+	alignment = "left";
+	break;
+    case CENTRE:
+	alignment = "center";
+	break;
+    case RIGHT:
+	alignment = "right";
+	break;
+    }
+
+    if (PDF_TextAngle) {
+	PDF_save(myPDF);
+	PDF_translate(myPDF, h, v);
+	PDF_rotate(myPDF, PDF_TextAngle);
+	/* vertical justification*/
+	PDF_translate(myPDF, 0, -(PDF_fontAscent-PDF_fontDescent)/2);
+	PDF_show_boxed(myPDF, str, 0,0, 0, 0, alignment, NULL);
+	PDF_restore(myPDF);
+    } else {
+	/* vertical justification*/
+	v -= (PDF_fontAscent - PDF_fontDescent) / 2;
+	PDF_show_boxed(myPDF, str, h , v, 0, 0, alignment, NULL);
+    }
+
+}
+
+
+TERM_PUBLIC int
+PDF_set_font (const char *font)
+{
+
+    if (!font || !(*font)) {
+	strcpy (PDF_fontNameCur, PDF_fontNameDef);
+	PDF_fontSizeCur = PDF_fontSizeDef;
+    } else {
+	int sep = strcspn(font,",");
+	if (sep > 0) {
+	    strncpy(PDF_fontNameCur,font,sep);
+	    PDF_fontNameCur[sep] = NUL;
+	}
+	if (font[sep] == ',')
+	    sscanf(&(font[sep+1]), "%lf", &PDF_fontSizeCur);
+    }
+
+    PDF_PathClose();
+    PDF_SetFont();
+
+    term->h_char = PDF_fontAvWidth;
+    term->v_char = (PDF_fontAscent + PDF_fontDescent + PDF_fontLeading);
+
+    return (TRUE);
+}
+
+TERM_PUBLIC void
+PDF_boxfill(int style, unsigned int x1, unsigned int y1,
+	    unsigned int width, unsigned int height)
+{
+    gpiPoint corner[4];
+
+	corner[0].x = x1;        corner[0].y = y1;
+	corner[1].x = x1+width;  corner[1].y = y1;
+	corner[2].x = x1+width;  corner[2].y = y1+height;
+	corner[3].x = x1;        corner[3].y = y1+height;
+
+	corner->style = style;
+	PDF_filled_polygon(4, corner);
+}
+
+TERM_PUBLIC void
+PDF_filled_polygon(int points, gpiPoint* corners)
+{
+    int i;
+    int fillpar = corners->style >> 4;
+    int style = corners->style &= 0xf;
+
+    PDF_PathClose();
+    PDF_save(myPDF);
+
+    switch (style) {
+	case FS_EMPTY: /* fill with white */
+	    PDF_setgray(myPDF, 1);
+	    break;
+	case FS_TRANSPARENT_SOLID:
+#if !HAVE_OLD_LIBPDF
+	    {
+		/* FIXME: This attribute will be in effect until the end of   */
+		/* the current page. We should explicitly reset it to restore */
+		/* opaque fill areas as the default. But when should it be?   */
+		char density[18];
+		double red   = PDF_current_rgb.r;
+		double green = PDF_current_rgb.g;
+		double blue  = PDF_current_rgb.b;
+		sprintf(density,"opacityfill=%4.2f", (double)fillpar*0.01);
+		i = PDF_create_gstate(myPDF, density);
+		PDF_set_gstate(myPDF, i);
+		if (PDF_monochrome)
+		    PDF_setgray_fill(myPDF, PDF_current_gray);
+		else
+		    PDF_setrgbcolor_fill(myPDF, red, green, blue);
+		break;
+	    }
+#endif
+	case FS_SOLID:
+	    {
+		double fact = (double)fillpar * 0.01;
+		double _fact = (double)(100-fillpar) * 0.01;
+		double red   = PDF_current_rgb.r * fact + _fact;
+		double green = PDF_current_rgb.g * fact + _fact;
+		double blue  = PDF_current_rgb.b * fact + _fact;
+		if (PDF_monochrome)
+		    PDF_setgray_fill(myPDF, PDF_current_gray);
+		else
+		    PDF_setrgbcolor_fill(myPDF, red, green, blue);
+	    }
+	    break;
+
+#if !HAVE_OLD_LIBPDF
+	case FS_PATTERN:
+	    fillpar = fillpar % (PDF_patterns + 1) /* 0 == white */;
+	    /* Fill in solid background before drawing pattern */
+	    /* NOTE:  kpdf/xpdf would accept this as part of the pattern definition */
+	    /*        but acroread does not. So for compatibility we do the fill in */
+	    /*        a separate step, despite its inefficiency.                    */
+	    if (fillpar != 0) {
+		PDF_setcolor(myPDF, "fill", "rgb", 1, 1, 1, 0 /* unused */);
+		PDF_moveto(myPDF, corners[0].x, corners[0].y);
+		for (i=1; i<points; i++)
+		    PDF_lineto(myPDF, corners[i].x, corners[i].y);
+		PDF_lineto(myPDF, corners[0].x, corners[0].y);
+		PDF_fill(myPDF);
+		PDF_restore(myPDF);
+		PDF_save(myPDF);
+	    }
+	    /* NOTE: Fall through to the actual pattern code */
+	case FS_TRANSPARENT_PATTERN:
+	    fillpar = fillpar % (PDF_patterns + 1) /* 0 == white */;
+	    switch (fillpar) {
+		case 0:
+		    /* fill with white */
+		    PDF_setcolor(myPDF, "fill", "rgb", 1, 1, 1, 0 /* unused */);
+		    break;
+		default:
+		    PDF_setcolor(myPDF, "fill", "pattern", PDF_patternHandles[fillpar - 1], 0, 0, 0);
+	    }
+	    break;
+#endif
+
+	default:
+	    break;
+    }
+
+    PDF_moveto(myPDF, corners[0].x, corners[0].y);
+    for (i=1; i<points; i++)
+	PDF_lineto(myPDF, corners[i].x, corners[i].y);
+    PDF_lineto(myPDF, corners[0].x, corners[0].y);
+    PDF_fill(myPDF);
+    PDF_restore(myPDF);
+}
+
+TERM_PUBLIC int
+PDF_make_palette(t_sm_palette *palette)
+{
+    if (palette == NULL) {
+	/* pdf can do continuous colors */
+	return 0;
+    }
+
+    return 0;
+}
+
+TERM_PUBLIC void
+PDF_set_color(t_colorspec *colorspec)
+{
+    if (colorspec->type == TC_LT) {
+	unsigned int irgb = pm3d_color_names_tbl[ 1 + PDF_Pen_RealID(colorspec->lt) ].value;
+	PDF_current_rgb.r = (double)((irgb >> 16) & 0xff) / 255.;
+	PDF_current_rgb.g = (double)((irgb >>  8) & 0xff) / 255.;
+	PDF_current_rgb.b = (double)((irgb      ) & 0xff) / 255.;
+	PDF_current_gray = 0.0; /* monochrome mode only */
+    } else if (colorspec->type == TC_FRAC) {
+	rgb1maxcolors_from_gray( colorspec->value, &PDF_current_rgb);
+	PDF_current_gray = colorspec->value; /* monochrome mode only */
+    } else if (colorspec->type == TC_RGB) {
+	PDF_current_rgb.r = (double)((colorspec->lt >> 16 ) & 255) / 255.;
+	PDF_current_rgb.g = (double)((colorspec->lt >> 8 ) & 255) / 255.;
+	PDF_current_rgb.b = (double)(colorspec->lt & 255) / 255.;
+    } else
+	return;
+
+    /* make sure that the path is stroked with the current color
+     * before changing the color */
+    PDF_PathClose();
+
+    if (PDF_monochrome && colorspec->type != TC_RGB)
+	PDF_setgray(myPDF, PDF_current_gray);  /* FIXME - Should this be NTSC(current_rgb)? */
+    else
+	PDF_setrgbcolor(myPDF, PDF_current_rgb.r, PDF_current_rgb.g, PDF_current_rgb.b);
+
+    /* mark linetype invalid so that the color will be
+     * set when PDF_linetype() is called next */
+    PDF_LineType = LT_UNDEFINED;
+}
+
+TERM_PUBLIC void
+PDF_previous_palette()
+{
+}
+ 
+TERM_PUBLIC void
+PDF_image (unsigned int M, unsigned int N, coordval * image, gpiPoint * corner, t_imagecolor color_mode)
+{
+    unsigned char *pixel;
+    float xscale, yscale;
+    int i, im;
+
+    /* Allocate memory to hold a copy of the entire image in raw RGB format */
+    unsigned char *rawrgb = gp_alloc( M*N*3, "Raw RGB image");
+
+    /* Convert the input image into raw RGB 24-bit color representation */
+    if (color_mode == IC_RGB) {
+	for (i=0, pixel=rawrgb; i<N*M*3;) {
+	    rgb_color rgb1;
+	    rgb255_color rgb255;
+	    rgb1.r = image[i++];
+	    rgb1.g = image[i++];
+	    rgb1.b = image[i++];
+	    rgb255_from_rgb1( rgb1, &rgb255 );
+	    *pixel++ = rgb255.r;
+	    *pixel++ = rgb255.g;
+	    *pixel++ = rgb255.b;
+	}
+    } else {
+        for (i=0, pixel=rawrgb; i< N*M; i++) {
+	    if (isnan(image[i])) {
+		/* Transparent would be better! */
+		*pixel++ = 255;
+		*pixel++ = 255;
+		*pixel++ = 255;
+	    } else {
+		rgb255_color rgb;
+		rgb255maxcolors_from_gray(image[i], &rgb);
+		*pixel++ = rgb.r;
+		*pixel++ = rgb.g;
+		*pixel++ = rgb.b;
+	    }
+	}
+    }
+      
+    /* Describe this image to PDF library */
+    im = PDF_open_image( myPDF, "raw", "memory", (char *)rawrgb,
+			 (long)(M*N*3), (int)M, (int)N,
+			 3, 8,				/* 3 colors, 8 bits each */
+			 "");
+
+    /* Clip to bounding box requested */
+	PDF_save(myPDF);
+	PDF_moveto(myPDF, corner[2].x, corner[2].y);
+	PDF_lineto(myPDF, corner[2].x, corner[3].y);
+	PDF_lineto(myPDF, corner[3].x, corner[3].y);
+	PDF_lineto(myPDF, corner[3].x, corner[2].y);
+	PDF_closepath(myPDF);
+	PDF_clip(myPDF);
+
+/* Scale and copy into the main PDF image */
+	xscale = fabs((float)corner[1].x - (float)corner[0].x) / (float)M;
+	yscale = fabs((float)corner[1].y - (float)corner[0].y) / (float)N;
+	PDF_translate(myPDF, corner[0].x, corner[0].y);
+	PDF_scale(myPDF, xscale, yscale);
+	PDF_translate(myPDF, 0, -(float)N);
+	PDF_place_image(myPDF, im, 0.0, 0.0, 1.0 );
+	PDF_restore(myPDF);
+
+    /* Clean up */
+	PDF_close_image(myPDF, im);
+	free(rawrgb);
+
+}
+
+/*
+ * Ethan A Merritt November 2003
+ *	- support for enhanced text mode
+ * BUGS:
+ *	- The baseline is not consistent if font size changes within a string.
+ *	- Placement of overprinted characters is not correct.
+ *	- libpdf exits if the requested font is not recognized.
+ *	- I implement text-rotation by hand, but it may be possible to use
+ *	  a gsave/translate/rotate/.../grestore sequence instead.
+ */
+
+static TBOOLEAN ENHpdf_opened_string;
+
+/* used in determining height of processed text */
+static float ENHpdf_base;
+
+/* use these so that we don't over-write the current font settings in pdf_state */
+static double  ENHpdf_fontsize;
+static char   *ENHpdf_font;
+
+/* A global flag that tells us this run is just to determine text size */
+static TBOOLEAN ENHpdf_sizeonly = FALSE;
+
+static TBOOLEAN ENHpdf_show = TRUE;
+static int ENHpdf_overprint = 0;
+static TBOOLEAN ENHpdf_widthflag = FALSE;
+static unsigned int ENHpdf_xsave, ENHpdf_ysave;
+
+/* Start a new string fragment */
+TERM_PUBLIC void
+ENHPDF_OPEN(
+    char *fontname,
+    double fontsize, double base,
+    TBOOLEAN widthflag, TBOOLEAN showflag,
+    int overprint)
+{
+    /* If the overprint code requests a save or request, that's all we do */
+    if (overprint == 3) {
+	ENHpdf_xsave = PDF_xLast;
+	ENHpdf_ysave = PDF_yLast;
+	return;
+    } else if (overprint == 4) {
+	PDF_move(ENHpdf_xsave, ENHpdf_ysave);
+	return;
+    }
+
+    if (!ENHpdf_opened_string) {
+	ENHpdf_opened_string = TRUE;
+	enhanced_cur_text = &enhanced_text[0];
+	ENHpdf_font = fontname;
+	ENHpdf_fontsize = fontsize;
+	ENHpdf_base = base * PDF_RESOLUTION;
+	ENHpdf_show = showflag;
+	ENHpdf_overprint = overprint;
+	ENHpdf_widthflag = widthflag;
+    }
+}
+
+/* Write a string fragment and update the current position */
+TERM_PUBLIC void
+ENHPDF_FLUSH()
+{
+    int x, y;
+    float stringlength;
+
+	if (ENHpdf_opened_string) {
+	    ENHpdf_opened_string = FALSE;
+	    *enhanced_cur_text = '\0';
+	    x = PDF_xLast;
+	    y = PDF_yLast;
+	    x -= sin((double)PDF_TextAngle * M_PI_2/90.) * ENHpdf_base;
+	    y += cos((double)PDF_TextAngle * M_PI_2/90.) * ENHpdf_base;
+	    x += sin((double)PDF_TextAngle * M_PI_2/90.) * (double)PDF_fontAvWidth/2.;
+	    y -= cos((double)PDF_TextAngle * M_PI_2/90.) * (double)PDF_fontAvWidth/2.;
+
+	    /* Select current font for enhanced text fragment, then restore context */
+	    if (1) {
+		char save_fontname[MAX_ID_LEN + 1];
+		double save_fontsize = PDF_fontSizeCur;
+		    strcpy(save_fontname,PDF_fontNameCur);
+		    PDF_fontSizeCur = ENHpdf_fontsize;
+		    PDF_set_font(ENHpdf_font);
+		    strcpy(PDF_fontNameCur,save_fontname);
+		    PDF_fontSizeCur = save_fontsize;
+	    }
+
+	    /* Find length of string in current font */
+	    stringlength = PDF_stringwidth(myPDF, enhanced_text,
+		PDF_currentFontHandle, ENHpdf_fontsize);
+	    stringlength *= PDF_RESOLUTION;
+
+	    if (ENHpdf_show && !ENHpdf_sizeonly) {
+		if (PDF_TextAngle == 0 ) {
+		    /* PDF_show(myPDF, enhanced_text); */
+		    PDF_show_boxed(myPDF, enhanced_text, x, y, 0, 0, "left", NULL);
+		} else {
+		    PDF_save(myPDF);
+		    PDF_translate(myPDF, x, y);
+		    PDF_rotate(myPDF, PDF_TextAngle);
+		    /* vertical justification*/
+		    PDF_translate(myPDF, 0, -(PDF_fontAscent-PDF_fontDescent)/2);
+		    PDF_show_boxed(myPDF, enhanced_text, 0, 0, 0, 0, "left", NULL);
+		    PDF_restore(myPDF);
+		}
+	    }
+	    if (ENHpdf_overprint == 1) {
+		PDF_xLast += stringlength * cos((double)PDF_TextAngle * M_PI_2/90.) / 2.;
+		PDF_yLast += stringlength * sin((double)PDF_TextAngle * M_PI_2/90.);
+	    } else if (ENHpdf_widthflag) {
+		PDF_xLast += stringlength * cos((double)PDF_TextAngle * M_PI_2/90.);
+		PDF_yLast += stringlength * sin((double)PDF_TextAngle * M_PI_2/90.);
+	    }
+	}
+}
+
+TERM_PUBLIC void
+ENHPDF_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    char *original_string = (char *)str;
+
+    if (ignore_enhanced_text) {
+	PDF_put_text(x,y,str);
+	return;
+    }
+
+    if (!str || !strlen(str))
+	return;
+
+    /* if there are no magic characters, we should just be able
+     * punt the string to PDF_put_text()
+     */
+    if (!strpbrk(str, "{}^_@&~")) {
+	/* do something to ensure default font is selected */
+	PDF_put_text(x,y,str);
+	return;
+    }
+
+    PDF_move(x, y);
+    PDF_PathClose();
+    PDF_save(myPDF);
+
+    /* FIXME - Is this the way to do it?????
+    if (PDF_TextAngle != 0)
+	ENHPDF_DEBUG(("currentpoint gsave translate %d rotate 0 0 moveto\n", PDF_TextAngle));
+     */
+
+    /* set up the global variables needed by enhanced_recursion() */
+    enhanced_fontscale = 1.0;
+    strncpy(enhanced_escape_format,"%c",sizeof(enhanced_escape_format));
+
+    ENHpdf_opened_string = FALSE;
+
+    /* EAM - Software text justification requires two passes */
+    if (PDF_TextJust == RIGHT || PDF_TextJust == CENTRE)
+	ENHpdf_sizeonly = TRUE;
+
+    /* Set the recursion going. We say to keep going until a
+     * closing brace, but we don't really expect to find one.
+     * If the return value is not the nul-terminator of the
+     * string, that can only mean that we did find an unmatched
+     * closing brace in the string. We increment past it (else
+     * we get stuck in an infinite loop) and try again.
+     */
+    while (*(str = enhanced_recursion((char *)str, TRUE,
+			PDF_fontNameCur, PDF_fontSizeCur,
+			0.0, TRUE, TRUE, 0))) {
+	(term->enhanced_flush)();
+
+	/* I think we can only get here if *str == '}' */
+	    enh_err_check(str);
+
+	if (!*++str)
+	    break; /* end of string */
+
+	/* else carry on and process the rest of the string */
+    }
+
+    PDF_restore(myPDF);
+
+    /* We can do text justification by running the entire top level string */
+    /* through 2 times, with the ENHpdf_sizeonly flag set the first time.   */
+    /* After seeing where the final position is, we then offset the start  */
+    /* point accordingly and run it again.                                 */
+    if (PDF_TextJust == RIGHT || PDF_TextJust == CENTRE) {
+	int justification = PDF_TextJust;
+	int x_offset = PDF_xLast - x;
+	int y_offset = 0;
+
+	if (PDF_TextAngle != 0)
+	    y_offset = PDF_yLast - y;
+	PDF_TextJust = LEFT;
+	ENHpdf_sizeonly = FALSE;
+
+	if (justification == RIGHT) {
+	    ENHPDF_put_text(x - x_offset, y - y_offset, original_string);
+	} else if (justification == CENTRE) {
+	    ENHPDF_put_text(x - x_offset/2, y - y_offset/2, original_string);
+	}
+	PDF_TextJust = justification;
+    }
+
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+TERM_TABLE_START (pdf_driver)
+    "pdf", "PDF (Portable Document File) file driver",
+    0 /* xmax */ , 0 /* ymax */ , 0 /* vchar */ , 0 /* hchar */ ,
+    0 /* vtic */ , 0 /* htic */ ,
+    PDF_options, PDF_init, PDF_reset, PDF_text, null_scale, PDF_graphics,
+    PDF_move, PDF_vector, PDF_linetype, PDF_put_text, PDF_text_angle,
+    PDF_justify_text, PDF_point, do_arrow, PDF_set_font, do_pointsize,
+    TERM_BINARY|TERM_CAN_DASH|TERM_LINEWIDTH,
+    0 /* suspend */, 0 /* resume */ , PDF_boxfill, PDF_linewidth
+#   ifdef USE_MOUSE
+   , 0, 0, 0, 0, 0 /* no mouse support for pdf */
+#   endif
+   , PDF_make_palette,
+   PDF_previous_palette,
+   PDF_set_color,
+   PDF_filled_polygon
+   , PDF_image
+   , ENHPDF_OPEN, ENHPDF_FLUSH, do_enh_writec
+TERM_TABLE_END (pdf_driver)
+#undef LAST_TERM
+#define LAST_TERM pdf_driver
+#endif /* TERM_TABLE */
+
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(pdf)
+"1 pdf",
+"?commands set terminal pdf",
+"?set terminal pdf",
+"?set term pdf",
+"?terminal pdf",
+"?term pdf",
+"?pdf",
+" This terminal produces files in the Adobe Portable Document Format",
+" (PDF), useable for printing or display with tools like Acrobat Reader",
+"",
+" Syntax:",
+"       set terminal pdf {monochrome|color|colour}",
+"                        {{no}enhanced}",
+"                        {fname \"<font>\"} {fsize <fontsize>}",
+"                        {font \"<fontname>{,<fontsize>}\"}",
+"                        {linewidth <lw>} {rounded|butt}",
+"                        {solid|dashed} {dl <dashlength>}}",
+"                        {size <XX>{unit},<YY>{unit}}",
+"",
+" The default is to use a different color for each line type. Selecting",
+" `monochome` will use black for all linetypes, in which case you probably",
+" want to select `dashed` to distinguish line types. Even in in mono mode",
+" you can still use explicit colors for filled areas or linestyles.",
+"",
+" where <font> is the name of the default font to use (default Helvetica)",
+" and <fontsize> is the font size (in points, default 12).",
+" For help on which fonts are available or how to install new ones, please",
+" see the documentation for your local installation of pdflib.",
+"",
+" The `enhanced` option enables enhanced text processing features",
+" (subscripts, superscripts and mixed fonts). See `enhanced`.",
+"",
+" The width of all lines in the plot can be increased by the factor <n>",
+" specified in `linewidth`. Similarly `dashlength` is a multiplier for the",
+" default dash spacing.",
+"",
+" `rounded` sets line caps and line joins to be rounded; `butt` is the",
+" default, butt caps and mitered joins.",
+"",
+" The default size for PDF output is 5 inches by 3 inches. The `size` option",
+" changes this to whatever the user requests. By default the X and Y sizes",
+" are taken to be in inches, but other units are possible (currently only cm).",
+""
+END_HELP(pdf)
+#endif
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/pm.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/pm.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/pm.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/pm.trm.svn-base	2012-01-03 17:07:42.252550700 -0800
@@ -0,0 +1,1315 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: pm.trm,v 1.55 2009/03/26 00:49:22 sfeam Exp $
+ */
+
+/* GNUPLOT - pm.trm */
+
+/*[
+ * Copyright 1992, 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ *    pm.trm  --- inboard terminal driver for Presentation Manager
+ *            --- after X-11 driver, by R.W.Fearick 31/1/92.
+ *    v1.1 11/8/92 -- speed things up
+ *
+ *    since March 1998: additions for mouse support implemented by Petr Mikulik
+ *	 last change: January 2000
+ *	 for mouse support, pm.trm has to be compiled with USE_MOUSE, e.g.
+ *	 gcc ... -DUSE_MOUSE ...
+ *    January 1999: terminal entries for PM3D functionality by Petr Mikulik
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(pm)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void PM_init __PROTO((void));
+TERM_PUBLIC void PM_options __PROTO((void));
+TERM_PUBLIC void PM_reset __PROTO((void));
+TERM_PUBLIC void PM_text __PROTO((void));
+TERM_PUBLIC void PM_graphics __PROTO((void));
+TERM_PUBLIC void PM_linetype __PROTO((int lt));
+TERM_PUBLIC void PM_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void PM_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC int PM_text_angle __PROTO((int ang));
+TERM_PUBLIC void PM_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC int PM_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC void PM_point __PROTO((unsigned int x, unsigned int y, int number));
+TERM_PUBLIC void PM_suspend __PROTO((void));
+TERM_PUBLIC void PM_resume __PROTO((void));
+TERM_PUBLIC void PM_fillbox __PROTO((int style, unsigned int x, unsigned int y, unsigned int w, unsigned int h));
+TERM_PUBLIC void PM_linewidth __PROTO((double linewidth));
+#ifdef USE_MOUSE
+TERM_PUBLIC void PM_set_ruler __PROTO((int, int));
+TERM_PUBLIC void PM_set_cursor __PROTO((int, int, int));
+TERM_PUBLIC void PM_put_tmptext __PROTO((int, const char str[]));
+TERM_PUBLIC void PM_set_clipboard __PROTO((const char[]));
+#endif
+TERM_PUBLIC int PM_make_palette (t_sm_palette *);
+#if 0
+TERM_PUBLIC void PM_previous_palette (void);
+#endif
+TERM_PUBLIC void PM_set_color (t_colorspec *);
+TERM_PUBLIC void PM_filled_polygon (int, gpiPoint *);
+TERM_PUBLIC void PM_image __PROTO((unsigned int, unsigned int, coordval *, gpiPoint *, t_imagecolor));
+
+#ifndef PM_OLD_ENHANCED_TEXT
+/* To support "set term pm enhanced" */
+TERM_PUBLIC void PM_enhanced_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC void PM_enhanced_open __PROTO((char * fontname, double fontsize,
+	    		double base, TBOOLEAN widthflag, TBOOLEAN showflag,
+			int overprint));
+TERM_PUBLIC void PM_enhanced_flush __PROTO((void));
+#endif
+
+/* define PM world coordinate limits */
+
+#define PM_XMAX 19500
+#define PM_YMAX 12500
+
+/* approximations for typical font/screen sizes */
+#define PM_VCHAR (550)
+#define PM_HCHAR (220)
+/* Note: VCHAR AND HCHAR sizes in gnuplot 3.5 were 415 and 242,
+   in X11 are 500 and 195, respectively.
+*/
+#if 0 /* Sizes of gnuplot 3.6 and 3.7: */
+#  define PM_VTIC (200)
+#  define PM_HTIC (200)
+#else /* Sizes as X11: */
+#  define PM_VTIC (125)
+#  define PM_HTIC (130)
+/* Note: sizes for VTIC and HTIC in gnuplot 3.5 were 122 and 128, respectively.
+*/
+#endif
+
+#endif
+
+#ifdef TERM_BODY
+
+#include <stdio.h>
+#include <process.h>
+#include <io.h>
+#define INCL_DOSPROCESS
+#define INCL_DOSSEMAPHORES
+#define INCL_DOSMISC
+#define INCL_DOSMODULEMGR
+#include <os2.h>
+#include "os2/pm_msgs.h"
+	
+#define PM_nopts 1
+
+/* path for pm program */
+static char PM_path[256] = "";
+/* track mode to avoid redraw after hitting break */
+static int PM_mode = 0;
+static HEV hev;
+static int PM_termmode = 0;
+static int PM_must_reset_opts = FALSE;
+static int PM_must_abort = 0;
+
+static char PM_opts[256] = "";
+static int PM_optargs = 0;
+static int PM_plot_number = 0;
+static char PM_term_title[128] = "";
+
+static int mouseGnupmdrv = 0; /* PM set to 1 if we are connected to a mouseable gnupmdrv */
+
+static FILE *PM_pipe = NULL;
+static FILE *PM_savepipe = NULL;
+
+
+#ifndef PM_OLD_ENHANCED_TEXT
+
+/* track current state of pm terminal */
+/* this is only needed for enhanced text */
+static char * PM_font = NULL; 
+static double PM_fontsize = 12.0;
+static unsigned int PM_x = 0;
+static unsigned int PM_y = 0;
+static enum JUSTIFY PM_justification = LEFT;
+static double PM_angle = 0.;  /* unit is radian */
+
+/* state variables for enhanced text processing */
+static TBOOLEAN ENHpm_opened_string;
+static TBOOLEAN ENHpm_show = TRUE;
+static int ENHpm_overprint = 0;
+static TBOOLEAN ENHpm_widthflag = TRUE;
+static TBOOLEAN ENHpm_sizeonly = FALSE;
+static double ENHpm_base;
+
+#endif
+
+static void PM_reset_opts(void);
+static void PM_query(void);
+static void PM_make_servername(char *);
+static void PM_abortplot();
+static void PM_query_font(void);
+
+
+TERM_PUBLIC void
+PM_init()
+{
+    static char buffer[1024];
+    int pid;
+    int rc;
+    int spawnmode;
+    PPIB pib;
+    PTIB tib;
+    char semname[32];
+    char pipename[32];
+    char tempname[32];
+
+    term_force_init = TRUE;
+    if (PM_savepipe != NULL && PM_termmode == 0) {
+	PM_pipe = PM_savepipe;
+    }
+    if ((PM_pipe == NULL) && (PM_termmode & 2)) {
+	/* check if term is running */
+	PM_make_servername(tempname);
+	strcpy(pipename, "\\pipe\\");
+	strcat(pipename, tempname);
+/*        sprintf( pipename, "\\pipe\\gpServ%d", PM_plot_number ) ; */
+	DosGetInfoBlocks(&tib, &pib);
+	PM_pipe = fopen(pipename, "r+b");
+	if (PM_pipe != NULL) {
+	    setvbuf(PM_pipe, buffer, _IOFBF, 1024);
+	    pid = pib->pib_ulpid;
+	    fwrite(&pid, 1, 4, PM_pipe);
+	    fflush(PM_pipe);
+	    /* set new options */
+/*            PM_reset_opts() ; */
+	}
+    }
+    /* else we start up term here */
+    if (PM_pipe == NULL) {
+	if (PM_termmode & 2) {
+	    PM_make_servername(tempname);
+/*            sprintf( tempname, "gpServ%d", PM_plot_number ) ; */
+	} else {
+	    static int gpid = 0;
+	    gpid++;
+	    sprintf(tempname, "gp%X%d", getpid(), gpid);
+	}
+	strcpy(semname, "\\sem32\\");
+	strcpy(pipename, "\\pipe\\");
+	strcat(semname, tempname);
+	strcat(pipename, tempname);
+	strcat(PM_path, "\\gnupmdrv.exe");
+	rc = access(PM_path, 0);
+	/* find exe file */
+	if (rc != 0)
+	    rc = DosSearchPath(0x0002,	/* search GNUPLOT environment */
+			       "GNUPLOT",
+			       "gnupmdrv.exe",
+			       PM_path,
+			       256);
+
+	if (rc != 0)
+	    rc = DosSearchPath(0x0003,	/* then try current directory & path */
+			       "PATH",
+			       "gnupmdrv.exe",
+			       PM_path,
+			       256);
+	if (rc != 0) {
+	    fputs("Cannot find gnupmdrv.exe !\n", stderr);
+	    exit(3);
+	}
+	rc = DosCreateEventSem(semname, &hev, 1, 0);
+	if (rc != 0) {
+	    fputs("Cannot create semaphore !\n", stderr);
+	    exit(3);
+	}
+	spawnmode = P_SESSION | P_DEFAULT;
+	if (PM_optargs != 0)
+	    spawnmode |= P_UNRELATED;
+	pid = spawnl(spawnmode, PM_path, PM_path, tempname, PM_opts, NULL);
+	if (pid == -1) {
+	    fputs("Cannot spawn gnupmdrv.exe !\n", stderr);
+	    exit(3);
+	}
+	DosGetInfoBlocks(&tib, &pib);
+	DosWaitEventSem(hev, 10000);
+	DosCloseEventSem(hev);
+	PM_pipe = fopen(pipename, "r+b");
+	if (PM_pipe == NULL) {
+	    fputs("Cannot open pipe to gnupmdrv.exe !\n", stderr);
+	    exit(3);
+	} else if (PM_termmode == 0)
+	    PM_savepipe = PM_pipe;
+	setvbuf(PM_pipe, buffer, _IOFBF, 1024);
+	pid = pib->pib_ulpid;
+	fwrite(&pid, 1, 4, PM_pipe);
+	fflush(PM_pipe);
+    } else {
+	if (PM_must_reset_opts)
+	    PM_reset_opts();
+    }
+#ifdef USE_MOUSE
+    /* PM: notify gnupmdrv that this is mouse-enhanced terminal */
+    putc( GR_MOUSECAPABLE, PM_pipe ) ;
+    fflush( PM_pipe ) ;
+    /* we catch mouseable gnupmdrv's answer in PM_query by 0xABCD */
+#endif
+    PM_query();
+}
+
+
+static void
+PM_make_servername(char *str)
+{
+    if (PM_term_title[0]) {
+	int hash = 0;
+	char *p = PM_term_title + 1;
+	int match = PM_term_title[0];
+	while (*p != match) {
+	    hash = (hash << 1) + hash + *p++;
+	}
+	hash %= (256 * 256 * 256 - 1);
+	sprintf(str, "gp%x", hash);
+    } else
+	sprintf(str, "gpServ%d", PM_plot_number);
+}
+
+
+TERM_PUBLIC void
+PM_options()
+{
+    int old_termmode = PM_termmode;
+    PM_termmode = 0;
+    term_options[0] = NUL;
+    PM_term_title[0] = NUL;
+    PM_opts[0] = NUL;
+    PM_optargs = 0;
+    while (!END_OF_COMMAND) {
+	if (almost_equals(c_token, "pe$rsist")) {
+	    strcat(PM_opts, "-p ");
+	    strcat(term_options, "persist ");
+	    PM_termmode |= 1;
+	    PM_optargs = 1;
+	    if (!(old_termmode & 1))
+		PM_pipe = NULL;
+	} else if (almost_equals(c_token, "s$erver")) {
+	    strcat(PM_opts, "-s ");
+	    strcat(term_options, "server ");
+	    PM_termmode |= 2;
+	    PM_optargs = 1;
+	    if (!(old_termmode & 2))
+		PM_pipe = NULL;
+	    if (isanumber(c_token + 1)) {
+		struct value t;
+		char *p = PM_opts + strlen(PM_opts);
+		c_token++;
+		PM_plot_number = (int) real(const_express(&t));
+		sprintf(p, "%d", PM_plot_number);
+		sprintf(term_options + strlen(term_options), "%d", PM_plot_number);
+	    }
+	} else if (almost_equals(c_token, "w$idelines")) {
+	    strcat(PM_opts, "-w ");
+	    strcat(term_options, "widelines ");
+	    PM_optargs = 1;
+	} else if (almost_equals(c_token, "e$nhanced")) {
+	    strcat(term_options, "enhanced ");
+#ifdef PM_OLD_ENHANCED_TEXT
+	    PM_optargs = 1;
+	    strcat(PM_opts, "-e ");
+	    term->put_text = PM_put_text;
+#else
+	    term->put_text = PM_enhanced_put_text;
+#endif
+	    term->flags |= TERM_ENHANCED_TEXT;
+	} else if (almost_equals(c_token, "noe$nhanced")) {
+	    strcat(term_options, "noenhanced ");
+	    term->put_text = PM_put_text;
+	    term->flags &= ~TERM_ENHANCED_TEXT;
+	} else if (isstring(c_token)) {
+	    copy_str(PM_term_title, c_token, 127);
+	}
+#if 0
+	else if (almost_equals(c_token, "po$rtrait")) {
+	    strcat(PM_opts, "-l ");
+	    strcat(term_options, "portrait ");
+	    PM_optargs = 1;
+	}
+#endif
+	c_token++;
+    }
+    if (PM_term_title[0]) {
+	strcat(PM_opts, " ");
+	strcat(term_options, " ");
+	strcat(PM_opts, PM_term_title);
+	strcat(term_options, PM_term_title);
+    }
+    PM_must_reset_opts = TRUE;
+}
+
+
+static void
+PM_reset_opts()
+{
+    int len;
+    putc(SET_OPTIONS, PM_pipe);
+    len = strlen(PM_opts) + 1;
+    fwrite(&len, sizeof(int), 1, PM_pipe);
+    fwrite(PM_opts, 1, len, PM_pipe);
+    for (len = sizeof(int) - len % sizeof(int); len > 0; len--) {
+	/* pad rest of int with zeros */
+	putc(NUL, PM_pipe);
+    }
+    fflush(PM_pipe);
+    PM_must_reset_opts = FALSE;
+}
+
+
+static void
+PM_query()
+{
+    int rc;
+    ULONG cbR;
+    putc(GR_QUERY, PM_pipe);
+    fflush(PM_pipe);
+    rc = DosRead(fileno(PM_pipe), &term->h_char, sizeof(int), &cbR);
+    if (term->h_char == 0xABCD) {
+      /* PM we have got greetings from mouseable gnupmdrv */
+      mouseGnupmdrv = 1; /*  thus set mouseGnupmdrv on and reread h_char */
+      rc = DosRead( fileno(PM_pipe), &term->h_char, sizeof(int), &cbR ) ;
+      }
+    rc = DosRead(fileno(PM_pipe), &term->v_char, sizeof(int), &cbR);
+}
+
+
+# ifdef USE_MOUSE
+/* update menu items in PM terminal */
+void
+PM_update_menu_items()
+{
+    /* connected to a mouseable gnupmdrv */
+    if ((PM_pipe != NULL) && (mouseGnupmdrv)) {
+	struct t_gpPMmenu gpPMmenu;
+
+	PM_set_gpPMmenu(&gpPMmenu);
+	putc(SET_MENU, PM_pipe);
+	fwrite(&gpPMmenu, sizeof(gpPMmenu), 1, PM_pipe);
+    }
+}
+#endif
+
+
+TERM_PUBLIC void
+PM_reset()
+{
+    putc(GR_RESET, PM_pipe);
+    fflush(PM_pipe);
+    term_force_init = FALSE;
+    if (PM_termmode > 0) {
+	fclose(PM_pipe);
+	PM_pipe = NULL;
+    }
+}
+
+
+TERM_PUBLIC void
+PM_suspend()
+{
+    putc(GR_SUSPEND, PM_pipe);
+    fflush(PM_pipe);
+}
+
+
+TERM_PUBLIC void
+PM_resume()
+{
+    putc(GR_RESUME, PM_pipe);
+    fflush(PM_pipe);
+}
+
+
+TERM_PUBLIC void
+PM_text()
+{
+    fflush(PM_pipe);
+    if (PM_mode != SET_TEXT) {
+	putc(SET_TEXT, PM_pipe);
+	fflush(PM_pipe);
+#if 0
+        keep_term_initialised = term_initialised ;
+        term_initialised = FALSE ; /* need to force init */
+#endif
+    }
+
+    PM_mode = SET_TEXT;
+#ifdef USE_MOUSE
+    {
+	/* FIXME 20040712: 'extern' in a source file is always wrong. */
+	extern TBOOLEAN allowmotion;
+	allowmotion = TRUE;
+    }
+#endif
+}
+
+
+TERM_PUBLIC void
+PM_graphics()
+{
+    static int last_encoding = -999;
+    putc(SET_GRAPHICS, PM_pipe);
+    fflush(PM_pipe);
+#ifdef USE_MOUSE
+    PM_update_menu_items();
+#endif
+    if (encoding != last_encoding) {
+	int cp;
+	switch (encoding) {
+	    case S_ENC_ISO8859_2: cp = 912; break;
+	    case S_ENC_CP437: cp = 437; break;
+	    case S_ENC_CP850: cp = 850; break;
+	    default: /*  S_ENC_DEFAULT, S_ENC_ISO8859_1 */
+		     cp = 0; break;
+	};
+	putc(SET_SPECIAL, PM_pipe);
+	putc('c', PM_pipe); /*  set codepage */
+	fwrite(&cp, sizeof(int), 1, PM_pipe);
+	fflush(PM_pipe);
+	last_encoding = encoding;
+    }
+    PM_mode = SET_GRAPHICS;
+}
+
+
+TERM_PUBLIC void
+PM_move(unsigned int x, unsigned int y)
+{
+    if (PM_must_abort)
+	PM_abortplot();
+
+    putc(GR_MOVE, PM_pipe);
+    fwrite(&x, sizeof(int), 1, PM_pipe);
+    fwrite(&y, sizeof(int), 1, PM_pipe);
+
+#ifndef PM_OLD_ENHANCED_TEXT
+    /* save current position, only needed for enhanced text */
+    PM_x = x; 
+    PM_y = y;
+#endif
+}
+
+
+TERM_PUBLIC void
+PM_vector(unsigned int x, unsigned int y)
+{
+    if (PM_must_abort)
+	PM_abortplot();
+    putc(GR_DRAW, PM_pipe);
+    fwrite(&x, sizeof(int), 1, PM_pipe);
+    fwrite(&y, sizeof(int), 1, PM_pipe);
+}
+
+
+TERM_PUBLIC void
+PM_linetype(int lt)
+{
+    putc(SET_LINE, PM_pipe);
+    fwrite(&lt, sizeof(int), 1, PM_pipe);
+}
+
+
+TERM_PUBLIC int
+PM_text_angle(int ang)
+{
+    putc(SET_ANGLE, PM_pipe);
+    fwrite(&ang, sizeof(int), 1, PM_pipe);
+#ifndef PM_OLD_ENHANCED_TEXT
+    /* store text angle, only needed for enhanced text */
+    PM_angle = (double)ang * M_PI / 180.;
+#endif
+    return TRUE;
+}
+
+
+TERM_PUBLIC void
+PM_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    int len;
+
+    if (PM_must_abort)
+	PM_abortplot();
+
+#ifdef PM_OLD_ENHANCED_TEXT
+    if (ignore_enhanced_text) {
+	putc(SET_SPECIAL, PM_pipe);
+	putc('e', PM_pipe); /* switch the enhanced mode off */
+	putc('0', PM_pipe);
+    }
+#endif
+
+    putc(GR_TEXT, PM_pipe);
+    fwrite(&x, sizeof(int), 1, PM_pipe);
+    fwrite(&y, sizeof(int), 1, PM_pipe);
+    len = strlen(str) + 1;
+    fwrite(&len, sizeof(int), 1, PM_pipe);
+    fwrite(str, 1, len, PM_pipe);
+    for (len = sizeof(int) - len % sizeof(int); len > 0; len--) {
+	/* pad rest of int with zeros */
+	putc(NUL, PM_pipe);
+    }
+
+#ifdef PM_OLD_ENHANCED_TEXT
+    if (ignore_enhanced_text) {
+	putc(SET_SPECIAL, PM_pipe);
+	putc('e', PM_pipe); /* restore the enhanced mode */
+	putc('2', PM_pipe);
+    }
+#endif
+}
+
+
+TERM_PUBLIC int
+PM_justify_text(enum JUSTIFY mode)
+{
+#ifdef PM_OLD_ENHANCED_TEXT
+    if (ignore_enhanced_text) {
+	putc(SET_SPECIAL, PM_pipe);
+	putc('e', PM_pipe); /* switch the enhanced mode off */
+	putc('0', PM_pipe);
+    }
+#endif
+	
+    putc(SET_JUSTIFY, PM_pipe);
+    fwrite(&mode, sizeof(int), 1, PM_pipe);
+
+#ifndef PM_OLD_ENHANCED_TEXT
+    /* store text justification, only needed for enhanced text */
+    PM_justification = mode;
+#else
+    if (ignore_enhanced_text) {
+	putc(SET_SPECIAL, PM_pipe);
+	putc('e', PM_pipe); /* restore the enhanced mode */
+	putc('2', PM_pipe);
+    }
+#endif
+    return TRUE;
+}
+
+
+TERM_PUBLIC int
+PM_set_font(const char *font)
+{
+    unsigned int len;
+
+    putc(SET_FONT, PM_pipe);
+    if (font == NULL)
+        len = 0;
+    else
+        len = strlen(font);
+
+    if (len==0) {
+        fwrite(&len, sizeof(int), 1, PM_pipe);
+    } else {
+        len += 1;
+        fwrite(&len, sizeof(int), 1, PM_pipe);
+        fwrite(font, 1, len, PM_pipe);
+        for (len = sizeof(int) - len % sizeof(int); len > 0; len--) {
+	    /* pad rest of int with zeros */
+	    putc(NUL, PM_pipe);
+        }
+    }
+
+    return TRUE;
+}
+
+
+#ifndef PM_OLD_ENHANCED_TEXT
+
+/* PM_query_font:
+	get current font name and size from gnupmdrv and
+	save them to PM_font and PM_fontsize
+*/
+static void PM_query_font(void)
+{
+    unsigned int len, fontsize;
+    char *newfont;
+    ULONG cbR, rc;
+
+    putc(GR_QUERY_FONT, PM_pipe);
+    fflush(PM_pipe);  
+
+    free( PM_font );
+    rc = DosRead(fileno(PM_pipe), &len, sizeof(int), &cbR);
+    newfont = (char *)malloc( len + 1 ); 
+    rc = DosRead(fileno(PM_pipe), newfont, len*sizeof(char), &cbR);
+    newfont[len] = '\0';
+    
+    PM_font = (char *)malloc( len + 1 ); 
+    sscanf( newfont, "%i.%s", &fontsize, PM_font );
+    PM_fontsize = (double)fontsize;
+    free(newfont);
+}
+
+#endif
+
+
+TERM_PUBLIC void
+PM_point(unsigned int x, unsigned int y, int number)
+/*
+** tell the driver we are plotting a point so it can decide whether to
+** use colour or not
+*/
+{
+    int mode;
+    mode = 1;
+    putc(SET_POINTMODE, PM_pipe);
+    fwrite(&mode, sizeof(int), 1, PM_pipe);
+    do_point(x, y, number);
+    mode = 0;
+    putc(SET_POINTMODE, PM_pipe);
+    fwrite(&mode, sizeof(int), 1, PM_pipe);
+}
+
+
+void
+PM_abortplot(void)
+{
+    PM_must_abort = 0;
+    term_reset();
+    (void) putc('\n', stderr);
+    bail_to_command_line();
+}
+
+
+void
+PM_intc_cleanup(void)
+{
+    if (PM_pipe == NULL || PM_mode == SET_TEXT)
+	PM_abortplot();
+    PM_must_abort = 1;
+}
+
+
+int
+PM_pause(char *str)
+/*
+** pause - using message box on PM screen
+*/
+{
+    int len, rc;
+    ULONG cbR;
+    char buf[256];
+    char *bp;
+
+    if (PM_pipe == NULL)
+	return 2;
+    bp = buf;
+    putc(GR_PAUSE, PM_pipe);
+    len = strlen(str) + 1;
+    fwrite(&len, sizeof(int), 1, PM_pipe);
+    fwrite(str, 1, len, PM_pipe);
+    for (rc = sizeof(int) - len % sizeof(int); rc > 0; rc--) {
+	/* pad rest of int with zeros */
+	putc(NUL, PM_pipe);
+    }
+    fflush(PM_pipe);
+    rc = DosRead(fileno(PM_pipe), &len, sizeof(int), &cbR);
+    return len;
+}
+
+
+TERM_PUBLIC void
+PM_fillbox(int style, unsigned int x, unsigned int y, unsigned int w, unsigned int h)
+{
+    putc(SET_FILLBOX, PM_pipe);
+    fwrite(&style, sizeof(style), 1, PM_pipe);
+    fwrite(&x, sizeof(x), 1, PM_pipe);
+    fwrite(&y, sizeof(y), 1, PM_pipe);
+    fwrite(&w, sizeof(w), 1, PM_pipe);
+    fwrite(&h, sizeof(h), 1, PM_pipe);
+}
+
+
+TERM_PUBLIC void
+PM_linewidth(double linewidth)
+{
+    int lw;
+    lw = linewidth * 100;
+    putc(SET_LINEWIDTH, PM_pipe);
+    fwrite(&lw, sizeof(int), 1, PM_pipe);
+}
+
+
+TERM_PUBLIC int
+PM_make_palette(t_sm_palette * palette)
+{
+    if (palette == NULL) {
+	ULONG rc, cbR;
+	int PM_nColors;
+
+	/* query maximum number of colours in palette */
+	putc(GR_MAKE_PALETTE, PM_pipe);
+	putc(0, PM_pipe);
+	fflush(PM_pipe);
+	rc = DosRead(fileno(PM_pipe), &PM_nColors, sizeof(int), &cbR);
+	return PM_nColors;
+    }
+
+    if (sm_palette.colors > 0) {
+	ULONG *rgbTable;
+	unsigned int i;
+
+	/* Note: gvpm sources have also limit 256, is it limit of PM palette?
+	   I suppose yes, thus let colours passed as unsigned char through the pipe.
+	   Gray interval [0;1] will be mapped to interval [0;255] whose r,g,b
+	   components are mapped by the array below.
+	 */
+	putc(GR_MAKE_PALETTE, PM_pipe);
+	putc(1, PM_pipe);
+	rgbTable = (ULONG *) malloc(sizeof(ULONG) * sm_palette.colors);
+	for (i = 0; i < sm_palette.colors; i++) {
+	    ULONG r, g, b;
+
+	    r = (ULONG) (palette->color[i].r * 255 + 0.5);
+	    g = (ULONG) (palette->color[i].g * 255 + 0.5);
+	    b = (ULONG) (palette->color[i].b * 255 + 0.5);
+	    rgbTable[i] = (r << 16) + (g << 8) + b;	/*  PM API likes this form */
+	}
+	fwrite(&sm_palette.colors, sizeof(int), 1, PM_pipe);
+	fwrite(rgbTable, sizeof(ULONG) * sm_palette.colors, 1, PM_pipe);
+	free(rgbTable);
+    }
+    return 0;
+}
+
+
+#if 0
+/* switch back to the palette used before calling make_palette */
+TERM_PUBLIC void
+PM_previous_palette()
+{
+    putc(GR_RELEASE_PALETTE, PM_pipe);
+}
+#endif
+
+
+TERM_PUBLIC void
+PM_set_color(t_colorspec *colorspec)
+{
+    switch (colorspec->type) {
+    case TC_FRAC:
+	if (sm_palette.colors == 0) {
+	    rgb255_color rgb255;
+	    unsigned int rgb;
+
+	    rgb255maxcolors_from_gray(colorspec->value, &rgb255);
+	    rgb = (rgb255.r << 16) + (rgb255.g << 8) + rgb255.b;
+	    putc(GR_SET_RGBCOLOR, PM_pipe);
+	    fwrite(&rgb, sizeof(int), 1, PM_pipe);
+	} else {
+	    unsigned char colorindex;
+
+	    /* map [0;1] to interval [0;sm_palette.colors-1] */
+	    colorindex = ((colorspec->value * (sm_palette.colors - 1.)) + 0.5);
+	    putc(GR_SET_COLOR, PM_pipe);
+	    fwrite(&colorindex, sizeof(colorindex), 1, PM_pipe);
+	}
+	break;
+    case TC_LT:
+	PM_linetype(colorspec->lt);
+	break;
+    case TC_RGB:
+	putc(GR_SET_RGBCOLOR, PM_pipe);
+	fwrite(&(colorspec->lt), sizeof(int), 1, PM_pipe);
+	/* fflush(PM_pipe); */ /* FIXME: why should that be necessary? */
+	break;
+    }
+}
+
+
+TERM_PUBLIC void PM_filled_polygon ( int points, gpiPoint *corners )
+{
+    int i;
+    putc(GR_FILLED_POLYGON, PM_pipe);
+    fwrite(&points, sizeof(int), 1, PM_pipe); /*  tell him number of corners */
+    for (i = 0; i < points; i++) {
+	fwrite(&corners[i].x, sizeof(int), 1, PM_pipe);
+	fwrite(&corners[i].y, sizeof(int), 1, PM_pipe);
+    }
+}
+
+
+#ifdef USE_MOUSE
+
+TERM_PUBLIC void
+PM_put_tmptext(int i, const char str[])
+{
+    if (PM_pipe) {
+	putc(PUT_TMPTEXT, PM_pipe);
+	fwrite(&i, sizeof(int), 1, PM_pipe);
+	i = strlen(str) + 1;
+	fwrite(&i, sizeof(int), 1, PM_pipe);
+	fwrite(&str[0], i, 1, PM_pipe);
+	fflush(PM_pipe);
+    }
+}
+
+
+TERM_PUBLIC void
+PM_set_ruler(int x, int y)
+{
+    if (PM_pipe) {
+	putc(SET_RULER, PM_pipe);
+	fwrite(&x, sizeof(int), 1, PM_pipe);
+	fwrite(&y, sizeof(int), 1, PM_pipe);
+	fflush(PM_pipe);
+    }
+}
+
+
+TERM_PUBLIC void
+PM_set_cursor(int c, int x, int y)
+{
+    if (PM_pipe) {
+	putc(SET_CURSOR, PM_pipe);
+	fwrite(&c, sizeof(int), 1, PM_pipe);
+	fwrite(&x, sizeof(int), 1, PM_pipe);
+	fwrite(&y, sizeof(int), 1, PM_pipe);
+	fflush(PM_pipe);
+    }
+}
+
+
+TERM_PUBLIC void
+PM_set_clipboard(const char s[])
+{
+    if (PM_pipe) {
+	int i = strlen(s);
+	putc(SET_CLIPBOARD, PM_pipe);
+	fwrite(&i, sizeof(int), 1, PM_pipe);
+	fwrite(s, i+1, 1, PM_pipe);
+	fflush(PM_pipe);
+    }
+}
+
+#endif /* USE_MOUSE */
+
+
+TERM_PUBLIC void
+PM_image(unsigned int M, unsigned int N, coordval *image, gpiPoint *corner, t_imagecolor color_mode)
+{
+    PBYTE rgb_image;
+    unsigned int image_size;
+    unsigned int pad_bytes;
+
+    /* IC_PALETTE and IC_RGB images are converted to a 24bit RGB format
+       suitable for OS/2's presentation manager:
+        - sequence of lines is reversed 
+        - each line starts at a 4 byte boundary
+    */
+
+    /* fprintf(stderr, "PM_image: %i x %i, mode=%s\n", M, N, color_mode==IC_RGB?"IC_RGB":"IC_PALETTE" ); */
+    pad_bytes = (4 - (3 * M) % 4) % 4; /* scan lines start on ULONG boundaries */
+    image_size = (M + pad_bytes ) * N * 3;
+    rgb_image = (PBYTE) gp_alloc(image_size, "PM RGB image");
+
+    if (color_mode == IC_PALETTE) {
+    	unsigned int x, y;
+
+	rgb_image += N * (3 * M + pad_bytes);
+	for (y=0; y<N; y++) {
+	    rgb_image -= 3 * M + pad_bytes;
+	    for(x=0; x<M; x++) {
+		rgb255_color rgb255;
+		rgb255maxcolors_from_gray(*image++, &rgb255);
+		*(rgb_image++) = rgb255.b;
+		*(rgb_image++) = rgb255.g;
+		*(rgb_image++) = rgb255.r;
+	    }
+	    rgb_image -= 3 * M;
+	}
+    } else if (color_mode == IC_RGB) {
+    	unsigned int x, y;
+
+	rgb_image += N * (3 * M + pad_bytes);
+	for (y=0; y<N; y++) {
+	    rgb_image -= 3 * M + pad_bytes;
+	    for(x=0; x<M; x++) {
+		rgb255_color rgb255;
+		rgb255.r = (BYTE) (*image++ * 255 + 0.5);
+		rgb255.g = (BYTE) (*image++ * 255 + 0.5);
+		rgb255.b = (BYTE) (*image++ * 255 + 0.5);
+		*(rgb_image++) = rgb255.b;
+		*(rgb_image++) = rgb255.g;
+		*(rgb_image++) = rgb255.r;
+	    }
+	    rgb_image -= 3 * M;
+	}
+    }
+
+    if ((color_mode == IC_PALETTE) || (color_mode == IC_RGB)) {
+	unsigned int i;
+
+	/* transfer data to gnupmdrv */
+	putc(GR_RGB_IMAGE, PM_pipe);
+	fwrite(&M, sizeof(M), 1, PM_pipe);
+	fwrite(&N, sizeof(N), 1, PM_pipe);
+	for (i=0; i<4; i++) {
+	    fwrite(&(corner[i].x), sizeof(int), 1, PM_pipe);
+	    fwrite(&(corner[i].y), sizeof(int), 1, PM_pipe);
+	}
+	fwrite(&image_size, sizeof(image_size), 1, PM_pipe);
+	fwrite(rgb_image, image_size, 1, PM_pipe);
+	fflush(PM_pipe);
+    }
+
+    free(rgb_image);
+}
+
+
+#ifndef PM_OLD_ENHANCED_TEXT
+
+TERM_PUBLIC void
+PM_enhanced_open(
+    char *fontname,
+    double fontsize, double base,
+    TBOOLEAN widthflag, TBOOLEAN showflag,
+    int overprint)
+{
+    static const int pm_scale = 35; /* scaling of base offset */  
+    static unsigned int ENHpm_xsave, ENHpm_ysave;
+    char *fontstring;
+
+    /* There are two special cases:
+     * overprint = 3 means save current position
+     * overprint = 4 means restore saved position
+     */
+    if (overprint == 3) {
+	ENHpm_xsave = PM_x;
+	ENHpm_ysave = PM_y;
+	return;
+    } else if (overprint == 4) {
+	PM_x = ENHpm_xsave;
+	PM_y = ENHpm_ysave;
+	return;
+    }
+
+    if (!ENHpm_opened_string) {
+	ENHpm_opened_string = TRUE;
+
+	/* Start new text fragment */
+	enhanced_cur_text = &enhanced_text[0];
+
+	/* Keep track of whether we are supposed to show this string */
+	ENHpm_show = showflag;
+
+	/* 0/1/2  no overprint / 1st pass / 2nd pass */
+	ENHpm_overprint = overprint;
+
+	/* widthflag FALSE means do not update text position after printing */
+	ENHpm_widthflag = widthflag;
+
+	/* Select font */
+	/* FIXME: It would be nice to have fractional font sizes 
+	          for super- and subscripts. */
+	/* FIXME: sometimes fontname has zero length */
+	if ((fontname != NULL) && strlen(fontname) > 0) {
+	    fontstring = malloc( strlen(fontname) + 16 );
+	    sprintf( fontstring, "%s,%i", fontname, (int)fontsize );
+	}
+	else {
+	    fontstring = malloc( strlen(PM_font) + 16 );
+	    sprintf( fontstring, "%s,%i", PM_font, (int)fontsize );
+	}
+	PM_set_font( fontstring );
+	free( fontstring );
+	PM_query_font();
+
+	/* Scale fractional font height to vertical units of display */
+	/* FIXME:	
+		Font scaling is not done properly (yet) and will lead to
+		non-optimal results for most font and size selections.
+		The old gnupmdrv code used FONTINFO information for super-
+		and subscripts.
+	*/
+	ENHpm_base = pm_scale * base;
+    }
+}
+
+
+TERM_PUBLIC void
+PM_enhanced_flush()
+{
+    static unsigned int ENHpm_xsave, ENHpm_ysave;
+
+    if (ENHpm_opened_string) {
+	int width, height;
+	unsigned int mode;
+	unsigned int x, y, len;
+	ULONG rc, cbR;
+
+	*enhanced_cur_text = '\0';
+	
+	if (PM_must_abort)
+	    PM_abortplot();
+
+	/* print the string fragment, perhaps invisibly */
+	/* NB: base expresses offset from current y pos */
+	x = PM_x - ENHpm_base * sin(PM_angle);
+	y = PM_y + ENHpm_base * cos(PM_angle);
+	mode = ((ENHpm_show && !ENHpm_sizeonly) ? 0x01 : 0x00 );
+	len = strlen(enhanced_text) + 1;
+
+	/* send message to gnupmdrv */
+	putc(GR_ENH_TEXT, PM_pipe);
+	fwrite(&x, sizeof(int), 1, PM_pipe);
+	fwrite(&y, sizeof(int), 1, PM_pipe);
+	/* write 'mode indicator' (currently show switch only) */
+	fwrite(&mode, sizeof(int), 1, PM_pipe); 
+	fwrite(&len, sizeof(int), 1, PM_pipe);
+	fwrite(enhanced_text, 1, len, PM_pipe);
+	for (len = sizeof(int) - len % sizeof(int); len > 0; len--) {
+	    /* pad rest of int with zeros */
+	    putc(NUL, PM_pipe);
+	}
+
+	/* answer from gnupmdrv is length of text */
+	fflush(PM_pipe);
+	rc = DosRead(fileno(PM_pipe), &width, sizeof(int), &cbR);
+	rc = DosRead(fileno(PM_pipe), &height, sizeof(int), &cbR);
+
+	/* update drawing position according to len */
+	if (!ENHpm_widthflag) {
+	    width = 0; 
+	    height = 0;
+	}
+	if (ENHpm_sizeonly) {
+	    /* This is the first pass for justified printing.        */
+	    /* We just adjust the starting position for second pass. */
+	    if (PM_justification == RIGHT) {
+		PM_x -= width;
+		PM_y -= height;
+	    }
+	    else if (PM_justification == CENTRE) {
+		PM_x -= width / 2;
+		PM_y -= height / 2;
+	    }
+	    /* nothing to do for LEFT justified text */
+	}
+	else if (ENHpm_overprint == 1) {
+	    /* Save current position */
+	    ENHpm_xsave = PM_x + width;
+	    ENHpm_ysave = PM_y + height;
+	    /* First pass of overprint, leave position in center of fragment */
+	    PM_x += width / 2;
+	    PM_y += height / 2;
+	}
+	else if (ENHpm_overprint == 2) {
+	    /* Restore current position,                          */
+	    /* this sets the position behind the overprinted text */
+	    PM_x = ENHpm_xsave;
+	    PM_y = ENHpm_ysave;
+	}
+	else {
+	    /* Normal case is to update position to end of fragment */
+	    PM_x += width;
+	    PM_y += height;
+	}
+
+	ENHpm_opened_string = FALSE;
+    }
+}
+
+
+TERM_PUBLIC void
+PM_enhanced_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    char *original_string = (char *)str;
+    unsigned int pass, num_passes;
+
+    /* If no enhanced text processing is needed, we can use the plain  */
+    /* vanilla put_text() routine instead of this fancy recursive one. */
+    if (ignore_enhanced_text || !strpbrk(str, "{}^_@&~")) {
+	PM_put_text(x,y,str);
+	return;
+    }
+
+    /* Set up global variables needed by enhanced_recursion() */
+    ENHpm_opened_string = FALSE;
+    enhanced_fontscale = 1.0;
+    strncpy(enhanced_escape_format,"%c",sizeof(enhanced_escape_format));
+
+    /* Tell the terminal to move the drawing position */
+    /* we store the current position to PM_x and PM_y */
+    PM_x = x; 
+    PM_y = y;
+
+    /* Text justification requires two passes. During the first pass we */
+    /* don't draw anything, we just measure the space it will take.     */
+    /* Without justification one pass is enough                         */
+    if (PM_justification == LEFT) {
+	num_passes = 1;
+    }
+    else {
+	num_passes = 2;
+	ENHpm_sizeonly = TRUE; 
+    }
+
+    for( pass=1; pass <= num_passes; pass++ ) {
+
+	/* This will restore the default font 
+	   and update PM_font and PM_fontsize */
+	PM_set_font(NULL); 
+	PM_query_font(); 
+
+	/* Set the recursion going. We say to keep going until a
+	* closing brace, but we don't really expect to find one.
+	* If the return value is not the nul-terminator of the
+	* string, that can only mean that we did find an unmatched
+	* closing brace in the string. We increment past it (else
+	* we get stuck in an infinite loop) and try again.
+	*/
+	while (*(str = enhanced_recursion((char *)str, TRUE,
+			NULL, PM_fontsize,
+			0.0, TRUE, TRUE, 0))) {
+	    (term->enhanced_flush)();
+
+	    /* I think we can only get here if *str == '}' */
+	    enh_err_check(str);
+
+	    if (!*++str)
+	    	break; /* end of string */
+
+	    /* else carry on and process the rest of the string */
+	}
+
+	/* In order to do text justification we need to do a second pass that */
+	/* uses information stored during the first pass.                     */
+	/* see PM_enhanced_flush()                                            */
+	if (pass == 1) {
+	    /* do the actual printing in the next pass */
+	    ENHpm_sizeonly = FALSE;
+	    str = original_string;
+	}
+    }
+
+    /* restore default font */
+    PM_set_font(NULL); 
+}
+
+#endif /* PM_OLD_ENHANCED_TEXT */
+
+
+/* helper function */
+void
+pm_raise_terminal_window()
+{
+    putc(SET_SPECIAL, PM_pipe);
+    putc('^', PM_pipe); /* raise window */
+    fflush(PM_pipe);
+}
+
+void
+pm_lower_terminal_window()
+{
+    putc(SET_SPECIAL, PM_pipe);
+    putc('_', PM_pipe); /* lower window */
+    fflush(PM_pipe);
+}
+
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+TERM_TABLE_START(PM_driver)
+    "pm", "OS/2 Presentation Manager",
+    PM_XMAX, PM_YMAX, PM_VCHAR, PM_HCHAR,
+    PM_VTIC, PM_HTIC, PM_options, PM_init, PM_reset,
+    PM_text, null_scale, PM_graphics, PM_move, PM_vector,
+    PM_linetype, PM_put_text, PM_text_angle,
+    PM_justify_text, PM_point, do_arrow, PM_set_font,
+    0 /*pointsize */ , TERM_CAN_MULTIPLOT|TERM_NO_OUTPUTFILE, 
+    PM_suspend, PM_resume,
+    PM_fillbox, PM_linewidth
+#ifdef USE_MOUSE
+    , 0 /* PM_waitforinput */,
+    PM_put_tmptext, PM_set_ruler, PM_set_cursor, PM_set_clipboard
+#endif
+    , PM_make_palette,
+    0, /* PM_previous_palette */
+    PM_set_color,
+    PM_filled_polygon
+    , PM_image
+#ifndef PM_OLD_ENHANCED_TEXT
+    , PM_enhanced_open, PM_enhanced_flush, do_enh_writec
+#endif
+TERM_TABLE_END(PM_driver)
+
+#undef LAST_TERM
+#define LAST_TERM PM_driver
+
+#endif /* TERM_TABLE */
+
+#ifdef TERM_HELP
+START_HELP(pm)
+"1 pm",
+"?commands set terminal pm",
+"?set terminal pm",
+"?set term pm",
+"?terminal pm",
+"?term pm",
+"?pm",
+" The `pm` terminal driver provides an OS/2 Presentation Manager window in",
+" which the graph is plotted.  The window is opened when the first graph is",
+" plotted.  This window has its own online help as well as facilities for",
+" printing, copying to the clipboard and some line type and color adjustments.",
+" The `multiplot` option is supported.",
+"",
+" Syntax:",
+"       set terminal pm {server {n}} {persist} {widelines} {enhanced} {\"title\"}",
+"",
+" If `persist` is specified, each graph appears in its own window and all",
+" windows remain open after `gnuplot` exits.  If `server` is specified, all",
+" graphs appear in the same window, which remains open when `gnuplot` exits.",
+" This option takes an optional numerical argument which specifies an instance",
+" of the server process.  Thus multiple server windows can be in use at the",
+" same time.",
+"",
+" If `widelines` is specified, all plots will be drawn with wide lines.  If",
+" `enhanced` is specified, sub- and superscripts and multiple fonts are enabled",
+" (see `enhanced text` for details).  Font names for the core PostScript fonts",
+" may be abbreviated to a single letter ",
+" (T/H/C/S for Times/Helvetica/Courier/Symbol).",
+"",
+" If `title` is specified, it will be used as the title of the plot window.",
+" It will also be used as the name of the server instance, and will override",
+" the optional numerical argument.",
+"",
+" Linewidths may be changed with `set linestyle`."
+END_HELP(pm)
+#endif /* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/post.h.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/post.h.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/post.h.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/post.h.svn-base	2012-01-03 17:07:42.464099300 -0800
@@ -0,0 +1,89 @@
+/*
+ * $Id: post.h,v 1.10 2005/07/18 18:24:00 sfeam Exp $
+ */
+
+/* GNUPLOT - post.h */
+
+/*[
+ * Copyright 1986 - 1993, 1998, 2004   Thomas Williams, Colin Kelley
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+#ifndef TERM_POST_H
+# define TERM_POST_H
+
+/* Needed by terminals which output postscript
+ * (post.trm and pslatex.trm)
+ */
+
+#ifdef PSLATEX_DRIVER
+TERM_PUBLIC void PSTEX_common_init __PROTO((void));
+TERM_PUBLIC void PSTEX_reopen_output __PROTO((void));
+TERM_PUBLIC void EPSLATEX_common_init __PROTO((void));
+TERM_PUBLIC void EPSLATEX_reopen_output __PROTO((void));
+#endif
+
+#define PS_POINT_TYPES 8
+
+/* assumes landscape */
+#define PS_XMAX (10*720)
+#define PS_YMAX (7*720)
+#define PS_YMAX_OLDSTYLE (6*720)
+
+/* These seem to be unnecessary, thus commented out */
+/*
+#define PS_XLAST (PS_XMAX - 1)
+#define PS_YLAST (PS_YMAX - 1)
+*/
+
+#define PS_VTIC (PS_YMAX/80)
+#define PS_HTIC (PS_YMAX/80)
+
+/* scale is 1pt = 10 units */
+#define PS_SC 10
+
+/* linewidth = 0.5 pts */
+#define PS_LW (0.5*PS_SC)
+
+/* character size defaults: */
+/* 14 pt for postscript */
+#define PS_VCHAR (14*PS_SC)
+#define PS_HCHAR (14*PS_SC*6/10)
+/* 10 pt for ps(la)tex */
+#define PSTEX_VCHAR (10*PS_SC)
+#define PSTEX_HCHAR (10*PS_SC*6/10)
+/* 11 pt for epslatex */
+#define EPSLATEX_VCHAR (11*PS_SC)
+#define EPSLATEX_HCHAR (11*PS_SC*6/10)
+
+/* additional LaTeX header information for epslatex terminal */
+#ifdef PSLATEX_DRIVER
+TERM_PUBLIC char *epslatex_header;
+#endif
+
+#endif /* TERM_POST_H */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/post.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/post.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/post.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/post.trm.svn-base	2012-01-03 17:07:42.671637500 -0800
@@ -0,0 +1,4277 @@
+/* Hello, Emacs: this is -*-C-*- !
+ * $Id: post.trm,v 1.243.2.4 2009/09/13 17:54:09 sfeam Exp $
+ */
+
+/* GNUPLOT - post.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 1999, 2000, 2001, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This terminal driver supports:
+ *     postscript
+ *
+ * AUTHORS
+ *  Russell Lang  <rjl@monu1.cc.monash.edu.au>
+ *
+ * modified 10/5/95 by drd - put in support for other postscript drivers
+ * (enhpost, pslatex, ...) so they dont have to work quite so hard
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ * The 'postscript' driver produces landscape output 10" wide and 7" high.
+ * To change font to Times-Roman and font size to 20pts use
+ * 'set term postscript "Times-Roman" 20'.
+ * To get a smaller (5" x 3.5") eps output use 'set term post eps'
+ * and make only one plot per file.  Font size for eps will be half
+ * the specified size.
+ *
+ * Erik Luijten 30/5/97: added %%CreationDate, made %%DocumentFonts conform
+ *                       to DSC, added version no. and patchl. to %%Creator
+ * Petr Mikulik, Jan 1999: terminal entries for PM3D functionality
+ *
+ * Dick Crawford 24/5/00: added 'a{}{}' syntax to allow for overprinting
+ *
+ * Dan Sebald, 7 March 2003: terminal entry for image functionality
+ *
+ * Harald Harders (h.harders@tu-bs.de), 2004-12-02:
+ * Moved all terminal settings into a single structure.
+ *
+ * Harald Harders (h.harders@tu-bs.de), 2005-02-08:
+ * Merged functionality of postscript, pslatex, pstex, and epslatex terminals.
+ *
+ * Ethan Merritt Mar 2006:   Break out prolog and character encodings into
+ * separate files loaded at runtime
+ *
+ * Thomas Henlich Sep 2007:   Add support for UTF-8 encoding via the glyphshow
+ * operator.  It supports PostScript Type1 fonts that use glyph names according
+ * to the Adobe Glyph List For New Fonts.
+ */
+
+#include "driver.h"
+
+#ifdef TERM_PROTO
+#include "variable.h"	/* For loadpath_handler used in PS_dump_prologue_file */
+#endif
+
+#ifdef TERM_REGISTER
+register_term(post)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void PS_options __PROTO((void));
+TERM_PUBLIC void PS_common_init __PROTO((TBOOLEAN uses_fonts, unsigned int xoff, unsigned int yoff, unsigned int bb_xmin, unsigned int bb_ymin, unsigned int bb_xmax, unsigned int bb_ymax, const char **dict));
+TERM_PUBLIC void PS_init __PROTO((void));
+TERM_PUBLIC void PS_graphics __PROTO((void));
+TERM_PUBLIC void PS_text __PROTO((void));
+TERM_PUBLIC void PS_reset __PROTO((void));
+TERM_PUBLIC void PS_linetype __PROTO((int linetype));
+TERM_PUBLIC void PS_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void PS_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void PS_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC int PS_text_angle __PROTO((int ang));
+TERM_PUBLIC int PS_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC void PS_point __PROTO((unsigned int x, unsigned int y, int number));
+TERM_PUBLIC void PS_arrow __PROTO(( unsigned int sx, unsigned int sy,
+    unsigned int ex, unsigned int ey, int head));
+TERM_PUBLIC int PS_set_font __PROTO((const char * font));
+TERM_PUBLIC void PS_fillbox __PROTO((int style, unsigned int x1, unsigned int y1, unsigned int width, unsigned int height));
+TERM_PUBLIC void PS_linewidth __PROTO((double linewidth)); /* JFi [linewidth] */
+TERM_PUBLIC void PS_pointsize __PROTO((double ptsize)); /* JFi [pointsize] */
+TERM_PUBLIC int PS_make_palette (t_sm_palette *);
+TERM_PUBLIC void PS_previous_palette (void);
+TERM_PUBLIC void PS_set_color (t_colorspec *);
+TERM_PUBLIC void PS_filled_polygon (int, gpiPoint *);
+TERM_PUBLIC void PS_image __PROTO((unsigned int, unsigned int, coordval *, gpiPoint *, t_imagecolor));
+
+/* To support "set term post enhanced" */
+TERM_PUBLIC void ENHPS_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC int  ENHPS_set_font __PROTO((const char * font));
+TERM_PUBLIC void ENHPS_OPEN __PROTO((char * fontname, double fontsize,
+	    		double base, TBOOLEAN widthflag, TBOOLEAN showflag,
+			int overprint));
+TERM_PUBLIC void ENHPS_FLUSH __PROTO((void));
+TERM_PUBLIC void ENHPS_WRITEC __PROTO((int c));
+static void PS_RememberFont __PROTO((char *fname));
+
+TERM_PUBLIC char *PS_escape_string __PROTO((char *origstr, char *escapelist));
+
+TERM_PUBLIC void PS_path __PROTO((int p));
+static TBOOLEAN PS_newpath = FALSE;
+static TBOOLEAN ENHps_opened_string = FALSE;  /* try to cut out empty ()'s */
+
+TERM_PUBLIC void PS_layer __PROTO((t_termlayer syncpoint));
+
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+
+#ifdef TERM_BODY
+
+#include "post.h"
+
+#define PS_FLUSH_PATH do {			\
+    if (ps_path_count) {			\
+	fputs("stroke\n", gppsfile);		\
+	ps_path_count = 0;			\
+	PS_relative_ok = FALSE;			\
+    }						\
+} while (0)
+
+/* Data structure implementing inclusion of font files */
+struct ps_fontfile_def {
+    struct ps_fontfile_def *next;/* pointer to next fontfile in linked list */
+    char *fontfile_name;
+    char *fontfile_fullname;
+    char *fontname;
+};
+
+/* Terminal type of postscript dialect */
+enum PS_TERMINALTYPE {
+    PSTERM_PSTEX, PSTERM_PSLATEX, PSTERM_EPSLATEX, PSTERM_POSTSCRIPT
+};
+
+enum PS_PSFORMAT {
+    PSTERM_EPS, PSTERM_PORTRAIT, PSTERM_LANDSCAPE
+};
+
+/* One struct that takes all terminal parameters
+ * by Harald Harders <h.harders@tu-bs.de> */
+typedef struct ps_params_t {
+    enum PS_TERMINALTYPE terminal;
+    int xoff;
+    int yoff;
+    enum PS_PSFORMAT psformat;
+    TBOOLEAN level1;
+    TBOOLEAN color;
+    TBOOLEAN blacktext;
+    TBOOLEAN solid;
+    float dash_length;
+    float linewidth_factor;
+    TBOOLEAN duplex_option;           /* one of duplex or simplex specified? */
+    TBOOLEAN duplex_state;
+    TBOOLEAN rounded;                 /* rounded linecaps and linejoins */
+    TBOOLEAN clipped;                 /* path clipped to BoundingBox? */
+    struct ps_fontfile_def *first_fontfile;
+    char font[MAX_ID_LEN+1];          /* name of font */
+    float fontsize;                     /* size of font in pts */
+    TBOOLEAN useauxfile;              /* only necessary for ps(la)tex */
+    TBOOLEAN rotate;                  /* only necessary for ps(la)tex */
+    int palfunc_samples;              /* setable via "palf$uncparam" */
+    double palfunc_deviation;         /* terminal option */
+    TBOOLEAN oldstyle;
+    TBOOLEAN epslatex_standalone;
+    TBOOLEAN adobeglyphnames;         /* Choice of output names for UTF8 */
+} ps_params_t;
+
+#define POST_PARAMS_DEFAULT { \
+    PSTERM_POSTSCRIPT, 50, 50, \
+    PSTERM_LANDSCAPE, FALSE, FALSE, FALSE, FALSE, 1.0, 1.0, FALSE, \
+    FALSE, FALSE, FALSE, NULL, "Helvetica", 14, FALSE, FALSE, 2000, 0.003, \
+    FALSE, TRUE, FALSE \
+}
+
+static ps_params_t post_params = POST_PARAMS_DEFAULT;
+static const ps_params_t post_params_default = POST_PARAMS_DEFAULT;
+
+#define EPSLATEX_PARAMS_DEFAULT { \
+    PSTERM_EPSLATEX, 50, 50, \
+    PSTERM_EPS, FALSE, FALSE, TRUE, FALSE, 1.0, 1.0, FALSE, \
+    FALSE, FALSE, FALSE, NULL, "", 11, TRUE, FALSE, 2000, 0.003, \
+    FALSE, FALSE, FALSE \
+}
+static ps_params_t epslatex_params = EPSLATEX_PARAMS_DEFAULT;
+static const ps_params_t epslatex_params_default = EPSLATEX_PARAMS_DEFAULT;
+
+#define PSLATEX_PARAMS_DEFAULT { \
+    PSTERM_PSLATEX, 0, 0, \
+    PSTERM_EPS, FALSE, FALSE, TRUE, FALSE, 1.0, 1.0, FALSE, \
+    FALSE, FALSE, FALSE, NULL, "", 0, FALSE, TRUE, 2000, 0.003, \
+    FALSE, FALSE, FALSE \
+}
+static ps_params_t pslatex_params = PSLATEX_PARAMS_DEFAULT;
+static const ps_params_t pslatex_params_default = PSLATEX_PARAMS_DEFAULT;
+
+#define PSTEX_PARAMS_DEFAULT { \
+    PSTERM_PSTEX, 0, 0, \
+    PSTERM_EPS, FALSE, FALSE, TRUE, FALSE, 1.0, 1.0, FALSE, \
+    FALSE, FALSE, FALSE, NULL, "", 0, FALSE, TRUE, 2000, 0.003, \
+    FALSE, FALSE, FALSE \
+}
+static ps_params_t pstex_params = PSTEX_PARAMS_DEFAULT;
+static const ps_params_t pstex_params_default = PSTEX_PARAMS_DEFAULT;
+
+static ps_params_t *ps_params = &post_params;
+
+static void make_interpolation_code __PROTO((void));
+static void make_color_model_code __PROTO((void));
+static char * save_space __PROTO((double gray));
+static void write_component_array __PROTO((const char *text, gradient_struct *grad, int cnt, int offset));
+static void write_gradient_definition __PROTO((gradient_struct *gradient, int cnt));
+static void write_color_space __PROTO((t_sm_palette *palette));
+static void make_palette_formulae __PROTO((void));
+static void PS_make_header __PROTO((t_sm_palette *palette));
+
+static float ps_fontsize;
+
+/* for enhanced mode, we keep a separate font name and size, which
+ * is restored to the default value on font of ""
+ */
+static char ps_enh_font[MAX_ID_LEN+1];
+static float ps_enh_fontsize;
+static int  ENHPS_initialized;
+
+static int ps_page = 0;		/* page count */
+static int ps_path_count = 0; 	/* count of lines in path */
+static int ps_ang = 0;			/* text angle */
+static enum JUSTIFY ps_justify = LEFT;	/* text is flush left */
+
+static void delete_ps_fontfile __PROTO((struct ps_fontfile_def *, struct ps_fontfile_def *));
+
+TERM_PUBLIC void PS_load_fontfile __PROTO((struct ps_fontfile_def *,TBOOLEAN));
+TERM_PUBLIC void PS_load_fontfiles __PROTO((TBOOLEAN));
+
+static TBOOLEAN ps_explicit_size = FALSE;
+static size_units ps_explicit_units = INCHES;
+static int eps_explicit_x = 0;
+static int eps_explicit_y = 0;
+
+#define DOTS_PER_INCH (300)    /* resolution of printer we expect to use */
+
+/* name of auxiliary file */
+static char *pslatex_auxname = NULL;
+
+/* Routine to copy pre-existing prolog files into output stream */
+static FILE *PS_open_prologue_file __PROTO((char *));
+static void PS_dump_prologue_file __PROTO((char *));
+static void PS_load_glyphlist __PROTO((void));
+
+static const char GPFAR * GPFAR OldEPSL_linetypes[] = {
+/* Line Types */
+"% Redefine line types to match old epslatex driver\n",
+"/LTw { PL [] 1 setgray } def\n", /* background (assumed white) */
+"/LTb { BL [] 0 0 0 DL } def\n", /* border */
+"/LTa { AL [1 udl mul 2 udl mul] 0 setdash 0 0 0 setrgbcolor } def\n", /* axes */
+"/LT0 { PL [] 1 0 0 DL } def\n",
+"/LT1 { PL [8 dl1 5 dl1] 0 0 1 DL } def\n",
+"/LT2 { PL [4 dl1 4 dl1] 0 1 1 DL } def\n",
+"/LT3 { PL [8 dl1 5 dl1 0.5 dl1 5 dl1] 1 0 1 DL } def\n",
+NULL
+};
+
+static const char GPFAR * GPFAR ENHPS_header[] = {
+/* For MFshow and MFwidth the tos is an array with the string and font info:  */
+/*	[<fontname (a string)> <fontsize> <vertical offset> <width significant?> <printed?> <overprint> <text string>]  */
+/* EAM Mar 2004 - Add in a special case overprint 3 = save, overprint 4 = restore */
+/* EAM Nov 2007 - Accommodate UTF-8 support (Gshow) */
+
+"/MFshow {\n",
+"   { dup 5 get 3 ge\n",	/* EAM test for overprint 3 or 4 */
+"     { 5 get 3 eq {gsave} {grestore} ifelse }\n", /* EAM */
+"     {dup dup 0 get findfont exch 1 get scalefont setfont\n",
+"     [ currentpoint ] exch dup 2 get 0 exch R dup 5 get 2 ne {dup dup 6\n",
+"     get exch 4 get {Gshow} {stringwidth pop 0 R} ifelse }if dup 5 get 0 eq\n",
+"     {dup 3 get {2 get neg 0 exch R pop} {pop aload pop M} ifelse} {dup 5\n",
+"     get 1 eq {dup 2 get exch dup 3 get exch 6 get stringwidth pop -2 div\n",
+"     dup 0 R} {dup 6 get stringwidth pop -2 div 0 R 6 get\n",
+"     show 2 index {aload pop M neg 3 -1 roll neg R pop pop} {pop pop pop\n",
+"     pop aload pop M} ifelse }ifelse }ifelse }\n",
+"     ifelse }\n", /* EAM */
+"   forall} def\n",
+
+/* get the width of the text */
+/* HH 2005-07-24 - Add in a special case overprint 3 = save, 4 = restore
+ * also for estimation of string width. This is done by interposing an 
+ * additional value on the stack. between XYsave and XYrestore,
+ * this number is increased by the strings. By pop'ing this number, all
+ * strings between XYsave and XYrestore are ignored. */
+/* EAM Nov 2007 - GSwidth is to allow the operator to work either with a string
+ * or with a glyph.  Needed for UTF-8 support. Gwidth may do it better. */
+"/Gswidth {dup type /stringtype eq {stringwidth} {pop (n) stringwidth} ifelse} def\n",
+"/MFwidth {0 exch { dup 5 get 3 ge { 5 get 3 eq { 0 } { pop } ifelse }\n",
+" {dup 3 get{dup dup 0 get findfont exch 1 get scalefont setfont\n",
+"     6 get Gswidth pop add} {pop} ifelse} ifelse} forall} def\n",
+
+/* flush left show */
+"/MLshow { currentpoint stroke M\n",
+"  0 exch R\n  Blacktext {gsave 0 setgray MFshow grestore} {MFshow} ifelse } bind def\n",
+
+/* flush right show */
+"/MRshow { currentpoint stroke M\n",
+"  exch dup MFwidth neg 3 -1 roll R\n  Blacktext {gsave 0 setgray MFshow grestore} {MFshow} ifelse } bind def\n",
+
+/* centred show */
+"/MCshow { currentpoint stroke M\n",
+"  exch dup MFwidth -2 div 3 -1 roll R\n  Blacktext {gsave 0 setgray MFshow grestore} {MFshow} ifelse } bind def\n",
+
+/* Save and restore for @-text (phantom box) */
+"/XYsave    { [( ) 1 2 true false 3 ()] } bind def\n",
+"/XYrestore { [( ) 1 2 true false 4 ()] } bind def\n",
+
+NULL
+};
+
+/* external/internal prologue files machinery */
+#if defined(GNUPLOT_PS_DIR)
+# if defined(_Windows)
+#  include "win/winmain.h"
+# elif defined(OS2)
+#  define INCL_DOSPROCESS
+#  define INCL_DOSMODULEMGR
+#  include <os2.h>
+# endif /* _Windows || OS2 */
+#else /* GNUPLOT_PS_DIR */
+# include "PostScript/prologues.h"
+#endif /* GNUPLOT_PS_DIR */
+
+/* added to enhpost by Matt Heffron <heffron@falstaff.css.beckman.com> */
+/* moved to post.trm by drd */
+
+static struct PS_FontName {
+	char *name;
+	struct PS_FontName *next;
+} *PS_DocFonts = NULL;
+
+static char PS_default_font[MAX_ID_LEN+1] = {'H','e','l','v','e','t','i','c','a',',','1','4','\0'};
+
+/* given a font, look in store to see if it is there already
+ * if so, return NULL. If not, reencode it if allowed to, otherwise
+ * return an appropriate re-encode string
+ */
+
+static void
+PS_RememberFont(char *fname)
+{
+    struct PS_FontName *fnp;
+    char *recode = NULL;
+    char *myfname = "Symbol";
+
+    if (strcmp(fname, "Symbol-Oblique") != 0)
+	myfname = fname;
+
+    for (fnp = PS_DocFonts; fnp ; fnp = fnp->next)
+	if (strcmp(fnp->name, myfname) == 0)
+	    return;
+
+    /* Ignore it if illegal characters will corrupt the PostScript syntax */
+    if (strpbrk(myfname, "{}[]() "))
+	return;
+
+    /* we have not seen this font before; store name and apply encoding */
+    fnp = (struct PS_FontName *)gp_alloc(sizeof(struct PS_FontName),
+					 "PostScript Font record");
+    fnp->name = gp_strdup(myfname);
+    fnp->next = PS_DocFonts;
+    PS_DocFonts = fnp;
+
+    switch(encoding) {
+    case S_ENC_ISO8859_1:
+    case S_ENC_UTF8:
+	recode = "reencodeISO def\n";
+	break;
+    case S_ENC_ISO8859_2:
+	recode = "reencodeISO2 def\n";
+	break;
+    case S_ENC_ISO8859_9: /* ISO8859-9 is Latin5 */
+    case S_ENC_CP1254:
+	recode = "reencodeISO9 def\n";
+	break;
+    case S_ENC_ISO8859_15: /* ISO8859-15 is Latin9 */
+	recode = "reencodeISO15 def\n";
+	break;
+    case S_ENC_CP437:
+	recode = "reencodeCP437 def\n";
+	break;
+    case S_ENC_CP850 :
+	recode = "reencodeCP850 def\n";
+	break;
+    case S_ENC_CP852 :
+	recode = "reencodeCP852 def\n";
+	break;
+    case S_ENC_KOI8_R :
+	recode = "reencodeKOI8R def\n";
+	break;
+    case S_ENC_CP1250 :
+	recode = "reencodeCP1250 def\n";
+	break;
+    case S_ENC_KOI8_U :
+	recode = "reencodeKOI8U def\n";
+	break;
+    default:
+	/* do nothing */
+	break;
+    }
+
+    if (recode) {
+	if (ENHps_opened_string)
+	    ENHPS_FLUSH();
+	fprintf(gppsfile,"/%s %s", fnp->name, recode);
+    }
+
+    return;
+}
+
+char *
+PS_escape_string(char *origstr, char *escapelist)
+{
+    char *newstr;
+    char *n;
+
+    if (!origstr || !*origstr)
+	return NULL;
+
+    newstr = gp_alloc(2*strlen(origstr)+1,"PS_escape_string");
+    for (n=newstr; *origstr; *n++ = *origstr++) {
+	if (strchr(escapelist,*origstr))
+	    *n++ = '\\';
+    }
+    *n = '\0';
+
+    return newstr;
+}
+
+static int PS_pen_x, PS_pen_y;
+static int PS_taken;
+static int PS_linetype_last;
+static double PS_linewidth_last;
+static double PS_linewidth_current;
+static TBOOLEAN PS_relative_ok;
+
+/* HBB 990914: PS_SOLID is already used by the WIN32 API headers.
+ * Renamed to PS_SOLIDE, therefore... */
+enum PS_id {
+    PS_PORTRAIT, PS_LANDSCAPE,
+    PS_EPSF, PS_DEFAULT, PS_ENHANCED, PS_NOENHANCED,
+    PS_LATEX, EPSLATEX_STANDALONE, EPSLATEX_INPUT,
+    PS_MONOCHROME, PS_COLOR, PS_BLACKTEXT, PS_COLORTEXT,
+    PS_SOLIDE, PS_DASHED, PS_DASHLENGTH, PS_LINEWIDTH,
+    PS_SIMPLEX, PS_DUPLEX, PS_DEFAULTPLEX,
+    PS_ROUNDED, PS_NOROUNDED, PS_CLIP, PS_NOCLIP, PS_FONTFILE, PS_NOFONTFILES,
+    PS_PALFUNCPARAM,
+    PS_LEVEL1, PS_LEVELDEFAULT, PS_FONT,
+    PSLATEX_ROTATE, PSLATEX_NOROTATE, PSLATEX_AUXFILE, PSLATEX_NOAUXFILE,
+    PSLATEX_OLDSTYLE, PSLATEX_NEWSTYLE, EPSLATEX_HEADER, EPSLATEX_NOHEADER,
+    PS_SIZE,
+    PS_ADOBEGLYPHNAMES, PS_NOADOBEGLYPHNAMES,
+    PS_OTHER
+};
+
+static struct gen_table PS_opts[] =
+{
+    { "d$efault", PS_DEFAULT },
+    { "p$ortrait", PS_PORTRAIT },
+    { "l$andscape", PS_LANDSCAPE },
+    { "ep$sf", PS_EPSF },
+    { "enh$anced", PS_ENHANCED },
+    { "noenh$anced", PS_NOENHANCED },
+    { "m$onochrome", PS_MONOCHROME },
+    { "c$olor", PS_COLOR },
+    { "c$olour", PS_COLOR },
+    { "b$lacktext", PS_BLACKTEXT },
+    { "colort$ext", PS_COLORTEXT },
+    { "colourt$ext", PS_COLORTEXT },
+    { "so$lid", PS_SOLIDE },
+    { "da$shed", PS_DASHED },
+    { "dashl$ength", PS_DASHLENGTH },
+    { "dl", PS_DASHLENGTH },
+    { "linew$idth", PS_LINEWIDTH },
+    { "lw", PS_LINEWIDTH },
+    { "size", PS_SIZE },
+    { "si$mplex", PS_SIMPLEX },
+    { "du$plex", PS_DUPLEX },
+    { "defaultp$lex", PS_DEFAULTPLEX },
+    { "butt", PS_NOROUNDED },
+    { "rou$nded", PS_ROUNDED },
+    { "clip", PS_CLIP },
+    { "noclip", PS_NOCLIP },
+    { "fontf$ile", PS_FONTFILE },
+    { "nofontf$iles", PS_NOFONTFILES },
+    { "palf$uncparam", PS_PALFUNCPARAM },
+    { "level1", PS_LEVEL1 },
+    { "leveldefault", PS_LEVELDEFAULT },
+    { "font", PS_FONT },
+    { "stand$alone", EPSLATEX_STANDALONE },
+    { "inp$ut", EPSLATEX_INPUT },
+    { "header", EPSLATEX_HEADER },
+    { "noheader", EPSLATEX_NOHEADER },
+    { "r$otate", PSLATEX_ROTATE },
+    { "n$orotate", PSLATEX_NOROTATE },
+    { "a$uxfile", PSLATEX_AUXFILE },
+    { "noa$uxfile", PSLATEX_NOAUXFILE },
+    { "old$style", PSLATEX_OLDSTYLE },
+    { "new$style", PSLATEX_NEWSTYLE },
+    { "adobe$glyphnames", PS_ADOBEGLYPHNAMES },
+    { "noadobe$glyphnames", PS_NOADOBEGLYPHNAMES },
+    { NULL, PS_OTHER }
+};
+
+
+TERM_PUBLIC void
+PS_options()
+{
+    char *s;
+    char *ps_fontfile_char = NULL;
+    char tmp_term_options[MAX_LINE_LEN+1] = "";
+
+    TBOOLEAN set_orientation = FALSE, set_enhanced = FALSE, set_plex = FALSE;
+    TBOOLEAN set_level = FALSE, set_color = FALSE, set_dashed = FALSE;
+    TBOOLEAN set_dashlen = FALSE, set_linewidth = FALSE, set_round = FALSE;
+    TBOOLEAN set_clip = FALSE, set_palfunc = FALSE, set_colortext = FALSE;
+    TBOOLEAN set_standalone = FALSE, set_epslheader = FALSE;
+    TBOOLEAN set_pslrotate = FALSE, set_pslauxfile = FALSE;
+    TBOOLEAN set_psloldstyle = FALSE, set_font = FALSE, set_fontsize = FALSE;
+
+    /* Annoying hack to handle the case of 'set termoption' after */
+    /* we have already initialized the terminal.                  */
+    if (c_token != 2)
+	ps_explicit_size = FALSE;
+
+    if (strcmp(term->name, "pstex") == 0)
+	ps_params = &pstex_params;
+    else if (strcmp(term->name, "pslatex") == 0)
+	ps_params = &pslatex_params;
+    else if (strcmp(term->name, "epslatex") == 0) {
+	ps_params = &epslatex_params;
+    } else
+	ps_params = &post_params;
+
+    if (ps_params->terminal == PSTERM_POSTSCRIPT) {
+	if (pslatex_auxname)
+	    free(pslatex_auxname);
+	pslatex_auxname = NULL;
+    } else {
+	term->set_font = PS_set_font;
+    }
+
+    if (!END_OF_COMMAND) {
+	if (lookup_table(&PS_opts[0],c_token) == PS_DEFAULT) {
+	    switch (ps_params->terminal) {
+	    case PSTERM_POSTSCRIPT:
+		while (ps_params->first_fontfile != NULL)
+		    delete_ps_fontfile((struct ps_fontfile_def *) NULL,
+				       ps_params->first_fontfile);
+		*ps_params = post_params_default;
+		break;
+	    case PSTERM_EPSLATEX:
+		*ps_params = epslatex_params_default;
+		break;
+	    case PSTERM_PSLATEX:
+		*ps_params = pslatex_params_default;
+		break;
+	    case PSTERM_PSTEX:
+		*ps_params = pstex_params_default;
+		break;
+	    }
+	    term->flags &= ~TERM_ENHANCED_TEXT;
+	    c_token++;
+	    if (!END_OF_COMMAND) 
+		int_error(c_token,
+			  "extraneous argument in set terminal %s",term->name);
+	}
+    }
+
+    while (!END_OF_COMMAND) {
+	switch(lookup_table(&PS_opts[0],c_token)) {
+	case PS_PORTRAIT:
+	    if (set_orientation || ps_params->terminal != PSTERM_POSTSCRIPT)
+		int_error(c_token,
+			  "extraneous argument in set terminal %s",term->name);
+	    set_orientation = TRUE;
+	    ps_params->psformat = PSTERM_PORTRAIT;
+	    c_token++;
+	    break;
+	case PS_LANDSCAPE:
+	    if (set_orientation || ps_params->terminal != PSTERM_POSTSCRIPT)
+		int_error(c_token,
+			  "extraneous argument in set terminal %s",term->name);
+	    set_orientation = TRUE;
+	    ps_params->psformat = PSTERM_LANDSCAPE;
+	    c_token++;
+	    break;
+	case PS_EPSF:
+	    if (set_orientation || ps_params->terminal != PSTERM_POSTSCRIPT)
+		int_error(c_token,
+			  "extraneous argument in set terminal %s",term->name);
+	    set_orientation = TRUE;
+	    ps_params->psformat = PSTERM_EPS;
+	    c_token++;
+	    break;
+	case PS_LEVEL1:
+	    if (set_level)
+		int_error(c_token,
+			  "extraneous argument in set terminal %s",term->name);
+	    set_level = TRUE;
+	    ps_params->level1 = TRUE;
+	    c_token++;
+	    break;
+	case PS_LEVELDEFAULT:
+	    if (set_level)
+		int_error(c_token,
+			  "extraneous argument in set terminal %s",term->name);
+	    set_level = TRUE;
+	    ps_params->level1 = FALSE;
+	    c_token++;
+	    break;
+	case PS_DEFAULT:
+	    int_error(c_token,
+		      "extraneous argument in set terminal %s",term->name);
+	    c_token++;
+	    break;
+	case PS_ENHANCED:
+	    if (set_enhanced || ps_params->terminal != PSTERM_POSTSCRIPT)
+		int_error(c_token,
+			  "extraneous argument in set terminal %s",term->name);
+	    set_enhanced = TRUE;
+	    term->put_text = ENHPS_put_text;
+	    term->set_font = ENHPS_set_font;
+	    term->flags |= TERM_ENHANCED_TEXT;
+	    ++c_token;
+	    break;
+	case PS_NOENHANCED:
+	   if (set_enhanced || ps_params->terminal != PSTERM_POSTSCRIPT)
+	        int_error(c_token,
+	                  "extraneous argument in set terminal %s",term->name);
+	    set_enhanced = TRUE;
+	    term->put_text = PS_put_text;
+	    term->set_font = PS_set_font;
+	    term->flags &= ~TERM_ENHANCED_TEXT;
+	    ++c_token;
+	    break;
+#ifdef PSLATEX_DRIVER
+	case EPSLATEX_STANDALONE:
+	    if (set_standalone || ps_params->terminal != PSTERM_EPSLATEX)
+		int_error(c_token,
+			  "extraneous argument in set terminal %s",term->name);
+	    set_standalone = TRUE;
+	    ps_params->epslatex_standalone = TRUE;
+	    ++c_token;
+	    break;
+	case EPSLATEX_INPUT:
+	    if (set_standalone || ps_params->terminal != PSTERM_EPSLATEX)
+		int_error(c_token,
+			  "extraneous argument in set terminal %s",term->name);
+	    set_standalone = TRUE;
+	    ps_params->epslatex_standalone = FALSE;
+	    ++c_token;
+	    break;
+
+	case EPSLATEX_HEADER:
+	    if (set_epslheader || ps_params->terminal != PSTERM_EPSLATEX)
+		int_error(c_token,
+			  "extraneous argument in set terminal %s",term->name);
+	    set_epslheader = TRUE;
+	    ++c_token;
+	    free(epslatex_header);
+	    /* Protect against int_error() bail from try_to_get_string() */
+		epslatex_header = NULL;
+	    epslatex_header = try_to_get_string();
+	    if (!epslatex_header)
+		int_error(c_token,"String containing header information expected");
+	    break;
+
+	case EPSLATEX_NOHEADER:
+	    if (set_epslheader || ps_params->terminal != PSTERM_EPSLATEX)
+		int_error(c_token,
+			  "extraneous argument in set terminal %s",term->name);
+	    set_epslheader = TRUE;
+	    free(epslatex_header);
+	    epslatex_header = NULL;
+	    ++c_token;
+	    break;
+
+	case PSLATEX_ROTATE:
+	    if (set_pslrotate || ((ps_params->terminal != PSTERM_PSLATEX) &&
+				  (ps_params->terminal != PSTERM_PSTEX)))
+		int_error(c_token,
+			  "extraneous argument in set terminal %s",term->name);
+	    set_pslrotate = TRUE;
+	    ps_params->rotate = TRUE;
+	    ++c_token;
+	    break;
+	case PSLATEX_NOROTATE:
+	    if (set_pslrotate || ((ps_params->terminal != PSTERM_PSLATEX) &&
+				  (ps_params->terminal != PSTERM_PSTEX)))
+		int_error(c_token,
+			  "extraneous argument in set terminal %s",term->name);
+	    set_pslrotate = TRUE;
+	    ps_params->rotate = FALSE;
+	    ++c_token;
+	    break;
+	case PSLATEX_AUXFILE:
+	    if (set_pslauxfile ||
+		((ps_params->terminal == PSTERM_POSTSCRIPT) ||
+		 (ps_params->terminal == PSTERM_EPSLATEX)))
+		int_error(c_token,
+			  "extraneous argument in set terminal %s",term->name);
+	    set_pslauxfile = TRUE;
+	    ps_params->useauxfile = TRUE;
+	    c_token++;
+	    break;
+	case PSLATEX_NOAUXFILE:
+	    if (set_pslauxfile ||
+		((ps_params->terminal == PSTERM_POSTSCRIPT) ||
+		 (ps_params->terminal == PSTERM_EPSLATEX)))
+		int_error(c_token,
+			  "extraneous argument in set terminal %s",term->name);
+	    set_pslauxfile = TRUE;
+	    ps_params->useauxfile = FALSE;
+	    c_token++;
+	    break;
+	case PSLATEX_OLDSTYLE:
+	    if (set_psloldstyle || ps_params->terminal == PSTERM_POSTSCRIPT)
+		int_error(c_token,
+			  "extraneous argument in set terminal %s",term->name);
+	    set_psloldstyle = TRUE;
+	    ps_params->oldstyle = TRUE;
+	    if (ps_params->terminal == PSTERM_EPSLATEX)
+		ps_params->rounded = TRUE;
+	    c_token++;
+	    break;
+	case PSLATEX_NEWSTYLE:
+	    if (set_psloldstyle || ps_params->terminal == PSTERM_POSTSCRIPT)
+		int_error(c_token,
+			  "extraneous argument in set terminal %s",term->name);
+	    set_psloldstyle = TRUE;
+	    ps_params->oldstyle = FALSE;
+	    c_token++;
+	    break;
+#endif
+	case PS_MONOCHROME:
+	    if (set_color)
+		int_error(c_token,
+			  "extraneous argument in set terminal %s",term->name);
+	    set_color = TRUE;
+	    ps_params->color = FALSE;
+	    term->flags |= TERM_MONOCHROME;
+	    c_token++;
+	    break;
+	case PS_COLOR:
+	    if (set_color)
+		int_error(c_token,
+			  "extraneous argument in set terminal %s",term->name);
+	    set_color = TRUE;
+	    ps_params->color = TRUE;
+	    term->flags &= ~TERM_MONOCHROME;
+	    c_token++;
+	    break;
+	case PS_BLACKTEXT:
+	    if (set_colortext || ((ps_params->terminal != PSTERM_POSTSCRIPT) &&
+				  (ps_params->terminal != PSTERM_EPSLATEX)))
+		int_error(c_token,
+			  "extraneous argument in set terminal %s",term->name);
+	    set_colortext = TRUE;
+	    ps_params->blacktext = TRUE;
+	    c_token++;
+	    break;
+	case PS_COLORTEXT:
+	    if (set_colortext || ((ps_params->terminal != PSTERM_POSTSCRIPT) &&
+				  (ps_params->terminal != PSTERM_EPSLATEX)))
+		int_error(c_token,
+			  "extraneous argument in set terminal %s",term->name);
+	    set_colortext = TRUE;
+	    ps_params->blacktext = FALSE;
+	    c_token++;
+	    break;
+	case PS_SOLIDE:
+	    if (set_dashed)
+		int_error(c_token,
+			  "extraneous argument in set terminal %s",term->name);
+	    set_dashed = TRUE;
+	    ps_params->solid = TRUE;
+	    c_token++;
+	    break;
+	case PS_DASHED:
+	    if (set_dashed)
+		int_error(c_token,
+			  "extraneous argument in set terminal %s",term->name);
+	    set_dashed = TRUE;
+	    ps_params->solid = FALSE;
+	    c_token++;
+	    break;
+	case PS_DASHLENGTH:
+	    if (set_dashlen)
+		int_error(c_token,
+			  "extraneous argument in set terminal %s",term->name);
+	    set_dashlen = TRUE;
+	    c_token++;
+	    ps_params->dash_length = real_expression();
+	    if (ps_params->dash_length <= 0.0)
+		ps_params->dash_length = 1.0;
+	    break;
+	case PS_LINEWIDTH:
+	    if (set_linewidth)
+		int_error(c_token,
+			  "extraneous argument in set terminal %s",term->name);
+	    set_linewidth = TRUE;
+	    c_token++;
+	    ps_params->linewidth_factor = real_expression();
+	    if (ps_params->linewidth_factor <= 0.0)
+		ps_params->linewidth_factor = 1.0;
+	    break;
+	case PS_SIMPLEX:
+	    if (set_plex || ps_params->terminal != PSTERM_POSTSCRIPT)
+		int_error(c_token,
+			  "extraneous argument in set terminal %s",term->name);
+	    set_plex = TRUE;
+	    ps_params->duplex_state  = FALSE;
+	    ps_params->duplex_option = TRUE;
+	    c_token++;
+	    break;
+	case PS_DUPLEX:
+	    if (set_plex || ps_params->terminal != PSTERM_POSTSCRIPT)
+		int_error(c_token,
+			  "extraneous argument in set terminal %s",term->name);
+	    set_plex = TRUE;
+	    ps_params->duplex_state  = TRUE;
+	    ps_params->duplex_option = TRUE;
+	    c_token++;
+	    break;
+	case PS_DEFAULTPLEX:
+	    if (set_plex || ps_params->terminal != PSTERM_POSTSCRIPT)
+		int_error(c_token,
+			  "extraneous argument in set terminal %s",term->name);
+	    set_plex = TRUE;
+	    ps_params->duplex_option = FALSE;
+	    c_token++;
+	    break;
+	case PS_ROUNDED:
+	    if (set_round)
+		int_error(c_token,
+			  "extraneous argument in set terminal %s",term->name);
+	    set_round = TRUE;
+	    ps_params->rounded = TRUE;
+	    c_token++;
+	    break;
+	case PS_NOROUNDED:
+	    if (set_round)
+		int_error(c_token,
+			  "extraneous argument in set terminal %s",term->name);
+	    set_round = TRUE;
+	    ps_params->rounded = FALSE;
+	    c_token++;
+	    break;
+	case PS_CLIP:
+	    if (set_clip)
+		int_error(c_token,
+			  "extraneous argument in set terminal %s",term->name);
+	    set_clip = TRUE;
+	    ps_params->clipped = TRUE;
+	    c_token++;
+	    break;
+	case PS_NOCLIP:
+	    if (set_clip)
+		int_error(c_token,
+			  "extraneous argument in set terminal %s",term->name);
+	    set_clip = TRUE;
+	    ps_params->clipped = FALSE;
+	    c_token++;
+	    break;
+	case PS_FONTFILE: {
+	    TBOOLEAN deleteentry = FALSE;
+	    char *fontfilename = NULL;
+	    c_token++;
+	    if (ps_params->terminal != PSTERM_POSTSCRIPT)
+		int_error(c_token,
+			  "extraneous argument in set terminal %s",term->name);
+
+	    if (equals(c_token, "add"))
+		c_token++;
+	    else if (almost_equals(c_token, "del$ete")) {
+		deleteentry = TRUE;
+		c_token++;
+	    }
+
+	    if (!(fontfilename = try_to_get_string())) {
+		int_error(c_token, "Font filename expected");
+	    } else {
+		TBOOLEAN filename_doubled = FALSE;
+		struct ps_fontfile_def *curr_ps_fontfile = 
+		    ps_params->first_fontfile;
+		struct ps_fontfile_def *prev_ps_fontfile = NULL;
+		struct ps_fontfile_def *new_ps_fontfile =
+		     gp_alloc(sizeof(struct ps_fontfile_def),
+			     "new_ps_fontfile");
+
+		new_ps_fontfile->fontfile_name =
+		    gp_alloc (token_len(c_token),
+			      "new_ps_fontfile->fontfile_name");
+		gp_expand_tilde(&fontfilename);
+		new_ps_fontfile->fontfile_name = fontfilename;
+		new_ps_fontfile->fontname = NULL;
+		if (!deleteentry) {
+#if defined(PIPES)
+		    if (*(new_ps_fontfile->fontfile_name) != '<') {
+#endif
+			new_ps_fontfile->fontfile_fullname =
+			    fontpath_fullname(new_ps_fontfile->fontfile_name);
+			if (!new_ps_fontfile->fontfile_fullname)
+			    int_error(c_token-1, "Font file '%s' not found",
+				      new_ps_fontfile->fontfile_name);
+#if defined(PIPES)
+		    } else
+			new_ps_fontfile->fontfile_fullname = NULL;
+#endif
+
+		}
+		new_ps_fontfile->next = NULL;
+
+		if (!deleteentry) {
+		    LFS *lf=lf_head;
+		    if (lf) {
+			while (lf->prev)
+			    lf=lf->prev;
+		    }
+		    if ((lf && lf->interactive) || interactive)
+			PS_load_fontfile(new_ps_fontfile,FALSE);
+		}
+
+		if (ps_params->first_fontfile) {
+		    while (curr_ps_fontfile) {
+			if (strcmp(curr_ps_fontfile->fontfile_name,
+				   new_ps_fontfile->fontfile_name) == 0) {
+			    filename_doubled = TRUE;
+			    if (deleteentry) {
+				delete_ps_fontfile(prev_ps_fontfile,
+						   curr_ps_fontfile);
+				curr_ps_fontfile = NULL;
+				break;
+			    }
+			}
+			prev_ps_fontfile = curr_ps_fontfile;
+			curr_ps_fontfile = curr_ps_fontfile->next;
+		    }
+		    if (!filename_doubled) {
+			if (!deleteentry)
+			    prev_ps_fontfile->next = new_ps_fontfile;
+			else
+			    int_warn(c_token-1,"Can't delete Font filename '%s'",
+				     new_ps_fontfile->fontfile_name);
+		    }
+		} else {
+		    if (!deleteentry)
+			ps_params->first_fontfile = new_ps_fontfile;
+		    else
+			int_warn(c_token-1, "Can't delete Font filename '%s'",
+				 new_ps_fontfile->fontfile_name);
+		}
+	    }
+	    break;
+	}
+	case PS_NOFONTFILES:
+	    if (ps_params->terminal != PSTERM_POSTSCRIPT)
+		int_error(c_token,
+			  "extraneous argument in set terminal %s",term->name);
+	    while (ps_params->first_fontfile != NULL)
+		delete_ps_fontfile((struct ps_fontfile_def *) NULL,
+				   ps_params->first_fontfile);
+	    ++c_token;
+	    break;
+	case PS_ADOBEGLYPHNAMES:
+	    ps_params->adobeglyphnames = TRUE;
+	    ++c_token;
+	    break;
+	case PS_NOADOBEGLYPHNAMES:
+	    ps_params->adobeglyphnames = FALSE;
+	    ++c_token;
+	    break;
+	case PS_PALFUNCPARAM:
+	    if (set_palfunc)
+		int_error(c_token,
+			  "extraneous argument in set terminal %s",term->name);
+	    set_palfunc = TRUE;
+	    ++c_token;
+	    ps_params->palfunc_samples = int_expression();
+	    if (ps_params->palfunc_samples < 2)
+		ps_params->palfunc_samples = 2;
+	    if (!END_OF_COMMAND && equals(c_token, ",")) {
+		++c_token;
+		ps_params->palfunc_deviation = fabs(real_expression());
+		if (ps_params->palfunc_deviation >= 1)
+		    int_error(c_token-1,"allowed deviation must be < 1");
+	    }
+	    break;
+	
+	case PS_SIZE:
+	    {
+	    float xmax_t, ymax_t;
+
+	    c_token++;
+	    ps_explicit_size = TRUE;
+	    ps_explicit_units = parse_term_size(&xmax_t, &ymax_t, INCHES);
+
+	    /* PostScript *always* works in pts, not locally defined dpi */
+	    term->xmax = xmax_t * PS_SC * 72./gp_resolution;
+	    term->ymax = ymax_t * PS_SC * 72./gp_resolution;
+	    eps_explicit_x = 2 * term->xmax;
+	    eps_explicit_y = 2 * term->ymax;
+	    break;
+	    }
+	
+	case PS_FONT:
+	    c_token++;
+	    /* Fall through to attempt to read font name */
+	case PS_OTHER:
+	default:
+	    if ((s = try_to_get_string())) {
+		if (set_font)
+		    int_error(c_token,
+			      "extraneous argument in set terminal %s",
+			      term->name);
+		set_font = TRUE;
+		if ((ps_params->terminal == PSTERM_POSTSCRIPT) ||
+		    (ps_params->terminal == PSTERM_EPSLATEX)) {
+		    char *comma = strrchr(s,',');
+		    if (comma && (1 == sscanf(comma+1,"%f",&ps_params->fontsize))) {
+			set_fontsize = TRUE;
+			*comma = '\0';
+		    }
+		    if (*s) {
+			/* Filter out characters that would confuse PostScript */
+			if (strpbrk(s, "()[]{}| ")) {
+			    int_warn(c_token-1,"Illegal characters in PostScript font name.");
+			    int_warn(NO_CARET,"I will try to fix it but this may not work.");
+			    while (strpbrk(s, "()[]{}| "))
+				*(strpbrk(s, "()[]{}| ")) = '-';
+			}
+			strncpy(ps_params->font, s, sizeof(ps_params->font));
+		    }
+		    free(s);
+		} else
+		    int_error(c_token-1,
+			      "terminal %s does not allow specification %s",
+			      term->name, "of font name");
+	    } else {
+		if (set_fontsize)
+		    int_error(c_token,
+			      "extraneous argument in set terminal %s",
+			      term->name);
+		set_fontsize = TRUE;
+		/* We have font size specified */
+		ps_params->fontsize = real_expression();
+	    }
+	    break;
+	}
+    }
+
+    switch (ps_params->terminal) {
+    case PSTERM_POSTSCRIPT:
+	ps_fontsize = ps_params->fontsize;
+	break;
+    case PSTERM_EPSLATEX:
+	ps_fontsize = 2 * ps_params->fontsize;
+	break;
+    case PSTERM_PSLATEX:
+    case PSTERM_PSTEX:
+	if (ps_params->fontsize > 0)
+	    ps_fontsize = 2 * ps_params->fontsize;
+	else
+	    ps_fontsize = 20; /* default: 10pt */
+	break;
+    }
+    term->v_char = (unsigned int)(ps_fontsize*PS_SC);
+    if (ps_params->oldstyle)
+	term->h_char = (unsigned int)(ps_fontsize*PS_SC*5/10);
+    else
+	term->h_char = (unsigned int)(ps_fontsize*PS_SC*6/10);
+    sprintf(PS_default_font,"%s,%g",ps_params->font,ps_fontsize);
+
+    if (ps_params->terminal == PSTERM_POSTSCRIPT) {
+	if (ps_params->first_fontfile) {
+	    struct ps_fontfile_def *curr_ps_fontfile =
+		ps_params->first_fontfile;
+	    unsigned int totlength = 0;
+	    char *running;
+
+	    while (curr_ps_fontfile) {
+		totlength += strlen(curr_ps_fontfile->fontfile_name) +
+		    strlen(" fontfile \"\"");
+		curr_ps_fontfile = curr_ps_fontfile->next;
+	    }
+	    curr_ps_fontfile = ps_params->first_fontfile;
+	    ps_fontfile_char = gp_alloc (totlength+1,"ps_fontfile_char");
+	    running = ps_fontfile_char;
+	    while (curr_ps_fontfile) {
+		sprintf(running," fontfile \"%s\"",
+			curr_ps_fontfile->fontfile_name);
+		running += strlen(running);
+		curr_ps_fontfile = curr_ps_fontfile->next;
+	    }
+	}
+    }
+
+    /* HBB 19990823: fixed the options string. It violated the 'save
+     * loadable output' rule */
+    if (ps_params->terminal == PSTERM_POSTSCRIPT)
+	sprintf(term_options,"%s %s %s \\\n",
+		ps_params->psformat==PSTERM_EPS ? "eps" :
+		(ps_params->psformat==PSTERM_PORTRAIT ?
+		 "portrait" : "landscape"),
+		term->put_text == ENHPS_put_text ? "enhanced" : "noenhanced",
+		ps_params->duplex_option ? (ps_params->duplex_state ?
+					    "duplex" : "simplex")
+		: "defaultplex");
+    else if (ps_params->terminal != PSTERM_EPSLATEX)
+	sprintf(term_options, "%s%s",
+		ps_params->rotate ? "rotate" : "norotate",
+		ps_params->useauxfile ? " auxfile" : "");
+    else
+	term_options[0] = '\0';
+
+    sprintf(tmp_term_options,"   %s %s %s \\\n\
+   %s dashlength %.1f linewidth %.1f %s %s \\\n",
+	    ps_params->level1 ? "level1" : "leveldefault",
+	    ps_params->color ? "color" : "monochrome",
+	    ps_params->blacktext ? "blacktext" : "colortext",
+	    ps_params->solid ? "solid" : "dashed",
+	    ps_params->dash_length,
+	    ps_params->linewidth_factor,
+	    ps_params->rounded ? "rounded" : "butt",
+	    ps_params->clipped ? "clip" : "noclip");
+    strcat(term_options,tmp_term_options);
+
+    sprintf(tmp_term_options,"   palfuncparam %d,%g \\\n   ",
+	    ps_params->palfunc_samples, ps_params->palfunc_deviation);
+    strcat(term_options,tmp_term_options);
+
+#ifdef PSLATEX_DRIVER
+    if ((ps_params->terminal == PSTERM_PSTEX) ||
+	(ps_params->terminal == PSTERM_PSLATEX)) {
+	sprintf(tmp_term_options, "%s %s ",
+		ps_params->rotate ? "rotate" : "norotate",
+		ps_params->useauxfile ? "auxfile" : "noauxfile");
+	strcat(term_options,tmp_term_options);
+    }
+
+    if (ps_params->terminal == PSTERM_EPSLATEX) {
+	sprintf(tmp_term_options, "%s ",
+		ps_params->epslatex_standalone ? "standalone" : "input");
+	if (epslatex_header)
+	    sprintf(tmp_term_options, "header \"%s\" ", epslatex_header);
+	else
+	    sprintf(tmp_term_options, "noheader ");
+	strcat(term_options,tmp_term_options);
+    }
+#endif
+
+    if ((encoding == S_ENC_UTF8) && (ps_params->terminal == PSTERM_POSTSCRIPT)) {
+	sprintf(tmp_term_options," %sadobeglyphnames \\\n   ",
+	    ps_params->adobeglyphnames ? "" : "no");
+	strcat(term_options,tmp_term_options);
+    }
+
+    if (ps_explicit_size) {
+	if (ps_explicit_units == CM)
+	    sprintf(tmp_term_options,"size %.2fcm, %.2fcm ",
+		2.54*(float)term->xmax/(72.*PS_SC), 2.54*(float)term->ymax/(72.*PS_SC));
+	else
+	    sprintf(tmp_term_options,"size %.2fin, %.2fin ",
+		(float)term->xmax/(72.*PS_SC), (float)term->ymax/(72.*PS_SC));
+	strcat(term_options,tmp_term_options);
+    }
+
+    if (ps_params->terminal == PSTERM_POSTSCRIPT)
+	sprintf(tmp_term_options,"\"%s\" %g%s ",
+		ps_params->font,ps_params->fontsize,
+		ps_fontfile_char ? ps_fontfile_char : "");
+    else if (ps_params->terminal == PSTERM_EPSLATEX)
+	sprintf(tmp_term_options,"\"%s\" %g ",
+		ps_params->font,ps_params->fontsize);
+    else if (ps_params->fontsize)
+	sprintf(tmp_term_options,"%g ",ps_params->fontsize);
+    else
+	tmp_term_options[0]='\0';
+    if (ps_fontfile_char)
+	free(ps_fontfile_char);
+
+    strcat(term_options,tmp_term_options);
+
+}
+
+/* store settings passed to common_init() for use in PS_graphics()
+ * ps_params->psformat, etc are reserved for storing the term options
+ */
+static TBOOLEAN ps_common_uses_fonts;
+static unsigned int ps_common_xoff, ps_common_yoff;
+
+/* The default UTF8 code will use glyph identifiers uniXXXX for all glyphs above 0x0100.
+ * If you define ADOBE_ENCODING_NAMES, then it will instead use the glyph names from the
+ * file aglfn.txt.  Names in the range 0x0100 - 0x01FF correspond to those used by the
+ * Latin1 encoding scheme.  This unicode code page deliberately uses the same character
+ * mapping as Latin1.  Adobe also recommends names for many characters outside this 
+ * range, but not all fonts adhere to this.  You can substitute a different aglfn.txt
+ * file at run time if you want to use a different scheme.
+ */
+#define ADOBE_ENCODING_NAMES 1
+
+#if (ADOBE_ENCODING_NAMES)
+
+typedef struct ps_glyph {
+  unsigned long unicode;
+  char * glyphname;
+} ps_glyph;
+
+static ps_glyph *aglist = NULL;
+static int aglist_alloc = 0;
+static int aglist_size = 0;
+static int psglyphs = 0;
+
+#endif
+
+TERM_PUBLIC void
+PS_load_fontfile(struct ps_fontfile_def *current_ps_fontfile, TBOOLEAN doload)
+{
+    if (current_ps_fontfile) {
+	unsigned int linesread = 0;
+	FILE *ffont = NULL;
+	char line[256];
+	char ext[4];
+	char cmd[256];
+	char *fontname = NULL;
+#if defined(PIPES)
+	char *envcmd = NULL;
+	TBOOLEAN ispipe = FALSE;
+#endif
+
+	ext[0] = '\0';
+	cmd[0] = '\0';
+
+	if (doload)
+	    fprintf(gppsfile,"%%%%BeginProcSet: %s\n",
+		    current_ps_fontfile->fontfile_name);
+
+	/* get filename extension if no pipe (if pipe *ext=='\0') */
+#if defined(PIPES)
+	if (*(current_ps_fontfile->fontfile_name) != '<') {
+	    /* Filename is given */
+#endif
+	    if (strlen(current_ps_fontfile->fontfile_name) > 3)
+		strcpy(ext, current_ps_fontfile->fontfile_name +
+		       strlen(current_ps_fontfile->fontfile_name) - 3);
+	    else
+		strcpy(ext, current_ps_fontfile->fontfile_name);
+
+	    /* make extension lowercase for comparison */
+	    lower_case(ext);
+
+	    if (!current_ps_fontfile->fontfile_fullname)
+		int_error(NO_CARET, "Font file '%s' not found",
+			  current_ps_fontfile->fontfile_name);
+#if defined(PIPES)
+	}
+#endif
+	if (strlen(ext) == 0) {
+#if defined(PIPES)
+	    /* Pipe is given */
+	    ispipe = TRUE;
+	    strcpy(cmd,current_ps_fontfile->fontfile_name + 1);
+	    ffont = popen(cmd, "r");
+	    if (!ffont)
+		int_error(NO_CARET, "Could not execute pipe '%s'",
+			  current_ps_fontfile->fontfile_name + 1);
+#endif
+	}
+	else if (!strcmp(ext,"ttf") || !strcmp(ext,"otf")) {
+	    /* TrueType */
+#if defined(PIPES)
+	    ispipe = TRUE;
+	    envcmd = getenv("GNUPLOT_TTFTOPFA");
+	    if (envcmd != NULL)
+		sprintf(cmd,envcmd,current_ps_fontfile->fontfile_fullname);
+	    else
+		sprintf(cmd,"ttf2pt1 -a -e -W 0 %s -",
+			current_ps_fontfile->fontfile_fullname);
+	    if (strlen(cmd) == 0)
+		int_error(NO_CARET,
+			  "No command for automatic font conversion ttf->pfa defined");
+	    else {
+		ffont = popen(cmd,"r");
+		if (!ffont)
+		    int_error(NO_CARET,"Could not execute command '%s'", cmd);
+	    }
+#else
+	    os_error(NO_CARET,
+		     "Automatic font conversion ttf->pfa not supported");
+#endif
+	} else if (strcmp(ext,"pfb") == 0) {
+	    /* PFB */
+#if defined(PIPES)
+	    ispipe = TRUE;
+	    envcmd = getenv("GNUPLOT_PFBTOPFA");
+	    if (envcmd != NULL)
+		sprintf(cmd,envcmd,current_ps_fontfile->fontfile_fullname);
+	    else
+		sprintf(cmd,"pfbtops %s",
+			current_ps_fontfile->fontfile_fullname);
+	    if (strlen(cmd) == 0)
+		int_error(NO_CARET,
+			  "No command for automatic font conversion pfb->pfa defined");
+	    else {
+		ffont = popen(cmd,"r");
+		if (!ffont)
+		    int_error(NO_CARET,"Could not execute command '%s'", cmd);
+	    }
+#else
+	    os_error(NO_CARET,
+		     "Automatic font conversion pfb->pfa not supported");
+#endif
+	} else {
+	    /* PFA */
+	    if (strcmp(ext,"pfa") != 0)
+		int_warn(NO_CARET,
+			 "Font file '%s' has unknown extension. Assume it is a pfa file",
+			 current_ps_fontfile->fontfile_name);
+	    ffont = fopen(current_ps_fontfile->fontfile_fullname, "r");
+	    if (!ffont)
+		int_error(NO_CARET, "Font file '%s' not found",
+			  current_ps_fontfile->fontfile_name);
+	}
+	/* read the file */
+	while (fgets(line,255,ffont)) {
+	    /* test file format */
+	    if ((linesread == 0) &&
+		 (strstr(line,"%!PS-AdobeFont") != line) &&
+		 (strstr(line,"%!FontType1") != line)) {
+#if defined(PIPES)
+		if (ispipe)
+		    int_warn(NO_CARET,
+			     "Command '%s' seems not to generate PFA data",
+			     cmd);
+		else
+#endif
+		    int_warn(NO_CARET,
+			     "Font file '%s' seems not to be a PFA file",
+			     current_ps_fontfile->fontfile_name);
+	    }
+	    /* get fontname */
+	    if (strstr(line,"/FontName") == line) {
+		char *fnende = NULL;
+		fontname = gp_alloc(strlen(line)-9,"load_fontfiles");
+		strcpy(fontname,strstr(line+1,"/")+1);
+		fnende = strstr(fontname," ");
+		*fnende = '\0';
+		current_ps_fontfile->fontname = gp_strdup(fontname);
+		/* Print font name */
+		if (!doload) {
+		    if (current_ps_fontfile->fontfile_fullname)
+			fprintf(stderr,
+				"Font file '%s' contains the font '%s'. Location:\n   %s\n",
+				current_ps_fontfile->fontfile_name,
+				fontname,
+				current_ps_fontfile->fontfile_fullname);
+		    else
+			fprintf(stderr,
+				"Pipe '%s' contains the font '%s'.\n",
+				current_ps_fontfile->fontfile_name,
+				fontname);
+#if defined(PIPES)
+		    /* Stop reading font file in order to save time */
+		    /* This does not work for pipes because they give the */
+		    /* error message 'broken pipe' */
+		    if (!ispipe)
+#endif
+			break;
+		}
+	    }
+
+	    if (doload)
+		fputs(line, gppsfile);
+
+	    ++linesread;
+	}
+#if defined(PIPES)
+	if (ispipe) {
+	    int exitcode;
+	    if ((exitcode = pclose(ffont)) != 0)
+		int_error(NO_CARET,
+			  "Command '%s' generated error, exitcode is %d",
+			  cmd, exitcode);
+	}
+	else
+#endif
+	    fclose(ffont);
+
+	if (linesread == 0) {
+#if defined(PIPES)
+	    if (ispipe)
+		int_error(NO_CARET,
+			  "Command '%s' generates empty output",
+			  cmd);
+	    else
+#endif
+		int_error(NO_CARET, "Font file '%s' is empty",
+			  current_ps_fontfile->fontfile_name);
+	}
+	if (doload)
+	    fputs("%%EndProcSet\n", gppsfile);
+
+	/* Computer Modern Symbol font with corrected baseline if the
+	 * font CMEX10 is embedded */
+	if (doload && fontname && (strcmp(fontname,"CMEX10") == 0)) {
+	    fputs("%%BeginProcSet: CMEX10-Baseline\n", gppsfile);
+	    fputs("/CMEX10-Baseline /CMEX10 findfont [1 0 0 1 0 1] makefont\n",
+		  gppsfile);
+	    fputs("dup length dict begin {1 index /FID eq {pop pop} {def} ifelse} forall\n", gppsfile);
+	    fputs("currentdict end definefont pop\n", gppsfile);
+	    fputs("%%EndProcSet\n",gppsfile);
+	}
+
+	if (fontname) {
+	    free(fontname);
+	    fontname = NULL;
+	}
+    }
+}
+
+
+TERM_PUBLIC void
+PS_load_fontfiles(TBOOLEAN doload)
+{
+    struct ps_fontfile_def *current_ps_fontfile=ps_params->first_fontfile;
+
+    while (current_ps_fontfile) {
+	PS_load_fontfile(current_ps_fontfile,doload);
+	if (current_ps_fontfile->fontname)
+		PS_RememberFont(current_ps_fontfile->fontname);
+	current_ps_fontfile = current_ps_fontfile->next;
+    }
+}
+
+
+TERM_PUBLIC void
+PS_common_init(
+    TBOOLEAN uses_fonts,		/* FALSE for (e)ps(la)tex */
+    unsigned int xoff, unsigned int yoff, /* how much to translate by */
+    unsigned int bb_xmin, unsigned int bb_ymin,
+    unsigned int bb_xmax, unsigned int bb_ymax, /* bounding box */
+    const char **dict) /* extra entries for the dictionary */
+{
+    static const char GPFAR psi1[] = "\
+%%%%Creator: gnuplot %s patchlevel %s\n\
+%%%%CreationDate: %s\n\
+%%%%DocumentFonts: %s\n";
+
+    static const char GPFAR psi2[] = "\
+%%%%EndComments\n\
+%%%%BeginProlog\n\
+/gnudict 256 dict def\ngnudict begin\n\
+%%\n\
+%% The following true/false flags may be edited by hand if desired.\n\
+%% The unit line width and grayscale image gamma correction may also be changed.\n\
+%%\n\
+/Color %s def\n\
+/Blacktext %s def\n\
+/Solid %s def\n\
+/Dashlength %g def\n\
+/Landscape %s def\n\
+/Level1 %s def\n\
+/Rounded %s def\n\
+/ClipToBoundingBox %s def\n\
+/TransparentPatterns false def\n\
+/gnulinewidth %.3f def\n\
+/userlinewidth gnulinewidth def\n\
+/Gamma 1.0 def\n\
+%%\n\
+/vshift %d def\n\
+/dl1 {\n\
+  %.1f Dashlength mul mul\n\
+  Rounded { currentlinewidth 0.75 mul sub dup 0 le { pop 0.01 } if } if\n\
+} def\n\
+/dl2 {\n\
+  %.1f Dashlength mul mul\n\
+  Rounded { currentlinewidth 0.75 mul add } if\n\
+} def\n\
+/hpt_ %.1f def\n\
+/vpt_ %.1f def\n\
+/hpt hpt_ def\n\
+/vpt vpt_ def\n";
+
+    static const char GPFAR psi3[] = "\
+Level1 {} {\n\
+/SDict 10 dict def\n\
+systemdict /pdfmark known not {\n\
+  userdict /pdfmark systemdict /cleartomark get put\n\
+} if\n\
+SDict begin [\n\
+  /Title (%s)\n\
+  /Subject (gnuplot plot)\n\
+  /Creator (gnuplot %s patchlevel %s)\n\
+  /Author (%s)\n\
+%%  /Producer (gnuplot)\n\
+%%  /Keywords ()\n\
+  /CreationDate (%s)\n\
+  /DOCINFO pdfmark\n\
+end\n\
+} ifelse\n";
+
+
+    struct termentry *t = term;
+    int i;
+    time_t now;
+    char *timedate;
+
+    ps_common_uses_fonts = uses_fonts;
+    ps_common_xoff = xoff;
+    ps_common_yoff = yoff;
+
+    ps_page = 0;
+
+    time(&now);
+    timedate=asctime(localtime(&now));
+    timedate[strlen(timedate)-1]='\0';
+
+#ifdef PSLATEX_DRIVER
+    /* Set files for (e)ps(la)tex terminals */
+    switch (ps_params->terminal) {
+    case PSTERM_EPSLATEX:
+	EPSLATEX_common_init();
+	break;
+    case PSTERM_PSLATEX:
+    case PSTERM_PSTEX:
+	PSTEX_common_init();
+	break;
+    default:; /* do nothing, just avoid a compiler warning */
+    }
+#endif
+
+    if (ps_params->psformat == PSTERM_EPS)
+	fputs("%!PS-Adobe-2.0 EPSF-2.0\n", gppsfile);
+    else
+	fputs("%!PS-Adobe-2.0\n", gppsfile);
+
+    if (outstr)
+	fprintf(gppsfile, "%%%%Title: %s\n", outstr);   /*  JFi  */
+    fprintf(gppsfile, psi1, gnuplot_version, gnuplot_patchlevel,
+	    timedate, uses_fonts ? "(atend)" : "");
+
+    fprintf(gppsfile,"%%%%BoundingBox: %d %d %d %d\n",
+	    xoff + bb_xmin, yoff + bb_ymin, xoff + bb_xmax, yoff + bb_ymax);
+
+    if ((ps_params->terminal == PSTERM_POSTSCRIPT) &&
+	(ps_params->psformat != PSTERM_EPS))
+	fprintf(gppsfile,"%%%%Orientation: %s\n",
+		ps_params->psformat == PSTERM_LANDSCAPE ?
+		"Landscape" : "Portrait");
+
+    if (ps_params->psformat != PSTERM_EPS)
+	fputs("%%Pages: (atend)\n", gppsfile);
+    fprintf(gppsfile, psi2,
+	    ps_params->color ? "true" : "false",
+	    ps_params->blacktext ? "true" : "false",
+	    ps_params->solid ? "true" : "false",
+	    ps_params->dash_length,	/* dash length */
+	    ps_params->psformat == PSTERM_LANDSCAPE ? "true" : "false",
+	    ps_params->level1 ? "true" : "false",
+	    ps_params->rounded ? "true" : "false",
+	    ps_params->clipped ? "true" : "false",
+	    PS_LW*ps_params->linewidth_factor,	/* line width */
+	    (int)(t->v_char)/(-3),	/* shift for vertical centring */
+	    PS_SC*1.0,	/* dash length */
+	    PS_SC*1.0,	/* dash length */
+	    PS_HTIC/2.0,		/* half point width */
+	    PS_VTIC/2.0);		/* half point height */
+
+    /* HH: print pdf information interpreted by ghostscript/acrobat */
+    {
+	char *username=getusername();
+	char *username2=PS_escape_string(username,"()\\");
+	char *outstr2=PS_escape_string(outstr,"()\\");
+	fprintf(gppsfile, psi3,
+		outstr2?outstr2:"",
+		gnuplot_version, gnuplot_patchlevel,
+		username2?username2:"", 
+		timedate);
+	if (username)
+	    free(username);
+	if (username2)
+	    free(username2);
+	if (outstr2)
+	    free(outstr2);
+    }
+
+    /* HH: Clip to BoundingBox if the corresponding flag is toggled */
+    fprintf(gppsfile,"\
+/doclip {\n\
+  ClipToBoundingBox {\n\
+    newpath %d %d moveto %d %d lineto %d %d lineto %d %d lineto closepath\n\
+    clip\n\
+  } if\n\
+} def\n", 
+	    xoff + bb_xmin, yoff + bb_ymin, 
+	    xoff + bb_xmax, yoff + bb_ymin, 
+	    xoff + bb_xmax, yoff + bb_ymax, 
+	    xoff + bb_xmin, yoff + bb_ymax);
+
+    /* Dump the body of the prologue */
+    PS_dump_prologue_file("prologue.ps");
+
+    /* insert font encoding vector */
+    if (uses_fonts) {
+	switch (encoding) {
+	    case S_ENC_ISO8859_1:   PS_dump_prologue_file("8859-1.ps"); break;
+	    case S_ENC_ISO8859_2:   PS_dump_prologue_file("8859-2.ps"); break;
+	    case S_ENC_CP1254:
+	    case S_ENC_ISO8859_9:   PS_dump_prologue_file("8859-9.ps"); break;
+	    case S_ENC_ISO8859_15:  PS_dump_prologue_file("8859-15.ps"); break;
+	    case S_ENC_CP437:	    PS_dump_prologue_file("cp437.ps"); break;
+	    case S_ENC_CP850:	    PS_dump_prologue_file("cp850.ps"); break;
+	    case S_ENC_CP852:	    PS_dump_prologue_file("cp852.ps"); break;
+	    case S_ENC_CP1250:	    PS_dump_prologue_file("cp1250.ps"); break;
+	    case S_ENC_KOI8_R:	    PS_dump_prologue_file("koi8r.ps"); break;
+	    case S_ENC_KOI8_U:	    PS_dump_prologue_file("koi8u.ps"); break;
+	    case S_ENC_UTF8:   	    PS_dump_prologue_file("utf-8.ps");
+				    if (!aglist) PS_load_glyphlist();
+				    break;
+	    case S_ENC_DEFAULT:
+	    default:		    break;
+	}
+    }
+
+    /* Redefine old epslatex linetypes if requested */
+    if ((ps_params->terminal == PSTERM_EPSLATEX) && ps_params->oldstyle) {
+	for (i = 0; OldEPSL_linetypes[i] != NULL; i++)
+	    fprintf(gppsfile,"%s",OldEPSL_linetypes[i]);
+    }
+
+    if (ps_params->duplex_option)
+	fprintf(gppsfile, "statusdict begin %s setduplexmode end\n",
+		ps_params->duplex_state ? "true" : "false");
+
+    if (dict)
+	while (*dict)
+	    fputs(*(dict++), gppsfile);
+
+    if (uses_fonts) {
+	PS_load_fontfiles(TRUE);
+	PS_RememberFont(ps_params->font);
+    }
+
+    fputs("end\n%%EndProlog\n", gppsfile);
+}
+
+/* the init fn for the postscript driver */
+TERM_PUBLIC void
+PS_init()
+{
+    unsigned int xmin_t = 0, ymin_t = 0, xmax_t = 0, ymax_t = 0;
+
+    switch (ps_params->psformat) {
+    case PSTERM_EPS:
+	if (ps_explicit_size) {
+	    term->xmax = eps_explicit_x;
+	    term->ymax = eps_explicit_y;
+	} else {
+	    term->xmax = PS_XMAX;
+	    if (ps_params->oldstyle)
+		term->ymax = PS_YMAX_OLDSTYLE;
+	    else
+		term->ymax = PS_YMAX;
+	}
+	xmin_t = term->xmax * xoffset / (2*PS_SC);
+	xmax_t = term->xmax * (xsize + xoffset) / (2*PS_SC);
+	ymin_t = term->ymax * yoffset / (2*PS_SC);
+	ymax_t = term->ymax * (ysize + yoffset) / (2*PS_SC);
+	term->tscale = PS_SC * 2;
+	break;
+    case PSTERM_PORTRAIT:
+	if (!ps_explicit_size) {
+	    term->xmax = PS_YMAX;
+	    term->ymax = PS_XMAX;
+	}
+	xmin_t = term->xmax * xoffset / PS_SC;
+	xmax_t = term->xmax * (xsize + xoffset) / PS_SC;
+	ymin_t = term->ymax * yoffset / PS_SC;
+	ymax_t = term->ymax * (ysize + yoffset) / PS_SC;
+	term->tscale = PS_SC;
+	break;
+    case PSTERM_LANDSCAPE:
+	if (!ps_explicit_size) {
+	    term->xmax = PS_XMAX;
+	    term->ymax = PS_YMAX;
+	}
+	ymin_t = term->xmax * xoffset / PS_SC;
+	ymax_t = term->xmax * (xsize+xoffset) / PS_SC;
+	xmin_t = term->ymax * (1-ysize-yoffset) / PS_SC;
+	xmax_t = term->ymax * (1-yoffset) / PS_SC;
+	term->tscale = PS_SC;
+	break;
+    default:
+	int_error(NO_CARET, "invalid postscript format used");
+    }
+
+    /* for enhanced postscript, copy ps_params->font to ps_enh_font
+     * does no harm for non-enhanced
+     */
+    strcpy(ps_enh_font, ps_params->font);
+    ps_enh_fontsize = ps_fontsize;
+
+    switch (ps_params->terminal) {
+    case PSTERM_POSTSCRIPT:
+	gppsfile = gpoutfile;
+	break;
+    default:
+#ifdef PSLATEX_DRIVER
+	PSTEX_reopen_output();
+	break;
+    case PSTERM_EPSLATEX:
+	EPSLATEX_reopen_output();
+#endif
+	break;
+    }
+
+    PS_common_init(ps_params->terminal == PSTERM_POSTSCRIPT,
+		   ps_params->xoff, ps_params->yoff,
+		   xmin_t, ymin_t, xmax_t, ymax_t,
+		   (term->put_text == ENHPS_put_text) ? ENHPS_header : NULL);
+    
+    /* Keep track of whether we have written the enhanced text dictionary yet */
+    ENHPS_initialized = (term->put_text == ENHPS_put_text) ? 2 : 1;
+}
+
+
+TERM_PUBLIC void
+PS_graphics()
+{
+    static char GPFAR psg1[] = "0 setgray\nnewpath\n";
+    struct termentry *t = term;
+    ps_page++;
+    if (ps_params->psformat != PSTERM_EPS)
+	fprintf(gppsfile,"%%%%Page: %d %d\n",ps_page,ps_page);
+
+    /* If we are about to use enhanced text mode for the first time in a plot that */
+    /* was initialized previously without it, we need to write out the macros now */
+    if (term->put_text == ENHPS_put_text && ENHPS_initialized == 1) {
+	const char **dict = ENHPS_header;
+	while (*dict)
+	    fputs(*(dict++), gppsfile);
+	fprintf(stderr,"Writing out PostScript macros for enhanced text mode\n");
+	ENHPS_initialized = 2;
+    }
+
+    fprintf(gppsfile,"\
+gnudict begin\ngsave\n\
+doclip\n\
+%d %d translate\n\
+%.3f %.3f scale\n",
+	    ps_common_xoff, ps_common_yoff,
+	    (ps_params->psformat == PSTERM_EPS ? 0.5 : 1.0)/PS_SC,
+	    (ps_params->psformat == PSTERM_EPS ? 0.5 : 1.0)/PS_SC);
+    if (ps_params->psformat == PSTERM_LANDSCAPE)
+	fprintf(gppsfile,"90 rotate\n0 %d translate\n", -(int)(term->ymax));
+    fprintf(gppsfile, psg1);
+    if (ps_common_uses_fonts)
+	fprintf(gppsfile, "(%s) findfont %d scalefont setfont\n",
+		ps_params->font, (t->v_char));
+    ps_path_count = 0;
+    PS_relative_ok = FALSE;
+    PS_pen_x = PS_pen_y = -4000;
+    PS_taken = 0;
+    PS_linetype_last = LT_UNDEFINED;
+    PS_linewidth_last = PS_linewidth_current = LT_UNDEFINED;
+}
+
+
+TERM_PUBLIC void
+PS_text()
+{
+    ps_path_count = 0;
+    fputs("stroke\ngrestore\nend\nshowpage\n", gppsfile);
+    /* fprintf(stderr,"taken %d times\n",PS_taken); */
+    /* informational:  tells how many times it was "cheaper"
+     * to do a relative moveto or lineto rather than an
+     * absolute one */
+}
+
+
+TERM_PUBLIC void
+PS_reset()
+{
+    fputs("%%Trailer\n", gppsfile);
+
+    if (ps_common_uses_fonts) {
+	fputs("%%DocumentFonts: ", gppsfile);
+	while (PS_DocFonts) {
+	    struct PS_FontName *fnp;
+	    fnp = PS_DocFonts->next;
+	    fprintf(gppsfile, "%s%s", PS_DocFonts->name, fnp ? " " : "\n");
+	    free(PS_DocFonts->name);
+	    free(PS_DocFonts);
+	    PS_DocFonts = fnp;
+	}
+    }
+    if (ps_params->psformat != PSTERM_EPS)
+	fprintf(gppsfile,"%%%%Pages: %d\n",ps_page);
+}
+
+TERM_PUBLIC void
+PS_linetype(int linetype)
+{
+    if ((ps_params->terminal == PSTERM_EPSLATEX) && ps_params->oldstyle)
+	linetype = (linetype % 4) + 3;
+    else
+	linetype = (linetype % 9) + 3;
+    if (linetype < 0)	/* LT_NODRAW, LT_BACKGROUND, LT_UNDEFINED */
+	linetype = 0;
+
+    if (PS_linetype_last == linetype) return;
+
+    PS_relative_ok = FALSE;
+    PS_FLUSH_PATH;
+
+    PS_linetype_last = linetype;
+    PS_linewidth_last = PS_linewidth_current;
+    fprintf(gppsfile, "LT%c\n", "wba012345678"[linetype]);
+    ps_path_count = 0;
+}
+
+
+TERM_PUBLIC void
+PS_linewidth (double linewidth)
+{
+    /* HBB NEW 20031219: don't do anything if nothing changed */
+    if (ps_path_count != 0 && PS_linewidth_last == linewidth)
+	return;
+    PS_FLUSH_PATH;
+
+    PS_linewidth_current = linewidth;
+    PS_linetype_last = LT_UNDEFINED;	/* disable cache for next linetype change */
+    fprintf(gppsfile, "%.3f UL\n", linewidth);
+
+    /*
+	Documentation of the 'change linewidth' strategy of the postscript terminal:
+
+	1. define a new postscript variable with a default value:
+	/userlinewidth gnulinewidth def
+
+	2. define a new postscript command to change the contents of that variable:
+	/UL { gnulinewidth mul /userlinewidth exch def } def
+	usage:  multiplication_factor UL
+
+	3. modify the already known postscript command /PL for the plot lines:
+	/PL { stroke userlinewidth setlinewidth } def
+
+	4. issue the new command before every change of the plot linestyle:
+	example:
+	4.0 UL
+	LT0
+	result:
+	Linetype 0 is drawn four times as thick as defined by the contents
+	of the postscript variable 'gnulinewidth'.
+    */
+}
+
+
+TERM_PUBLIC void
+PS_pointsize (double ptsize)
+{
+    fprintf(gppsfile, "%.3f UP\n", ptsize);
+
+/*
+ *  Documentation of the 'change pointsize' strategy of the postscript
+ * terminal:
+ *
+ * 1. define two new postscript variables to hold the overall pointsize:
+ *    /hpt_  and  /vpt_
+ *
+ * 2. define a new postscript command to use the contents of these variables:
+ *    /UP { cf. definition above } def
+ *    usage:  multiplication_factor UP
+ *
+ * [3.] [doesn't exist, skip to next number]
+ *
+ * 4. issue the new command whereever you change the symbols (and linetype):
+ *    example:
+ *        2.5 UP
+ *        4.0 UL  % optionally change linewidth, too
+ *        LT0
+ *    result:
+ *        Next symbols will be drawn 2.5 times as big as defined by the
+ *        GNUPLOT `set pointsize` command (= overall pointsize).
+ */
+}
+
+
+TERM_PUBLIC void
+PS_move(unsigned int x, unsigned int y)
+{
+    /* Make this semi-dynamic and independent of architecture */
+    char abso[5+2*INT_STR_LEN], rel[5+2*INT_STR_LEN];
+    int dx = x - PS_pen_x;
+    int dy = y - PS_pen_y;
+
+    /* can't cancel all null moves--need a move after stroke'ing */
+    if (dx==0 && dy==0 && PS_relative_ok)
+	return;
+
+    sprintf(abso, "%d %d M\n", x, y);
+    sprintf(rel, "%d %d R\n", dx, dy);
+
+    if (PS_newpath) {
+	fprintf(gppsfile, "%d %d N\n", x, y);
+	PS_newpath = FALSE;
+    } else
+    if (strlen(rel) < strlen(abso) && PS_relative_ok) {
+	fputs(rel, gppsfile);
+	PS_taken++;
+    } else
+	fputs(abso, gppsfile);
+    PS_relative_ok = TRUE;
+    ps_path_count += 1;
+
+    PS_pen_x = x;
+    PS_pen_y = y;
+}
+
+TERM_PUBLIC void
+PS_vector(unsigned int x, unsigned int y)
+{
+    char abso[5+2*INT_STR_LEN], rel[5+2*INT_STR_LEN];
+    int dx = x - PS_pen_x;
+    int dy = y - PS_pen_y;
+
+    if (dx==0 && dy==0)
+	return;
+
+    sprintf(abso, "%d %d L\n", x, y);
+    sprintf(rel, "%d %d V\n", dx, dy);
+
+    /* The following PS_move() is executed only when the limit of ps_path_count
+     * has been reached below: then PS_FLUSH_PATH has been called which has not
+     * moved to currentpoint after the stroke. */
+    if (!PS_relative_ok)
+	PS_move(PS_pen_x, PS_pen_y);
+
+    if (strlen(rel) < strlen(abso)) {
+	fputs(rel, gppsfile);
+	PS_taken++;		/* only used for debug info */
+	ps_path_count += 1;
+    } else {
+	fputs(abso, gppsfile);
+	ps_path_count = 1;  /* If we set it to zero, it may never get flushed */
+    }
+    /* Ghostscript has a "pile-up of rounding errors" bug: a sequence of many
+     * rmove's or rlineto's does not yield the same line as move's or lineto's.
+     * Therefore, we periodically force an update of the absolute position.
+     * There was a case when 400 rlineto's were too much, so let's go a little
+     * bit higher than the default function sampling rate in gnuplot.
+     * This runs into a second ghostscript bug, that mixing relative and absolute
+     * lineto with no intervening 'stroke' is ridiculously slow to render.
+     * So we stroke the partial line, update the position in absolute terms,
+     * then continue.  This whole section can go away if ghostscript/gv is fixed.
+     */
+#define MAX_REL_PATHLEN 105
+    if (ps_path_count >= MAX_REL_PATHLEN) {
+	fprintf(gppsfile, "stroke %d %d M\n", x, y);
+	ps_path_count = 1;
+    }
+
+    PS_relative_ok = TRUE;
+    PS_pen_x = x;
+    PS_pen_y = y;
+}
+
+
+TERM_PUBLIC void
+PS_put_text(unsigned int x, unsigned int y, const char *str)
+{
+#define PS_NONE 0
+#define PS_TEXT 1
+#define PS_GLYPH 2
+    unsigned long ch;
+
+    if (!str && !strlen(str))
+	return;
+    PS_move(x,y);
+    if (ps_ang != 0)
+	fprintf(gppsfile,"currentpoint gsave translate %d rotate 0 0 M\n", ps_ang);
+
+    if (encoding == S_ENC_UTF8 && contains8bit(str)) {
+	/* UTF-8 encoding with multibyte characters present */
+	int mode = PS_NONE;
+
+	putc('[', gppsfile);
+
+	for (utf8toulong(&ch, &str); ch != '\0'; utf8toulong(&ch, &str)) {
+	    if (ch < 0x100) {
+		if (mode != PS_TEXT)
+		    putc('(', gppsfile);
+		if (ch == '(' || ch == ')' || ch == '\\')
+		    putc('\\', gppsfile);
+		putc((char)ch, gppsfile);
+		mode = PS_TEXT;
+	    } else {
+		int i;
+		if (mode == PS_TEXT)
+		    putc(')', gppsfile);
+		putc('/', gppsfile);
+#if (ADOBE_ENCODING_NAMES)
+		for (i = 0; i < psglyphs; i++) {
+		    if (aglist[i].unicode == ch) {
+		    	fputs(aglist[i].glyphname, gppsfile);
+			break;
+		    }
+		}
+		if (i >= psglyphs) /* Must not have found a glyph name */
+#endif
+		    fprintf(gppsfile, (ch > 0xffff) ? "u%lX" : "uni%04lX", ch);
+		mode = PS_GLYPH;
+	    }
+	}
+
+	if (mode == PS_TEXT)
+	    putc(')', gppsfile);
+
+	switch(ps_justify) {
+	    case LEFT :
+		fputs("] GLshow\n", gppsfile);
+		break;
+	    case CENTRE :
+		fputs("] GCshow\n", gppsfile);
+		break;
+	    case RIGHT :
+		fputs("] GRshow\n", gppsfile);
+		break;
+	}
+
+    } else {
+	/* plain old 8-bit mode (not UTF-8), or UTF-8 string with only 7-bit characters */
+	putc('(',gppsfile);
+	ch = (char) *str++;
+	while(ch!='\0') {
+	    if ((ch=='(') || (ch==')') || (ch=='\\'))
+		putc('\\', gppsfile);
+	    putc((char) ch, gppsfile);
+	    ch = (char) *str++;
+	}
+
+	switch(ps_justify) {
+	    case LEFT :
+		fputs(") Lshow\n", gppsfile);
+		break;
+	    case CENTRE :
+		fputs(") Cshow\n", gppsfile);
+		break;
+	    case RIGHT :
+		fputs(") Rshow\n", gppsfile);
+		break;
+	}
+    }
+
+    if (ps_ang != 0)
+	fputs("grestore\n", gppsfile);
+    ps_path_count = 0;
+    PS_relative_ok = FALSE;
+
+#undef PS_NONE
+#undef PS_TEXT
+#undef PS_GLYPH
+}
+
+
+TERM_PUBLIC int
+PS_text_angle(int ang)
+{
+    ps_ang = ang;
+    return TRUE;
+}
+
+
+TERM_PUBLIC int
+PS_justify_text(enum JUSTIFY mode)
+{
+    ps_justify = mode;
+    return TRUE;
+}
+
+
+TERM_PUBLIC int
+PS_set_font(const char *font)
+{
+    char *name;
+    unsigned int  i;
+    float size;
+    size_t sep;
+
+    if (!font || !(*font))
+	font = PS_default_font;
+    sep = strcspn(font,",");
+    name = gp_strdup(font);
+    name[sep] = NUL;
+    for (i=0; i<sep; i++)
+	if (name[i] == ' ') name[i] = '-';
+    size = ps_fontsize;
+    if (font[sep] == ',')
+	sscanf (&(font[sep+1]),"%f",&size);
+
+    /* If TeX is doing the font handling, we don't need to */
+    /* write anything into the postscript stream */
+    if (ps_params->terminal == PSTERM_POSTSCRIPT) {
+	PS_RememberFont(name);
+	fprintf(gppsfile, "/%s findfont %g scalefont setfont\n",
+		name, size*PS_SC);
+    }
+    free(name);
+
+    term->v_char = (unsigned int)(size*PS_SC);
+    term->h_char = (unsigned int)(size*PS_SC*6/10);
+    return TRUE;
+}
+
+
+/* postscript point routines */
+
+
+TERM_PUBLIC void
+PS_point(unsigned int x, unsigned int y, int number)
+{
+    static const char GPFAR * GPFAR pointFNS[] = {
+	"Pnt",  "Pls",   "Crs",    "Star",
+	"Box",  "BoxF",  "Circle", "CircleF",
+	"TriU", "TriUF", "TriD",   "TriDF",
+	"Dia",  "DiaF",  "Pent",   "PentF",
+	"C0",   "C1",    "C2",     "C3",
+	"C4",   "C5",    "C6",     "C7",
+	"C8",   "C9",    "C10",    "C11",
+	"C12",  "C13",   "C14",    "C15",
+	"S0",   "S1",    "S2",     "S3",
+	"S4",   "S5",    "S6",     "S7",
+	"S8",   "S9",    "S10",    "S11",
+	"S12",  "S13",   "S14",    "S15",
+	"D0",   "D1",    "D2",     "D3",
+	"D4",   "D5",    "D6",     "D7",
+	"D8",   "D9",    "D10",    "D11",
+	"D12",  "D13",   "D14",    "D15",
+	"BoxE", "CircE", "TriUE",  "TriDE",
+	"DiaE", "PentE", "BoxW",   "CircW",
+	"TriUW","TriDW", "DiaW",   "PentW"
+    };
+    static const char GPFAR * GPFAR pointFNS_OldEPSL[] = {
+	"Pnt",  "Dia",   "Circle", "Pls",
+	"Crs",  "Box",   "DiaF",   "CircleF",
+	"BoxF"
+    };
+    if ((ps_params->terminal == PSTERM_EPSLATEX) && ps_params->oldstyle) {
+	if (number < 0)
+	    number = -1;		/* negative types are all 'dot' */
+	else
+	    number %= sizeof(pointFNS_OldEPSL)/sizeof(pointFNS_OldEPSL[0]) -1;
+	fprintf(gppsfile, "%d %d %s\n", x, y, pointFNS_OldEPSL[number+1]);
+    } else {
+	if (number < 0)
+	    number = -1;		/* negative types are all 'dot' */
+	else
+	    number %= sizeof(pointFNS)/sizeof(pointFNS[0]) -1;
+	fprintf(gppsfile, "%d %d %s\n", x, y, pointFNS[number+1]);
+    }
+
+    PS_relative_ok = FALSE;
+    ps_path_count = 0;
+    PS_linetype_last = LT_UNDEFINED; /* force next linetype change */
+}
+
+TERM_PUBLIC void
+PS_fillbox(
+    int style,
+    unsigned int x1, unsigned int y1,
+    unsigned int width, unsigned int height)
+{
+    double filldens;
+    int pattern;
+
+    PS_FLUSH_PATH;
+
+    switch(style & 0xf) {
+
+    case FS_DEFAULT:
+	/* Fill with current color, wherever it came from */
+	fprintf(gppsfile, "%d %d %d %d Rec fill\n", x1,y1, width,height);
+	break;
+
+    case FS_SOLID:
+    case FS_TRANSPARENT_SOLID:
+	/* style == 1 --> fill with intensity according to filldensity */
+	filldens = (style >> 4) / 100.0;
+	if(filldens < 0.0)
+	    filldens = 0.0;
+	if(filldens > 1.0)
+	    filldens = 1.0;
+	fprintf(gppsfile, "%.3f %d %d %d %d BoxColFill\n",
+		filldens, x1,y1, width,height);
+	break;
+
+    case FS_PATTERN:
+    case FS_TRANSPARENT_PATTERN:
+	/* style == 2 --> fill with pattern according to fillpattern */
+	/* the upper 3 nibbles of 'style' contain pattern number */
+	pattern = (style >> 4) % 8;
+	switch (pattern) {
+
+	default:
+	case 0:
+		fprintf(gppsfile, "%d %d %d %d BoxFill\n",
+			x1, y1, width, height);
+		break;
+	case 1:
+		fprintf(gppsfile, "%d %d %d %d %d %d 1 PatternFill\n",
+			x1, y1, width, height, 80, -45);
+		break;
+	case 2:
+		fprintf(gppsfile, "%d %d %d %d %d %d 2 PatternFill\n",
+			x1, y1, width, height, 40,  45);
+		break;
+	case 3:
+		fprintf(gppsfile, "1 %d %d %d %d BoxColFill\n",
+			x1, y1, width, height);
+		break;
+	case 4:
+		fprintf(gppsfile, "%d %d %d %d %d %d 0 PatternFill\n",
+			x1, y1, width, height, 80,  45);
+		break;
+	case 5:
+		fprintf(gppsfile, "%d %d %d %d %d %d 0 PatternFill\n",
+			x1, y1, width, height, 80, -45);
+		break;
+	case 6:
+		fprintf(gppsfile, "%d %d %d %d %d %d 0 PatternFill\n",
+			x1, y1, width, height, 40,  30);
+		break;
+	case 7:
+		fprintf(gppsfile, "%d %d %d %d %d %d 0 PatternFill\n",
+			x1, y1, width, height, 40, -30);
+		break;
+	}
+	break; /* end of pattern filling part */
+
+    case FS_EMPTY:
+    default: /* fill with background color */
+	fprintf(gppsfile, "%d %d %d %d BoxFill\n", x1, y1, width, height);
+    }
+
+    PS_relative_ok = FALSE;
+    PS_linetype_last = LT_UNDEFINED;
+}
+
+
+/* ENHPOST */
+
+/*
+ * close a postscript string if it has been opened
+ */
+TERM_PUBLIC void
+ENHPS_FLUSH()
+{
+    if (ENHps_opened_string) {
+	fputs(")]\n", gppsfile);
+	ENHps_opened_string = FALSE;
+    }
+}
+
+static char *ENHps_opensequence = NULL;
+
+/*
+ * open a postscript string
+ */
+TERM_PUBLIC void
+ENHPS_OPEN(
+    char *fontname,
+    double fontsize, double base,
+    TBOOLEAN widthflag, TBOOLEAN showflag,
+    int overprint)
+{
+    /* overprint 3 means save current position; 4 means restore saved position */
+    /* EAM FIXME - I couldn't figure out how to use less than the 7 parameters */
+    /* that the normal case macro wants. Somebody more familiar with PostScript*/
+    /* than I am please clean it up!                                           */
+    if (overprint == 3) {
+	fputs("XYsave\n", gppsfile);
+	return;
+    } else if (overprint == 4) {
+	fputs("XYrestore\n", gppsfile);
+	return;
+    }
+
+	if (!ENHps_opened_string) {
+	    int safelen = strlen(fontname) + 40;
+	    free(ENHps_opensequence);
+	    ENHps_opensequence = gp_alloc(safelen,"ENHPS_opensequence");
+	    /* EAM November 2007 - moved here from enhanced_recursion() */
+	    PS_RememberFont(fontname);
+#ifdef HAVE_SNPRINTF
+	    snprintf(ENHps_opensequence, safelen, "[(%s) %.1f %.1f %s %s %d ",
+		    fontname, fontsize, base,
+		    widthflag ? "true" : "false",
+		    showflag ? "true" : "false",
+		    overprint);
+#else
+	    sprintf(ENHps_opensequence, "[(%s) %.1f %.1f %s %s %d ",
+		    fontname, fontsize, base,
+		    widthflag ? "true" : "false",
+		    showflag ? "true" : "false",
+		    overprint);
+#endif
+	    fprintf(gppsfile, "%s(", ENHps_opensequence);
+	    ENHps_opened_string = TRUE;
+	}
+}
+
+/*
+ * Write one character from inside enhanced text processing.
+ * This is trivial except in the case of multi-byte encoding.
+ */
+TERM_PUBLIC void
+ENHPS_WRITEC(int c)
+{
+    static int in_utf8 = 0; /* nonzero means we are inside a multibyte sequence */
+    static char utf8[6];    /* holds the multibyte sequence being accumulated   */
+    static int nbytes = 0;  /* number of bytes expected in the sequence */
+
+    /* UTF-8 Encoding */
+    if (encoding == S_ENC_UTF8 && (c & 0x80) != 0) {
+	if (in_utf8 == 0) {
+	    nbytes = (c & 0xE0) == 0xC0 ? 2
+		   : (c & 0xF0) == 0xE0 ? 3
+		   : (c & 0xF8) == 0xF0 ? 4
+		   : 0;
+	    if (!nbytes) /* Illegal UTF8 char; hope it's printable  */
+		fputc(c, gppsfile);
+	    else
+		utf8[in_utf8++] = c;
+	} else {
+	    utf8[in_utf8++] = c;
+	    if (in_utf8 >= nbytes) {
+		unsigned long wch = '\0';
+		const char *str = &utf8[0];
+		int i;
+
+		utf8[nbytes] = '\0';
+		in_utf8 = 0;
+		utf8toulong(&wch, &str);
+
+		if (wch < 0x100) { /* Single byte ISO8859-1 character */
+		    fputc(wch, gppsfile);
+		    return;
+		}
+
+		/* Finish off previous partial string, if any */
+		ENHPS_FLUSH();
+
+		/* Write a new partial string for this glyph */
+		fprintf(gppsfile, "%s/", ENHps_opensequence);
+#if (ADOBE_ENCODING_NAMES)
+		for (i = 0; i < psglyphs; i++) {
+		    if (aglist[i].unicode == wch) {
+			fputs(aglist[i].glyphname, gppsfile);
+			break;
+		    }
+		}
+		if (i >= psglyphs) /* Must not have found a glyph name */
+#endif
+		    fprintf(gppsfile, (wch > 0xffff) ? "u%lX" : "uni%04lX", wch);
+		fprintf(gppsfile, "]\n");
+
+		/* Mark string closed */
+		ENHps_opened_string = FALSE;
+	    }
+	}
+    } else
+
+    /* Single byte character */
+	fputc(c, gppsfile);
+}
+
+/* a set-font routine for enhanced post : simply copies
+ * the font into a global, or restores the globals
+ * to the ps_params->font default
+ */
+
+TERM_PUBLIC int
+ENHPS_set_font(const char *font)
+{
+    if (ignore_enhanced_text)
+	return PS_set_font(font);
+
+    if (*font) {
+	size_t sep = strcspn(font,",");
+	if (sep > 0) {
+	    strncpy(ps_enh_font,font,sep);
+	    ps_enh_font[sep] = NUL;
+	    PS_RememberFont(ps_enh_font);
+	}
+	ps_enh_fontsize = ps_fontsize;
+	sscanf (font+sep+1,"%f",&ps_enh_fontsize);
+    } else {
+	/* return to defaults */
+	strcpy(ps_enh_font, ps_params->font);
+	ps_enh_fontsize = ps_fontsize;
+    }
+    term->v_char = (unsigned int)(ps_enh_fontsize*PS_SC);
+    term->h_char = (unsigned int)(ps_enh_fontsize*PS_SC*6/10);
+
+    return TRUE;
+}
+
+TERM_PUBLIC void
+ENHPS_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    if (ignore_enhanced_text) {
+	PS_put_text(x,y,str);
+	return;
+    }
+
+    /* flush any pending graphics (all the XShow routines do this...) */
+
+    if (!strlen(str))
+	return;
+
+    PS_FLUSH_PATH;
+
+    /* FIXME: if there are no magic characters, we should just be able
+     * punt the string to PS_put_text(), which will give shorter
+     * ps output [eg tics and stuff rarely need extra processing],
+     * but we need to make sure that the current font is the
+     * default one before we can do that. {ie I tried it and it
+     * used the wrong font !}
+     * if (!strpbrk(str, "{}^_@&~"))
+     * {
+     *   - do something to ensure default font is selected
+     *   PS_put_text(x,y,str);
+     *   return;
+     * }
+     */
+
+    PS_move(x,y);
+
+    if (ps_ang != 0)
+	fprintf(gppsfile,"currentpoint gsave translate %d rotate 0 0 moveto\n",
+		ps_ang);
+
+    fputs("[ ", gppsfile);
+
+    /* set up the global variables needed by enhanced_recursion() */
+    enhanced_max_height = -1000;
+    enhanced_min_height = 1000;
+    enhanced_fontscale = PS_SC;
+    strncpy(enhanced_escape_format,"\\%o",sizeof(enhanced_escape_format));
+
+    ENHps_opened_string = FALSE;
+
+    /* Set the recursion going. We say to keep going until a
+     * closing brace, but we don't really expect to find one.
+     * If the return value is not the nul-terminator of the
+     * string, that can only mean that we did find an unmatched
+     * closing brace in the string. We increment past it (else
+     * we get stuck in an infinite loop) and try again.
+     *
+     * ps_enh_font and ps_enh_fontsize are either set to the
+     * the defaults set on option line, or have been set to
+     * "font,size". That is to say, ps_params->font is used only
+     * at startup and by ENHPS_set_font
+     */
+    while (*(str = enhanced_recursion((char *)str, TRUE, ps_enh_font,
+		 (double)(ps_enh_fontsize*PS_SC), 0.0, TRUE, TRUE, 0))) {
+	ENHPS_FLUSH();
+
+	/* I think we can only get here if *str == '}' */
+	enh_err_check(str);
+
+	if (!*++str)
+	    break; /* end of string */
+
+	/* else carry on and process the rest of the string */
+    }
+
+    enhanced_max_height += enhanced_min_height;
+
+    fprintf(gppsfile, "] %.1f ", -enhanced_max_height/3);
+
+    switch(ps_justify) {
+    case LEFT :
+	fputs("MLshow\n", gppsfile);
+	break;
+    case CENTRE :
+	fputs("MCshow\n", gppsfile);
+	break;
+    case RIGHT :
+	fputs("MRshow\n", gppsfile);
+	break;
+    }
+
+    if (ps_ang != 0)
+	fputs("grestore\n", gppsfile);
+    ps_path_count = 0;
+    PS_relative_ok = FALSE;
+}
+
+static void
+make_palette_formulae()
+{
+#define R sm_palette.formulaR
+#define G sm_palette.formulaG
+#define B sm_palette.formulaB
+/* print the definition of R,G,B formulae */
+  fputs("/InterpolatedColor false def\n", gppsfile);
+if (sm_palette.ps_allcF == 0) { /* print only those 3 used formulae */
+    fprintf(gppsfile, "/cF%i {%s} bind def\t%% %s\n",
+	     abs(R), ps_math_color_formulae[ 2*abs(R) ],
+	     ps_math_color_formulae[ 2*abs(R)+1 ]);
+    if (abs(G) != abs(R))
+      fprintf(gppsfile, "/cF%i {%s} bind def\t%% %s\n",
+	       abs(G), ps_math_color_formulae[ 2*abs(G) ],
+	       ps_math_color_formulae[ 2*abs(G)+1 ]);
+    if ((abs(B) != abs(R)) && (abs(B) != abs(G)))
+      fprintf(gppsfile, "/cF%i {%s} bind def\t%% %s\n",
+	       abs(B), ps_math_color_formulae[ 2*abs(B) ],
+	       ps_math_color_formulae[ 2*abs(B)+1 ]);
+    }
+  else { /* all color formulae are written into the output PostScript file */
+    int i = 0;
+    while (*(ps_math_color_formulae[2*i])) {
+      fprintf(gppsfile, "/cF%i {%s} bind def\t%% %s\n",
+	       i, ps_math_color_formulae[ 2*i ],
+	       ps_math_color_formulae[ 2*i+1 ]);
+      i++;
+      }
+    }
+#undef R
+#undef G
+#undef B
+}
+
+
+
+static void
+make_interpolation_code()
+{
+    static const char *header[] = {
+	"/grayindex {/gidx 0 def\n",
+	"  {GrayA gidx get grayv ge {exit} if /gidx gidx 1 add def} loop} def\n",
+	"/dgdx {grayv GrayA gidx get sub GrayA gidx 1 sub get\n",
+	"  GrayA gidx get sub div} def \n",
+	"/redvalue {RedA gidx get RedA gidx 1 sub get\n",
+	"  RedA gidx get sub dgdxval mul add} def\n",
+	"/greenvalue {GreenA gidx get GreenA gidx 1 sub get\n",
+	"  GreenA gidx get sub dgdxval mul add} def\n",
+	"/bluevalue {BlueA gidx get BlueA gidx 1 sub get\n",
+	"  BlueA gidx get sub dgdxval mul add} def\n",
+	"/interpolate {\n",
+	"  grayindex grayv GrayA gidx get sub abs 1e-5 le\n",
+	"    {RedA gidx get GreenA gidx get BlueA gidx get}\n",
+	"    {/dgdxval dgdx def redvalue greenvalue bluevalue} ifelse} def\n",
+	NULL,
+    };
+    int i;
+
+    for(i=0; header[i]!=NULL; ++i) {
+	fputs(header[i], gppsfile);
+    }
+}
+
+
+static void
+make_color_model_code()
+{
+    /* Postscript version of the color space transformations in getcolor.c */
+    static const char *header[] = {
+	"/HSV2RGB {",
+	"  exch dup 0.0 eq {pop exch pop dup dup} % achromatic gray\n",
+	"  { /HSVs exch def /HSVv exch def 6.0 mul dup floor dup 3 1 roll sub\n ",
+	"    /HSVf exch def /HSVi exch cvi def /HSVp HSVv 1.0 HSVs sub mul def\n",
+	"	 /HSVq HSVv 1.0 HSVs HSVf mul sub mul def \n",
+	"	 /HSVt HSVv 1.0 HSVs 1.0 HSVf sub mul sub mul def\n",
+	"	 /HSVi HSVi 6 mod def 0 HSVi eq {HSVv HSVt HSVp}\n",
+	"	 {1 HSVi eq {HSVq HSVv HSVp}{2 HSVi eq {HSVp HSVv HSVt}\n",
+	"	 {3 HSVi eq {HSVp HSVq HSVv}{4 HSVi eq {HSVt HSVp HSVv}\n",
+	"	 {HSVv HSVp HSVq} ifelse} ifelse} ifelse} ifelse} ifelse\n",
+	"  } ifelse} def\n",
+	"/Constrain {\n",
+	"  dup 0 lt {0 exch pop}{dup 1 gt {1 exch pop} if} ifelse} def\n",
+	"/YIQ2RGB {\n",
+	"  3 copy -1.702 mul exch -1.105 mul add add Constrain 4 1 roll\n",
+	"  3 copy -0.647 mul exch -0.272 mul add add Constrain 5 1 roll\n",
+	"  0.621 mul exch -0.956 mul add add Constrain 3 1 roll } def\n",
+	"/CMY2RGB {",
+	"  1 exch sub exch 1 exch sub 3 2 roll 1 exch sub 3 1 roll exch } def\n",
+	"/XYZ2RGB {",
+	"  3 copy -0.9017 mul exch -0.1187 mul add exch 0.0585 mul exch add\n",
+	"  Constrain 4 1 roll 3 copy -0.0279 mul exch 1.999 mul add exch\n",
+	"  -0.9844 mul add Constrain 5 1 roll -0.2891 mul exch -0.5338 mul add\n",
+	"  exch 1.91 mul exch add Constrain 3 1 roll} def\n",
+	"/SelectSpace {ColorSpace (HSV) eq {HSV2RGB}{ColorSpace (XYZ) eq {\n",
+	"  XYZ2RGB}{ColorSpace (CMY) eq {CMY2RGB}{ColorSpace (YIQ) eq {YIQ2RGB}\n",
+	"  if} ifelse} ifelse} ifelse} def\n",
+	NULL,
+    };
+    int i;
+
+    for(i=0; header[i]!=NULL; ++i) {
+	fputs(header[i], gppsfile);
+    }
+}
+
+
+static char
+*save_space(double gray)
+{
+    /* printing the gray with 4 digits and without the leading 0
+     * ... saving space */
+    static char s[40];
+
+    gray = 0.0001*(int)(gray*10000+0.5); /* round it to 4 digits */
+    sprintf(s, "%.4g", gray);
+    if (s[0] == '0' && s[1] == '.')
+	return &(s[1]);  /* strip leading 0 */
+    else
+	return s;
+}
+
+
+static void
+write_color_space(t_sm_palette *palette)
+{
+    /* write something like
+     *   /ColorSpace (HSV) def
+     * depending on the selected cmodel in palette */
+    fputs("/ColorSpace ", gppsfile);
+    switch(palette->cmodel) {
+    case C_MODEL_RGB:
+	fputs("(RGB)", gppsfile);
+	break;
+    case C_MODEL_HSV:
+	fputs("(HSV)", gppsfile);
+	break;
+    case C_MODEL_CMY:
+	fputs("(CMY)", gppsfile);
+	break;
+    case C_MODEL_YIQ:
+	fputs("(YIQ)", gppsfile);
+	break;
+    case C_MODEL_XYZ:
+	fputs("(XYZ)", gppsfile);
+	break;
+    default:
+	fprintf(stderr,"%s:%d ooops: Unkown color model '%c'. Will be RGB\n",
+		__FILE__, __LINE__, (char)(palette->cmodel));
+	fputs("(RGB)", gppsfile);
+	break;
+    }
+    fputs(" def\n", gppsfile);
+}
+
+
+static void
+write_component_array(const char *text, gradient_struct *grad,
+		      int cnt, int offset)
+{
+    /*  write someting like
+     *     /RedA [ 0 .1 .2 .3 .35 .3 .2 .1 0 0 0 ] def
+     *  nicely formated to gppsfile
+     */
+    int i=0, len=0;
+    char *val;
+
+    fprintf(gppsfile, "/%s [", text);
+    len = strlen(text) + 4;
+    for(i=0; i<cnt; ++i) {
+	char *ref = (char*)(&(grad[i]));
+
+	ref += offset;
+	val = save_space(*((double*) (ref)));
+	len += strlen(val) + 1;
+	if(len > 77) {
+	    fputs("\n  ",gppsfile);
+	    len = strlen(val) + 3;
+	}
+	fprintf(gppsfile, "%s ", val);
+    }
+    fputs("] def\n", gppsfile);
+}
+
+
+static void
+write_gradient_definition(gradient_struct *gradient, int cnt)
+{
+    /* some strange pointer acrobatic here, but it seems to work... */
+    char *ref = (char*) (gradient);
+    int p = (char*) (&(gradient[0].pos)) - ref;
+    int r = (char*) (&(gradient[0].col.r)) - ref;
+    int g = (char*) (&(gradient[0].col.g)) - ref;
+    int b = (char*) (&(gradient[0].col.b)) - ref;
+
+    write_component_array("GrayA", gradient, cnt, p);
+    write_component_array("RedA", gradient, cnt, r);
+    write_component_array("GreenA", gradient, cnt, g);
+    write_component_array("BlueA", gradient, cnt, b);
+}
+
+
+static void
+PS_make_header(t_sm_palette *palette)
+{
+    /* write header for smooth colors */
+    fputs("gsave % colour palette begin\n", gppsfile);
+    fprintf(gppsfile, "/maxcolors %i def\n", sm_palette.use_maxcolors);
+    make_color_model_code();
+
+    switch(sm_palette.colorMode) {
+    case SMPAL_COLOR_MODE_GRAY:
+	fputs("/InterpolatedColor false def\n", gppsfile);
+	break;  /* nothing to do for gray */
+    case SMPAL_COLOR_MODE_RGB:
+	make_palette_formulae();
+	break;
+    case SMPAL_COLOR_MODE_FUNCTIONS: {
+	int cnt=0;
+	gradient_struct *gradient;
+
+	fputs("/InterpolatedColor true def\n", gppsfile);
+	make_interpolation_code();
+	gradient = approximate_palette(palette, ps_params->palfunc_samples,
+				       ps_params->palfunc_deviation, &cnt);
+	write_gradient_definition(gradient, cnt);
+	free(gradient);
+	break;
+    }
+    case SMPAL_COLOR_MODE_GRADIENT:
+	fputs("/InterpolatedColor true def\n", gppsfile);
+	make_interpolation_code();
+	write_gradient_definition(palette->gradient, palette->gradient_num);
+	break;
+    default:
+	fprintf(stderr, "%s:%d ooops: Unknown color mode '%c'\n",
+		 __FILE__, __LINE__, (char)(sm_palette.colorMode));
+    }
+    fputs("/pm3dround {maxcolors 0 gt {dup 1 ge\n", gppsfile);
+    fputs("\t{pop 1} {maxcolors mul floor maxcolors 1 sub div} ifelse} if} def\n",
+	  gppsfile);
+    fprintf(gppsfile, "/pm3dGamma 1.0 %g Gamma mul div def\n", sm_palette.gamma);
+    write_color_space(palette);
+
+/* Now print something like
+   /g {dup cF7 exch dup cF5 exch cF15 setrgbcolor} bind def
+*/
+#define R sm_palette.formulaR
+#define G sm_palette.formulaG
+#define B sm_palette.formulaB
+
+/* 18.1.2009 Since the beginning of pm3d, the Color definition switched
+   between gray and colour map. This led to ambiguities for custom colour
+   palettes if they contain grays only. Thus let postscript choose always
+   always colour palette for interpolated colours ('set palette defined',
+   'set palette file') and colour/gray according to Color otherwise
+   ('set palette gray', 'set palette rgb').
+*/
+#if 0
+    fprintf(gppsfile, "Color %s and { %% COLOUR vs. GRAY map\n",
+	    (sm_palette.colorMode!=SMPAL_COLOR_MODE_GRAY) ? "true":"false");
+#else
+    if (sm_palette.colorMode == SMPAL_COLOR_MODE_GRAY)
+	fputs("false { % COLOUR vs. GRAY map\n", gppsfile);
+    else
+	fputs("Color InterpolatedColor or { % COLOUR vs. GRAY map\n", gppsfile);
+#endif
+
+    fputs("  InterpolatedColor { %% Interpolation vs. RGB-Formula\n",
+	  gppsfile);
+    fputs("    /g {stroke pm3dround /grayv exch def interpolate\n", gppsfile);
+    fputs("        SelectSpace setrgbcolor} bind def\n", gppsfile);
+    fputs("  }{\n", gppsfile);
+    fputs("  /g {stroke pm3dround dup ", gppsfile);
+    if (R < 0)
+	fputs("1 exch sub ", gppsfile); /* negate */
+    fprintf(gppsfile,"cF%i Constrain exch dup ", abs(R));
+    if (G < 0)
+	fputs("1 exch sub ", gppsfile); /* negate */
+    fprintf(gppsfile,"cF%i Constrain exch ", abs(G));
+    if (R<0 || G<0 || B<0)
+	fputs("\n\t", gppsfile);
+    if (B < 0)
+	fputs("1 exch sub ", gppsfile); /* negate */
+    fprintf(gppsfile,"cF%i Constrain ", abs(B));
+    fputs("\n       SelectSpace setrgbcolor} bind def\n", gppsfile);
+    fputs("  } ifelse\n", gppsfile);
+    fputs("}{\n", gppsfile);
+    fputs("  /g {stroke pm3dround pm3dGamma exp setgray} bind def\n", gppsfile);
+    fputs("} ifelse\n", gppsfile);
+#undef R
+#undef G
+#undef B
+}
+
+
+TERM_PUBLIC int PS_make_palette (t_sm_palette *palette)
+{
+    if (palette == NULL) {
+	return 0;  /* postscript can do continuous colors */
+    }
+
+    PS_make_header(palette);
+    return 0;
+}
+
+
+TERM_PUBLIC void PS_set_color (t_colorspec *colorspec)
+{
+    double gray;
+
+    PS_linetype_last = LT_UNDEFINED;  /* Force next call to linetype to be honored */
+
+    if (PS_linewidth_last != PS_linewidth_current) {
+	PS_linewidth_last = PS_linewidth_current;
+	fprintf(gppsfile, "PL ");
+    }
+
+    if (colorspec->type == TC_LT) {
+	int linetype = colorspec->lt;
+	PS_FLUSH_PATH;
+	if ((ps_params->terminal == PSTERM_EPSLATEX) && ps_params->oldstyle)
+	    linetype = (linetype % 4) + 3;
+	else
+	    linetype = (linetype % 9) + 3;
+	if (linetype < 0)	/* LT_NODRAW, LT_BACKGROUND, LT_UNDEFINED */
+	    linetype = 0;
+	fprintf(gppsfile, "LC%1c setrgbcolor\n","wba012345678"[linetype]);
+    } else if (colorspec->type == TC_RGB) {
+	double r = (double)((colorspec->lt >> 16 ) & 255) / 255.;
+	double g = (double)((colorspec->lt >> 8 ) & 255) / 255.;
+	double b = (double)(colorspec->lt & 255) / 255.;
+	PS_FLUSH_PATH;
+	fprintf(gppsfile, "%3.2f %3.2f %3.2f C ",r,g,b);
+    }
+
+    if (colorspec->type != TC_FRAC)
+	return;
+
+/* map [0;1] to gray/colors */
+    gray = colorspec->value;
+    if (gray <= 0)
+	fputs("0 g ", gppsfile);
+    else {
+	if (gray >= 1)
+	    fputs("1 g ", gppsfile);
+	else
+	    fprintf(gppsfile, "%s g ", save_space(gray));
+    }
+    PS_relative_ok = FALSE; /* "M" required because "g" forces stroke (??) */
+}
+
+
+TERM_PUBLIC void PS_filled_polygon (int points, gpiPoint *corners)
+{
+    int i;
+    float filldens = 1.0;
+    int pattern = 0;
+    int style = corners->style;
+
+    /* Stroke the previous graphic element if required. */
+    if (PS_relative_ok)
+	PS_FLUSH_PATH;
+
+    if (points == 4 && style == FS_OPAQUE) {
+	/* Special case for pm3d surface quadrangles
+	 *  <x0> <y0> ... <x4> <y4> h
+	 */
+	    fprintf(gppsfile, "%i %i N", corners[0].x, corners[0].y);
+	    fprintf(gppsfile, " %i %i %i %i %i %i h\n",
+	    corners[3].x-corners[2].x, corners[3].y-corners[2].y,
+	    corners[2].x-corners[1].x, corners[2].y-corners[1].y,
+	    corners[1].x-corners[0].x, corners[1].y-corners[0].y);
+    } else {
+	/* General case for solid or pattern-filled polygons
+	 * gsave <x0> <y0> N <x1> <y1> ... <xn> <yn> density PolyFill
+	 */
+	int fillpar = style >> 4;
+	style = style &0xf;
+
+	fprintf(gppsfile, "gsave ");
+	fprintf(gppsfile, "%i %i N", corners[0].x, corners[0].y);
+	for (i = 1; i < points; i++) {
+	    /* The rationale for mixing V and L is given in PS_vector */
+	    if (i % MAX_REL_PATHLEN)
+		fprintf(gppsfile, " %i %i V", corners[i].x-corners[i-1].x,
+		    corners[i].y-corners[i-1].y);
+	    else
+		fprintf(gppsfile, " %i %i L", corners[i].x, corners[i].y);
+	}
+
+	switch(style) {
+	
+	case FS_SOLID:
+	case FS_TRANSPARENT_SOLID:
+	    filldens = (fillpar) / 100.0;
+	    if(filldens < 0.0)
+		filldens = 0.0;
+	    if(filldens >= 1.0)
+		fprintf(gppsfile, " 1 PolyFill\n");
+	    else
+		fprintf(gppsfile, " %.2f PolyFill\n", filldens);
+	    break;
+	    
+	case FS_TRANSPARENT_PATTERN:
+	    fprintf(gppsfile," /TransparentPatterns true def\n");
+	case FS_PATTERN:
+	    pattern = (fillpar) % 8;
+	    if (pattern == 0)  {
+		filldens = 0.5;
+		fprintf(gppsfile, " %.1f PolyFill\n", filldens);
+	    } else {
+		fprintf(gppsfile," Pattern%d fill grestore\n", pattern);
+	    }
+	    break;
+
+	default:
+	    fputs(" 1 PolyFill\n", gppsfile);
+	    break;
+
+	}
+    }
+
+    PS_relative_ok = FALSE;
+}
+
+#undef MAX_REL_PATHLEN
+
+TERM_PUBLIC void PS_previous_palette()
+{
+    /* Needed to stroke the previous graphic element. */
+    PS_FLUSH_PATH;
+    fputs("grestore % colour palette end\n", gppsfile);
+}
+
+
+/*
+ * The reason for having a PostScript-specific wrapper for do_arrow
+ * is that post.trm draws dotted lines for monochrome output, and
+ * dotted arrowheads are ugly.  So in that case we call do_arrow twice,
+ * the second time to retrace the head with the line style forced to solid.
+ */
+TERM_PUBLIC void PS_arrow (
+    unsigned int sx, unsigned int sy,
+    unsigned int ex, unsigned int ey,
+    int head)
+{
+    do_arrow( sx, sy, ex, ey, head );
+    if (!ps_params->solid && head != 0) {
+	PS_FLUSH_PATH;
+	fputs("gsave [] 0 setdash\n", gppsfile);
+	do_arrow( sx, sy, ex, ey, -head );
+	PS_FLUSH_PATH;
+	fputs("grestore\n", gppsfile);
+    }
+}
+
+static void
+delete_ps_fontfile(struct ps_fontfile_def *prev, struct ps_fontfile_def *this)
+{
+    if (this != NULL) {		/* there really is something to delete */
+	FPRINTF((stderr, "Remove font/kerning file `%s'\n",
+		 this->fontfile_name));
+	if (prev != NULL)	/* there is a previous ps_fontfile */
+	    prev->next = this->next;
+	else			/* this = ps_params->first_fontfile */
+		                /* so change ps_params->first_fontfile */
+	    ps_params->first_fontfile = this->next;
+	free(this->fontfile_name);
+	free(this->fontfile_fullname);
+	free(this->fontname);
+	free(this);
+	this = NULL;
+    }
+}
+
+
+static void
+PS_encode85(unsigned long tuple4, unsigned char *tuple5)
+{
+    /* The compiler should know to carry out the powers of
+     * 85 computation at compilation time.
+     */
+    tuple5[0] = tuple4/(85*85*85*85);
+    tuple4 -= ((unsigned long)tuple5[0])*(85*85*85*85);
+    tuple5[1] = tuple4/(85*85*85);
+    tuple4 -= ((unsigned long)tuple5[1])*(85*85*85);
+    tuple5[2] = tuple4/(85*85);
+    tuple4 -= ((unsigned long)tuple5[2])*(85*85);
+    tuple5[3] = tuple4/(85);
+    tuple4 -= ((unsigned long)tuple5[3])*(85);
+    tuple5[4] = tuple4;
+}
+
+enum PS_ENCODING {
+    PS_ASCII_HEX,
+    PS_ASCII85
+} PS_ENCODING;
+
+/* Returns pointer to encoded image, allocated on heap that the
+ * caller must free.  Can error to command line so make sure all
+ * heap memory is recorded in static pointers when calling this
+ * routine.
+ */
+static char *
+PS_encode_image(unsigned int M, unsigned int N, coordval *image, t_imagecolor color_mode,
+		int bits_per_component, int max_colors, double cscale,
+		enum PS_ENCODING encoding, int *return_num_bytes)
+{
+    unsigned int coord_remaining;
+    coordval *coord_ptr;
+    unsigned short i_line;
+    unsigned int i_element;
+    unsigned int end_of_line;
+    unsigned short bits_remaining, bits_start;
+
+    unsigned long tuple4;
+    unsigned char tuple5[5];
+    int max_encoded_bytes;
+    char *encoded_image, *encoded_image_ptr;
+    unsigned long total_bits;
+
+#define ASCII_PER_LINE 78
+
+    /* 18.1.2009 RGB images ("plot ... with rgbimage") are drawn always in color,
+     * i.e. for both "set term post color" and "set term post mono".
+     */
+    total_bits = bits_per_component*M*N*((color_mode == IC_RGB /* && ps_params->color */) ? 3 : 1);
+
+    /* At the end of each image line, data is aligned to the nearest 8 bits,
+     * which means potentially adding 7 bits per line.
+     */
+    end_of_line = M;
+    total_bits += N*7;
+
+    /* Compute max number of ascii characters encoding will require.
+     */
+    if (encoding == PS_ASCII_HEX) {
+	/* Straight hex encoding */
+	max_encoded_bytes = (total_bits/4 + 1);
+	max_encoded_bytes += max_encoded_bytes / ASCII_PER_LINE; /* newline characters */
+    } else {
+	/* ASCII85 encoding */
+	max_encoded_bytes = (total_bits/32 + 1)*5 + 2; /* 5 tuples and additional ~> */
+	max_encoded_bytes += max_encoded_bytes / ASCII_PER_LINE; /* newline characters */
+    }
+
+    /* Reserve enough memory. */
+    if (!(encoded_image = gp_alloc(max_encoded_bytes, "encoded image")))
+	int_error(NO_CARET, "GNUPLOT (post.trm):  Error allocating memory.\n");
+    encoded_image_ptr = encoded_image;
+
+    coord_ptr = image;
+    i_line = ASCII_PER_LINE;
+    i_element = 0;
+    coord_remaining = M*N;
+    if (color_mode == IC_RGB /* && ps_params->color */) {
+	end_of_line *= 3;
+	coord_remaining *= 3;
+    }
+    bits_remaining = 32;
+    bits_start = 0;
+    tuple4 = 0;
+
+    while (coord_remaining) {
+	unsigned short us_tmp;
+	if (0 /* color_mode == IC_RGB && !ps_params->color */) {
+	    coordval c_tmp;
+	    c_tmp = *coord_ptr++;
+	    c_tmp += *coord_ptr++;
+	    c_tmp += *coord_ptr++;
+	    us_tmp = (unsigned short) (c_tmp*(max_colors-1)/3.0 + 0.5);
+	} else
+	    us_tmp = (unsigned short) ((*coord_ptr++) * max_colors);
+
+	if (us_tmp > (max_colors-1)) us_tmp = max_colors-1;
+
+	/* Rescale to accommodate a mismatch between max_colors and # of bits */
+	us_tmp *= cscale;
+
+	if (bits_remaining < bits_per_component) {
+	    tuple4 <<= bits_remaining;
+	    bits_start = bits_per_component - bits_remaining;
+	    bits_remaining = 0;
+	    tuple4 |= (us_tmp >> bits_start);
+	} else {
+	    tuple4 <<= bits_per_component;
+	    tuple4 |= us_tmp;
+	    bits_remaining -= bits_per_component;
+	}
+
+	/* If this is last pixel in line, pad to nearest 8 bits. */
+	i_element++;
+	if (i_element == end_of_line) {
+	    register unsigned short bit_align = (bits_remaining & 0x7);
+	    tuple4 <<= bit_align;
+	    bits_remaining -= bit_align;
+	    i_element = 0;
+	}
+
+	/* Check if another 4-tuple is complete. */
+	if (!bits_remaining) {
+	    if (ps_params->level1) {
+		/* A straight hex encoding for every 4 bits. */
+		unsigned char tuple8[8];
+		int i;
+		for (i=7; i >= 0; i--) {
+		    tuple8[i] = tuple4 & 0xf;
+		    tuple4 >>= 4;
+		}
+		for (i=0; i < 8; i++) {
+		    sprintf(encoded_image_ptr++, "%1x", tuple8[i]);
+		    i_line--;
+		    if (!i_line) {i_line = ASCII_PER_LINE; *encoded_image_ptr++ = '\n';}
+		}
+	    } else {
+		/* Convert to ASCII85 representation. */
+		if (tuple4) {
+		    int i;
+		    PS_encode85(tuple4, tuple5);
+		    tuple4 = 0;
+		    for (i=0; i < 5; i++) {
+			sprintf(encoded_image_ptr++, "%c", tuple5[i]+'!');
+			i_line--;
+			if (!i_line) {i_line = ASCII_PER_LINE; *encoded_image_ptr++ = '\n';}
+		    }
+		} else {
+		    *encoded_image_ptr++ = 'z';
+		    i_line--;
+		    if (!i_line) {i_line = ASCII_PER_LINE; *encoded_image_ptr++ = '\n';}
+		}
+	    }
+
+	    /* Now pick up any bits that may have not made it into the 4-tuple. */
+	    if (bits_start) {tuple4 = us_tmp - ((us_tmp>>bits_start)<<bits_start);}
+	    bits_remaining = 32 - bits_start;
+	    bits_start = 0;
+
+	}
+
+	coord_remaining--;
+
+    }
+
+    if (bits_remaining < 32) {
+	int i;
+	int n = 4 - bits_remaining/8;
+	if (ps_params->level1) {
+	    /* A straight hex encoding for every 4 bits. */
+	    unsigned char tuple8[8];
+	    for (i=2*n-1; i >= 0; i--) {
+		tuple8[i] = tuple4 & 0xf;
+		tuple4 >>= 4;
+	    }
+	    for (i=0; i < 2*n; i++) {
+		sprintf(encoded_image_ptr++, "%1x", tuple8[i]);
+		i_line--;
+		if (!i_line) {i_line = ASCII_PER_LINE; *encoded_image_ptr++ = '\n';}
+	    }
+	} else {
+	    /* Convert to ASCII85 representation.
+	     *
+	     * The case where not all bytes in a tuple are used is slightly different.
+	     * There is no use of 'z' as a special character and the remaining bytes
+	     * need to be filled.  Then use only a portion of the final 5-tuple.
+	     */
+	    tuple4 <<= bits_remaining;
+	    PS_encode85(tuple4, tuple5);
+	    /* Write first n+1 bytes. */
+	    for (i=0; i <= n; i++) {
+		sprintf(encoded_image_ptr++, "%c", tuple5[i]+'!');
+		i_line--;
+		if (!i_line) {i_line = ASCII_PER_LINE; *encoded_image_ptr++ = '\n';}
+	    }
+	}
+    }
+
+    if (!ps_params->level1) {
+	sprintf(encoded_image_ptr, "~>");
+	encoded_image_ptr += 2;
+    }
+
+    *return_num_bytes = (encoded_image_ptr - encoded_image);
+    assert(*return_num_bytes <= max_encoded_bytes); 
+    return encoded_image;
+}
+
+
+static void
+print_five_operand_image(unsigned int M, unsigned int N, gpiPoint *corner, t_imagecolor color_mode, unsigned short bits_per_component)
+{
+    char *space = ps_params->level1 ? "" : "  ";
+
+    fprintf(gppsfile, "%sgsave\n", space);
+    if (sm_palette.colorMode == SMPAL_COLOR_MODE_GRAY)
+	fprintf(gppsfile, "%s{pm3dGamma exp} settransfer\n", space);
+    fprintf(gppsfile, "%s%d %d translate\n", space, corner[0].x, corner[0].y);
+    fprintf(gppsfile, "%s%d %d scale\n", space, (corner[1].x - corner[0].x), (corner[1].y - corner[0].y));
+    fprintf(gppsfile, "%s%d %d %d\n", space, M, N, bits_per_component);
+    fprintf(gppsfile, "%s[ %d 0 0 %d 0 0 ]\n", space, M, N);
+    if (ps_params->level1) {
+	fprintf(gppsfile, "/imagebuf %d string def\n", 
+		(M*N*bits_per_component*((color_mode == IC_RGB /* && ps_params->color */) ? 3 : 1) + 7)/8);
+	fputs("{currentfile imagebuf readhexstring pop}\n", gppsfile);
+    } else
+	fprintf(gppsfile, "  currentfile /ASCII85Decode filter\n");
+    if (color_mode == IC_RGB /* && ps_params->color */) {
+	fprintf(gppsfile, "%sfalse 3\n"
+			  "%scolorimage\n", space, space);
+    } else
+	fprintf(gppsfile, "%simage\n", space);
+}
+
+
+TERM_PUBLIC void
+PS_image (unsigned int M, unsigned int N, coordval *image, gpiPoint *corner, t_imagecolor color_mode)
+{
+    char *encoded_image;
+    int num_encoded_bytes;
+    unsigned short bits_per_component = 0;
+    int max_colors, i_tmp;
+    TBOOLEAN five_operand_image;
+    double cscale;
+
+#define DEFAULT_BITS_PER_COMPONENT 8
+#define DEFAULT_COMPONENT_MAX (1<<DEFAULT_BITS_PER_COMPONENT)
+
+    if (sm_palette.use_maxcolors > 0)
+	max_colors = sm_palette.use_maxcolors;
+    else
+	max_colors = DEFAULT_COMPONENT_MAX;
+
+    i_tmp = 1;
+    while (i_tmp < max_colors) {
+	bits_per_component++;
+	i_tmp <<= 1;
+    }
+
+    if (bits_per_component < 1 || bits_per_component > 12) {
+	fprintf(stderr, "GNUPLOT (post.trm):  Component bits (%d) out of range.\n", bits_per_component);
+	return;
+    }
+
+    if (bits_per_component > 8)
+	bits_per_component = 12;
+    else if (bits_per_component > 4)
+	bits_per_component = 8;
+    else if (bits_per_component > 2)
+	bits_per_component = 4;
+
+    /* Color and gray scale images do not need a palette and can use
+     * the 5 operand form of the image routine.
+     */
+#if 0
+    /* 18.1.2009 It was decided to use the custom palette (i.e. colours) also
+       for the monochrome postscript output.
+    */
+    if ((color_mode == IC_RGB) || (sm_palette.colorMode == SMPAL_COLOR_MODE_GRAY) || !ps_params->color)
+#else
+    if ((color_mode == IC_RGB) || (sm_palette.colorMode == SMPAL_COLOR_MODE_RGB && !ps_params->color) || (sm_palette.colorMode == SMPAL_COLOR_MODE_GRAY))
+#endif
+	five_operand_image = TRUE;
+    else
+	five_operand_image = FALSE;
+
+    /* The five operand image doesn't have a palette and the values are
+     * such that 0 maps to 0.0 and 2^bits_per_component - 1 maps to 1.0
+     * in the PostScript driver.  Without any other knowledge, we scale
+     * things so that our max colors corresponds to 1.0.
+     */
+    if (five_operand_image)
+	cscale =  (float)((1 << bits_per_component)-1) / (float)(max_colors-1);
+    else
+	cscale = 1.0;
+
+    encoded_image = PS_encode_image(M, N, image, color_mode, 
+				bits_per_component, max_colors, cscale,
+				(ps_params->level1 ? PS_ASCII_HEX : PS_ASCII85), &num_encoded_bytes);
+
+    fputs("%%%%BeginImage\n", gppsfile);
+
+    /* Clip image to requested bounding box */
+    fprintf(gppsfile,"gsave %d %d N %d %d L %d %d L %d %d L Z clip\n",
+	corner[2].x, corner[2].y, corner[2].x, corner[3].y, corner[3].x, corner[3].y, corner[3].x, corner[2].y);
+
+    /* Color and gray scale images do not need a palette and can use
+     * the 5 operand form of the image routine.  For other types of
+     * palettes, the 1 operand form of the image routine must be used
+     * and an indexed palette needs to be constructed.
+     */
+    if (five_operand_image) {
+
+	if (ps_params->level1) {
+	    print_five_operand_image(M, N, corner, color_mode, bits_per_component);
+	} else {
+	    fputs("InterpretLevel1 {\n"
+		  "  %% Construct a box instead of image\n"
+		  "  LTb\n", gppsfile);
+	    fprintf(gppsfile, "  %d %d M\n", corner[0].x, corner[0].y);
+	    fprintf(gppsfile, "  %d 0 V\n", (corner[1].x - corner[0].x));
+	    fprintf(gppsfile, "  0 %d V\n", (corner[1].y - corner[0].y));
+	    fprintf(gppsfile, "  %d 0 V\n", -(corner[1].x - corner[0].x));
+	    fprintf(gppsfile, "  %d %d L\n", corner[0].x, corner[0].y);
+	    fputs("  40 -110 R\n"
+		  "  (PS level 2 image) Lshow\n"
+		  "  % Read data but ignore it\n", gppsfile);
+	    fprintf(gppsfile, "  /imagebuf %d string def\n", num_encoded_bytes);
+	    fputs("  currentfile imagebuf readstring\n"
+		  "} {\n", gppsfile);
+	    print_five_operand_image(M, N, corner, color_mode, bits_per_component);
+	    fputs("} ifelse\n", gppsfile);
+	}
+
+    }
+    else {
+
+	int allocated;
+	unsigned short i_tuple;
+	double fact = 1.0 / (double)(max_colors-1);
+	if (!ps_params->level1) {
+	    fputs("InterpretLevel1 {\n"
+		  "  %% Construct a box instead of image\n"
+		  "  LTb\n", gppsfile);
+	    fprintf(gppsfile, "  %d %d M\n", corner[0].x, corner[0].y);
+	    fprintf(gppsfile, "  %d 0 V\n", (corner[1].x - corner[0].x));
+	    fprintf(gppsfile, "  0 %d V\n", (corner[1].y - corner[0].y));
+	    fprintf(gppsfile, "  %d 0 V\n", -(corner[1].x - corner[0].x));
+	    fprintf(gppsfile, "  %d %d L\n", corner[0].x, corner[0].y);
+	    fprintf(gppsfile, "  40 -110 R\n"
+		    "  (PS level 2 image) Lshow\n"
+		    "  %% Read data but ignore it\n"
+		    "  /imagebuf %d string def\n"
+		    "  currentfile imagebuf readstring\n", num_encoded_bytes);
+	    fputs("} {\n", gppsfile);
+	}
+	fputs("gsave\n", gppsfile);
+	fprintf(gppsfile, "%d %d translate\n", corner[0].x, corner[0].y);
+	fprintf(gppsfile, "%d %d scale\n", (corner[1].x - corner[0].x), (corner[1].y - corner[0].y));
+	fputs("%%%%BeginPalette\n", gppsfile);
+	fprintf(gppsfile, "[ /Indexed\n  /DeviceRGB %d\n  <", (max_colors-1));
+
+#define TUPLES_PER_LINE 8
+
+	for (allocated = 0, i_tuple = 0; allocated < max_colors; allocated++, i_tuple--) {
+	    double gray = (double) allocated * fact;
+	    rgb255_color color;
+	    rgb255maxcolors_from_gray( gray, &color );
+	    if (!i_tuple) { fprintf(gppsfile,"\n  "); i_tuple = TUPLES_PER_LINE; }
+	    fprintf(gppsfile," %2.2x%2.2x%2.2x", (int)color.r, (int)color.g, (int)color.b);
+	}
+
+	fputs("\n  >\n] setcolorspace\n", gppsfile);
+	fputs("%%%%EndPalette\n", gppsfile);
+	fprintf(gppsfile, "<<\n  /ImageType 1\n  /Width %d\n  /Height %d\n", M, N);
+	fprintf(gppsfile, "  /BitsPerComponent %d\n  /ImageMatrix [ %d 0 0 %d 0 0 ]\n", bits_per_component, M, N);
+	fprintf(gppsfile, "  /Decode [ 0 %d ]\n", ((1<<bits_per_component)-1));
+	if (ps_params->level1) {
+	    fprintf(gppsfile, "  /imagebuf %d string def\n", (M*N*bits_per_component + 7)/8);
+	    fputs("  /DataSource {currentfile imagebuf readhexstring pop}\n", gppsfile);
+	} else {
+	    fputs("  /DataSource currentfile /ASCII85Decode filter\n", gppsfile);
+	}
+	fputs("  /MultipleDataSources false\n", gppsfile);
+	fputs("  /Interpolate false\n"
+	      ">>\n"
+	      "image\n", gppsfile);
+	if (!ps_params->level1)
+	    fputs("} ifelse\n", gppsfile);
+
+    }
+
+    /* Send encoded image to file. */
+    {
+    char *encoded_image_ptr;
+    for (i_tmp=0, encoded_image_ptr = encoded_image; i_tmp < num_encoded_bytes; i_tmp++)
+	fputc(*encoded_image_ptr++, gppsfile);
+    }
+
+    if (ps_params->level1)
+	fputs("\ngrestore\n", gppsfile);
+    else
+	fputs("\nInterpretLevel1 not {\n"
+	      "  grestore\n"
+	      "} if\n", gppsfile);
+    fputs("grestore\n", gppsfile);
+    fputs("%%%%EndImage\n", gppsfile);
+
+    free(encoded_image);
+
+    return;
+}
+
+
+/* First look for the GNUPLOT_PS_DIR environment variable
+ * If unsuccessful, look for hardcoded absolute path on UNIX,
+ * or hardcoded relative path on Windows and OS2,
+ * or files included at compile time. */
+static FILE *
+PS_open_prologue_file(char *name)
+{
+    char *fullname;
+    char *ps_prologue_dir;
+    FILE *prologue_fd;
+
+    if ((ps_prologue_dir = getenv("GNUPLOT_PS_DIR")) == NULL) {
+#ifdef GNUPLOT_PS_DIR
+# if defined(_Windows)
+	/* retrieve prologues path relatively to gnuplot executable,
+	 * whose path is in szModuleName (winmain.c) */
+	ps_prologue_dir = gp_alloc(strlen((char*) szPackageDir)
+			+ strlen(GNUPLOT_PS_DIR) + 2, "Prolog path");
+	strcpy(ps_prologue_dir, (char*) szPackageDir);
+	strcat(ps_prologue_dir, "\\");
+	/* GNUPLOT_PS_DIR is _relative_ path */
+	strcat(ps_prologue_dir, GNUPLOT_PS_DIR);
+# elif defined(OS2)
+	const ULONG bufsiz = 1024;
+	CHAR exepath[bufsiz];
+	PPIB ppib;
+	ULONG rc;
+	
+	rc = DosGetInfoBlocks(NULL, &ppib);
+	if (!rc)
+		rc = DosQueryModuleName(ppib->pib_hmte, bufsiz, (PCHAR) &exepath);
+	if (!rc) {
+	    char *p = strrchr(exepath, '\\');
+	    *(++p) = '\0';
+	    ps_prologue_dir = gp_alloc(strlen(exepath) + strlen(GNUPLOT_PS_DIR) + 2,
+			"Prolog path");
+	    strcpy(ps_prologue_dir, exepath);
+	    strcat(ps_prologue_dir, "\\");
+	    /* GNUPLOT_PS_DIR is _relative_ path */
+	    strcat(ps_prologue_dir, GNUPLOT_PS_DIR);
+	}
+	else {
+	    ps_prologue_dir = gp_alloc(1, "Prolog path");
+	    /* unsucessful to retrieve executable path */
+	    strcpy(ps_prologue_dir,"");
+	}
+# else /* !_Windows && !OS2 */
+	/* use hardcoded _absolute_ path */
+	ps_prologue_dir = GNUPLOT_PS_DIR;
+# endif
+#else /* using headers included at compile time */
+	const char **dump = NULL;
+	int i;
+
+	/* load from included header */
+	if (!strcmp(name,"8859-15.ps"))
+		dump = prologue_8859_15_ps;
+	else if (!strcmp(name,"8859-1.ps"))
+		dump = prologue_8859_1_ps;
+	else if (!strcmp(name,"8859-2.ps"))
+		dump = prologue_8859_2_ps;
+	else if (!strcmp(name,"8859-9.ps"))
+		dump = prologue_8859_9_ps;
+	else if (!strcmp(name,"cp1250.ps"))
+		dump = prologue_cp1250_ps;
+	else if (!strcmp(name,"cp437.ps"))
+		dump = prologue_cp437_ps;
+	else if (!strcmp(name,"cp850.ps"))
+		dump = prologue_cp850_ps;
+	else if (!strcmp(name,"cp852.ps"))
+		dump = prologue_cp852_ps;
+	else if (!strcmp(name,"koi8r.ps"))
+		dump = prologue_koi8r_ps;
+	else if (!strcmp(name,"koi8u.ps"))
+		dump = prologue_koi8u_ps;
+	else if (!strcmp(name,"utf-8.ps"))
+		dump = prologue_utf_8_ps;
+	else if (!strcmp(name,"prologue.ps"))
+		dump = prologue_prologue_ps;
+	else
+		int_warn(NO_CARET,"Requested Postscript prologue %s not found",name);
+
+	if (dump) {
+		for (i = 0; dump[i] != NULL; ++i)
+		fprintf(gppsfile, "%s", dump[i]);
+	}
+	return NULL;
+#endif /* GNUPLOT_PS_DIR */
+    }
+
+    fullname = gp_alloc(strlen(ps_prologue_dir) + strlen(name) + 4,"Prolog name");
+    strcpy(fullname,ps_prologue_dir);
+#if defined(_Windows) || defined(OS2)
+    if (fullname[strlen(fullname)-1] != '\\')
+	strcat(fullname,"\\");
+#elif !defined(VMS)
+    if (fullname[strlen(fullname)-1] != '/')
+	strcat(fullname,"/");
+#endif
+    strcat(fullname,name);
+    prologue_fd = fopen(fullname,"r");
+#if defined(_Windows) || defined(OS2)
+    if (getenv("GNUPLOT_PS_DIR") == NULL)
+	free(ps_prologue_dir);
+#endif
+    if (!prologue_fd)
+	prologue_fd = loadpath_fopen(name,"r");
+    if (!prologue_fd) {
+	fprintf(stderr,"Can't find PostScript prologue file %s\n", fullname);
+	loadpath_handler(ACTION_SHOW,NULL);
+	free(fullname);
+	fprintf(stderr,"Please copy %s to one of the above directories\n",name);
+	fprintf(stderr,"or set the loadpath appropriately\n");
+	fprintf(stderr,"or set the environmental variable GNUPLOT_PS_DIR\n");
+	int_error(NO_CARET,"Plot failed!");
+    }
+    free(fullname);
+    return prologue_fd;
+}
+    
+static void
+PS_dump_prologue_file(char *name)
+{
+    char buf[256];
+    FILE *prologue_fd = PS_open_prologue_file(name);
+
+    if (prologue_fd) {
+	while (fgets(buf, sizeof(buf), prologue_fd))
+	    fputs(buf, gppsfile);
+	fclose(prologue_fd);
+    }
+}
+
+static void
+PS_load_glyphlist()
+{
+    char buf[256];
+    char *next = NULL;
+    unsigned int code;
+    int  len;
+    char glyph_name[32];
+    FILE *prologue_fd = PS_open_prologue_file("aglfn.txt");
+    
+    if (!prologue_fd)
+	return;
+
+    while (fgets(buf, sizeof(buf), prologue_fd)) {
+	if (*buf == '#' || *buf == '\n')
+	    continue;
+	code = strtol(buf,&next,16);
+
+	/* User control over whether Adobe glyph names are used for unicode   */
+	/* entries above 0x0100.  I.e. when we see a UTF-8 alpha, do we write */
+	/* /alpha rather than /uni03B1?   Some fonts want one or the other.   */
+	/* This is controlled by 'set term post adobeglyphnames'.             */
+	if (code >= 0x0100 && !ps_params->adobeglyphnames)
+	    continue;
+	
+	next++;
+	len = strchr(next,';') - next;
+	strncpy(glyph_name, next, len);
+	glyph_name[len] = '\0';
+	FPRINTF((stderr, "%04X   %s\n", code, glyph_name));
+	if (aglist_size + sizeof(ps_glyph) > aglist_alloc) {
+	    aglist_alloc += 2048;
+	    aglist = gp_realloc(aglist, aglist_alloc, "aglist");
+	}
+	aglist[psglyphs].unicode = code;
+	aglist[psglyphs].glyphname = gp_strdup(glyph_name);
+	aglist_size += sizeof(ps_glyph);
+	psglyphs++;
+    }
+
+    fclose(prologue_fd);
+}
+
+TERM_PUBLIC void
+PS_path(int p)
+{
+    switch (p) {
+	case 0:	/* Start new path */
+		PS_FLUSH_PATH;
+		PS_newpath = TRUE;
+		break;
+
+	case 1: /* Close path */
+		fprintf(gppsfile, "Z ");
+		PS_FLUSH_PATH;
+		break;
+    }
+
+}
+
+TERM_PUBLIC void
+PS_layer(t_termlayer syncpoint)
+{
+    static int plotno = 0;
+
+    /* We must ignore all syncpoints that we don't recognize */
+    switch (syncpoint) {
+
+	default:
+		break;
+	
+	case TERM_LAYER_BEFORE_PLOT:
+		fprintf(gppsfile, "%% Begin plot #%d\n", ++plotno);
+		break;
+	
+	case TERM_LAYER_AFTER_PLOT:
+		fprintf(gppsfile, "%% End plot #%d\n", plotno);
+		break;
+	
+	case TERM_LAYER_RESET:
+		plotno = 0;
+		break;
+
+    }
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(post_driver)
+    "postscript",
+    "PostScript graphics, including EPSF embedded files (*.eps)",
+    PS_XMAX, PS_YMAX, PS_VCHAR, PS_HCHAR, 
+    PS_VTIC, PS_HTIC, PS_options, PS_init, PS_reset, 
+    PS_text, null_scale, PS_graphics, PS_move, PS_vector, 
+    PS_linetype, PS_put_text, PS_text_angle, 
+    PS_justify_text, PS_point, PS_arrow, PS_set_font, PS_pointsize,
+    TERM_BINARY|TERM_IS_POSTSCRIPT|TERM_CAN_CLIP|TERM_CAN_DASH|TERM_MONOCHROME|TERM_LINEWIDTH, 
+    0 /*suspend*/, 0 /*resume*/, PS_fillbox, PS_linewidth
+#ifdef USE_MOUSE
+    , 0, 0, 0, 0, 0 /* no mouse support for postscript */
+#endif
+    , PS_make_palette,
+    PS_previous_palette, /* write grestore */
+    PS_set_color,
+    PS_filled_polygon
+    , PS_image
+    , ENHPS_OPEN, ENHPS_FLUSH, ENHPS_WRITEC
+    , PS_layer		/* used only to insert comments */
+    , PS_path
+    , PS_SC		/* terminal to pixel coord scale factor */
+TERM_TABLE_END(post_driver)
+
+#undef LAST_TERM
+#define LAST_TERM post_driver
+
+#endif /* TERM_TABLE */
+
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+/* This is a pseudo help section that is labeled with 00psglobal to be
+ * sure that it is sorted in before `post', `epslatex', and `pslatex'.
+ * This section just defines commonly used text snippets for all three
+ * help sections defined in this file. Defining PS_COMMON_OPTS1,
+ * PS_COMMON_OPTS2, and PS_COMMON_DOC1 outside START_HELP()...END_HELP()
+ * does not work.
+ * The last line before the END_HELP(00psglobal) contains one single line
+ * of "text" that is necessary to avoid errors.
+ */
+START_HELP(00psglobal)
+#define PS_COMMON_OPTS1 \
+"                               {level1 | leveldefault}",\
+"                               {color | colour | monochrome}",\
+"                               {solid | dashed}",\
+"                               {dashlength | dl <DL>}",\
+"                               {linewidth | lw <LW>}",\
+"                               {rounded | butt}",\
+"                               {clip | noclip}",\
+"                               {palfuncparam <samples>{,<maxdeviation>}}",\
+"                               {size <XX>{unit},<YY>{unit}}",
+#define PS_COMMON_OPTS2 \
+"                               {blacktext | colortext | colourtext}",\
+"                               {{font} \"fontname{,fontsize}\" {<fontsize>}}",
+#define PS_COMMON_PROLOG_INFO \
+" If you see the error message",\
+"       \"Can't find PostScript prologue file ... \"",\
+" Please see and follow the instructions in `postscript prologue`.",\
+"",
+#define PS_COMMON_DOC1 \
+" The option `color` enables color, while `monochrome` prefers black and white",\
+" drawing elements. Further, `monochrome` uses gray `palette` but it does not",\
+" change color of objects specified with an explicit `colorspec`."\
+"",\
+" `solid` draws all plots with solid lines, overriding any dashed patterns.",\
+" `dashlength` or `dl` scales the length of the dashed-line segments by <DL>,",\
+" which is a floating-point number greater than zero.",\
+" `linewidth` or `lw` scales all linewidths by <LW>.",\
+"",\
+" By default the generated PostScript code uses language features that were",\
+" introduced in PostScript Level 2, notably filters and pattern-fill of",\
+" irregular objects such as filledcurves.  PostScript Level 2 features are",\
+" conditionally protected so that PostScript Level 1 interpreters do not issue",\
+" errors but, rather, display a message or a PostScript Level 1 approximation.",\
+" The `level1` option substitutes PostScript Level 1 approximations of these",\
+" features and uses no PostScript Level 2 code.  This may be required by some",\
+" old printers and old versions of Adobe Illustrator.  The flag `level1` can be", \
+" toggled later by editing a single line in the PostScript output file to force",\
+" PostScript Level 1 interpretation.  In the case of files containing level 2",\
+" code, the above features will not appear or will be replaced by a note when",\
+" this flag is set or when the interpreting program does not indicate that it",\
+" understands level 2 PostScript or higher.",\
+"",\
+" `rounded` sets line caps and line joins to be rounded; `butt` is the",\
+" default, butt caps and mitered joins.",\
+"",\
+" `clip` tells PostScript to clip all output to the bounding box;",\
+" `noclip` is the default.",\
+"",\
+" `palfuncparam` controls how `set palette functions` are encoded as gradients",\
+" in the output. Analytic color component functions (set via",\
+" `set palette functions`) are encoded as linear interpolated gradients in the",\
+" postscript output:  The color component functions are sampled at <samples>",\
+" points and all points are removed from this gradient which can be removed",\
+" without changing the resulting colors by more than <maxdeviation>. For",\
+" almost every useful palette you may savely leave the defaults of",\
+" <samples>=2000 and <maxdeviation>=0.003 untouched.",\
+"",\
+" The default size for postscript output is 10 inches x 7 inches. The default",\
+" for eps output is 5 x 3.5 inches.  The `size` option changes this to",\
+" whatever the user requests. By default the X and Y sizes are taken to be in",\
+" inches, but other units are possibly (currently only cm). The BoundingBox",\
+" of the plot is correctly adjusted to contain the resized image.",\
+" Screen coordinates always run from 0.0 to 1.0 along the full length of the",\
+" plot edges as specified by the `size` option.",\
+" NB: `this is a change from the previously recommended method of using the",\
+" set size command prior to setting the terminal type`.  The old method left",\
+" the BoundingBox unchanged and screen coordinates did not correspond to the",\
+" actual limits of the plot.",\
+"",
+""
+END_HELP(00psglobal)
+
+START_HELP(epslatex)
+"1 epslatex",
+"?commands set terminal epslatex",
+"?set terminal epslatex",
+"?set term epslatex",
+"?terminal epslatex",
+"?term epslatex",
+"?epslatex",
+" The `epslatex` driver generates output for further processing by LaTeX.",
+"",
+" Syntax:",
+"       set terminal epslatex   {default}",
+"       set terminal epslatex   {standalone | input}",
+"                               {oldstyle | newstyle}",
+PS_COMMON_OPTS1
+"                               {header <header> | noheader}",
+PS_COMMON_OPTS2
+"",
+" The epslatex terminal prints a plot as `terminal postscript eps`",
+" but transfers the texts to LaTeX instead of including in the PostScript",
+" code. Thus, many options are the same as in the `postscript terminal`.",
+"",
+" The appearance of the epslatex terminal changed between versions 4.0 and 4.2",
+" to reach better consistency with the postscript terminal:",
+" The plot size has been changed from 5 x 3 inches to 5 x 3.5 inches;",
+" the character width is now estimated to be 60% of the font size",
+" while the old epslatex terminal used 50%;  now, the larger number of",
+" postscript linetypes and symbols are used.  To reach an appearance that is",
+" nearly identical to the old one specify the option `oldstyle`. (In fact",
+" some small differences remain: the symbol sizes are slightly different, the",
+" tics are half as large as in the old terminal which can be changed using",
+" `set tics scale`, and the arrows have all features as in the postscript",
+" terminal.)",
+"",
+PS_COMMON_PROLOG_INFO
+PS_COMMON_DOC1
+" `blacktext` forces all text to be written in black even in color mode;",
+"",
+" The epslatex driver offers a special way of controlling text positioning:",
+" (a) If any text string begins with '{', you also need to include a '}' at the",
+" end of the text, and the whole text will be centered both horizontally",
+" and vertically by LaTeX.  (b) If the text string begins with '[', you need",
+" to continue it with: a position specification (up to two out of t,b,l,r,c),",
+" ']{', the text itself, and finally, '}'. The text itself may be anything",
+" LaTeX can typeset as an LR-box. \\rule{}{}'s may help for best positioning.",
+" See also the documentation for the `pslatex` terminal driver.",
+" To create multiline labels, use \\shortstack, for example",
+"    set ylabel '[r]{\\shortstack{first line \\\\ second line}}' ",
+"",
+" The `back` option of `set label` commands is handled slightly different",
+" than in other terminals. Labels using 'back' are printed behind all other",
+" elements of the plot while labels using 'front' are printed above ",
+" everything else.",
+"",
+" The driver produces two different files, one for the eps part of the figure",
+" and one for the LaTeX part. The name of the LaTeX file is taken from the",
+" `set output` command. The name of the eps file is derived by replacing",
+" the file extension (normally `.tex`) with `.eps` instead.  There is no",
+" LaTeX output if no output file is given!  Remember to close the",
+" `output file` before next plot unless in `multiplot` mode.",
+"",
+" In your LaTeX documents use '\\input{filename}' to include the figure.",
+" The `.eps` file is included by the command \\includegraphics{...}, so you",
+" must also include \\usepackage{graphicx} in the LaTeX preamble.  If you",
+" want to use coloured text (option `textcolour`) you also have to include",
+" \\usepackage{color} in the LaTeX preamble.",
+"",
+" Pdf files can be made from the eps file using 'epstopdf'. If the graphics",
+" package is properly configured, the LaTeX files can also be processed by",
+" pdflatex without changes, using the pdf files instead of the eps files."
+"",
+" The behaviour concerning font selection depends on the header mode.",
+" In all cases, the given font size is used for the calculation of proper",
+" spacing. When not using the `standalone` mode the actual LaTeX font and",
+" font size at the point of inclusion is taken, so use LaTeX commands for",
+" changing fonts. If you use e.g. 12pt as font size for your LaTeX",
+" document, use '\"\" 12' as options. The font name is ignored. If using",
+" `standalone` the given font and font size are used, see below for a",
+" detailed description.",
+"",
+" If text is printed coloured is controlled by the TeX booleans \\ifGPcolor",
+" and \\ifGPblacktext. Only if \\ifGPcolor is true and \\ifGPblacktext is",
+" false, text is printed coloured. You may either change them in the",
+" generated TeX file or provide them globally in your TeX file, for example",
+" by using",
+"    \\newif\\ifGPblacktext",
+"    \\GPblacktexttrue",
+" in the preamble of your document. The local assignment is only done if no",
+" global value is given.",
+"",
+" When using the epslatex terminal give the name of the TeX file in the",
+" `set output` command including the file extension (normally \".tex\").",
+" The eps filename is generated by replacing the extension by \".eps\".",
+"",
+" If using the `standalone` mode a complete LaTeX header is added to the",
+" LaTeX file; and \"-inc\" is added to the filename of the eps file.",
+" The `standalone` mode generates a TeX file that produces",
+" output with the correct size when using dvips, pdfTeX, or VTeX.",
+" The default, `input`, generates a file that has to be included into a",
+" LaTeX document using the \\input command.",
+"",
+" If a font other than \"\" or \"default\" is given it is interpreted as",
+" LaTeX font name.  It contains up to three parts, separated by a comma:",
+" 'fontname,fontseries,fontshape'.  If the default fontshape or fontseries",
+" are requested, they can be omitted.  Thus, the real syntax for the fontname",
+" is '[fontname][,fontseries][,fontshape]'.  The naming convention for all",
+" parts is given by the LaTeX font scheme.  The fontname is 3 to 4 characters",
+" long and is built as follows: One character for the font vendor, two",
+" characters for the name of the font, and optionally one additional",
+" character for special fonts, e.g., 'j' for fonts with old-style numerals",
+" or 'x' for expert fonts. The names of many fonts is described in",
+"^ <a href=\"http://www.tug.org/fontname/fontname.pdf\">",
+"           http://www.tug.org/fontname/fontname.pdf",
+"^ </a>",
+" For example, 'cmr' stands for Computer Modern Roman, 'ptm' for Times-Roman,",
+" and 'phv' for Helvetica.  The font series denotes the thickness of the",
+" glyphs, in most cases 'm' for normal (\"medium\") and 'bx' or 'b' for bold",
+" fonts.  The font shape is 'n' for upright, 'it' for italics, 'sl' for",
+" slanted, or 'sc' for small caps, in general.  Some fonts may provide",
+" different font series or shapes.",
+"",
+" Examples:",
+"",
+" Use Times-Roman boldface (with the same shape as in the surrounding text):",
+"       set terminal epslatex 'ptm,bx'",
+" Use Helvetica, boldface, italics:",
+"       set terminal epslatex 'phv,bx,it'",
+" Continue to use the surrounding font in slanted shape:",
+"       set terminal epslatex ',,sl'",
+" Use small capitals:",
+"       set terminal epslatex ',,sc'",
+"",
+" By this method, only text fonts are changed. If you also want to change",
+" the math fonts you have to use the \"gnuplot.cfg\" file or the `header`",
+" option, described below.",
+"",
+" In standalone mode, the font size is taken from the given font size in the",
+" `set terminal` command. To be able to use a specified font size, a file",
+" \"size<size>.clo\" has to reside in the LaTeX search path.  By default,",
+" 10pt, 11pt, and 12pt are supported.  If the package \"extsizes\" is",
+" installed, 8pt, 9pt, 14pt, 17pt, and 20pt are added.",
+"",
+" The `header` option takes a string as argument.  This string is written",
+" into the generated LaTeX file.  If using the `standalone` mode, it is ",
+" written into the preamble, directly before the \\begin{document} command.",
+" In the `input` mode, it is placed directly after the \\begingroup command",
+" to ensure that all settings are local to the plot.",
+"",
+" Examples:",
+"",
+" Use T1 fontencoding, change the text and math font to Times-Roman as well",
+" as the sans-serif font to Helvetica:",
+"     set terminal epslatex standalone header \\",
+"     \"\\\\usepackage[T1]{fontenc}\\n\\\\usepackage{mathptmx}\\n\\\\usepackage{helvet}\"",
+" Use a boldface font in the plot, not influencing the text outside the plot:",
+"     set terminal epslatex input header \"\\\\bfseries\"",
+"",
+" If the file \"gnuplot.cfg\" is found by LaTeX it is input in the preamble",
+" the LaTeX document, when using `standalone` mode.  It can be used for",
+" further settings, e.g., changing the document font to Times-Roman,",
+" Helvetica, and Courier, including math fonts (handled by \"mathptmx.sty\"):",
+"       \\usepackage{mathptmx}",
+"       \\usepackage[scaled=0.92]{helvet}",
+"       \\usepackage{courier}",
+" The file \"gnuplot.cfg\" is loaded before the header information given",
+" by the `header` command.  Thus, you can use `header` to overwrite some of",
+" settings performed using \"gnuplot.cfg\"",
+""
+END_HELP(epslatex)
+
+START_HELP(pslatex)
+"1 pslatex and pstex",
+"?commands set terminal pslatex",
+"?set terminal pslatex",
+"?set term pslatex",
+"?terminal pslatex",
+"?term pslatex",
+"?pslatex",
+"?commands set terminal pstex",
+"?set terminal pstex",
+"?set term pstex",
+"?terminal pstex",
+"?term pstex",
+"?pstex",
+" The `pslatex` driver generates output for further processing by LaTeX,",
+" while the `pstex` driver generates output for further processing by",
+" TeX. `pslatex` uses \\specials understandable by dvips and xdvi. Figures",
+" generated by `pstex` can be included in any plain-based format (including",
+" LaTeX).",
+"",
+" Syntax:",
+"       set terminal [pslatex | pstex] {default}",
+"       set terminal [pslatex | pstex]",
+"                               {rotate | norotate}",
+"                               {oldstyle | newstyle}",
+"                               {auxfile | noauxfile}",
+PS_COMMON_OPTS1
+"                               {<font_size>}",
+"",
+PS_COMMON_PROLOG_INFO
+PS_COMMON_DOC1
+" if `rotate` is specified, the y-axis label is rotated.",
+" <font_size> is the size (in pts) of the desired font.",
+"",
+" If `auxfile` is specified, it directs the driver to put the PostScript",
+" commands into an auxiliary file instead of directly into the LaTeX file.",
+" This is useful if your pictures are large enough that dvips cannot handle",
+" them.  The name of the auxiliary PostScript file is derived from the name of",
+" the TeX file given on the `set output` command; it is determined by replacing",
+" the trailing `.tex` (actually just the final extent in the file name) with",
+" `.ps` in the output file name, or, if the TeX file has no extension, `.ps`",
+" is appended.  The `.ps` is included into the `.tex` file by a",
+" \\special{psfile=...} command.  Remember to close the `output file` before",
+" next plot unless in `multiplot` mode.",
+"",
+" Gnuplot versions prior to version 4.2 generated plots of the size",
+" 5 x 3 inches using the ps(la)tex terminal while the current version generates",
+" 5 x 3.5 inches to be consistent with the postscript eps terminal.  In",
+" addition, the character width is now estimated to be 60% of the font size",
+" while the old epslatex terminal used 50%. To reach the old format specify",
+" the option `oldstyle`.",
+"",
+" The pslatex driver offers a special way of controlling text positioning: ",
+" (a) If any text string begins with '{', you also need to include a '}' at the",
+" end of the text, and the whole text will be centered both horizontally",
+" and vertically by LaTeX.  (b) If the text string begins with '[', you need",
+" to continue it with: a position specification (up to two out of t,b,l,r),",
+" ']{', the text itself, and finally, '}'. The text itself may be anything",
+" LaTeX can typeset as an LR-box. \\rule{}{}'s may help for best positioning.",
+"",
+" The options not described here are identical to the `Postscript terminal`.",
+" Look there if you want to know what they do.",
+"",
+" Examples:",
+"       set term pslatex monochrome dashed rotate       # set to defaults",
+" To write the PostScript commands into the file \"foo.ps\":",
+"       set term pslatex auxfile",
+"       set output \"foo.tex\"; plot ...; set output",
+" About label positioning:",
+" Use gnuplot defaults (mostly sensible, but sometimes not really best):",
+"        set title '\\LaTeX\\ -- $ \\gamma $'",
+" Force centering both horizontally and vertically:",
+"        set label '{\\LaTeX\\ -- $ \\gamma $}' at 0,0",
+" Specify own positioning (top here):",
+"        set xlabel '[t]{\\LaTeX\\ -- $ \\gamma $}'",
+" The other label -- account for long ticlabels:",
+"        set ylabel '[r]{\\LaTeX\\ -- $ \\gamma $\\rule{7mm}{0pt}}'",
+"",
+" Linewidths and pointsizes may be changed with `set style line`."
+""
+END_HELP(pslatex)
+
+START_HELP(post)
+"1 postscript",
+"?commands set terminal postscript",
+"?set terminal postscript",
+"?set term postscript",
+"?terminal postscript",
+"?term postscript",
+"?postscript",
+" Several options may be set in the `postscript` driver.",
+"",
+" Syntax:",
+"       set terminal postscript {default}",
+"       set terminal postscript {landscape | portrait | eps}",
+"                               {enhanced | noenhanced}",
+"                               {defaultplex | simplex | duplex}",
+"                               {fontfile [add | delete] \"<filename>\"",
+"                                | nofontfiles} {{no}adobeglyphnames}",
+PS_COMMON_OPTS1
+PS_COMMON_OPTS2
+PS_COMMON_PROLOG_INFO
+"",
+" `landscape` and `portrait` choose the plot orientation.",
+" `eps` mode generates EPS (Encapsulated PostScript) output, which is just",
+" regular PostScript with some additional lines that allow the file to be",
+" imported into a variety of other applications.  (The added lines are",
+" PostScript comment lines, so the file may still be printed by itself.)  To",
+" get EPS output, use the `eps` mode and make only one plot per file.  In `eps`",
+" mode the whole plot, including the fonts, is reduced to half of the default",
+" size.",
+"",
+" `enhanced` enables enhanced text mode features (subscripts,",
+" superscripts and mixed fonts). See `enhanced` for more information.",
+" `blacktext` forces all text to be written in black even in color mode;",
+"",
+" Duplexing in PostScript is the ability of the printer to print on both",
+" sides of the same sheet of paper.  With `defaultplex`, the default setting",
+" of the printer is used; with `simplex` only one side is printed; `duplex`",
+" prints on both sides (ignored if your printer can't do it).",
+"",
+" `\"<fontname>\"` is the name of a valid PostScript font; and `<fontsize>` is",
+" the size of the font in PostScript points.",
+" In addition to the standard postscript fonts, an oblique version of the",
+" Symbol font, useful for mathematics, is defined. It is called",
+" \"Symbol-Oblique\".",
+"",
+" `default` sets all options to their defaults: `landscape`, `monochrome`,",
+" `dashed`, `dl 1.0`, `lw 1.0`, `defaultplex`, `noenhanced`, \"Helvetica\" and",
+" 14pt.  Default size of a PostScript plot is 10 inches wide and 7 inches high.",
+PS_COMMON_DOC1
+" Fonts listed by `fontfile` or `fontfile add` encapsulate the font",
+" definitions of the listed font from a postscript Type 1 or TrueType font",
+" file directly into the gnuplot output postscript file.  Thus, the enclosed",
+" font can be used in labels, titles, etc.  See the section",
+" `postscript fontfile` for more details.  With `fontfile delete`, a fontfile",
+" is deleted from the list of embedded files.  `nofontfiles` cleans the list",
+" of embedded fonts.",
+"",
+" Examples:",
+"       set terminal postscript default       # old postscript",
+"       set terminal postscript enhanced      # old enhpost",
+"       set terminal postscript landscape 22  # old psbig",
+"       set terminal postscript eps 14        # old epsf1",
+"       set terminal postscript eps 22        # old epsf2",
+"       set size 0.7,1.4; set term post portrait color \"Times-Roman\" 14",
+"       set term post \"VAGRoundedBT_Regular\" 14 fontfile \"bvrr8a.pfa\"",
+"",
+" Linewidths and pointsizes may be changed with `set style line`.",
+"",
+" The `postscript` driver supports about 70 distinct pointtypes, selectable",
+" through the `pointtype` option on `plot` and `set style line`.",
+"",
+" Several possibly useful files about `gnuplot`'s PostScript are included",
+" in the /docs/psdoc subdirectory of the `gnuplot` distribution and at the",
+" distribution sites.  These are \"ps_symbols.gpi\" (a `gnuplot` command file",
+" that, when executed, creates the file \"ps_symbols.ps\" which shows all the",
+" symbols available through the `postscript` terminal), \"ps_guide.ps\" (a",
+" PostScript file that contains a summary of the enhanced syntax and a page",
+" showing what the octal codes produce with text and symbol fonts),",
+" \"ps_file.doc\" (a text file that contains a discussion of the organization",
+" of a PostScript file written by `gnuplot`), and \"ps_fontfile_doc.tex\"",
+" (a LaTeX file which contains a short documentation concerning the",
+" encapsulation of LaTeX fonts with a glyph table of the math fonts).",
+"",
+" A PostScript file is editable, so once `gnuplot` has created one, you are",
+" free to modify it to your heart's desire.  See the `editing postscript`",
+" section for some hints.",
+"2 editing postscript",
+"?commands set terminal postscript editing",
+"?set terminal postscript editing",
+"?set term postscript editing",
+"?terminal postscript editing",
+"?term postscript editing",
+"?editing_postscript",
+"?editing postscript",
+" The PostScript language is a very complex language---far too complex to",
+" describe in any detail in this document.  Nevertheless there are some things",
+" in a PostScript file written by `gnuplot` that can be changed without risk of",
+" introducing fatal errors into the file.",
+"",
+" For example, the PostScript statement \"/Color true def\" (written into the",
+" file in response to the command `set terminal postscript color`), may be",
+" altered in an obvious way to generate a black-and-white version of a plot.",
+" Similarly line colors, text colors, line weights and symbol sizes can also be",
+" altered in straight-forward ways.  Text (titles and labels) can be edited to",
+" correct misspellings or to change fonts.  Anything can be repositioned, and",
+" of course anything can be added or deleted, but modifications such as these",
+" may require deeper knowledge of the PostScript language.",
+"",
+" The organization of a PostScript file written by `gnuplot` is discussed in",
+" the text file \"ps_file.doc\" in the docs/ps subdirectory of the gnuplot",
+" source distribution.",
+"2 postscript fontfile",
+"?commands set terminal postscript fontfile",
+"?set terminal postscript fontfile",
+"?set term postscript fontfile",
+"?terminal postscript fontfile",
+"?term postscript fontfile",
+"?postscript fontfile",
+"?fontfile",
+" The `fontfile` or `fontfile add` option takes one file name as argument",
+" and encapsulates this file into the postscript output in order to make",
+" this font available for text elements (labels, tic marks, titles, etc.).",
+" The `fontfile delete` option also takes one file name as argument. It",
+" deletes this file name from the list of encapsulated files.",
+"",
+" The postscript terminal understands some",
+" font file formats: Type 1 fonts in ASCII file format (extension \".pfa\"),",
+" Type 1 fonts in binary file format (extension \".pfb\"), and TrueType",
+" fonts (extension \".ttf\"). Pfa files are understood directly, pfb and ttf",
+" files are converted on the fly if appropriate conversion tools are",
+" installed (see below). You have to specify the full filename including the",
+" extension. Each `fontfile` option takes exact one font file name. This",
+" option can be used multiple times in order to include more than one font",
+" file.",
+"",
+" The font file is searched in the working directory and in all directories",
+" listed in the fontpath which is determined by `set fontpath`.",
+" In addition, the fontpath can be set using the environment variable",
+" GNUPLOT_FONTPATH. If this is not set a system dependent default search",
+" list is used. See `set fontpath` for more details.",
+"",
+" For using the encapsulated font file you have to specify the font name",
+" (which normally is not the same as the file name). When embedding a",
+" font file by using the `fontfile` option in interactive mode, the ",
+" font name is printed on the screen. E.g.",
+"    Font file 'p052004l.pfb' contains the font 'URWPalladioL-Bold'. Location:",
+"    /usr/lib/X11/fonts/URW/p052004l.pfb",
+"",
+" When using pfa or pfb fonts, you can also find it out by looking into the",
+" font file. There is a line similar to \"/FontName /URWPalladioL-Bold def\".",
+" The middle string without the slash is the fontname, here",
+" \"URWPalladioL-Bold\".",
+" For TrueType fonts, this is not so easy since the font name is stored in a",
+" binary format. In addition, they often have spaces in the font names which",
+" is not supported by Type 1 fonts (in which a TrueType is converted on the",
+" fly). The font names are changed in order to eliminate the spaces in the",
+" fontnames. The easiest way to find out which font name is generated for",
+" use with gnuplot, start gnuplot in interactive mode and type in",
+" \"set terminal postscript fontfile '<filename.ttf>'\".",
+"",
+" For converting font files (either ttf or pfb) to pfa format, the conversion",
+" tool has to read the font from a file and write it to standard output. If",
+" the output cannot be written to standard output, on-the-fly conversion is",
+" not possible.",
+"",
+" For pfb files \"pfbtops\" is a tool which can do this. If this program",
+" is installed on your system the on the fly conversion should work.",
+" Just try to encapsulate a pfb file. If the compiled in program call does",
+" not work correctly you can specify how this program is called by",
+" defining the environment variable GNUPLOT_PFBTOPFA e.g. to",
+" \"pfbtops %s\". The `%s` will be replaced by the font file name and thus",
+" has to exist in the string.",
+"",
+" If you don't want to do the conversion on the fly but get a pfa file of",
+" the font you can use the tool \"pfb2pfa\" which is written in simple c",
+" and should compile with any c compiler.",
+" It is available from many ftp servers, e.g.",
+"^ <a href=\"ftp://ftp.dante.de/tex-archive/fonts/utilities/ps2mf/\">",
+"           ftp://ftp.dante.de/tex-archive/fonts/utilities/ps2mf/",
+"^ </a>",
+" In fact, \"pfbtopfa\" and \"pfb2ps\" do the same job. \"pfbtopfa\" puts",
+" the resulting pfa code into a file, whereas \"pfbtops\" writes it to",
+" standard output.",
+"",
+" TrueType fonts are converted into Type 1 pfa format, e.g.",
+" by using the tool \"ttf2pt1\" which is available from",
+"^ <a href=\"http://ttf2pt1.sourceforge.net/\">",
+"           http://ttf2pt1.sourceforge.net/",
+"^ </a>",
+" If the builtin conversion does not",
+" work, the conversion command can be changed by the environment variable",
+" GNUPLOT_TTFTOPFA. For usage with ttf2pt1 it may be set to",
+" \"ttf2pt1 -a -e -W 0 %s - \". Here again, `%s` stands for the",
+" file name.",
+"",
+" For special purposes you also can use a pipe (if available for your",
+" operating system). Therefore you start the file name definition with ",
+" the character \"<\" and append a program call. This program has ",
+" to write pfa data to standard output. Thus, a pfa file may be accessed",
+" by `set fontfile \"< cat garamond.pfa\"`.",
+"",
+" For example, including Type 1 font files can be used for including the",
+" postscript output in LaTeX documents. The \"european computer modern\"",
+" font (which is a variant of the \"computer modern\" font) is available",
+" in pfb format from any CTAN server, e.g.",
+"^ <a href=\"ftp://ftp.dante.de/tex-archive/fonts/ps-type1/cm-super/\">",
+"           ftp://ftp.dante.de/tex-archive/fonts/ps-type1/cm-super/",
+"^ </a>",
+" For example, the file \"sfrm1000.pfb\" contains the normal upright fonts",
+" with serifs in the design size 10pt (font name \"SFRM1000\").",
+" The computer modern fonts, which are still necessary for mathematics,",
+" are available from",
+"^ <a href=\"ftp://ftp.dante.de/tex-archive/fonts/cm/ps-type1/bluesky\">",
+"           ftp://ftp.dante.de/tex-archive/fonts/cm/ps-type1/bluesky",
+"^ </a>",
+" With these you can use any character available in TeX. However, the",
+" computer modern fonts have a strange encoding. (This is why you should not",
+" use cmr10.pfb for text, but sfrm1000.pfb instead.)",
+" The usage of TeX fonts is shown in one of the demos.",
+" The file \"ps_fontfile_doc.tex\" in the /docs/psdoc subdirectory of the",
+" `gnuplot` source distribution contains a table with glyphs of the TeX",
+" mathfonts.",
+"",
+" If the font \"CMEX10\" is embedded (file \"cmex10.pfb\") gnuplot defines",
+" the additional font \"CMEX10-Baseline\". It is shifted vertically in order",
+" to fit better to the other glyphs (CMEX10 has its baseline at the top of",
+" the symbols).",
+"2 postscript prologue",
+"?commands set terminal postscript prologue",
+"?set terminal postscript prologue",
+"?terminal postscript prologue",
+"?postscript prologue",
+"?prologue",
+" Each PostScript output file includes a %%Prolog section and possibly some",
+" additional user-defined sections containing, for example, character",
+" encodings. These sections are copied from a set of PostScript prologue files",
+" which are either compiled in the gnuplot executable or stored elsewhere on your",
+" computer. This behaviour and the default directory where these files live are",
+" controlled at the time gnuplot is built. However, you can control this",
+" either by defining an environment variable GNUPLOT_PS_DIR or by using the",
+" gnuplot command `set loadpath`. See `set loadpath`.",
+"2 postscript adobeglyphnames",
+"?commands set terminal postscript adobeglyphnames",
+"?set terminal postscript adobeglyphnames",
+"?terminal postscript adobeglyphnames",
+"?postscript adobeglyphnames",
+"?adobeglyphnames",
+"=UTF-8",
+" This setting is only relevant to PostScript output with UTF-8 encoding.",
+" It controls the names used to describe characters with Unicode entry points",
+" higher than 0x00FF.  That is, all characters outside of the Latin1 set.",
+" In general unicode characters do not have a unique name; they have only a",
+" unicode identification code.  However, Adobe have a recommended scheme for",
+" assigning names to certain ranges of characters (extended Latin, Greek, etc).",
+" Some fonts use this scheme, others do not.  By default, gnuplot will use",
+" the Adobe glyph names.  E.g. the lower case Greek letter alpha will be called",
+" /alpha.  If you specific `noadobeglyphnames` then instead gnuplot will use",
+" /uni03B1 to describe this character.  If you get this setting wrong, the",
+" character may not be found even if it is present in the font.",
+" It is probably always correct to use the default for Adobe fonts, but for",
+" other fonts you may have to try both settings.  See also `fontfile`.",
+"",
+""
+END_HELP(post)
+#endif /* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/pslatex.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/pslatex.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/pslatex.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/pslatex.trm.svn-base	2012-01-03 17:07:43.099747700 -0800
@@ -0,0 +1,1012 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: pslatex.trm,v 1.75 2009/05/11 17:55:20 sfeam Exp $
+ */
+
+/* GNUPLOT - pslatex.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This file supplies the terminal drivers:
+ *     pslatex  -- LaTeX with embedded postscript
+ *     pstex    -- plain TeX with embedded postscript
+ *     epslatex -- LaTeX using \includegraphics, postscript part in an 
+ *                 external file
+ *
+ * AUTHORS
+ *  George Phillips
+ *  Russell Lang
+ *  David Kotz
+ *
+ *  Petr Mikulik, May 2000: terminal entries for PM3D functionality
+ *
+ *  Dan Sebald, 5 March 2003: terminal entry for image functionality
+ *
+ *  Theo Hopman
+ *      23 May 2003:
+ *              - added epslatex support. Replaces epslatex.trm; pointtype
+ *              and linetypes for epslatex terminal are now identical to
+ *              those of pslatex terminal.
+ *              - added arbitrary text rotations to all [e]ps[la]tex
+ *              terminals.
+ *      27 May 2004:
+ *              - epslatex patch updated for gnuplot 4.0
+ *      
+ *  Harald Harders (h.harders@tu-bs.de), 2005-02-08:
+ *  - Merged functionality of postscript, pslatex, pstex, and
+ *    epslatex terminals. Therefore deleted epslatex.trm.
+ *  - Added a standalone mode to the epslatex mode for standalone use without
+ *    an additional LaTeX document.
+ *  - Fixed text rotation of ps(la)tex terminals.
+ *
+ * Send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(pslatex)
+register_term(pstex)
+register_term(epslatex)
+#endif
+
+#ifdef TERM_PROTO
+/* Common functions for epslatex and ps(la)tex */
+/* All these routines begin with PSLATEX_ */
+TERM_PUBLIC void PSLATEX_reset __PROTO((void));
+
+/* Functions for ps(la)tex */
+/* All these routines begin with PSTEX_ */
+TERM_PUBLIC void PSTEX_reopen_output __PROTO((void));
+TERM_PUBLIC void PSTEX_common_init __PROTO((void));
+TERM_PUBLIC void PSTEX_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC void PSTEX_text __PROTO((void));
+
+/* Functions for epslatex */
+/* All these routines begin with EPSLATEX_ */
+TERM_PUBLIC void EPSLATEX_reopen_output __PROTO((void));
+TERM_PUBLIC void EPSLATEX_common_init __PROTO((void));
+TERM_PUBLIC void EPSLATEX_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC void EPSLATEX_linetype __PROTO((int linetype));
+TERM_PUBLIC void EPSLATEX_layer __PROTO((t_termlayer syncpoint));
+
+/* additional LaTeX header information for epslatex terminal */
+TERM_PUBLIC char *epslatex_header = NULL;
+
+#endif /* TERM_PROTO */
+
+
+#ifndef TERM_PROTO_ONLY
+
+#ifdef TERM_BODY
+
+#include "post.h"
+
+struct pstex_text_command {
+    int x, y, angle, justify;
+    char *label;
+    struct pstex_text_command *next;
+};
+
+static struct pstex_text_command *pstex_labels = NULL;
+static int epslatex_text_layer = 0;
+
+/* Support for optimization of set_color */
+static t_colorspec tex_previous_colorspec = {-1, 0, 0.0};  /* Initialize to invalid type */
+static char tex_current_color[64];
+static TBOOLEAN tex_color_synced = FALSE;
+
+#define EPSLATEX_sync_color \
+    do { \
+	if (!tex_color_synced) { \
+	    fputs(tex_current_color,gpoutfile); \
+	    tex_color_synced = TRUE; \
+	} \
+    } while (0)
+
+/* Common functions for epslatex and ps(la)tex */
+
+TERM_PUBLIC void
+PSLATEX_reset()
+{
+    switch (ps_params->terminal) {
+    case PSTERM_EPSLATEX:
+        PS_reset();
+        if (gpoutfile) {
+	    fprintf(gpoutfile, "\
+    \\gplbacktext\n\
+    \\put(0,0){\\includegraphics{%s}}%%\n\
+    \\gplfronttext\n\
+  \\end{picture}%%\n\
+\\endgroup\n", pslatex_auxname);
+            if (ps_params->epslatex_standalone)
+                fputs("\\end{document}\n", gpoutfile);
+        }
+        break;
+    case PSTERM_PSLATEX:
+        fputs("\
+\\end{picture}%\n\
+\\endgroup\n\
+\\endinput\n", gpoutfile);
+        break;
+    case PSTERM_PSTEX:
+        fputs("\
+\\endGNUPLOTpicture\n\
+\\endgroup\n\
+\\endinput\n", gpoutfile);
+        break;
+    default:; /* do nothing, just avoid a compiler warning */
+    }
+
+    if (pslatex_auxname) {
+        free(pslatex_auxname);
+        pslatex_auxname = NULL;
+    }
+    if (gppsfile && (gppsfile != gpoutfile)) {
+        fclose(gppsfile);
+        gppsfile = NULL;
+    }
+}
+
+
+/* Functions for ps(la)tex */
+
+TERM_PUBLIC void
+PSTEX_reopen_output()
+{
+    if (outstr) {
+        char *dotIndex;
+
+        /* if there's no extension, append ".ps" */
+        if ((dotIndex = strrchr(outstr, '.')) == NULL)
+            dotIndex = strchr(outstr, NUL);
+
+        /* try to open the auxiliary file for the postscript parts. */
+        if (ps_params->useauxfile) {
+            /* length of outstr plus ('.' or '\0') plus "eps" plus '\0' */
+            pslatex_auxname = gp_realloc(pslatex_auxname,dotIndex - outstr + 5,
+                                          "pslatex aux filename");
+            if (pslatex_auxname) {
+                /* include period or '\0' */
+                strncpy(pslatex_auxname, outstr, (dotIndex - outstr) + 1);
+                /* period or '\0' is overwritten with period, and "ps" appended */
+                strcpy(pslatex_auxname + (dotIndex - outstr), ".ps");
+                gppsfile = fopen(pslatex_auxname, "w");
+                if (gppsfile  == (FILE *) NULL) {
+                    fprintf(stderr, "Cannot open aux file %s for output. Switching off auxfile option.\n",
+                            pslatex_auxname);
+                    free(pslatex_auxname);
+                    pslatex_auxname = NULL;
+                    ps_params->useauxfile = FALSE;
+                    gppsfile = gpoutfile;
+                }
+            } else {
+                fprintf(stderr, "Cannot make PostScript file name from %s\n",
+                        outstr);
+                fprintf(stderr, "Turning off auxfile option\n");
+                ps_params->useauxfile = FALSE;
+                gppsfile = gpoutfile;
+            }
+        } else
+            gppsfile = gpoutfile;
+    } else {
+        if (ps_params->useauxfile) {
+            fprintf(stderr, "Cannot use aux file on stdout. Switching off auxfile option.\n");
+            ps_params->useauxfile = FALSE;
+        }
+        gppsfile = gpoutfile;
+    }
+}
+
+
+TERM_PUBLIC void
+PSTEX_common_init()
+{
+    switch (ps_params->terminal) {
+    case PSTERM_PSLATEX:
+        fprintf(gpoutfile,"\
+%% GNUPLOT: LaTeX picture with Postscript\n\
+\\begingroup%%\n\
+\\makeatletter%%\n\
+\\newcommand{\\GNUPLOTspecial}{%%\n\
+  \\@sanitize\\catcode`\\%%=14\\relax\\special}%%\n\
+\\setlength{\\unitlength}{%.4fbp}%%\n", 1.0 / (2*PS_SC));
+        fprintf(gpoutfile, "\\begin{picture}(%d,%d)(0,0)%%\n",
+                (int) (xsize * term->xmax), (int) (ysize * term->ymax));
+        break;
+    case PSTERM_PSTEX:
+        /* write plain TeX header */
+        fprintf(gpoutfile, "\
+%% GNUPLOT: plain TeX with Postscript\n\
+\\begingroup\n\
+\\catcode`\\@=11\\relax\n\
+\\def\\GNUPLOTspecial{%%\n\
+  \\def\\do##1{\\catcode`##1=12\\relax}\\dospecials\n\
+  \\catcode`\\{=1\\catcode`\\}=2\\catcode\\%%=14\\relax\\special}%%\n\
+%%\n\
+\\expandafter\\ifx\\csname GNUPLOTpicture\\endcsname\\relax\n\
+  \\csname newdimen\\endcsname\\GNUPLOTunit\n\
+  \\gdef\\GNUPLOTpicture(#1,#2){\\vbox to#2\\GNUPLOTunit\\bgroup\n\
+    \\def\\put(##1,##2)##3{\\unskip\\raise##2\\GNUPLOTunit\n\
+      \\hbox to0pt{\\kern##1\\GNUPLOTunit ##3\\hss}\\ignorespaces}%%\n\
+    \\def\\ljust##1{\\vbox to0pt{\\vss\\hbox to0pt{##1\\hss}\\vss}}%%\n\
+    \\def\\cjust##1{\\vbox to0pt{\\vss\\hbox to0pt{\\hss ##1\\hss}\\vss}}%%\n\
+    \\def\\rjust##1{\\vbox to0pt{\\vss\\hbox to0pt{\\hss ##1}\\vss}}%%\n\
+    \\def\\stack##1{\\let\\\\=\\cr\\tabskip=0pt\\halign{\\hfil ####\\hfil\\cr ##1\\crcr}}%%\n\
+    \\def\\lstack##1{\\hbox to0pt{\\vbox to0pt{\\vss\\stack{##1}}\\hss}}%%\n\
+    \\def\\cstack##1{\\hbox to0pt{\\hss\\vbox to0pt{\\vss\\stack{##1}}\\hss}}%%\n\
+    \\def\\rstack##1{\\hbox to0pt{\\vbox to0pt{\\stack{##1}\\vss}\\hss}}%%\n\
+    \\vss\\hbox to#1\\GNUPLOTunit\\bgroup\\ignorespaces}%%\n\
+  \\gdef\\endGNUPLOTpicture{\\hss\\egroup\\egroup}%%\n\
+\\fi\n\
+\\GNUPLOTunit=%.4fbp\n", 1.0 / (2*PS_SC));
+        fprintf(gpoutfile, "\\GNUPLOTpicture(%d,%d)\n",
+                (int) (xsize * term->xmax), (int) (ysize * term->ymax));
+        break;
+    default:; /* do nothing, just avoid a compiler warning */
+    }
+
+    if (gppsfile != gpoutfile) {
+        /* these are taken from the post.trm file computation
+         * of the bounding box, but without the X_OFF and Y_OFF */
+        int urx = (int) (xsize * term->xmax / (2*PS_SC) + 0.5);
+        int ury = (int) (ysize * term->ymax / (2*PS_SC) + 0.5);
+        /* moved this code here from beginning of the function
+         * pslatex_auxname is only != NULL with the `auxfile' option */
+        char *psfile_basename = strrchr(pslatex_auxname, DIRSEP1);
+
+        /* If pslatex_auxname is not a simple file name, but a path,
+         * we need to strip the path off the auxiliary file name,
+         * because tex file and ps aux file end up in the same directory! */
+        if (psfile_basename)
+            psfile_basename++;
+        else {
+#if DIRSEP2 != NUL
+	    psfile_basename = strrchr(pslatex_auxname, DIRSEP2);
+	    if (psfile_basename)
+		psfile_basename++;
+	    else
+		psfile_basename = pslatex_auxname;
+#else
+	    psfile_basename = pslatex_auxname;
+#endif
+	}
+
+        /* generate special which xdvi and dvips can handle */
+        fprintf(gpoutfile,
+                "  \\special{psfile=%s llx=0 lly=0 urx=%d ury=%d rwi=%d}\n",
+                psfile_basename, urx, ury, 10 * urx);
+    } else
+        fputs("  {\\GNUPLOTspecial{\"\n", gpoutfile);
+
+    /* HH: really necessary?
+    ps_ang = 0;
+    ps_justify = 0;
+    */
+    pstex_labels = (struct pstex_text_command *) NULL;
+}
+
+
+TERM_PUBLIC void
+PSTEX_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    struct pstex_text_command *tc;
+
+    /* ignore empty strings */
+    if (str[0] == NUL)
+        return;
+
+    /* Save the text for later printing after the core graphics */
+    tc = (struct pstex_text_command *) gp_alloc(sizeof(struct pstex_text_command),
+                                                term->name);
+    tc->x = x;
+    tc->y = y;
+    tc->label = (char *) gp_alloc(strlen(str) + 1, term->name);
+    strcpy(tc->label, str);
+    tc->justify = ps_justify;
+    tc->angle = ps_ang;
+
+    tc->next = pstex_labels;
+    pstex_labels = tc;
+}
+
+TERM_PUBLIC void
+PSTEX_text()
+{
+    struct pstex_text_command *tc;
+
+    PS_text();
+    if (gppsfile == gpoutfile)
+        fputs("  }}%\n", gpoutfile);
+
+    if (ps_params->fontsize) {
+        if (ps_params->terminal == PSTERM_PSLATEX)
+            fprintf(gpoutfile, "\\fontsize{%g}{\\baselineskip}\\selectfont\n",
+                    ps_params->fontsize);
+        /* Should have an else clause here to handle pstex equivalent */
+    }
+
+    for (tc = pstex_labels;
+         tc != (struct pstex_text_command *) NULL;
+         tc = tc->next) {
+        fprintf(gpoutfile, "  \\put(%d,%d){", tc->x, tc->y);
+        if ((ps_params->rotate) && (tc->angle != 0))
+            fprintf(gpoutfile, "\
+%%\n  \\special{ps: gsave currentpoint currentpoint translate\n\
+%d rotate neg exch neg exch translate}%%\n  ", 360 - tc->angle);
+        if ((ps_params->terminal == PSTERM_PSLATEX) &&
+            ((tc->label[0] == '{') || (tc->label[0] == '['))) {
+            fprintf(gpoutfile, "\\makebox(0,0)%s", tc->label);
+        } else
+            switch (tc->justify) {
+            case LEFT:
+                fprintf(gpoutfile, (ps_params->terminal == PSTERM_PSLATEX
+                                    ? "\\makebox(0,0)[l]{\\strut{}%s}"
+                                    : "\\ljust{\\strut{}%s}"), tc->label);
+                break;
+            case CENTRE:
+                fprintf(gpoutfile, (ps_params->terminal == PSTERM_PSLATEX
+                                    ? "\\makebox(0,0){\\strut{}%s}"
+                                    : "\\cjust{\\strut{}%s}"), tc->label);
+                break;
+            case RIGHT:
+                fprintf(gpoutfile, (ps_params->terminal == PSTERM_PSLATEX
+                                    ? "\\makebox(0,0)[r]{\\strut{}%s}"
+                                    : "\\rjust{\\strut{}%s}"), tc->label);
+                break;
+            }
+        if ((ps_params->rotate) && (tc->angle != 0))
+            fputs("%\n  \\special{ps: currentpoint grestore moveto}%\n  ",
+                  gpoutfile);
+        fputs("}%\n", gpoutfile);
+    }
+
+    while (pstex_labels) {
+        tc = pstex_labels->next;
+        free(pstex_labels->label);
+        free(pstex_labels);
+        pstex_labels = tc;
+    }
+
+}
+
+
+/* Functions for epslatex */
+
+/* the common init function for the epslatex driver */
+TERM_PUBLIC void
+EPSLATEX_common_init()
+{
+    char *fontfamily = NULL;
+    char *fontseries = NULL;
+    char *fontshape = NULL;
+
+    if (!gpoutfile) {
+        char *temp = gp_alloc(strlen(outstr) + 1, "temp file string");
+        if (temp) {
+            strcpy(temp, outstr);
+            term_set_output(temp);  /* will free outstr */
+            if (temp != outstr) {
+                if (temp)
+                    free(temp);
+                temp = outstr;
+            }
+        } else
+            os_error(c_token, "Cannot reopen output files");
+    }
+    if (!outstr)
+        os_error(c_token,
+                 "epslatex terminal cannot write to standard output");
+    if (gpoutfile) {
+        char *inputenc = NULL;
+
+        fprintf(gpoutfile, "%% GNUPLOT: LaTeX picture with Postscript\n");
+
+        switch(encoding) {
+        case S_ENC_DEFAULT:
+            break;
+        case S_ENC_ISO8859_1:
+            inputenc = "latin1";
+            break;
+        case S_ENC_ISO8859_2:
+            inputenc = "latin2";
+            break;
+        case S_ENC_ISO8859_9:	/* ISO8859-9 is Latin5 */
+            inputenc = "latin5";
+            break;
+        case S_ENC_ISO8859_15:	/* ISO8859-15 is Latin9 */
+            inputenc = "latin9";
+            break;
+        case S_ENC_CP437:
+            inputenc = "cp437de";
+            break;
+        case S_ENC_CP850:
+            inputenc = "cp850";
+            break;
+        case S_ENC_CP852:
+            inputenc = "cp852";
+            break;
+        case S_ENC_CP1250:
+            inputenc = "cp1250";
+            break;
+        case S_ENC_KOI8_R:
+            inputenc = "koi8-r";
+            break;
+        case S_ENC_KOI8_U:
+            inputenc = "koi8-u";
+            break;
+        case S_ENC_INVALID:
+            int_error(NO_CARET, "invalid input encoding used");
+            break;
+        default:
+            /* do nothing */
+            break;
+        }
+
+	/* Clear previous state */
+	tex_previous_colorspec.type = -1;
+
+	/* Clear any leftover text-layering state */
+	EPSLATEX_layer(TERM_LAYER_RESET);
+
+        /* Analyse LaTeX font name 'family,series,shape' */
+        if ((strlen(ps_params->font) > 0) &&
+            (strcmp(ps_params->font,"default") != 0)) {
+            char *comma = NULL;
+            fontfamily = gp_alloc(strlen(ps_params->font)+1,
+                                  "EPSLATEX_common_init");
+            fontseries = gp_alloc(strlen(ps_params->font)+1,
+                                  "EPSLATEX_common_init");
+            fontshape = gp_alloc(strlen(ps_params->font)+1,
+                                 "EPSLATEX_common_init");
+            strcpy(fontfamily,ps_params->font);
+            *fontseries = '\0';
+            *fontshape = '\0';
+            if ((comma = strchr(fontfamily, ',')) != NULL) {
+                *comma = '\0';
+                strcpy(fontseries,comma+1);
+                if ((comma = strchr(fontseries, ',')) != NULL) {
+                    *comma = '\0';
+                    strcpy(fontshape,comma+1);
+                }
+            }
+        }
+            
+        if (ps_params->epslatex_standalone) {
+            fprintf(gpoutfile, "\
+\\documentclass{minimal}\n\
+%% Set font size\n\
+\\makeatletter\n\
+\\def\\@ptsize{%d}\n\
+\\InputIfFileExists{size%d.clo}{}{%%\n\
+   \\GenericError{(gnuplot) \\space\\space\\space\\@spaces}{%%\n\
+      Gnuplot Error: File `size%d.clo' not found! Could not set font size%%\n\
+   }{See the gnuplot documentation for explanation.%%\n\
+   }{For using a font size a file `size<fontsize>.clo' has to exist.\n\
+        Falling back ^^Jto default fontsize 10pt.}%%\n\
+  \\def\\@ptsize{0}\n\
+  \\input{size10.clo}%%\n\
+}%%\n\
+\\makeatother\n",
+                    (int)(ps_params->fontsize-10),
+                    (int)(ps_params->fontsize),
+                    (int)(ps_params->fontsize));
+
+            if (fontfamily && strlen(fontfamily) > 0)
+                fprintf(gpoutfile, "\\renewcommand*\\rmdefault{%s}%%\n",
+                        fontfamily);
+            if (fontseries && strlen(fontseries) > 0)
+                fprintf(gpoutfile, "\\renewcommand*\\mddefault{%s}%%\n",
+                        fontseries);
+            if (fontshape && strlen(fontshape) > 0)
+                fprintf(gpoutfile, "\\renewcommand*\\updefault{%s}%%\n",
+                        fontshape);
+
+            fputs("\
+% Load packages\n\
+\\usepackage{graphicx}\n\
+\\usepackage{color}\n", gpoutfile);
+
+            if (inputenc)
+                fprintf(gpoutfile, "\\usepackage[%s]{inputenc}\n", inputenc);
+
+            fprintf(gpoutfile, "\
+\\makeatletter\n\
+%% Select an appropriate default driver (from TeXLive graphics.cfg)\n\
+\\begingroup\n\
+  \\chardef\\x=0 %%\n\
+  %% check pdfTeX\n\
+  \\@ifundefined{pdfoutput}{}{%%\n\
+    \\ifcase\\pdfoutput\n\
+    \\else\n\
+      \\chardef\\x=1 %%\n\
+    \\fi\n\
+  }%%\n\
+  %% check VTeX\n\
+  \\@ifundefined{OpMode}{}{%%\n\
+    \\chardef\\x=2 %%\n\
+  }%%\n\
+\\expandafter\\endgroup\n\
+\\ifcase\\x\n\
+  %% default case\n\
+  \\PassOptionsToPackage{dvips}{geometry}\n\
+\\or\n\
+  %% pdfTeX is running in pdf mode\n\
+  \\PassOptionsToPackage{pdftex}{geometry}\n\
+\\else\n\
+  %% VTeX is running\n\
+  \\PassOptionsToPackage{vtex}{geometry}\n\
+\\fi\n\
+\\makeatother\n\
+%% Set papersize\n\
+\\usepackage[papersize={%.2fbp,%.2fbp},text={%.2fbp,%.2fbp}]{geometry}\n\
+%% No page numbers and no paragraph indentation\n\
+\\pagestyle{empty}\n\
+\\setlength{\\parindent}{0bp}%%\n\
+%% Load configuration file\n\
+\\InputIfFileExists{gnuplot.cfg}{%%\n\
+  \\typeout{Using configuration file gnuplot.cfg}%%\n\
+}{%%\n\
+ \\typeout{No configuration file gnuplot.cfg found.}%%\n\
+}%%\n\
+%s\n\
+\\begin{document}\n",
+                    term->xmax * xsize / (2.0*PS_SC),
+                    term->ymax * ysize / (2.0*PS_SC),
+                    term->xmax * xsize / (2.0*PS_SC),
+                    term->ymax * ysize / (2.0*PS_SC),
+                    epslatex_header ? epslatex_header : "%" );
+        }
+
+        fputs("\\begingroup\n", gpoutfile);
+        
+        if (inputenc)
+            fprintf(gpoutfile, "\
+  %% Encoding inside the plot.  In the header of your document, this encoding\n\
+  %% should to defined, e.g., by using\n\
+  %% \\usepackage[%s,<other encodings>]{inputenc}\n\
+  \\inputencoding{%s}%%\n", inputenc, inputenc);
+
+        if (!ps_params->epslatex_standalone) {
+            if (fontfamily && strlen(fontfamily) > 0)
+                fprintf(gpoutfile, "  \\fontfamily{%s}%%\n",
+                        fontfamily);
+            if (fontseries && strlen(fontseries) > 0)
+                fprintf(gpoutfile, "  \\fontseries{%s}%%\n",
+                        fontseries);
+            if (fontshape && strlen(fontshape) > 0)
+                fprintf(gpoutfile, "  \\fontshape{%s}%%\n",
+                        fontshape);
+            if (fontfamily || fontseries || fontshape)
+                fputs("  \\selectfont\n", gpoutfile);
+            if (epslatex_header)
+                fprintf(gpoutfile, "%s\n", epslatex_header );
+        }
+
+        fprintf(gpoutfile, "\
+  \\makeatletter\n\
+  \\providecommand\\color[2][]{%%\n\
+    \\GenericError{(gnuplot) \\space\\space\\space\\@spaces}{%%\n\
+      Package color not loaded in conjunction with\n\
+      terminal option `colourtext'%%\n\
+    }{See the gnuplot documentation for explanation.%%\n\
+    }{Either use 'blacktext' in gnuplot or load the package\n\
+      color.sty in LaTeX.}%%\n\
+    \\renewcommand\\color[2][]{}%%\n\
+  }%%\n\
+  \\providecommand\\includegraphics[2][]{%%\n\
+    \\GenericError{(gnuplot) \\space\\space\\space\\@spaces}{%%\n\
+      Package graphicx or graphics not loaded%%\n\
+    }{See the gnuplot documentation for explanation.%%\n\
+    }{The gnuplot epslatex terminal needs graphicx.sty or graphics.sty.}%%\n\
+    \\renewcommand\\includegraphics[2][]{}%%\n\
+  }%%\n\
+  \\providecommand\\rotatebox[2]{#2}%%\n\
+  \\@ifundefined{ifGPcolor}{%%\n\
+    \\newif\\ifGPcolor\n\
+    \\GPcolor%s\n\
+  }{}%%\n\
+  \\@ifundefined{ifGPblacktext}{%%\n\
+    \\newif\\ifGPblacktext\n\
+    \\GPblacktext%s\n\
+  }{}%%\n\
+  %% define a \\g@addto@macro without @ in the name:\n\
+  \\let\\gplgaddtomacro\\g@addto@macro\n\
+  %% define empty templates for all commands taking text:\n\
+  \\gdef\\gplbacktext{}%%\n\
+  \\gdef\\gplfronttext{}%%\n\
+  \\makeatother\n",
+                (ps_params->color?"true":"false"),
+                (ps_params->blacktext?"true":"false") );
+
+        /* use \expandafter\def\csname LT0\endcsname{...} 
+         * instead of \def\LT0{...} because digits may not be part of
+         * \... sequences */
+        fputs("\
+  \\ifGPblacktext\n\
+    % no textcolor at all\n\
+    \\def\\colorrgb#1{}%\n\
+    \\def\\colorgray#1{}%\n\
+  \\else\n\
+    % gray or color?\n\
+    \\ifGPcolor\n\
+      \\def\\colorrgb#1{\\color[rgb]{#1}}%\n\
+      \\def\\colorgray#1{\\color[gray]{#1}}%\n\
+      \\expandafter\\def\\csname LTw\\endcsname{\\color{white}}%\n\
+      \\expandafter\\def\\csname LTb\\endcsname{\\color{black}}%\n\
+      \\expandafter\\def\\csname LTa\\endcsname{\\color{black}}%\n",
+              gpoutfile);
+        if (ps_params->oldstyle) {
+            fputs("\
+      \\expandafter\\def\\csname LT0\\endcsname{\\color[rgb]{1,0,0}}%\n\
+      \\expandafter\\def\\csname LT1\\endcsname{\\color[rgb]{0,0,1}}%\n\
+      \\expandafter\\def\\csname LT2\\endcsname{\\color[rgb]{0,1,1}}%\n\
+      \\expandafter\\def\\csname LT3\\endcsname{\\color[rgb]{1,0,1}}%\n",
+                  gpoutfile);
+        } else {
+            fputs("\
+      \\expandafter\\def\\csname LT0\\endcsname{\\color[rgb]{1,0,0}}%\n\
+      \\expandafter\\def\\csname LT1\\endcsname{\\color[rgb]{0,1,0}}%\n\
+      \\expandafter\\def\\csname LT2\\endcsname{\\color[rgb]{0,0,1}}%\n\
+      \\expandafter\\def\\csname LT3\\endcsname{\\color[rgb]{1,0,1}}%\n\
+      \\expandafter\\def\\csname LT4\\endcsname{\\color[rgb]{0,1,1}}%\n\
+      \\expandafter\\def\\csname LT5\\endcsname{\\color[rgb]{1,1,0}}%\n\
+      \\expandafter\\def\\csname LT6\\endcsname{\\color[rgb]{0,0,0}}%\n\
+      \\expandafter\\def\\csname LT7\\endcsname{\\color[rgb]{1,0.3,0}}%\n\
+      \\expandafter\\def\\csname LT8\\endcsname{\\color[rgb]{0.5,0.5,0.5}}%\n",
+                  gpoutfile);
+        }
+        fputs("\
+    \\else\n\
+      % gray\n\
+      \\def\\colorrgb#1{\\color{black}}%\n\
+      \\def\\colorgray#1{\\color[gray]{#1}}%\n\
+      \\expandafter\\def\\csname LTw\\endcsname{\\color{white}}%\n\
+      \\expandafter\\def\\csname LTb\\endcsname{\\color{black}}%\n\
+      \\expandafter\\def\\csname LTa\\endcsname{\\color{black}}%\n\
+      \\expandafter\\def\\csname LT0\\endcsname{\\color{black}}%\n\
+      \\expandafter\\def\\csname LT1\\endcsname{\\color{black}}%\n\
+      \\expandafter\\def\\csname LT2\\endcsname{\\color{black}}%\n\
+      \\expandafter\\def\\csname LT3\\endcsname{\\color{black}}%\n\
+      \\expandafter\\def\\csname LT4\\endcsname{\\color{black}}%\n\
+      \\expandafter\\def\\csname LT5\\endcsname{\\color{black}}%\n\
+      \\expandafter\\def\\csname LT6\\endcsname{\\color{black}}%\n\
+      \\expandafter\\def\\csname LT7\\endcsname{\\color{black}}%\n\
+      \\expandafter\\def\\csname LT8\\endcsname{\\color{black}}%\n\
+    \\fi\n\
+  \\fi\n", gpoutfile);
+
+        fprintf(gpoutfile,"\
+  \\setlength{\\unitlength}{%.4fbp}%%\n\
+  \\begin{picture}(%.2f,%.2f)%%\n",
+                1.0 / (2*PS_SC), term->xmax * xsize, term->ymax * ysize);
+    }
+
+    if (fontfamily)
+        free(fontfamily);
+    if (fontseries)
+        free(fontseries);
+    if (fontshape)
+        free(fontshape);
+}
+
+
+TERM_PUBLIC void
+EPSLATEX_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    if (gpoutfile) {
+	EPSLATEX_sync_color;
+	fprintf(gpoutfile, "      \\put(%d,%d){", x, y);
+        if (ps_ang)
+            fprintf(gpoutfile,"\\rotatebox{%d}{", ps_ang);
+        if (((str[0] == '{') || (str[0] == '['))) {
+            fprintf(gpoutfile, "\\makebox(0,0)%s", str);
+        } else
+            switch (ps_justify) {
+            case LEFT:
+                fprintf(gpoutfile, "\\makebox(0,0)[l]{\\strut{}%s}", str);
+                break;
+            case CENTRE:
+                fprintf(gpoutfile, "\\makebox(0,0){\\strut{}%s}", str);
+                break;
+            case RIGHT:
+                fprintf(gpoutfile, "\\makebox(0,0)[r]{\\strut{}%s}", str);
+                break;
+            }
+        if (ps_ang) {
+            fputs("}", gpoutfile);
+        }
+        fputs("}%\n", gpoutfile);
+    }
+}
+
+
+/* assigns dest to outstr, so it must be allocated or NULL
+ * and it must not be outstr itself !
+ */
+void
+EPSLATEX_reopen_output()
+{
+    char *psoutstr = NULL;
+
+    if (outstr) {
+        unsigned int outstrlen = strlen(outstr);
+        if (strrchr(outstr, '.') != &outstr[outstrlen-4] ) {
+            int_error(NO_CARET,
+                      "epslatex outputfile may not have dots inside %s",
+                      "their filenames before the extension .tex or .eps");
+        }
+
+        /* copy filename to postsript output */
+        psoutstr = gp_alloc(outstrlen+5, "epslatex eps filename");
+        strcpy( psoutstr, outstr);
+
+        if ((!strncmp( &outstr[outstrlen-4], ".eps", 4 )) ||
+            (!strncmp( &outstr[outstrlen-4], ".EPS", 4 ))) {
+            if (ps_params->epslatex_standalone)
+                int_error(NO_CARET,
+                          "For epslatex standalone mode, you have to %s",
+                          "give the tex filename as output");
+            /* rename primary output (tex) */
+            strncpy( &outstr[outstrlen-4], ".tex", 4);
+            /* redirect FILE stream */
+            gppsfile = gpoutfile;
+            gpoutfile = fopen(outstr,"w");
+            int_warn(NO_CARET, "Resetting primary output file to %s,\n\
+                  PostScript output to %s", outstr, psoutstr);
+            if (!gpoutfile)
+                int_error(NO_CARET, "--- reopen failed");
+        } else {
+            if (ps_params->epslatex_standalone)
+                strncpy( &psoutstr[outstrlen-4], "-inc.eps", 9);
+            else
+                strncpy( &psoutstr[outstrlen-4], ".eps", 4);
+            gppsfile = fopen(psoutstr,"w");
+        }
+        if (!gppsfile)
+            int_error(NO_CARET, "open of postscipt output file %s failed",
+                      psoutstr);
+
+        /* set the name for the \includegraphics command */
+        pslatex_auxname = gp_alloc(strlen(psoutstr)-3,
+                                   "epslatex TeX filename");
+        strncpy( pslatex_auxname, psoutstr, strlen(psoutstr)-4 );
+        pslatex_auxname[strlen(psoutstr)-4] = '\0';
+
+        free(psoutstr);
+    }
+}
+
+
+TERM_PUBLIC void
+EPSLATEX_set_color(t_colorspec *colorspec)
+{
+    double gray;
+
+    /* EAM Jul 2006 - Filter out duplicate requests */
+    if (!memcmp(&tex_previous_colorspec, colorspec, sizeof(t_colorspec)))
+	return;
+    else
+	memcpy(&tex_previous_colorspec, colorspec, sizeof(t_colorspec));
+
+    /* Fancy footwork to deal with mono/grayscale plots */
+    if (colorspec->type == TC_LT && !ps_params->color)
+	PS_linetype(colorspec->lt);
+    else
+	PS_set_color(colorspec);
+
+    /* Many [most? all?] of the set_color commands only affect the *.eps     */
+    /* output stream.  So rather than printing them all to the *.tex stream, */
+    /* we update the current color and set a flag to say it has changed.     */
+    /* Only when some TeX object is output do we sync the current color by   */
+    /* writing it out.                                                       */
+    tex_color_synced = FALSE;
+
+    if (colorspec->type == TC_RGB) {
+        double r = (double)((colorspec->lt >> 16 ) & 255) / 255.;
+        double g = (double)((colorspec->lt >> 8 ) & 255) / 255.;
+        double b = (double)(colorspec->lt & 255) / 255.;
+	sprintf(tex_current_color, "      \\colorrgb{%3.2f,%3.2f,%3.2f}%%\n",r,g,b);
+    }
+
+    if (colorspec->type == TC_LT) {
+        int linetype = colorspec->lt;
+        if (ps_params->oldstyle)
+            linetype = (linetype % 4) + 3;
+        else
+            linetype = (linetype % 9) + 3;
+
+	sprintf(tex_current_color, "      \\csname LT%c\\endcsname%%\n",
+                "wba012345678"[linetype]);
+    }
+
+    if (colorspec->type != TC_FRAC)
+        return;
+
+/* map [0;1] to gray/colors */
+    gray = colorspec->value;
+
+    if (ps_params->blacktext) {
+	if (gray <= 0)
+	    sprintf(tex_current_color, "      \\color{black}%%\n");
+	else if (gray >= 1)
+	    sprintf(tex_current_color, "      \\color{white}%%\n");
+        else
+	    sprintf(tex_current_color, "      \\colorgray{%s}%%\n",save_space(gray));
+    } else {
+	rgb_color color;
+	rgb1_from_gray( colorspec->value, &color );
+	sprintf(tex_current_color, "      \\colorrgb{%3.2f,%3.2f,%3.2f}%%\n",color.r,color.g,color.b);
+    }
+}
+
+TERM_PUBLIC void
+EPSLATEX_linetype(int linetype)
+{
+    t_colorspec tempcol = {TC_LT, 0, 0.0};
+    tempcol.lt = linetype;
+    PS_linetype(linetype);
+
+    /* This leads to redundant *.eps output */
+    EPSLATEX_set_color(&tempcol);
+}
+
+/*
+ * The TERM_LAYER mechanism is used here to signal a difference between
+ * "front" text and "back" text.
+ */
+TERM_PUBLIC void
+EPSLATEX_layer(t_termlayer syncpoint)
+{
+    switch (syncpoint) {
+
+    case TERM_LAYER_RESET:        /* Start of plot; reset flag */
+	epslatex_text_layer = 0;
+	break;
+
+    case TERM_LAYER_BACKTEXT: /* Start of "back" text layer */
+	if (epslatex_text_layer == 1)
+	    break;
+	if (epslatex_text_layer == 2)
+	    fputs("    }%\n", gpoutfile);
+	epslatex_text_layer = 1;
+	fputs("    \\gplgaddtomacro\\gplbacktext{%\n", gpoutfile);
+	break;
+
+    case TERM_LAYER_FRONTTEXT:/* Start of "front" text layer */
+	if (epslatex_text_layer == 2)
+	    break;
+	if (epslatex_text_layer == 1)
+	    fputs("    }%\n", gpoutfile);
+	epslatex_text_layer = 2;
+	fputs("    \\gplgaddtomacro\\gplfronttext{%\n", gpoutfile);
+	break;
+
+    case TERM_LAYER_END_TEXT:     /* Close off front or back macro before leaving */
+	if (epslatex_text_layer == 1 || epslatex_text_layer == 2)
+	    fputs("    }%\n", gpoutfile);
+	epslatex_text_layer = 0;
+	break;
+
+    default:
+	break;
+    }
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+#ifndef GOT_POST_PROTO
+#define TERM_PROTO_ONLY
+#include "post.trm"
+#undef TERM_PROTO_ONLY
+#endif /* GOT_POST_PROTO */
+
+TERM_TABLE_START(epslatex_driver)
+    "epslatex", "LaTeX picture environment using graphicx package",
+    PS_XMAX, PS_YMAX, EPSLATEX_VCHAR, EPSLATEX_HCHAR,
+    PS_VTIC, PS_HTIC, PS_options, PS_init, PSLATEX_reset,
+    PS_text, null_scale, PS_graphics, PS_move,
+    PS_vector, EPSLATEX_linetype, EPSLATEX_put_text, PS_text_angle,
+    PS_justify_text, PS_point, do_arrow, PS_set_font,
+    PS_pointsize, TERM_BINARY|TERM_IS_POSTSCRIPT|TERM_CAN_CLIP /*flags */,
+    0 /*suspend */, 0 /*resume */,
+    PS_fillbox, PS_linewidth,
+#ifdef USE_MOUSE
+    0, 0, 0, 0, 0, /* no mouse support for postscript */
+#endif
+    PS_make_palette, PS_previous_palette,
+    EPSLATEX_set_color, PS_filled_polygon,
+    PS_image,
+    0, 0, 0, /* Enhanced text mode not used */
+    EPSLATEX_layer, /* Used to signal front/back text */
+    PS_path
+TERM_TABLE_END(epslatex_driver)
+#undef LAST_TERM
+#define LAST_TERM epslatex_driver
+
+TERM_TABLE_START(pslatex_driver)
+    "pslatex", "LaTeX picture environment with PostScript \\specials",
+    PS_XMAX, PS_YMAX, PSTEX_VCHAR, PSTEX_HCHAR,
+    PS_VTIC, PS_HTIC, PS_options, PS_init, PSLATEX_reset,
+    PSTEX_text, null_scale, PS_graphics, PS_move,
+    PS_vector, PS_linetype, PSTEX_put_text, PS_text_angle,
+    PS_justify_text, PS_point, PS_arrow, set_font_null,
+    PS_pointsize, TERM_CAN_CLIP /*flags */ , 0 /*suspend */
+    , 0 /*resume */ ,
+    PS_fillbox, PS_linewidth
+#ifdef USE_MOUSE
+   , 0, 0, 0, 0, 0 /* no mouse support for postscript */
+#endif
+   , PS_make_palette,
+   PS_previous_palette, /* write grestore */
+   PS_set_color,
+   PS_filled_polygon
+    , PS_image
+    , 0, 0, 0	/* No enhanced text mode because this is LaTeX */
+    , 0         /* layer */
+    , PS_path
+TERM_TABLE_END(pslatex_driver)
+#undef LAST_TERM
+#define LAST_TERM pslatex_driver
+
+TERM_TABLE_START(pstex_driver)
+    "pstex", "plain TeX with PostScript \\specials",
+    PS_XMAX, PS_YMAX, PSTEX_VCHAR, PSTEX_HCHAR,
+    PS_VTIC, PS_HTIC, PS_options, PS_init, PSLATEX_reset,
+    PSTEX_text, null_scale, PS_graphics, PS_move,
+    PS_vector, PS_linetype, PSTEX_put_text, PS_text_angle,
+    PS_justify_text, PS_point, PS_arrow, set_font_null,
+    PS_pointsize, TERM_CAN_CLIP /*flags */ , 0 /*suspend */
+    , 0 /*resume */ ,
+    PS_fillbox, PS_linewidth
+#ifdef USE_MOUSE
+   , 0, 0, 0, 0, 0 /* no mouse support for postscript */
+#endif
+   , PS_make_palette,
+   PS_previous_palette, /* write grestore */
+   PS_set_color,
+   PS_filled_polygon
+    , PS_image
+    , 0, 0, 0	/* No enhanced text mode because this is LaTeX */
+    , 0         /* layer */
+    , PS_path
+TERM_TABLE_END(pstex_driver)
+#undef LAST_TERM
+#define LAST_TERM pstex_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/pstricks.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/pstricks.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/pstricks.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/pstricks.trm.svn-base	2012-01-03 17:07:43.336361300 -0800
@@ -0,0 +1,698 @@
+/* Hey Emacs this is -*- C -*-
+ *
+ * $Id: pstricks.trm,v 1.33 2006/11/18 17:24:26 sfeam Exp $
+ */
+
+/* GNUPLOT - pstricks.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *   The PSTricks macros for LaTeX.
+ *
+ * AUTHORS
+ *   David Kotz
+ *
+ *   Raymond Toy	toy@soho.crd.ge.com
+ *	Modified the eepic.trm file to use PSTricks macros instead.
+ *
+ *	20 Mar 93:
+ *		Utilized many suggestions from Gisli Ottarsson
+ *		(gisli@liapunov.eecs.umich.edu) to create a new version.
+ *		Should also work with TeX as well as LaTeX.
+ *
+ *		If you have PSTricks version 0.91, #define OLD_PST to
+ *		get the right dots.
+ *
+ *		Added a really ugly hack (enabled by default) to print
+ *		"nice" numbers for axis labels.  This should really be at
+ *		a higher level in the code, but I'm lazy right now.
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+
+/*
+ *  This file contains the PSTricks terminal driver, intended for use with the
+ *  pstricks.sty macro package for LaTeX. This is an alternative to the
+ *  eepic and latex driver. You need pstricks.sty, and, of course, a printer
+ *  that understands PostScript.  Ghostscript understands Postscript too.
+ *
+ *  PSTricks is available via anonymous ftp from the /pub directory
+ *  at Princeton.EDU.  This driver definitely does not come close to
+ *  using the full capability of the PSTricks package.
+ */
+/*
+ * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
+ *
+ * adapted to support pm3d by Tim Piessens and Petr Mikulik (Jan. 2003)
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(pstricks)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void PSTRICKS_options __PROTO((void));
+TERM_PUBLIC void PSTRICKS_init __PROTO((void));
+TERM_PUBLIC void PSTRICKS_graphics __PROTO((void));
+TERM_PUBLIC void PSTRICKS_text __PROTO((void));
+TERM_PUBLIC void PSTRICKS_linetype __PROTO((int linetype));
+TERM_PUBLIC void PSTRICKS_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void PSTRICKS_point __PROTO((unsigned int x, unsigned int y, int number));
+TERM_PUBLIC void PSTRICKS_vector __PROTO((unsigned int ux, unsigned int uy));
+TERM_PUBLIC void PSTRICKS_arrow __PROTO((unsigned int sx, unsigned int sy, unsigned int ex, unsigned int ey, int head));
+TERM_PUBLIC void PSTRICKS_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
+TERM_PUBLIC int PSTRICKS_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC int PSTRICKS_text_angle __PROTO((int ang));
+TERM_PUBLIC void PSTRICKS_reset __PROTO((void));
+TERM_PUBLIC int PSTRICKS_make_palette __PROTO((t_sm_palette *));
+TERM_PUBLIC void PSTRICKS_set_color __PROTO((t_colorspec *));
+TERM_PUBLIC void PSTRICKS_filled_polygon __PROTO((int, gpiPoint *));
+
+#define PSTRICKS_XMAX 10000.0
+#define PSTRICKS_YMAX 10000.0
+
+#define PSTRICKS_HTIC	150
+#define PSTRICKS_VTIC	200
+#define PSTRICKS_HCHAR	160
+#define PSTRICKS_VCHAR	420
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+static void PSTRICKS_endline __PROTO((void));
+static char *PSTRICKS_hack_text __PROTO((const char *s));
+
+static float PSTRICKS_posx;
+static float PSTRICKS_posy;
+static enum JUSTIFY PSTRICKS_justify = LEFT;
+static int PSTRICKS_angle = 0;
+
+/* if 1 below, then the file size is shorter thanks to a macro for polygon */
+#define PSTRICKS_SHORTER_FILE 1
+
+#ifdef PSTRICKS_SHORTER_FILE
+static int PSTRICKS_color = 0;
+#else
+static char PSTRICKS_color_str[16] = "";
+#endif
+static int PSTRICKS_palette_set = FALSE;
+static int PSTRICKS_palette_size = 128;
+
+#define	PSTRICKS_TINY_DOT	0.00025		/* A tiny dot */
+
+/* POINTS */
+#define PSTRICKS_POINT_TYPES 12	/* we supply more point types */
+
+static const char *PSTRICKS_points[] = {
+    "\\PST@Diamond",
+    "\\PST@Plus",
+    "\\PST@Square",
+    "\\PST@Cross",
+    "\\PST@Circle",
+    "\\PST@Triangle",
+    "\\PST@Pentagon",
+    "\\PST@Filldiamond",
+    "\\PST@Fillsquare",
+    "\\PST@Filltriangle",
+    "\\PST@Fillcircle",
+    "\\PST@Fillpentagon"
+};
+
+/* LINES */
+#define PSTRICKS_NUMLINES 6	/* number of linetypes below */
+
+static const char *PSTRICKS_lines[] = {
+    "\\PST@Border",
+    "\\PST@Axes",
+    "\\PST@Solid",
+    "\\PST@Dashed",
+    "\\PST@Dotted",
+    "\\PST@LongDash"
+};
+
+/* current line type */
+static int PSTRICKS_type;
+
+/* are we in the middle of a line */
+static TBOOLEAN PSTRICKS_inline = FALSE;
+
+/* terminate any line in progress */
+static void PSTRICKS_endline __PROTO((void));
+
+/* number of points in line so far */
+static int PSTRICKS_linecount = 0;
+
+/* max value for linecount */
+#define PSTRICKS_LINEMAX 100
+
+/*
+ * Handle options
+ */
+
+static int PST_hack_text = TRUE;	/* Hack text on */
+static int PST_unit_plot = FALSE;	/* Unit-sized plot off */
+
+TERM_PUBLIC void
+PSTRICKS_options()
+{
+    if (!END_OF_COMMAND) {
+	if (almost_equals(c_token, "no$hacktext")) {
+	    PST_hack_text = FALSE;
+	    c_token++;
+	} else if (almost_equals(c_token, "u$nit")) {
+	    PST_unit_plot = TRUE;
+	    c_token++;
+	}
+    }
+}
+
+TERM_PUBLIC void
+PSTRICKS_init()
+{
+    PSTRICKS_posx = PSTRICKS_posy = 0;
+    PSTRICKS_linetype(-1);
+    fseek(gpoutfile,0,SEEK_SET);
+    fputs("% GNUPLOT: LaTeX picture using PSTRICKS macros\n", gpoutfile);
+    PSTRICKS_palette_set = FALSE;    /* PM3D palette set? */
+}
+
+
+TERM_PUBLIC void
+PSTRICKS_graphics()
+{
+    fputs("\
+% Define new PST objects, if not already defined\n\
+\\ifx\\PSTloaded\\undefined\n\
+\\def\\PSTloaded{t}\n\
+\\psset{arrowsize=.01 3.2 1.4 .3}\n\
+\\psset{dotsize=.01}\n\
+\\catcode`@=11\n\n", gpoutfile);
+
+    /* Define line type objects */
+    fputs("\
+\\newpsobject{PST@Border}{psline}{linewidth=.0015,linestyle=solid}\n\
+\\newpsobject{PST@Axes}{psline}{linewidth=.0015,linestyle=dotted,dotsep=.004}\n\
+\\newpsobject{PST@Solid}{psline}{linewidth=.0015,linestyle=solid}\n\
+\\newpsobject{PST@Dashed}{psline}{linewidth=.0015,linestyle=dashed,dash=.01 .01}\n\
+\\newpsobject{PST@Dotted}{psline}{linewidth=.0025,linestyle=dotted,dotsep=.008}\n\
+\\newpsobject{PST@LongDash}{psline}{linewidth=.0015,linestyle=dashed,dash=.02 .01}\n", gpoutfile);
+
+    /* Define point objects */
+
+#ifdef	OLD_PST
+    /* PSTricks version 0.91 had x and diamond dot types */
+    fputs("\
+\\newpsobject(PST@Diamond}{psdots}{linewidth=.001,linestyle=solid,dotstyle=diamond}\n\
+\\newpsobject(PST@Filldiamond}{psdots}{linewidth=.001,linestyle=solid,dotstyle=diamond*}\n\
+\\newpsobject{PST@Cross}{psdots}{linewidth=.001,linestyle=solid,dotstyle=x}\n", gpoutfile);
+#else
+    /* Newer versions use rotated plus and square to get the x and diamond dots */
+    fputs("\
+\\newpsobject{PST@Diamond}{psdots}{linewidth=.001,linestyle=solid,dotstyle=square,dotangle=45}\n\
+\\newpsobject{PST@Filldiamond}{psdots}{linewidth=.001,linestyle=solid,dotstyle=square*,dotangle=45}\n\
+\\newpsobject{PST@Cross}{psdots}{linewidth=.001,linestyle=solid,dotstyle=+,dotangle=45}\n", gpoutfile);
+#endif
+
+    fputs("\
+\\newpsobject{PST@Plus}{psdots}{linewidth=.001,linestyle=solid,dotstyle=+}\n\
+\\newpsobject{PST@Square}{psdots}{linewidth=.001,linestyle=solid,dotstyle=square}\n\
+\\newpsobject{PST@Circle}{psdots}{linewidth=.001,linestyle=solid,dotstyle=o}\n\
+\\newpsobject{PST@Triangle}{psdots}{linewidth=.001,linestyle=solid,dotstyle=triangle}\n\
+\\newpsobject{PST@Pentagon}{psdots}{linewidth=.001,linestyle=solid,dotstyle=pentagon}\n\
+\\newpsobject{PST@Fillsquare}{psdots}{linewidth=.001,linestyle=solid,dotstyle=square*}\n\
+\\newpsobject{PST@Fillcircle}{psdots}{linewidth=.001,linestyle=solid,dotstyle=*}\n\
+\\newpsobject{PST@Filltriangle}{psdots}{linewidth=.001,linestyle=solid,dotstyle=triangle*}\n\
+\\newpsobject{PST@Fillpentagon}{psdots}{linewidth=.001,linestyle=solid,dotstyle=pentagon*}\n", gpoutfile);
+
+    /* Define arrow object */
+    fputs("\
+\\newpsobject{PST@Arrow}{psline}{linewidth=.001,linestyle=solid}\n\
+\\catcode`@=12\n\n\
+\\fi\n", gpoutfile);
+
+    /* Set the scaled plot size, if it's not a unit plot */
+    if (!PST_unit_plot) {
+	fputs("\\psset{unit=5.0in,xunit=5.0in,yunit=3.0in}\n", gpoutfile);
+    }
+    /* HBB 20001027: fix bounding box bug by letting the currently
+     * active 'size' and 'offset' setting influence the area used by
+     * the picture environment */
+    fprintf(gpoutfile, "\
+\\pspicture(%f,%f)(%f,%f)\n\
+\\ifx\\nofigs\\undefined\n\
+\\catcode`@=11\n\n",
+	    xoffset,
+	    yoffset,
+	    (xoffset + xsize),
+	    (yoffset + ysize)
+    );
+}
+
+
+TERM_PUBLIC void
+PSTRICKS_text()
+{
+    PSTRICKS_endline();
+    fputs("\
+\\catcode`@=12\n\
+\\fi\n\
+\\endpspicture\n", gpoutfile);
+}
+
+
+TERM_PUBLIC void
+PSTRICKS_linetype(int linetype)
+{
+    PSTRICKS_endline();
+
+    if (linetype >= PSTRICKS_NUMLINES - 2)
+	linetype %= (PSTRICKS_NUMLINES - 2);
+
+    if (linetype < -2)
+	linetype = LT_BLACK;
+
+    PSTRICKS_type = linetype;
+}
+
+
+
+TERM_PUBLIC void
+PSTRICKS_move(unsigned int x, unsigned int y)
+{
+    PSTRICKS_endline();
+
+    PSTRICKS_posx = x / PSTRICKS_XMAX;
+    PSTRICKS_posy = y / PSTRICKS_YMAX;
+}
+
+
+TERM_PUBLIC void
+PSTRICKS_point(unsigned int x, unsigned int y, int number)
+{
+    PSTRICKS_move(x, y);
+
+    /* Print the character defined by 'number'; number < 0 means
+       to use a dot, otherwise one of the defined points. */
+
+    if (number < 0) {
+	fprintf(gpoutfile, "\\qdisk(%.4f,%.4f){%.4f}\n",
+		x / PSTRICKS_XMAX,
+		y / PSTRICKS_YMAX,
+		PSTRICKS_TINY_DOT);
+    } else {
+	fprintf(gpoutfile, "%s(%.4f,%.4f)\n",
+		PSTRICKS_points[number % PSTRICKS_POINT_TYPES],
+		x / PSTRICKS_XMAX,
+		y / PSTRICKS_YMAX);
+    }
+}
+
+
+TERM_PUBLIC void
+PSTRICKS_vector(unsigned ux, unsigned uy)
+{
+    if (!PSTRICKS_inline) {
+	PSTRICKS_inline = TRUE;
+
+	/* Start a new line. This depends on line type */
+	fprintf(gpoutfile, "%s(%.4f,%.4f)\n",
+		PSTRICKS_lines[PSTRICKS_type + 2],
+		PSTRICKS_posx, PSTRICKS_posy);
+	PSTRICKS_linecount = 1;
+    } else {
+	/*
+	 * Even though we are in middle of a path,
+	 * we may want to start a new path command.
+	 * If they are too long then latex will choke.
+	 */
+	if (PSTRICKS_linecount++ >= PSTRICKS_LINEMAX) {
+	    /* fprintf(gpoutfile, "\n"); */
+	    fprintf(gpoutfile, "%s(%.4f,%.4f)\n",
+		    PSTRICKS_lines[PSTRICKS_type + 2],
+		    PSTRICKS_posx, PSTRICKS_posy);
+	    PSTRICKS_linecount = 1;
+	}
+    }
+    PSTRICKS_posx = ux / PSTRICKS_XMAX;
+    PSTRICKS_posy = uy / PSTRICKS_YMAX;
+    fprintf(gpoutfile, "(%.4f,%.4f)\n", PSTRICKS_posx, PSTRICKS_posy);
+}
+
+static void
+PSTRICKS_endline()
+{
+    if (PSTRICKS_inline) {
+	putc('\n', gpoutfile);
+	PSTRICKS_inline = FALSE;
+    }
+}
+
+
+TERM_PUBLIC void
+PSTRICKS_arrow(
+    unsigned int sx, unsigned int sy,
+    unsigned int ex, unsigned int ey,
+    int head)
+{
+    fprintf(gpoutfile, "\\PST@Arrow%s(%.4f,%.4f)(%.4f,%.4f)\n",
+	    head ? "{->}" : "",
+	    sx / PSTRICKS_XMAX,
+	    sy / PSTRICKS_YMAX,
+	    ex / PSTRICKS_XMAX,
+	    ey / PSTRICKS_YMAX);
+
+    PSTRICKS_posx = ex / PSTRICKS_XMAX;
+    PSTRICKS_posy = ey / PSTRICKS_YMAX;
+}
+
+/*
+ * A really ugly hack!!!
+ *
+ * This function takes an input string and hacks it up.  If the
+ * input string starts with a number, it converts the number into a
+ * TeX style number including exponential notation.  Thus, if
+ * the input is the string "3.14159e3 is a number", then
+ * the output is "$3.14159\cdot 10^{3}$ is a number", so that TeX
+ * will produce something nice.
+ *
+ * This is basically meant for producing axis labels that look nice.
+ *
+ * What a hack!
+ */
+
+
+static char *
+PSTRICKS_hack_text(const char *s)
+{
+    double value;
+    char *ends;
+    static char hack[BUFSIZ];
+
+    /*
+     * Does the string start with a number?
+     */
+
+    value = strtod(s, &ends);
+
+    if (s == ends) {
+	/*
+	 * This doesn't start a number, so just copy the string over
+	 */
+
+	strcpy(hack, s);
+    } else {
+	char *ptr;
+
+	/*
+	 * We have a number!  Check to see if the number
+	 * is in scientific notation
+	 */
+
+	safe_strncpy(hack, s, ends - s + 1);
+	/* hack[ends - s] = '\0'; */
+
+	ptr = strchr(hack, 'e');
+	if (ptr == NULL) {
+	    ptr = strchr(hack, 'E');
+	}
+	if (ptr != NULL) {
+	    /*
+	     * Exponential notation!  Let's get the mantissa and exponent separately
+	     */
+
+	    double man_val;
+	    int expo_val;
+
+	    *ptr = NUL;
+
+	    man_val = atof(hack);
+	    expo_val = atoi(ptr + 1);
+
+	    if (man_val == 0) {
+		sprintf(hack, "0");
+	    } else if (man_val == 1) {
+		sprintf(hack, "$10^{%d}$", expo_val);
+	    } else if (man_val == (int) man_val) {
+		if (expo_val == 1) {
+		    sprintf(hack, "$%d$", (int) man_val);
+		} else {
+		    sprintf(hack, "$%d \\times 10^{%d}$", (int) man_val, expo_val);
+		}
+	    } else {
+		if (expo_val == 1) {
+		    sprintf(hack, "$%f$", man_val);
+		} else {
+		    sprintf(hack, "$%f \\times 10^{%d}$", man_val, expo_val);
+		}
+	    }
+	}
+	/*
+	 * Copy anything that's left of the string
+	 */
+
+	strcat(hack, ends);
+    }
+
+    return hack;
+}
+
+TERM_PUBLIC void
+PSTRICKS_put_text(unsigned int x, unsigned int y, const char str[])
+{
+    PSTRICKS_endline();
+
+    /* Skip this if the string is empty */
+
+    if (strlen(str) > 0) {
+	fputs("\\rput", gpoutfile);
+
+	/* Set justification */
+
+	switch (PSTRICKS_justify) {
+	case LEFT:
+	    fputs("[l]", gpoutfile);
+	    break;
+	case CENTRE:
+	    break;
+	case RIGHT:
+	    fputs("[r]", gpoutfile);
+	    break;
+	}
+
+	/* Set text angle */
+
+	switch (PSTRICKS_angle) {
+	case 0:
+	    break;
+	case 1:
+	    fputs("{L}", gpoutfile);
+	    break;
+	}
+
+	/* Set reference position and text */
+
+	fprintf(gpoutfile, "(%.4f,%.4f)",
+		x / PSTRICKS_XMAX,
+		y / PSTRICKS_YMAX);
+	if (PST_hack_text) {
+	    char *hack;
+
+	    /* Hack leading numbers to something nice for TeX */
+
+	    hack = PSTRICKS_hack_text(str);
+	    fprintf(gpoutfile, "{%s}\n", hack);
+	} else {
+	    fprintf(gpoutfile, "{%s}\n", str);
+	}
+    }
+}
+
+
+
+TERM_PUBLIC int
+PSTRICKS_justify_text(enum JUSTIFY mode)
+{
+    PSTRICKS_justify = mode;
+    return (TRUE);
+}
+
+TERM_PUBLIC int
+PSTRICKS_text_angle(int ang)
+{
+    PSTRICKS_angle = (ang ? 1 : 0);
+    return (TRUE);
+}
+
+TERM_PUBLIC void
+PSTRICKS_reset()
+{
+    PSTRICKS_endline();
+    PSTRICKS_posx = PSTRICKS_posy = 0;
+}
+
+
+TERM_PUBLIC int
+PSTRICKS_make_palette (t_sm_palette *palette)
+{
+    /* Query to determine palette size */
+    if (palette==NULL) {
+	return PSTRICKS_palette_size;
+    }
+
+    if (PSTRICKS_palette_set == FALSE) {
+	int i;
+	/* Create new palette */
+	PSTRICKS_palette_set = TRUE;
+	if (sm_palette.colorMode == SMPAL_COLOR_MODE_GRAY) {
+	    /* Grey palette */
+	    for (i=0; i < sm_palette.colors; i++) {
+		double g = i * 1.0 / (sm_palette.colors - 1);
+		g = 1e-3 * (int)(g * 1000); /* round to 3 digits to use %g below */
+		fprintf(gpoutfile, "\\newgray{PST@COLOR%d}{%g}\n", i, g);
+	    }
+	} else
+	    if (sm_palette.colorMode == SMPAL_COLOR_MODE_RGB) {
+		/* Color palette */
+		double r, g, b;
+		for (i=0; i < sm_palette.colors; i++) {
+		    /* round to 3 digits to avoid sth like 1e-7 in %g below */
+		    r = 1e-3 * (int)(palette->color[i].r * 1000);
+		    g = 1e-3 * (int)(palette->color[i].g * 1000);
+		    b = 1e-3 * (int)(palette->color[i].b * 1000);
+		    fprintf(gpoutfile, "\\newrgbcolor{PST@COLOR%d}{%g %g %g}\n", i, r, g, b);
+		}
+	    }
+    }
+    /* use the following macro to shorten the file size */
+    fprintf(gpoutfile, "\\def\\polypmIIId#1{\\pspolygon[linestyle=none,fillstyle=solid,fillcolor=PST@COLOR#1]}\n\n");
+    return 0;
+}
+
+
+TERM_PUBLIC void
+PSTRICKS_set_color (t_colorspec *colorspec)
+{
+    int new_color;
+    double gray = colorspec->value;
+
+    if (colorspec->type != TC_FRAC)
+	return;
+
+    new_color = (gray <=0) ? 0 : (int)(gray*sm_palette.colors);
+    if (new_color >= PSTRICKS_palette_size)
+	new_color = PSTRICKS_palette_size - 1;
+    if (PSTRICKS_palette_set == FALSE) {
+	fprintf(stderr, "pstricks: Palette used before set!\n");
+    }
+#ifdef PSTRICKS_SHORTER_FILE
+    PSTRICKS_color = new_color;
+#else
+    sprintf(PSTRICKS_color_str, "PST@COLOR%d", new_color);
+#endif
+}
+
+
+TERM_PUBLIC void
+PSTRICKS_filled_polygon (int points, gpiPoint *corners)
+{
+    int i;
+
+#ifdef PSTRICKS_SHORTER_FILE
+    /* using a macro for an abbreviation */
+    fprintf(gpoutfile, "\\polypmIIId{%d}", PSTRICKS_color);
+#else
+    fprintf(gpoutfile, "\\pspolygon[linestyle=none,fillstyle=solid,fillcolor=%s]", PSTRICKS_color_str);
+#endif
+    for (i=0; i < points; i++) {
+	if (i % 8 == 7) /* up to 8 corners per line */
+	    fprintf(gpoutfile, "\n");
+	fprintf(gpoutfile,"(%.4g,%.4g)", corners[i].x/PSTRICKS_XMAX, corners[i].y/PSTRICKS_YMAX);
+    }
+    fprintf(gpoutfile, "\n");
+}
+
+#endif /* TERM_BODY */
+
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(pstricks_driver)
+    "pstricks", "LaTeX picture environment with PSTricks macros",
+    PSTRICKS_XMAX, PSTRICKS_YMAX, PSTRICKS_VCHAR, PSTRICKS_HCHAR,
+    PSTRICKS_VTIC, PSTRICKS_HTIC, PSTRICKS_options, PSTRICKS_init, PSTRICKS_reset,
+    PSTRICKS_text, null_scale, PSTRICKS_graphics, PSTRICKS_move, PSTRICKS_vector,
+    PSTRICKS_linetype, PSTRICKS_put_text, PSTRICKS_text_angle,
+    PSTRICKS_justify_text, PSTRICKS_point, PSTRICKS_arrow, set_font_null, 0,
+    TERM_BINARY /*flags*/, 0 /*suspend*/, 0 /*resume*/, 0 , 0
+#ifdef USE_MOUSE
+    , 0, 0, 0, 0, 0
+#endif
+     , PSTRICKS_make_palette, 0,  PSTRICKS_set_color, PSTRICKS_filled_polygon
+TERM_TABLE_END(pstricks_driver)
+
+#undef LAST_TERM
+#define LAST_TERM pstricks_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(pstricks)
+"1 pstricks",
+"?commands set terminal pstricks",
+"?set terminal pstricks",
+"?set term pstricks",
+"?terminal pstricks",
+"?term pstricks",
+"?pstricks",
+" The `pstricks` driver is intended for use with the \"pstricks.sty\" macro",
+" package for LaTeX.  It is an alternative to the `eepic` and `latex` drivers.",
+" You need \"pstricks.sty\", and, of course, a printer that understands",
+" PostScript, or a converter such as Ghostscript.",
+"",
+" PSTricks is available via anonymous ftp from the /pub directory at",
+" Princeton.edu.  This driver definitely does not come close to using the full",
+" capability of the PSTricks package.",
+"",
+" Syntax:",
+"       set terminal pstricks {hacktext | nohacktext} {unit | nounit}",
+"",
+" The first option invokes an ugly hack that gives nicer numbers; the second",
+" has to do with plot scaling.  The defaults are `hacktext` and `nounit`."
+END_HELP(pstricks)
+#endif /* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/qms.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/qms.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/qms.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/qms.trm.svn-base	2012-01-03 17:07:43.539889100 -0800
@@ -0,0 +1,238 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: qms.trm,v 1.12 2006/07/21 02:35:48 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - qms.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *  QMS laser printers
+ *
+ * AUTHORS
+ *  Colin Kelley, Thomas Williams, Russell Lang
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+
+/*
+ * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(qms)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void QMS_init __PROTO((void));
+TERM_PUBLIC void QMS_graphics __PROTO((void));
+TERM_PUBLIC void QMS_text __PROTO((void));
+TERM_PUBLIC void QMS_linetype __PROTO((int linetype));
+TERM_PUBLIC void QMS_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void QMS_vector __PROTO((unsigned int x2, unsigned int y2));
+TERM_PUBLIC void QMS_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
+TERM_PUBLIC void QMS_reset __PROTO((void));
+
+#define QMS_XMAX 9000
+#define QMS_YMAX 6000
+
+#define QMS_XLAST (QMS_XMAX - 1)
+#define QMS_YLAST (QMS_YMAX - 1)
+
+#define QMS_VCHAR		120
+#define QMS_HCHAR		70
+#define QMS_VTIC		70
+#define QMS_HTIC		70
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+static int qms_line = 0;	/* to remember current line type */
+
+TERM_PUBLIC void
+QMS_init()
+{
+    /* This was just ^IOL, but at Rutgers at least we need some more stuff */
+    fputs("^PY^-\n^IOL\n^ISYNTAX00000^F^IB11000^IJ00000^IT00000\n", gpoutfile);
+    /*     ^ QUIC on    ^set defaults  ^ set botttom,top,left margins
+     *            ^landscape         ^free format
+     */
+
+/* set defaults are: implicit decimal point, units in inches,
+ * numbers left justified, units in 1/1000 inch, do not ignore spaces
+ * margins are in 1/1000 inch units
+ */
+}
+
+
+TERM_PUBLIC void
+QMS_graphics()
+{
+    fputs("^IGV\n", gpoutfile);
+    /*     ^enter graphics vector mode */
+}
+
+
+
+TERM_PUBLIC void
+QMS_text()
+{
+/* added ^-, because ^, after an ^I command doesn't actually print a page */
+/* Did anybody try this code out?  [uhh...-cdk] */
+    fputs("^IGE\n^-^,", gpoutfile);
+    /*     ^exit graphics vector mode
+     *           ^pass terminator
+     *             ^print page
+     */
+}
+
+
+TERM_PUBLIC void
+QMS_linetype(int linetype)
+{
+    static int width[2 + 9] = { 7, 3, 3, 3, 3, 5, 5, 5, 7, 7, 7 };
+    static int type[2 + 9] = { 0, 1, 0, 2, 3, 0, 2, 3, 0, 2, 3 };
+/*
+ * I don't know about Villanova, but on our printer, using ^V without
+ * previously setting up a pattern crashes the microcode.
+ * [nope, doesn't crash here. -cdk]
+ * [it generates a controller error here on dotted lines. - rjl]
+ */
+/* Code to define patterns added by rjl
+ * According to the manual it should work - but it doesn't
+ */
+    qms_line = linetype;
+    if (linetype >= 9)
+	linetype %= 9;
+
+    fprintf(gpoutfile, "^PW%02d\n", width[linetype + 2]);
+/*	                 ^width in dots */
+
+    switch (type[linetype + 2]) {
+    case 1:			/* short dash */
+	fputs("^PV102025^G\n^V1\n", gpoutfile);
+	/* ^PV = define pattern vector, 1 = pattern number,
+	 * 02 = number of pen downs and ups, 025 = .025" length of ups/downs
+	 */
+	break;
+    case 2:			/* medium dash */
+	fputs("^PV202050^G\n^V2\n", gpoutfile);
+	break;
+    case 3:			/* long dash */
+	fputs("^PV302100^G\n^V3\n", gpoutfile);
+	break;
+    default:
+    case 0:
+	fputs("^V0\n", gpoutfile);
+	break;
+    }
+}
+
+
+TERM_PUBLIC void
+QMS_move(unsigned int x, unsigned int y)
+{
+    fprintf(gpoutfile, "^U%05d:%05d\n", 1000 + x, QMS_YLAST + 1000 - y);
+    /*                   ^pen up vector*/
+}
+
+
+TERM_PUBLIC void
+QMS_vector(unsigned int x2, unsigned int y2)
+{
+    fprintf(gpoutfile, "^D%05d:%05d\n", 1000 + x2, QMS_YLAST + 1000 - y2);
+    /*                  ^pen down vector*/
+}
+
+
+TERM_PUBLIC void
+QMS_put_text(unsigned int x, unsigned int y, const char str[])
+{
+    char ch;
+    QMS_move(x, y + QMS_VCHAR / 3);
+    fputs("^IGE\n", gpoutfile);
+    ch = *str++;
+    while (ch != NUL) {
+	if (ch == '^')
+	    putc('^', gpoutfile);
+	putc(ch, gpoutfile);
+	ch = *str++;
+    }
+    fputs("\n^IGV\n", gpoutfile);
+    QMS_linetype(qms_line);	/* restore line type */
+}
+
+
+TERM_PUBLIC void
+QMS_reset()
+{
+    fputs("^PN^-\n", gpoutfile);
+    /*     ^QUIC off */
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+TERM_TABLE_START(qms_driver)
+    "qms", "QMS/QUIC Laser printer (also Talaris 1200 and others)",
+    QMS_XMAX, QMS_YMAX, QMS_VCHAR, QMS_HCHAR,
+    QMS_VTIC, QMS_HTIC, options_null, QMS_init, QMS_reset,
+    QMS_text, null_scale, QMS_graphics, QMS_move, QMS_vector,
+    QMS_linetype, QMS_put_text, null_text_angle,
+    null_justify_text, line_and_point, do_arrow, set_font_null
+TERM_TABLE_END(qms_driver)
+
+#undef LAST_TERM
+#define LAST_TERM qms_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(qms)
+"1 qms",
+"?commands set terminal qms",
+"?set terminal qms",
+"?set term qms",
+"?terminal qms",
+"?term qms",
+"?qms",
+" The `qms` terminal driver supports the QMS/QUIC Laser printer, the Talaris",
+" 1200 and others.  It has no options."
+END_HELP(qms)
+#endif
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/regis.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/regis.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/regis.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/regis.trm.svn-base	2012-01-03 17:07:43.767479300 -0800
@@ -0,0 +1,274 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: regis.trm,v 1.15 2006/07/21 02:35:48 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - regis.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *  REGIS devices
+ *
+ * AUTHORS
+ *  Colin Kelley, Thomas Williams
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(regis)
+#endif
+
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void REGIS_init __PROTO((void));
+TERM_PUBLIC void REGIS_graphics __PROTO((void));
+TERM_PUBLIC void REGIS_init __PROTO((void));
+TERM_PUBLIC void REGIS_graphics __PROTO((void));
+TERM_PUBLIC void REGIS_text __PROTO((void));
+TERM_PUBLIC void REGIS_linetype __PROTO((int linetype));
+TERM_PUBLIC void REGIS_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void REGIS_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void REGIS_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC int REGIS_text_angle __PROTO((int ang));
+TERM_PUBLIC void REGIS_reset __PROTO((void));
+TERM_PUBLIC void REGIS_options __PROTO((void));
+
+#define REGISXMAX 800
+#define REGISYMAX 440
+
+#define REGISXLAST (REGISXMAX - 1)
+#define REGISYLAST (REGISYMAX - 1)
+
+#define REGISVCHAR		20
+#define REGISHCHAR		9
+#define REGISVTIC		8
+#define REGISHTIC		6
+
+/* is defined in plot.h
+#define TRUE 1
+#define FALSE 0
+*/
+#endif
+
+
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+static int REGIS16color = FALSE;
+
+static int REGISang = 0;
+
+TERM_PUBLIC void
+REGIS_init()
+{
+    fputs("\033[r\033[24;1H", gpoutfile);
+    /*     1     2
+     * 1. reset scrolling region
+     * 2. locate cursor on bottom line
+     */
+}
+
+
+/* thanks to calmasd!dko (Dan O'Neill) for adding S(E) for vt125s */
+TERM_PUBLIC void
+REGIS_graphics()
+{
+    fputs("\033[2J\033P1pS(C0)S(E)T(A0)\n", gpoutfile);
+    /*     1      2      3    4   5
+     * 1. clear screen
+     * 2. enter ReGIS graphics
+     * 3. turn off graphics diamond cursor
+     * 4. clear graphics screen
+     * 5. character set option.
+     */
+    (void) REGIS_text_angle(0);	/* select text size and angle */
+}
+
+
+TERM_PUBLIC void
+REGIS_text()
+{
+    fputs("\033\\\033[24;1H", gpoutfile);
+    /*     1    2
+     * 1. Leave ReGIS graphics mode
+     * 2. locate cursor on last line of screen
+     */
+}
+
+
+TERM_PUBLIC void
+REGIS_linetype(int linetype)
+{
+    /* This will change color in order G,R,B,G-dot,R-dot,B-dot */
+
+    static int in_16_map[15 + 2] = { 7, 7, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
+    static int lt_16_map[15 + 2] = { 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
+    static int in_map[9 + 2] = { 2, 2, 3, 2, 1, 3, 2, 1, 3, 2, 1 };
+    static int lt_map[9 + 2] = { 1, 4, 1, 1, 1, 4, 4, 4, 6, 6, 6 };
+
+    if (linetype < -2)
+	linetype = LT_BLACK;
+
+    if (!REGIS16color) {
+	if (linetype >= 9)
+	    linetype %= 9;
+	fprintf(gpoutfile, "W(I%d)\n", in_map[linetype + 2]);
+	fprintf(gpoutfile, "W(P%d)\n", lt_map[linetype + 2]);
+    } else {
+	if (linetype >= 15)
+	    linetype %= 15;
+	fprintf(gpoutfile, "W(I%d)\n", in_16_map[linetype + 2]);
+	fprintf(gpoutfile, "W(P%d)\n", lt_16_map[linetype + 2]);
+    }
+}
+
+
+
+/*
+** The \n was added in the functions below (and above) in order to not cause
+** a buffer overflow in devices that can't deal with long line lengths.
+** The DEC vt-340 doesn't need this, but Reflection 4, a vt-340 emulator
+** for PC's under MS-DOS and Microsoft Windows does need it.
+** Also needed for DECterm, a vt-340 emulator for use with Motif 1.0
+** on Open/VMS.
+** NGB 9/13/93
+*/
+
+TERM_PUBLIC void
+REGIS_move(unsigned int x, unsigned int y)
+{
+    fprintf(gpoutfile, "P[%d,%d]\n", x, REGISYLAST - y);
+}
+
+
+TERM_PUBLIC void
+REGIS_vector(unsigned int x, unsigned int y)
+{
+    fprintf(gpoutfile, "v[]v[%d,%d]\n", x, REGISYLAST - y);
+    /* the initial v[] is needed to get the first pixel plotted */
+}
+
+
+/* put_text and text_angle by rjl */
+TERM_PUBLIC void
+REGIS_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    if (REGISang == 1)
+	REGIS_move(x - REGISVCHAR / 2 - 1, y);
+    else
+	REGIS_move(x, y + REGISVCHAR / 2 - 1);
+    (void) putc('T', gpoutfile);
+    (void) putc('\'', gpoutfile);
+    while (*str) {
+	(void) putc(*str, gpoutfile);
+	if (*str == '\'')
+	    (void) putc('\'', gpoutfile);	/* send out another one */
+	str++;
+    }
+    (void) putc('\'', gpoutfile);
+    (void) putc('\n', gpoutfile);
+}
+
+
+TERM_PUBLIC int
+REGIS_text_angle(int ang)
+{
+    REGISang = (ang ? 1 : 0);
+    if (REGISang == 1)
+	fputs("T(D90,S1)\n", gpoutfile);
+    else
+	fputs("T(D0,S1)\n", gpoutfile);
+    return TRUE;
+}
+
+
+TERM_PUBLIC void
+REGIS_reset()
+{
+    fputs("\033[2J\033[24;1H", gpoutfile);
+}
+
+TERM_PUBLIC void
+REGIS_options()
+{
+    int i = 0;
+    struct value a;
+
+    if (!END_OF_COMMAND) {
+	i = (int) real(const_express(&a));
+    }
+    REGIS16color = (i == 16);
+    sprintf(term_options, "%s", REGIS16color ? "16" : "4");
+}
+
+#endif
+
+
+#ifdef TERM_TABLE
+TERM_TABLE_START(regis_driver)
+    "regis", "REGIS graphics language",
+    REGISXMAX, REGISYMAX, REGISVCHAR, REGISHCHAR,
+    REGISVTIC, REGISHTIC, REGIS_options, REGIS_init, REGIS_reset,
+    REGIS_text, null_scale, REGIS_graphics, REGIS_move, REGIS_vector,
+    REGIS_linetype, REGIS_put_text, REGIS_text_angle,
+    null_justify_text, line_and_point, do_arrow, set_font_null
+TERM_TABLE_END(regis_driver)
+
+#undef LAST_TERM
+#define LAST_TERM regis_driver
+#endif
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(regis)
+"1 regis",
+"?commands set terminal regis",
+"?set terminal regis",
+"?set term regis",
+"?terminal regis",
+"?term regis",
+"?regis",
+" The `regis` terminal device generates output in the REGIS graphics language.",
+" It has the option of using 4 (the default) or 16 colors.",
+"",
+" Syntax:",
+"       set terminal regis {4 | 16}"
+END_HELP(regis)
+#endif
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/rgip.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/rgip.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/rgip.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/rgip.trm.svn-base	2012-01-03 17:07:43.963988900 -0800
@@ -0,0 +1,618 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: rgip.trm,v 1.17 2006/07/21 02:35:48 sfeam Exp $
+ */
+
+/* GNUPLOT - rgip.trm Uniplex graphics metafile */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *   RGIP metafile
+ *
+ * AUTHORS
+ *   Hans Olav Eggestad
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+
+/*
+ * Original for direct RGIP Metafile output.
+ */
+/*
+ * Max pixels for X and Y in one window is 10000.
+ */
+/*
+ * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(rgip)
+register_term(uniplex)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void RGIP_init __PROTO((void));
+TERM_PUBLIC void RGIP_graphics __PROTO((void));
+TERM_PUBLIC void RGIP_text __PROTO((void));
+TERM_PUBLIC void RGIP_linetype __PROTO((int lt));
+TERM_PUBLIC void RGIP_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void RGIP_vector __PROTO((unsigned int ux, unsigned int uy));
+TERM_PUBLIC int RGIP_text_angle __PROTO((int ang));
+TERM_PUBLIC int RGIP_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC void RGIP_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC void RGIP_reset __PROTO((void));
+TERM_PUBLIC void RGIP_do_point __PROTO((unsigned int x, unsigned int y, int number));
+TERM_PUBLIC void RGIP_options __PROTO((void));
+#define RGIP_X_MAX 10000
+#define RGIP_Y_MAX 6700
+
+#define RGIP_FONTSIZE 1
+#define RGIP_SC (300)
+#define RGIP_XMAX 9900
+#define RGIP_YMAX 6600
+#define RGIP_HTIC (100)
+#define RGIP_VTIC (100)
+#define RGIP_VCHAR (RGIP_FONTSIZE*RGIP_SC)
+#define RGIP_HCHAR (RGIP_VCHAR*3/7)
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+
+void RGIP_write_poly __PROTO((void));
+static unsigned char *RGIP_cvts __PROTO((unsigned char *str, int *lcnt));
+/* static void RGIP_setfont __PROTO((int sz)); */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#define RGIPDOTS 0
+#define RGIPMARK 1
+#define RGIPTEXT 2
+#define RGIPLINE 3
+#define RGIPPOLY 4
+#define RGIP_MAX_POLY 250
+static char *RGIP_Obj[6] =
+{"DOTS", "MARK", "TEXT", "LINE", "POLY"};
+
+/*
+ * RGIP fontsises range from 1 to 8
+ */
+
+#define RGIP_FACES 3
+#define RGIP_FSTYLES 4
+#define RGIP_FSIZES 8
+#define RGIP_HELVETICA 0
+#define RGIP_TIMES 1
+#define RGIP_COURIER 2
+#define RGIP_LINE_WIDTHS 8	/* future, currently invisible and visible 0
+				   and 1 */
+#define RGIP_LINE_TYPES 8
+#define RGIP_COLORS 16
+#define RGIP_POINT_TYPES 8
+
+
+
+
+static int RGIP_orgX;		/* absolute-pixel-ORIgin of graph.      */
+static int RGIP_orgY;
+static int RGIP_orgx;		/* absolute-pixel-ORIgin of current plot. */
+static int RGIP_orgy;
+static int RGIP_posx;		/* current drawing position (lines).    */
+static int RGIP_posy;
+/* static int RGIP_inplot; */
+static int RGIP_xmax = RGIP_XMAX;	/* width of graph in pixels.         */
+static int RGIP_ymax = RGIP_YMAX;	/* height of graph in pixels.        */
+static int RGIP_winx = RGIP_XMAX;	/* width of graph in pixels.         */
+static int RGIP_winy = RGIP_YMAX;	/* height of graph in pixels.        */
+/* static int RGIP_blofs; */            /* BaseLine OFfSet from bounding box.*/
+static int RGIP_angle = 0;	/* 0 for horizontal text, 90 for vertical */
+static int RGIP_portrait = 0;	/* 0 for horizontal text, 90 for vertical */
+static enum JUSTIFY RGIP_justify = LEFT;	/* left/center/right */
+static int RGIP_fface = 2;	/* Times */
+static int RGIP_ftype = 1;	/* style roman */
+static int RGIP_fontsize = RGIP_FONTSIZE;	/*  */
+static int RGIP_tcol = 7;	/* text color */
+static int RGIP_lsty = 1;	/* line style */
+static int RGIP_lcol = 7;	/* line color */
+static int RGIP_lwid = 1;	/* line width */
+static int RGIP_fsty = 8;	/* fill style */
+static int RGIP_fcol = 8;	/* fill color */
+static int RGIP_mcol = 7;	/* marker color */
+static int RGIP_msty = 1;	/* marker style */
+static int RGIP_msize = 1;	/* marker size */
+
+static int RGIP_win_horiz = 1;
+static int RGIP_win_verti = 1;
+static int RGIP_plot_nr = 0;
+
+unsigned int RGIP_vecpos;
+unsigned int RGIP_xvector[RGIP_MAX_POLY];
+unsigned int RGIP_yvector[RGIP_MAX_POLY];
+static unsigned char *RGIP_cvts();
+
+
+TERM_PUBLIC void
+RGIP_init()
+{
+    register struct termentry *t = term;
+
+    RGIP_posx = RGIP_posy = 0;
+
+    if (RGIP_portrait) {
+	RGIP_orgX = (RGIP_Y_MAX - RGIP_YMAX) / 2;
+	RGIP_orgY = (RGIP_X_MAX - RGIP_XMAX) / 2;
+	RGIP_xmax = RGIP_winx = (int) (RGIP_YMAX / RGIP_win_horiz);
+	RGIP_ymax = RGIP_winy = (int) (RGIP_XMAX / RGIP_win_verti);
+    } else {
+	RGIP_orgX = (RGIP_X_MAX - RGIP_XMAX) / 2;
+	RGIP_orgY = (RGIP_Y_MAX - RGIP_YMAX) / 2;
+	RGIP_xmax = RGIP_winx = (int) (RGIP_XMAX / RGIP_win_horiz);
+	RGIP_ymax = RGIP_winy = (int) (RGIP_YMAX / RGIP_win_verti);
+    }
+
+    t->xmax = (unsigned int) (RGIP_xmax);
+    t->ymax = (unsigned int) (RGIP_ymax);
+
+    RGIP_vecpos = 0;
+}
+
+TERM_PUBLIC void
+RGIP_graphics()
+{
+    static int Gnr = 0;
+    struct stat buf;
+    unsigned char *p, fn[128];
+
+    int tmpx, tmpy;
+    /*    int xoff, yoff; */
+
+    if (RGIP_vecpos) {
+	RGIP_write_poly();
+    }
+    if (!Gnr || RGIP_plot_nr >= (RGIP_win_horiz * RGIP_win_verti)) {
+	fstat(fileno(gpoutfile), &buf);
+	if (S_ISREG(buf.st_mode)) {
+	    if (outstr && (p = (unsigned char *) strchr(outstr, 'X'))) {
+                /* substitute X with graphnr */
+ 		if (!Gnr) {	/* delete the base file */
+		    unlink(outstr);	/* should we close it first ? ? ? */
+		} else {
+		    fputs("%RI_GROUPEND\n", gpoutfile);
+		    fclose(gpoutfile);
+		}
+		*p = NUL;
+		sprintf(fn, "%s%1d%s", outstr, ++Gnr, p + 1);
+		if ((gpoutfile = fopen(fn, "w")) == (FILE *) NULL) {
+		    os_error(NO_CARET, "cannot reopen file with binary type; output unknown");
+		}
+		*p = 'X';	/* put back X */
+	    }
+	}
+	fprintf(gpoutfile, "\
+%RGIP_METAFILE: 1.0a\n\
+%RI_GROUPSTART\n\
+0 0 %d %d SetWindow\n\
+100 100 %d %d 10 1 7 1 8 BOX\n",
+		(RGIP_portrait) ? RGIP_Y_MAX : RGIP_X_MAX,
+		(RGIP_portrait) ? RGIP_X_MAX : RGIP_Y_MAX,
+		(RGIP_portrait) ? RGIP_YMAX : RGIP_XMAX,
+		(RGIP_portrait) ? RGIP_XMAX : RGIP_YMAX);
+	RGIP_plot_nr = 0;
+    } else {
+	fputs("%RI_GROUPEND\n", gpoutfile);
+    }
+    fputs("%RI_GROUPSTART\n", gpoutfile);
+    RGIP_plot_nr++;
+    /* Gnr++; */
+    tmpx = RGIP_orgX + ((RGIP_plot_nr - 1) % RGIP_win_horiz) * RGIP_winx;
+    tmpy = RGIP_orgY + ((RGIP_win_verti - 1) - (int) ((RGIP_plot_nr - 1) / RGIP_win_horiz)) * RGIP_winy;
+    RGIP_orgx = tmpx + (int) ((RGIP_winx - RGIP_xmax) / 2);
+    RGIP_orgy = tmpy + (int) ((RGIP_winy - RGIP_ymax) / 2);
+
+
+    /* RGIP_linetype(-1); */
+}
+
+TERM_PUBLIC void
+RGIP_text()
+{
+}
+
+TERM_PUBLIC void
+RGIP_linetype(int lt)
+{
+/*    int pen, pattern; */
+
+    if (RGIP_vecpos) {
+	RGIP_write_poly();
+    }
+
+    if (lt <= LT_BLACK) {
+	lt = 1;
+	RGIP_lwid = 5;
+    } else if (lt == LT_AXIS) {
+	lt = 5;
+	RGIP_lwid = 2;
+    } else {
+	RGIP_lwid = (int) (lt / RGIP_LINE_TYPES);
+	if (RGIP_lwid < 1)
+	    RGIP_lwid = 1;
+	RGIP_lwid *= 2;
+	lt = (lt % RGIP_LINE_TYPES) + 1;
+    }
+    fputs("%RI_GROUPEND\n\
+%RI_GROUPSTART\n", gpoutfile);
+
+    /* RGIP_lsty  = (lt == 0 || lt == 2) ? 1 : lt; */
+
+    RGIP_lsty = lt;
+}
+
+
+TERM_PUBLIC void
+RGIP_move(unsigned int x, unsigned int y)
+{
+/*
+    fputs("%RI_GROUPEND\n", gpoutfile);
+    fputs("%RI_GROUPSTART\n", gpoutfile);
+*/
+    if (RGIP_vecpos) {
+	RGIP_write_poly();
+    }
+    RGIP_xvector[0] = x + RGIP_orgx;
+    RGIP_yvector[0] = y + RGIP_orgy;
+    RGIP_vecpos = 1;
+    /*
+       RGIP_posx = x;
+       RGIP_posy = y;
+     */
+}
+
+
+TERM_PUBLIC void
+RGIP_vector(unsigned int ux, unsigned int uy)
+{
+    /* store polygon-node */
+
+    RGIP_xvector[RGIP_vecpos] = ux + RGIP_orgx;
+    RGIP_yvector[RGIP_vecpos] = uy + RGIP_orgy;
+    RGIP_vecpos++;
+    if (RGIP_vecpos >= RGIP_MAX_POLY) {
+	RGIP_write_poly();
+	RGIP_xvector[RGIP_vecpos] = ux + RGIP_orgx;
+	RGIP_yvector[RGIP_vecpos] = uy + RGIP_orgy;
+	RGIP_vecpos++;
+    }
+}
+
+void
+RGIP_write_poly()
+{
+    register int i;
+
+    putc('[', gpoutfile);
+    for (i = 0; i < RGIP_vecpos; i++) {
+	if (!(i % 8))
+	    putc('\n', gpoutfile);
+	fprintf(gpoutfile, " %1d\
+ %1d",
+		RGIP_xvector[i],
+		RGIP_yvector[i]);
+    }
+    RGIP_vecpos = 0;
+    putc(']', gpoutfile);
+
+    fprintf(gpoutfile, " %1d %d %1d %1d %1d %s\n", RGIP_lwid, RGIP_lsty,
+	    RGIP_lcol, RGIP_fsty, RGIP_fcol, RGIP_Obj[RGIPPOLY]);
+
+    /*
+       RGIP_posx = ux;
+       RGIP_posy = uy;
+     */
+    /* RGIP_move(ux, uy); */
+}
+
+
+TERM_PUBLIC int
+RGIP_text_angle(int ang)
+{
+    if (RGIP_vecpos) {
+	RGIP_write_poly();
+    }
+    if (RGIP_angle != ang) {
+	RGIP_angle = ang;	/* record for later use */
+    }
+    return (TRUE);
+}
+
+TERM_PUBLIC int
+RGIP_justify_text(enum JUSTIFY mode)
+{
+    if (RGIP_vecpos) {
+	RGIP_write_poly();
+    }
+    RGIP_justify = mode;
+    return (TRUE);
+}
+
+static unsigned char *
+RGIP_cvts(unsigned char *str, int *lcnt)
+{
+    unsigned char *cp1;
+    unsigned char *cp2;
+    static unsigned char *buf = NULL;
+    int lc = 1;
+
+    lc = 1;
+    /* Free up old buffer, if there is one, get a new one.  Since       */
+    /* all transformations shorten the string, get a buffer that is     */
+    /* the same size as the input string.                               */
+
+    if (buf != NULL)
+	(void) free(buf);
+    buf = (unsigned char *) gp_alloc(strlen(str), "converted label string");
+
+    /* Do the transformations. */
+
+    cp1 = str;
+    cp2 = buf;
+    while (strlen(cp1) > 0) {
+	switch (*cp1) {
+	case '\\':		/* Escape sequence. */
+	    if (*++cp1 == '\\') {
+		/* Begin new line. */
+		*cp2++ = '\n';
+		lc++;
+		break;
+	    }
+	case '(':
+	    *cp2++ = '\\';
+	    *cp2++ = '(';
+	    break;
+	case ')':
+	    *cp2++ = '\\';
+	    *cp2++ = ')';
+	    break;
+	    /* Fall through to just copy next char out. */
+
+	default:
+	    *cp2++ = *cp1;
+	    break;
+	}
+	cp1++;
+    }
+
+    *cp2++ = '\n';
+    *cp2 = NUL;
+    *lcnt = lc;
+    return (buf);
+}
+
+TERM_PUBLIC void
+RGIP_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    register struct termentry *t = term;
+    unsigned char *cvstr, *p;
+    int xlines;			/* lines */
+
+    if (RGIP_vecpos) {
+	RGIP_write_poly();
+    }
+    cvstr = RGIP_cvts(str, &xlines);
+
+    x += RGIP_orgx,
+	y += RGIP_orgy;
+
+    if (!RGIP_angle) {		/* horisontal */
+	y += (int) (t->v_char) * (xlines - 2) / 2;
+	/* y += (t->v_char)*xlines; */
+	y += (int) (t->v_char) / 4;
+    } else {
+	x -= (int) (t->v_char) * (xlines - 2) / 2;
+	x -= (int) (t->v_char) / 4;
+    }
+
+    while ((p = (unsigned char *) strchr(cvstr, '\n'))) {
+	*p = '\0';
+	if (strlen(cvstr))
+	    fprintf(gpoutfile, "%1d %1d %1d  %1d (%s) %1d %1d %1d %1d %s\n",
+		    x, y, RGIP_justify, RGIP_angle, cvstr, RGIP_fface,
+		    RGIP_ftype, RGIP_fontsize, RGIP_tcol, RGIP_Obj[RGIPTEXT]);
+	cvstr = ++p;
+	if (RGIP_angle) {	/* vertical */
+	    x += (t->v_char);
+	} else {
+	    y -= (t->v_char);
+	}
+    }
+}
+
+
+TERM_PUBLIC void
+RGIP_reset()
+{
+    if (RGIP_vecpos) {
+	RGIP_write_poly();
+    }
+    fputs("%RI_GROUPEND\n", gpoutfile);
+    /* fputs("%RI_GROUPEND\n", gpoutfile); */
+}
+
+#if 0 /* HBB 20040619: found commented out --- why? */
+RGIP_setfont(int sz)
+{
+    RGIP_fontsize = (int) (sz);
+    if ( RGIP_fontsize < 1 )
+	RGIP_fontsize = 1;
+    term->v_char = RGIP_fontsize * RGIP_SC;
+    term->h_char = RGIP_fontsize * RGIP_SC * 3 / 7;
+}
+#endif
+
+TERM_PUBLIC void
+RGIP_do_point(unsigned int x, unsigned int y, int number)
+{
+
+    x += RGIP_orgx,
+	y += RGIP_orgy;
+
+    if (number < 0) {		/* do dot */
+	fprintf(gpoutfile, "%1d %1d %1d %s\n",
+		x, y, RGIP_mcol, RGIP_Obj[RGIPDOTS]);
+	return;
+    }
+    RGIP_msty = (number % RGIP_POINT_TYPES) + 1;
+    RGIP_msize = ((int) (number / RGIP_POINT_TYPES)) + 1;
+
+    fprintf(gpoutfile, "%1d %1d %1d %1d %1d %s\n",
+	    x, y, RGIP_msize, RGIP_msty, RGIP_mcol, RGIP_Obj[RGIPMARK]);
+}
+
+TERM_PUBLIC void
+RGIP_options()
+{
+    struct value a;
+
+    while (!END_OF_COMMAND) {
+	if (almost_equals(c_token, "p$ortrait")) {
+	    RGIP_portrait = TRUE;
+	    c_token++;
+	} else if (almost_equals(c_token, "l$andscape")) {
+	    RGIP_portrait = FALSE;
+	    c_token++;
+	} else if (equals(c_token, "[")) {	/* windows spesified */
+	    c_token++;
+	    /* if (RGIP_plot_nr>1) */
+	    if (equals(c_token, "]")) {
+		/* RGIP_page(); */
+		c_token++;
+		continue;
+	    }
+	    if (END_OF_COMMAND) {
+		int_error(c_token, "no. windows: [horizontal,vertical] expected");
+	    } else if (!equals(c_token, ",")) {
+		RGIP_win_horiz = (int) real(const_express(&a));
+	    }
+	    if (!equals(c_token, ","))
+		int_error(c_token, "',' expected");
+	    c_token++;
+	    if (!equals(c_token, "]")) {
+		RGIP_win_verti = (int) real(const_express(&a));
+	    }
+	    if (!equals(c_token, "]"))
+		int_error(c_token, "expecting ']'");
+	    c_token++;
+	} else {
+	    /* We have font size specified */
+	    RGIP_fontsize = (int) real(const_express(&a));
+	    if (RGIP_fontsize < 1)
+		RGIP_fontsize = 1;
+	    term->v_char = (unsigned int) (RGIP_fontsize * RGIP_SC);
+	    term->h_char = (unsigned int) (RGIP_fontsize * RGIP_SC * 3 / 7);
+	}
+    }
+    sprintf(term_options, "%s %d [%1d,%1d]",
+	    (RGIP_portrait) ? "portrait" : "landscape",
+	    RGIP_fontsize, RGIP_win_horiz, RGIP_win_verti);
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(rgip_driver)
+    "rgip", "RGIP metafile (Uniplex). Option: fontsize (1-8)",
+    RGIP_XMAX, RGIP_YMAX, RGIP_VCHAR, RGIP_HCHAR,
+    RGIP_VTIC, RGIP_HTIC, RGIP_options, RGIP_init, RGIP_reset,
+    RGIP_text, null_scale, RGIP_graphics, RGIP_move,
+    RGIP_vector, RGIP_linetype, RGIP_put_text, RGIP_text_angle,
+    RGIP_justify_text, RGIP_do_point, do_arrow, set_font_null
+TERM_TABLE_END(rgip_driver)
+
+#undef LAST_TERM
+#define LAST_TERM rgip_driver
+
+TERM_TABLE_START(uniplex_driver)
+    "uniplex", "RGIP metafile (Uniplex). Option: fontsize (1-8) (Same as rgip)",
+    RGIP_XMAX, RGIP_YMAX, RGIP_VCHAR, RGIP_HCHAR,
+    RGIP_VTIC, RGIP_HTIC, RGIP_options, RGIP_init, RGIP_reset,
+    RGIP_text, null_scale, RGIP_graphics, RGIP_move,
+    RGIP_vector, RGIP_linetype, RGIP_put_text, RGIP_text_angle,
+    RGIP_justify_text, RGIP_do_point, do_arrow, set_font_null
+TERM_TABLE_END(uniplex_driver)
+
+#undef LAST_TERM
+#define LAST_TERM uniplex_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(rgip)
+"1 rgip",
+"?commands set terminal rgip",
+"?set terminal rgip",
+"?set term rgip",
+"?terminal rgip",
+"?term rgip",
+"?rgip",
+"?commands set terminal uniplex",
+"?set terminal uniplex",
+"?set term uniplex",
+"?terminal uniplex",
+"?term uniplex",
+"?uniplex",
+" The `rgip` and `uniplex` terminal drivers support RGIP metafiles.  They can",
+" combine several graphs on a single page, but only one page is allowed in a",
+" given output file.",
+"",
+" Syntax:",
+"       set terminal rgip | uniplex {portrait | landscape}",
+"                                   {[<horiz>,<vert>]} {<fontsize>}",
+"",
+" permissible values for the font size are in the range 1--8, with the default",
+" being 1.  The default layout is landscape.  Graphs are placed on the page in",
+" a `horiz`x`vert` grid, which defaults to [1,1].",
+"",
+" Example:",
+"       set terminal uniplex portrait [2,3]",
+"",
+" puts six graphs on a page in three rows of two in portrait orientation."
+END_HELP(rgip)
+#endif /* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/sun.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/sun.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/sun.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/sun.trm.svn-base	2012-01-03 17:07:44.184560900 -0800
@@ -0,0 +1,373 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: sun.trm,v 1.14 2008/04/19 04:07:51 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - sun.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *   SUNview windowing system
+ *
+ * AUTHORS
+ *  Maurice Castro
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+/*
+ * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(sun)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void SUN_init __PROTO((void));
+TERM_PUBLIC void SUN_graphics __PROTO((void));
+TERM_PUBLIC void SUN_text __PROTO((void));
+TERM_PUBLIC void SUN_linetype __PROTO((int linetype));
+TERM_PUBLIC void SUN_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void SUN_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void SUN_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC int SUN_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC void SUN_reset __PROTO((void));
+#define SUN_XMAX 600
+#define SUN_YMAX 512
+
+#define SUN_VCHAR (12)		/* default, will be changed */
+#define SUN_HCHAR (8)		/* default, will be changed */
+#define SUN_VTIC (SUN_YMAX/80)
+#define SUN_HTIC (SUN_XMAX/80)
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+#include <suntool/sunview.h>
+#include <suntool/canvas.h>
+#include <suntool/scrollbar.h>
+#include <suntool/panel.h>
+#include <pixrect/pixrect_hs.h>
+
+void sun_setmaskpixel __PROTO((unsigned int x, unsigned int y, unsigned int value));
+void sun_line __PROTO((unsigned int x1, unsigned int x2, unsigned int y1, unsigned int y2));
+static Notify_value local_notice_destroy __PROTO((Frame frame, Destroy_status status));
+
+#define MARGIN 5
+#define MINWIN 128
+
+static Frame frame;
+static Canvas SUN_canvas;
+static Pixwin *pw;
+static struct pixfont *sun_font = NULL;
+
+static enum JUSTIFY sun_justify = LEFT;
+
+static Notify_value local_notice_destroy();
+
+extern Notify_error notify_dispatch();
+
+/* dotted line generator */
+unsigned int sun_value = 1;	/* this can be used for colour */
+unsigned int sun_line_mask = 0xffff;	/* 16 bit mask for dotted lines */
+static unsigned int sun_pattern[] =
+{0xffff, 0x1111,
+ 0xffff, 0x5555, 0x3333, 0x7777, 0x3f3f, 0x0f0f, 0x5f5f};
+int sun_mask_count = 0;
+unsigned int sun_lastx, sun_lasty;	/* last pixel set - used by sun_line */
+
+
+TERM_PUBLIC void
+SUN_init()
+{
+    struct termentry *t = term;
+    struct pr_subregion bound;
+
+    frame = window_create(NULL, FRAME,
+			  FRAME_LABEL, "Gnuplot",
+			  0);
+    notify_interpose_destroy_func(frame, local_notice_destroy);
+    SUN_canvas = window_create(frame, CANVAS,
+			   CANVAS_AUTO_EXPAND, TRUE,
+			   CANVAS_AUTO_SHRINK, TRUE,
+			   CANVAS_MARGIN, MARGIN,
+			   0);
+    notify_do_dispatch();
+    pw = canvas_pixwin(SUN_canvas);
+    window_set(frame, WIN_SHOW, TRUE, 0);
+
+    /* figure out font and rough size */
+    sun_font = pf_default();
+    pf_textbound(&bound, 1, sun_font, "M");
+    t->v_char = bound.size.y;
+    t->h_char = bound.size.x;
+
+    return;
+}
+
+TERM_PUBLIC void
+SUN_graphics()
+{
+    term->xmax = (int) window_get(SUN_canvas, CANVAS_WIDTH);
+    term->ymax = (int) window_get(SUN_canvas, CANVAS_HEIGHT);
+    pw_writebackground(pw, 0, 0, term->xmax, term->ymax, PIX_SRC);
+    notify_dispatch();
+    /* do not let the user make the window too small */
+    if ((term->xmax) < MINWIN) {
+	window_set(frame,
+		   WIN_WIDTH, MINWIN + 2 * MARGIN + 24,
+		   0);
+	notify_dispatch();
+	SUN_graphics();
+    }
+    if ((term->ymax) < MINWIN) {
+	window_set(frame,
+		   WIN_HEIGHT, MINWIN + 2 * MARGIN + 24,
+		   0);
+	notify_dispatch();
+	SUN_graphics();
+    }
+    notify_dispatch();
+    return;
+}
+
+TERM_PUBLIC void
+SUN_text()
+{
+    notify_dispatch();
+    return;			/* enter text from another window!!! */
+}
+
+TERM_PUBLIC void
+SUN_linetype(int linetype)
+{
+    if (linetype < -2)
+	linetype = LT_BLACK;
+    if (linetype >= 7)
+	linetype %= 7;
+    sun_line_mask = sun_pattern[linetype + 2];
+    sun_mask_count = 0;
+}
+
+
+TERM_PUBLIC void
+SUN_move(unsigned int x, unsigned int y)
+{
+    sun_lastx = x;
+    sun_lasty = y;
+    notify_dispatch();
+    return;
+}
+
+TERM_PUBLIC void
+SUN_vector(unsigned int x, unsigned int y)
+{
+    if ((x >= term->xmax) || (y >= term->ymax))
+	return;
+    sun_line(sun_lastx, x, sun_lasty, y);
+    canvas_pixwin(SUN_canvas);
+    notify_dispatch();
+    return;
+}
+
+TERM_PUBLIC void
+SUN_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    struct pr_subregion bound;
+
+    if ((x >= term->xmax) || (y >= term->ymax))
+	return;
+
+    pf_textbound(&bound, strlen(str), sun_font, str);
+    y = term->ymax - 1 - y + bound.size.y / 3;	/* vertical centering */
+
+    switch (sun_justify) {
+    case LEFT:
+	break;
+    case CENTRE:
+	x -= bound.size.x / 2;
+	break;
+    case RIGHT:
+	x -= bound.size.x;
+	break;
+    }
+    pw_text(pw, x, y, PIX_SRC | PIX_DST, 0, str);
+    canvas_pixwin(SUN_canvas);
+    notify_dispatch();
+    return;
+}
+
+
+TERM_PUBLIC int
+SUN_justify_text(enum JUSTIFY mode)
+{
+    sun_justify = mode;
+    return (TRUE);
+}
+
+
+
+
+TERM_PUBLIC void
+SUN_reset()
+{
+
+    term->xmax = SUN_XMAX;
+    term->ymax = SUN_YMAX;
+    window_set(frame, WIN_SHOW, FALSE, 0);
+    return;
+}
+
+
+
+void
+sun_setmaskpixel(unsigned int x, unsigned int y, unsigned int value)
+{
+    /* dotted line generator */
+    if ((sun_line_mask >> sun_mask_count) & (unsigned int) (1)) {
+	pw_put(pw, x, term->ymax - 1 - y, sun_value);
+    }
+    sun_mask_count = (sun_mask_count + 1) % 16;
+    sun_lastx = x;		/* last pixel set with mask */
+    sun_lasty = y;
+}
+
+
+
+
+void
+sun_line(unsigned int x1, unsigned int x2, unsigned int y1, unsigned int y2)
+{
+    int runcount;
+    int dx, dy;
+    int xinc, yinc;
+    unsigned int xplot, yplot;
+
+    runcount = 0;
+    dx = ABS((int) (x1) - (int) (x2));
+    if (x2 > x1)
+	xinc = 1;
+    if (x2 == x1)
+	xinc = 0;
+    if (x2 < x1)
+	xinc = -1;
+    dy = ABS((int) (y1) - (int) (y2));
+    if (y2 > y1)
+	yinc = 1;
+    if (y2 == y1)
+	yinc = 0;
+    if (y2 < y1)
+	yinc = -1;
+    xplot = x1;
+    yplot = y1;
+    if (dx > dy) {
+	/* iterate x */
+	if ((sun_line_mask == 0xffff) ||
+	    ((xplot != sun_lastx) && (yplot != sun_lasty)))
+	    sun_setmaskpixel(xplot, yplot, sun_value);
+	while (xplot != x2) {
+	    xplot += xinc;
+	    runcount += dy;
+	    if (runcount >= (dx - runcount)) {
+		yplot += yinc;
+		runcount -= dx;
+	    }
+	    sun_setmaskpixel(xplot, yplot, sun_value);
+	}
+    } else {
+	/* iterate y */
+	if ((sun_line_mask == 0xffff) ||
+	    ((xplot != sun_lastx) && (yplot != sun_lasty)))
+	    sun_setmaskpixel(xplot, yplot, sun_value);
+	while (yplot != y2) {
+	    yplot += yinc;
+	    runcount += dx;
+	    if (runcount >= (dy - runcount)) {
+		xplot += xinc;
+		runcount -= dy;
+	    }
+	    sun_setmaskpixel(xplot, yplot, sun_value);
+	}
+    }
+}
+
+
+static Notify_value
+local_notice_destroy(Frame frame, Destroy_status status)
+{
+    if (status != DESTROY_CHECKING) {
+	SUN_reset();
+	/* extern TBOOLEAN term_init is gone; is it sufficient just */
+	/* to comment it out? -lh */
+	/* term_init = FALSE; */
+    }
+    return (NOTIFY_DONE);
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(sun_driver)
+    "sun", "SunView window system",
+    SUN_XMAX, SUN_YMAX, SUN_VCHAR, SUN_HCHAR,
+    SUN_VTIC, SUN_HTIC, options_null, SUN_init, SUN_reset,
+    SUN_text, null_scale, SUN_graphics, SUN_move, SUN_vector,
+    SUN_linetype, SUN_put_text, null_text_angle,
+    SUN_justify_text, line_and_point, do_arrow, set_font_null
+TERM_TABLE_END(sun_driver)
+
+#undef LAST_TERM
+#define LAST_TERM sun_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(sun)
+"1 sun",
+"?commands set terminal sun",
+"?set terminal sun",
+"?set term sun",
+"?terminal sun",
+"?term sun",
+"?sun",
+" The `sun` terminal driver supports the SunView window system.  It has no",
+" options."
+END_HELP(sun)
+#endif
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/svg.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/svg.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/svg.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/svg.trm.svn-base	2012-01-03 17:07:44.404130300 -0800
@@ -0,0 +1,1564 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: svg.trm,v 1.101.2.3 2010/03/04 17:16:38 sfeam Exp $
+ */
+
+/*------------------------------------------------------------------------------------------------------------------------------------
+	GNUPLOT - svg.trm
+
+	This file is included by ../term.c.
+
+	This terminal driver supports:
+		W3C Scalable Vector Graphics
+
+	AUTHOR
+
+		Amedeo Farello
+		afarello@libero.it
+
+	HEAVILY MODIFIED by
+
+		Hans-Bernhard Br"oker
+		broeker@physik.rwth-aachen.de
+
+------------------------------------------------------------------------------------------------------------------------------------*/
+
+/* PM3D support by Johannes Zellner <johannes@zellner.org>, May-16-2002 */
+/* set_color fixes by Petr Mikulik <mikulik@physics.muni.cz>, June-10-2002 */
+/* ISO-Latin encoding, Font selection fixes, option "fixed|dynamic" by
+ * Wilhelm Braunschober <Wilhelm.Braunschober@t-online.de>, Feb-21-2002 */
+
+/*
+ * Additional code for gnuplot versions 4.2 and 4.3
+ *
+ *   Tweaked code for compatibility with Sodipodi svg viewer/editor.
+ *   Added enhanced text support.
+ *   Additional line properties.
+ *   Increase resolution by adding a coordinate scale factor.
+ *   CODDLE_NONCOMPLIANT_VIEWERS
+ *   Support dashed lines, TC_* color model.
+ *   Change path markup from    style='attribute: foo'  to   attribute='foo'
+ *
+ * Ethan Merritt  <merritt@u.washington.edu>
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(svg)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void SVG_options __PROTO ((void));
+TERM_PUBLIC void SVG_init __PROTO ((void));
+TERM_PUBLIC void SVG_graphics __PROTO ((void));
+TERM_PUBLIC void SVG_text __PROTO ((void));
+TERM_PUBLIC void SVG_linetype __PROTO ((int linetype));
+TERM_PUBLIC void SVG_move __PROTO ((unsigned int x, unsigned int y));
+TERM_PUBLIC void SVG_vector __PROTO ((unsigned int x, unsigned int y));
+TERM_PUBLIC void SVG_put_text __PROTO ((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC void SVG_reset __PROTO ((void));
+TERM_PUBLIC int SVG_justify_text __PROTO ((enum JUSTIFY mode));
+TERM_PUBLIC int SVG_text_angle __PROTO ((int ang));
+TERM_PUBLIC void SVG_point __PROTO ((unsigned int x, unsigned int y, int pointstyle));
+TERM_PUBLIC int SVG_set_font __PROTO ((const char *font));
+/* TERM_PUBLIC void SVG_pointsize __PROTO((double pointsize)); */
+TERM_PUBLIC void SVG_fillbox __PROTO((int style, unsigned int x1, unsigned int y1, unsigned int width, unsigned int height));
+TERM_PUBLIC void SVG_linewidth __PROTO ((double linewidth));
+TERM_PUBLIC int SVG_make_palette __PROTO((t_sm_palette *));
+TERM_PUBLIC void SVG_previous_palette __PROTO((void));
+TERM_PUBLIC void SVG_set_color __PROTO((t_colorspec *));
+TERM_PUBLIC void SVG_filled_polygon __PROTO((int, gpiPoint *));
+TERM_PUBLIC void SVG_layer __PROTO((t_termlayer syncpoint));
+
+TERM_PUBLIC void ENHsvg_OPEN __PROTO((char *, double, double, TBOOLEAN, TBOOLEAN, int));
+TERM_PUBLIC void ENHsvg_FLUSH __PROTO((void));
+TERM_PUBLIC void ENHsvg_put_text __PROTO((unsigned int, unsigned int, const char *));
+TERM_PUBLIC void ENHsvg_writec __PROTO((int));
+
+TERM_PUBLIC void SVG_path __PROTO((int p));
+
+#define SVG_SCALE	10.
+#define Y(y) ((float)((int)term->ymax - (int)y) / SVG_SCALE)
+#define X(x) ((float)(x) / SVG_SCALE)
+
+#define SVG_XMAX	(600 * SVG_SCALE)
+#define SVG_YMAX	(480 * SVG_SCALE)
+
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+static t_sm_palette SVG_palette;
+static unsigned char SVG_red = 0;
+static unsigned char SVG_green = 0;
+static unsigned char SVG_blue = 0;
+static unsigned char SVG_color_mode = TC_DEFAULT;
+static char *SVG_linecolor = NULL;
+
+static TBOOLEAN SVG_groupFilledIsOpen = FALSE; /* open pm3d group flag*/
+
+struct SVG_PEN
+{
+    double width;
+    char color[8];
+};
+
+static unsigned int SVG_xSize = SVG_XMAX; /* plot horizontal size */
+static unsigned int SVG_ySize = SVG_YMAX; /* plot vertical size*/
+static TBOOLEAN SVG_fixed_size = TRUE;  /* make SVG viewer size fixed */
+
+static unsigned int SVG_xLast = UINT_MAX; /* current pen horizontal position*/
+static unsigned int SVG_yLast = UINT_MAX;	/* current pen vertical position*/
+
+static int SVG_LineType = LT_NODRAW;	/* current line type*/
+static double SVG_LineWidth = 1.0; /* current line width*/
+static double SVG_linewidth_factor = 1.0; /* Multiplier for linewidths */
+static TBOOLEAN SVG_rounded = FALSE; /* linejoin and linecap */
+static int SVG_TextAngle = 0;	/* current text orientation*/
+static enum JUSTIFY SVG_TextJust = LEFT; /* current text justification*/
+
+/* default text font family: */
+static char *SVG_fontNameDef = NULL;
+static double SVG_fontSizeDef = 12;	/* default text size*/
+/* current text font family: */
+static char *SVG_fontNameCur = NULL;
+static double SVG_fontSizeCur = 12;	/* current text size*/
+static TBOOLEAN SVG_groupIsOpen = FALSE; /* open group flag*/
+static TBOOLEAN SVG_pathIsOpen = FALSE; /* open path flag*/
+static unsigned int SVG_path_count = 0;	/* size of current path*/
+static struct SVG_PEN SVG_pens[16];	/* pen descriptors*/
+
+static int SVG_fillPattern = -1; /* active fill pattern (-1 == undefined) */
+static unsigned int SVG_fillPatternIndex = 0;
+
+static int SVG_fontAscent = 0;	/* estimated current font ascent*/
+static int SVG_fontDescent = 0;	/* estimated current font descent*/
+static int SVG_fontLeading = 0;	/* estimated current font leading*/
+static int SVG_fontAvWidth = 0;	/* estimated current font char average width*/
+
+static short SVG_Pen_RealID __PROTO ((int));
+static void SVG_PathOpen __PROTO ((void));
+static void SVG_PathClose __PROTO ((void));
+static void SVG_PathLimit __PROTO ((void));
+static void SVG_GroupOpen __PROTO ((void));
+static void SVG_GroupClose __PROTO ((void));
+static void SVG_SetFont __PROTO ((const char *name, double size));
+static void SVG_GroupFilledOpen __PROTO ((void));
+static void SVG_GroupFilledClose __PROTO ((void));
+static void SVG_StyleColor __PROTO((const char*));
+static void SVG_StyleFillColor __PROTO((void));
+static void SVG_local_reset __PROTO((void));
+static void SVG_DefineFillPattern __PROTO((int fillpat));
+static void SVG_MoveForced __PROTO((unsigned int x, unsigned int y));
+
+/* Points to source of requested embedded font */
+static char *SVG_embedded_font = NULL;
+static void SVG_load_fontfile __PROTO((char *fontfile));
+
+/* Stuff for enhanced text mode */
+static int ENHsvg_string_state = 0;
+static double ENHsvg_x_offset = 0;
+static TBOOLEAN ENHsvg_preserve_spaces = FALSE;
+#define CODDLE_NONCOMPLIANT_VIEWERS 1	/* Use pt rather than em spacing */
+
+/* Support for dashed lines */
+#define SVG_dashtypes 5
+static TBOOLEAN SVG_dashed = FALSE;
+static char *SVG_dashpattern[SVG_dashtypes] = {
+    "", " 5,8", " 1,4", " 8,4,2,4", " 9,4,1,4,1,4"
+    };
+
+/*------------------------------------------------------------------------------------------------------------------------------------
+	SVG_Pen_RealID
+------------------------------------------------------------------------------------------------------------------------------------*/
+static short
+SVG_Pen_RealID (int inPenCode)
+{
+    if (inPenCode >= 13)
+	inPenCode %= 13;	/* normalize pen code*/
+    inPenCode += 3;
+    if (inPenCode < 0)
+	inPenCode = 0;		/* LT_NODRAW or LT_BACKGROUND should use background color */
+
+    return (inPenCode);
+}
+
+/*------------------------------------------------------------------------------------------------------------------------------------
+	SVG_GroupOpen
+------------------------------------------------------------------------------------------------------------------------------------*/
+static void
+SVG_GroupOpen ()
+{
+    SVG_GroupFilledClose();
+    if (!SVG_groupIsOpen) {
+
+	fprintf (gpoutfile, "<g style=\"fill:none; color:%s; stroke:",
+		 SVG_pens[SVG_Pen_RealID (SVG_LineType)].color);
+
+	if (SVG_color_mode == TC_RGB)
+	    fprintf(gpoutfile, "rgb(%3d, %3d, %3d)", SVG_red, SVG_green, SVG_blue);
+	else if (SVG_color_mode == TC_LT)
+	    fprintf(gpoutfile, "%s", SVG_linecolor);
+	else
+	    fprintf(gpoutfile, "currentColor");
+
+	fprintf (gpoutfile, "; stroke-width:%.2f; stroke-linecap:%s; stroke-linejoin:%s",
+		 SVG_pens[SVG_Pen_RealID (SVG_LineType)].width * SVG_linewidth_factor,
+		 SVG_rounded ? "round" : "butt",
+		 SVG_rounded ? "round" : "miter");
+
+	fprintf (gpoutfile, "\">\n");
+
+	SVG_groupIsOpen = TRUE;
+    }
+}
+
+/*------------------------------------------------------------------------------------------------------------------------------------
+	SVG_GroupClose
+------------------------------------------------------------------------------------------------------------------------------------*/
+static void
+SVG_GroupClose ()
+{
+    SVG_GroupFilledClose();
+    if (SVG_groupIsOpen) {
+	  fputs ("</g>\n", gpoutfile);
+	  SVG_groupIsOpen = FALSE;
+	  SVG_fillPattern = -1;
+      }
+}
+
+/*------------------------------------------------------------------------------------------------------------------------------------
+	SVG_PathOpen
+------------------------------------------------------------------------------------------------------------------------------------*/
+static void
+SVG_PathOpen ()
+{
+    if (!SVG_pathIsOpen) {
+	SVG_GroupFilledClose();
+	    
+	fputs ("\t<path ", gpoutfile);
+
+	/* Line color */
+	if (SVG_color_mode == TC_RGB)
+	    fprintf(gpoutfile, "stroke='rgb(%3d, %3d, %3d)' ",
+		    SVG_red, SVG_green, SVG_blue);
+	else if (SVG_color_mode == TC_LT)
+	    fprintf(gpoutfile, "stroke='%s' ", SVG_linecolor);
+	
+	/* Dash patterns */
+	if (SVG_dashed && SVG_LineType % SVG_dashtypes > 0)
+	    fprintf(gpoutfile, "stroke-dasharray='%s' ",
+	 	    SVG_dashpattern[SVG_LineType % SVG_dashtypes]);
+	
+	fputs (" d='", gpoutfile);
+
+	SVG_pathIsOpen = TRUE;
+    }
+}
+
+/*------------------------------------------------------------------------------------------------------------------------------------
+	SVG_PathClose
+------------------------------------------------------------------------------------------------------------------------------------*/
+static void
+SVG_PathClose ()
+{
+    if (SVG_pathIsOpen) {
+	SVG_GroupFilledClose();
+	fputs ("'></path>\n", gpoutfile);
+	SVG_path_count = 0;
+	SVG_pathIsOpen = FALSE;
+    }
+}
+
+/*------------------------------------------------------------------------------------------------------------------------------------
+	SVG_PathLimit
+------------------------------------------------------------------------------------------------------------------------------------*/
+static void
+SVG_PathLimit ()
+{
+    if (SVG_path_count % 8 == 0)	/* avoid excessive line length*/
+	fputs ("\n\t\t", gpoutfile);
+}
+
+/*------------------------------------------------------------------------------------------------------------------------------------
+	SVG_SetFont
+------------------------------------------------------------------------------------------------------------------------------------*/
+static void
+SVG_SetFont (const char *name, double size)
+{
+    if (name != SVG_fontNameCur) {
+	free(SVG_fontNameCur);
+	SVG_fontNameCur = gp_strdup(name);
+    }
+    SVG_fontSizeCur = size;
+
+/* since we cannot interrogate SVG about text properties and according
+ * to SVG 1.0 W3C Candidate Recommendation 2 August 2000 the
+ * "line-height" of the 'text' element is defined to be equal to the
+ * 'font-size' (!), we have to to define font properties in a less
+ * than optimal way */
+
+    SVG_fontAscent = (int) (SVG_fontSizeCur * 1.00 * SVG_SCALE); /* estimated current font ascent*/
+    SVG_fontDescent = (int) (SVG_fontSizeCur * 0.25 * SVG_SCALE); /* estimated current font descent*/
+    SVG_fontLeading = (int) (SVG_fontSizeCur * 0.25 * SVG_SCALE); /* estimated current font leading*/
+    SVG_fontAvWidth = (int) (SVG_fontSizeCur * 0.70 * SVG_SCALE); /* estimated current font char average width*/
+}
+
+static void
+SVG_GroupFilledOpen()
+{
+    if (!SVG_groupFilledIsOpen) {
+	SVG_PathClose();
+	fputs("\t<g style = 'stroke:none; shape-rendering:crispEdges'>\n",
+	      gpoutfile);
+	SVG_groupFilledIsOpen = TRUE;
+    }
+}
+
+static void
+SVG_GroupFilledClose()
+{
+    if (SVG_groupFilledIsOpen) {
+	fputs("\t</g>\n", gpoutfile);
+	SVG_groupFilledIsOpen = FALSE;
+    }
+}
+
+static void
+SVG_StyleColor(const char* paint)
+{
+    if (SVG_color_mode == TC_RGB)
+	fprintf(gpoutfile, "%s = 'rgb(%3d, %3d, %3d)'", paint, SVG_red, SVG_green, SVG_blue);
+    else if (SVG_color_mode == TC_LT)
+	fprintf(gpoutfile, "%s = '%s'", paint, SVG_linecolor);
+    else
+	fprintf(gpoutfile, "%s = 'currentColor'", paint);
+}
+
+static void
+SVG_StyleFillColor()
+{
+    SVG_StyleColor("fill");
+}
+
+static void
+SVG_DefineFillPattern(int fillpat)
+{
+    char *path;
+    char *style="stroke";
+
+    fillpat %= 8;
+    if (fillpat != SVG_fillPattern) {
+	SVG_fillPattern = fillpat;
+	SVG_PathClose();
+	SVG_fillPatternIndex++;
+
+	fprintf(gpoutfile,
+	    "\t<defs>\n"
+	    "\t\t<pattern id='gpPat%d' patternUnits='userSpaceOnUse' x='0' y='0' width='8' height='8'>\n",
+	    SVG_fillPatternIndex);
+	switch (fillpat) {
+	    default:
+	    case 0:
+		    path="";
+		    break;
+	    case 1:
+		    path="M0,0 L8,8 M0,8 L8,0";
+		    break;
+	    case 2:
+		    path="M0,0 L8,8 M0,8 L8,0 M0,4 L4,8 L8,4 L4,0 L0,4";
+		    break;
+	    case 3:
+		    path="M0,0 L0,8 L8,8 L8,0 L0,0";
+		    style="fill";
+		    break;
+	    case 4:
+		    path="M-4,0 L8,12 M0,-4 L12,8";
+		    break;
+	    case 5:
+		    path="M-4,8 L8,-4 M0,12 L12,0";
+		    break;
+	    case 6:
+		    path="M-2,8 L4,-4 M0,12 L8,-4 M4,12 L10,0";
+		    break;
+	    case 7:
+		    path="M-2,0 L4,12 M0,-4 L8,12 M4,-4 L10,8";
+		    break;
+	}
+	if (*path) {
+	    if (SVG_color_mode == TC_RGB)
+		fprintf(gpoutfile,"\t\t\t<path style='fill:none; %s:rgb(%d,%d,%d)' d='%s'/>\n",
+			style, SVG_red, SVG_green, SVG_blue, path);
+	    else if (SVG_color_mode == TC_LT)
+		fprintf(gpoutfile, "\t\t\t<path style = '%s:%s' d= '%s'/>\n",
+			style, SVG_linecolor, path);
+	    else
+		fprintf(gpoutfile, "\t\t\t<path style = '%s:currentColor' d='%s'/>\n",
+			style, path);
+	}
+	fputs("\t\t</pattern>\n" "\t</defs>\n", gpoutfile);
+    }
+}
+
+static void
+SVG_MoveForced(unsigned int x, unsigned int y)
+{
+    if (SVG_path_count > 512)
+	SVG_PathClose();
+
+    SVG_PathOpen ();
+
+    fprintf (gpoutfile, "M%.1f,%.1f ", X(x), Y(y));
+    SVG_path_count++;
+
+    SVG_PathLimit ();
+
+    SVG_xLast = x;
+    SVG_yLast = y;
+}
+
+/*------------------------------------------------------------------------------------------------------------------------------------
+	SVG_options
+------------------------------------------------------------------------------------------------------------------------------------*/
+TERM_PUBLIC void
+SVG_options ()
+{
+    /* Annoying hack to handle the case of 'set termoption' after */
+    /* we have already initialized the terminal settings.         */
+    if (c_token != 2)
+	SVG_local_reset();
+
+    while (!END_OF_COMMAND) {
+	if (almost_equals(c_token, "s$ize")) {
+	    double value;
+
+	    c_token++;
+
+	    if (END_OF_COMMAND)
+		int_error(c_token,"expecting x size");
+	    value = real_expression();
+	    if (value < 2 || value > 8192)
+		int_error(c_token,"x size out of range");
+	    SVG_xSize = value * SVG_SCALE;
+
+	    if (equals(c_token,","))
+		c_token++;
+	    if (END_OF_COMMAND)
+		int_error(c_token,"expecting y size");
+	    value = real_expression();
+	    if (value < 2 || value > 8192)
+		int_error(c_token,"y size out of range");
+	    SVG_ySize = value * SVG_SCALE;
+	    continue;
+	}
+
+	if (almost_equals(c_token, "d$ynamic")) {
+	    c_token++;
+	    SVG_fixed_size = FALSE;
+	    continue;
+	}
+
+	if (almost_equals(c_token, "fi$xed")){
+	    c_token++;
+	    SVG_fixed_size = TRUE;
+	    continue;
+	}
+
+	if (almost_equals(c_token, "enh$anced")) {
+	    c_token++;
+	    term->put_text = ENHsvg_put_text;
+	    term->flags |= TERM_ENHANCED_TEXT;
+	    continue;
+	}
+
+	if (almost_equals(c_token, "noenh$anced")) {
+	    c_token++;
+	    term->put_text = SVG_put_text;
+	    term->flags &= ~TERM_ENHANCED_TEXT;
+	    continue;
+	}
+
+	if (almost_equals(c_token, "fn$ame") || almost_equals(c_token, "font"))  {
+	    char *s, *comma;
+	    c_token++;
+
+	    if (!(s = try_to_get_string()))
+		int_error(c_token,"expecting font name");
+	    comma = strrchr(s,',');
+	    if (comma && (1 == sscanf(comma + 1, "%lf", &SVG_fontSizeDef)))
+		*comma = '\0';
+	    if (*s) {
+		free(SVG_fontNameDef);
+		SVG_fontNameDef = s;
+	    } else
+		free(s);
+	    continue;
+	}
+
+	if (almost_equals(c_token, "fs$ize")) {
+	    c_token++;
+
+	    if (END_OF_COMMAND)
+		int_error(c_token,"fsize: expecting font size");
+	    SVG_fontSizeDef = real_expression();
+	    continue;
+	}
+
+	if (almost_equals(c_token, "fontfile")) {
+	    char *fontfile_name;
+	    c_token++;
+
+	    fontfile_name = try_to_get_string();
+	    if (!fontfile_name)
+                int_error(c_token, "Font filename expected");
+	    gp_expand_tilde(&fontfile_name);
+#if defined(PIPES)
+	    if ( *fontfile_name == '<' ) {
+		SVG_embedded_font = fontfile_name;
+	    } else
+#endif
+		SVG_embedded_font = fontpath_fullname(fontfile_name);
+	    if (!SVG_embedded_font)
+		int_error(c_token, "Font file '%s' not found", fontfile_name);
+
+            continue;
+	}
+
+	if (almost_equals(c_token, "linew$idth") || equals(c_token, "lw")) {
+	    c_token++;
+	    SVG_linewidth_factor = real_expression();
+	    if (SVG_linewidth_factor <= 0.0)
+		SVG_linewidth_factor = 1.0;
+	    continue;
+	}
+									
+	if (almost_equals (c_token, "round$ed")) {
+	    c_token++;
+	    SVG_rounded = TRUE;
+	    continue;
+	}
+									
+	if (equals (c_token, "butt")) {
+	    c_token++;
+	    SVG_rounded = FALSE;
+	    continue;
+	}
+
+	if (equals(c_token, "solid")) {
+	    c_token++;
+	    SVG_dashed = FALSE;
+	    continue;
+	}
+									
+	if (almost_equals(c_token, "dash$ed")) {
+	    c_token++;
+	    SVG_dashed = TRUE;
+	    continue;
+	}
+									
+	int_error(c_token, "unrecognized terminal option");
+    }
+
+    /* I don't think any error checks on font name are possible; just set it */
+    SVG_set_font("");
+
+    /* Save options back into options string in normalized format */
+    sprintf(term_options, "size %d,%d%s %s fname '%s'  fsize %g ",
+	    (int)(SVG_xSize/SVG_SCALE), (int)(SVG_ySize/SVG_SCALE),
+        SVG_fixed_size ? " fixed": " dynamic",
+	term->put_text == ENHsvg_put_text ? "enhanced" : "",
+        SVG_fontNameCur, SVG_fontSizeCur);
+
+    if (SVG_embedded_font) {
+	sprintf(term_options + strlen(term_options),
+	    "fontfile \"%s\" ", SVG_embedded_font);
+    }
+
+    sprintf(term_options + strlen(term_options),
+	SVG_rounded ? "rounded " : "butt ");
+
+    sprintf(term_options + strlen(term_options),
+	SVG_dashed ? "dashed " : "solid ");
+
+    if (SVG_linewidth_factor != 1.0) {
+	sprintf(term_options + strlen(term_options),
+	    "linewidth %3.1f ", SVG_linewidth_factor);
+    }
+
+}
+
+static void
+SVG_local_reset()
+{
+    SVG_xSize      = SVG_XMAX;
+    SVG_ySize      = SVG_YMAX;
+    SVG_fixed_size = TRUE;
+    free(SVG_fontNameDef);
+    SVG_fontNameDef = gp_strdup("Arial");
+    SVG_fontSizeDef  = 12;
+    if (SVG_embedded_font)
+	free(SVG_embedded_font);
+    SVG_embedded_font = NULL;
+}
+
+/*------------------------------------------------------------------------------------------------------------------------------------
+	SVG_init
+------------------------------------------------------------------------------------------------------------------------------------*/
+TERM_PUBLIC void
+SVG_init ()
+{
+    double stroke_width;
+    char *svg_encoding = "";
+
+    /* setup pens*/
+    SVG_pens[0].width = SVG_LineWidth;
+    strcpy (SVG_pens[0].color, "white"); /* should really be background */
+    SVG_pens[1].width = SVG_LineWidth;
+    strcpy(SVG_pens[1].color, "black");
+    SVG_pens[2].width = SVG_LineWidth;
+    strcpy(SVG_pens[2].color, "gray");
+    SVG_pens[3].width = SVG_LineWidth;
+    strcpy(SVG_pens[3].color, "red");
+    SVG_pens[4].width = SVG_LineWidth;
+    strcpy(SVG_pens[4].color, "green");
+    SVG_pens[5].width = SVG_LineWidth;
+    strcpy(SVG_pens[5].color, "blue");
+    SVG_pens[6].width = SVG_LineWidth;
+    strcpy(SVG_pens[6].color, "cyan");
+    SVG_pens[7].width = SVG_LineWidth;
+    sprintf(SVG_pens[7].color, "#%2.2X%2.2X%2.2X", 21, 117, 69); /* pine green*/
+    SVG_pens[8].width = SVG_LineWidth;
+    sprintf (SVG_pens[8].color, "#%2.2X%2.2X%2.2X", 0, 0, 148);	/* navy*/
+    SVG_pens[9].width = SVG_LineWidth;
+    sprintf (SVG_pens[9].color, "#%2.2X%2.2X%2.2X", 255, 153, 0); /* orange*/
+    SVG_pens[10].width = SVG_LineWidth;
+    sprintf (SVG_pens[10].color, "#%2.2X%2.2X%2.2X", 0, 153, 161); /* green blue*/
+    SVG_pens[11].width = SVG_LineWidth;
+    sprintf (SVG_pens[11].color, "#%2.2X%2.2X%2.2X", 214, 214, 69); /* olive*/
+    SVG_pens[12].width = SVG_LineWidth;
+    sprintf (SVG_pens[12].color, "#%2.2X%2.2X%2.2X", 163, 145, 255); /* cornflower*/
+    SVG_pens[13].width = SVG_LineWidth;
+    sprintf (SVG_pens[13].color, "#%2.2X%2.2X%2.2X", 255, 204, 0); /* gold*/
+    SVG_pens[14].width = SVG_LineWidth;
+    sprintf (SVG_pens[14].color, "#%2.2X%2.2X%2.2X", 214, 0, 120); /* mulberry*/
+    SVG_pens[15].width = SVG_LineWidth;
+    sprintf (SVG_pens[15].color, "#%2.2X%2.2X%2.2X", 171, 214, 0); /* green yellow*/
+
+    SVG_LineType = LT_NODRAW;
+
+/* set xmax, ymax*/
+
+    term->xmax = SVG_xSize;
+    term->ymax = SVG_ySize;
+
+/* set current font*/
+
+    SVG_SetFont (SVG_fontNameCur, SVG_fontSizeCur);
+
+/* set h_char, v_char*/
+
+    term->h_char = SVG_fontAvWidth;
+    term->v_char = (SVG_fontAscent + SVG_fontDescent + SVG_fontLeading);
+
+/* set h_tic, v_tic*/
+
+    term->h_tic = term->v_char / 2;
+    term->v_tic = term->v_char / 2;
+
+/* write file header*/
+
+    switch (encoding) {
+	case S_ENC_ISO8859_1:	svg_encoding = "encoding=\"iso-8859-1\" "; break;
+	case S_ENC_ISO8859_2:	svg_encoding = "encoding=\"iso-8859-2\" "; break;
+	case S_ENC_ISO8859_9:	svg_encoding = "encoding=\"iso-8859-9\" "; break;
+	case S_ENC_ISO8859_15:	svg_encoding = "encoding=\"iso-8859-15\" "; break;
+	case S_ENC_CP850:	svg_encoding = "encoding=\"ibm-850\" "; break;
+	case S_ENC_CP852:	svg_encoding = "encoding=\"ibm-852\" "; break;
+	case S_ENC_CP1250:	svg_encoding = "encoding=\"windows-1250\" "; break;
+	case S_ENC_KOI8_R:	svg_encoding = "encoding=\"koi8-r\" "; break;
+	case S_ENC_KOI8_U:	svg_encoding = "encoding=\"koi8-u\" "; break;
+	case S_ENC_CP437:	svg_encoding = ""; break;
+	default: /* UTF-8 */
+				svg_encoding = "encoding=\"utf-8\" ";
+				break;
+    }
+
+    fprintf (gpoutfile,
+	     "<?xml version=\"1.0\" %s standalone=\"no\"?>\n"
+	     "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \n"
+	     " \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n"
+	     "<svg ", svg_encoding);
+
+    if (SVG_fixed_size)
+        fprintf (gpoutfile, "width=\"%u\" height=\"%u\" ",
+		 (unsigned int) (term->xmax / SVG_SCALE),
+		 (unsigned int) (term->ymax / SVG_SCALE));
+
+    fprintf (gpoutfile, "viewBox=\"0 0 %u %u\"\n",
+	     (unsigned int) (term->xmax / SVG_SCALE),
+	     (unsigned int) (term->ymax / SVG_SCALE));
+    fprintf (gpoutfile, " xmlns=\"http://www.w3.org/2000/svg\"\n");
+    fprintf (gpoutfile, " xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n");
+#if (0)
+    /* This should be required, but Firefox gets it totally wrong */
+    fprintf (gpoutfile, " xml:space=\"preserve\"\n");
+#endif
+    fprintf (gpoutfile, ">\n\n");
+
+    fprintf (gpoutfile,
+	     "<desc>Produced by GNUPLOT %s patchlevel %s </desc>\n\n",
+	     gnuplot_version, gnuplot_patchlevel);
+
+    /* Start prologue section of output file, and load fonts if requested */
+    fprintf(gpoutfile,"<defs>\n");
+    if (SVG_embedded_font)
+	SVG_load_fontfile(SVG_embedded_font);
+
+    /* definitions of point symbols */
+    /* FIXME: SVG scales linewidth along with the marker itself, and
+     * there seems to be no way to avoid that without copying the
+     * marker definition into the file, rather than referencing a
+     * defined one :-( That would make for much larger files */
+    /* "\t<path id='gpPt3' stroke-width='%.3f' d='M-1,-1 h2 v2 h-2 z'/>\n" */
+
+    stroke_width = 2.0 *SVG_SCALE / term->h_tic;
+    fprintf (gpoutfile,
+	     "\n"
+	     /* dot: */
+	     "\t<circle id='gpDot' r='0.5' stroke-width='0.5'/>\n"
+	     /*  0 plus */
+	     "\t<path id='gpPt0' stroke-width='%.3f' stroke='currentColor' d='M-1,0 h2 M0,-1 v2'/>\n"
+	     /*  1 X */
+	     "\t<path id='gpPt1' stroke-width='%.3f' stroke='currentColor' d='M-1,-1 L1,1 M1,-1 L-1,1'/>\n"
+	     /*  2 star */
+	     "\t<path id='gpPt2' stroke-width='%.3f' stroke='currentColor' d='M-1,0 L1,0 M0,-1 L0,1 M-1,-1 L1,1 M-1,1 L1,-1'/>\n"
+	     /*  3 box */
+	     "\t<rect id='gpPt3' stroke-width='%.3f' stroke='currentColor' x='-1' y='-1' width='2' height='2'/>\n"
+	     /*  4 box                   filled */
+	     "\t<rect id='gpPt4' stroke-width='%.3f' stroke='currentColor' fill='currentColor' x='-1' y='-1' width='2' height='2'/>\n"
+	     /*  5 circle */
+	     "\t<circle id='gpPt5' stroke-width='%.3f' stroke='currentColor' cx='0' cy='0' r='1'/>\n"
+	     /*  6 circle (disk)         filled */
+	     "\t<use xlink:href='#gpPt5' id='gpPt6' fill='currentColor' stroke='none'/>\n"
+	     /*  7 triangle */
+	     "\t<path id='gpPt7' stroke-width='%.3f' stroke='currentColor' d='M0,-1.33 L-1.33,0.67 L1.33,0.67 z'/>\n"
+	     /*  8 triangle  filled */
+	     "\t<use xlink:href='#gpPt7' id='gpPt8' fill='currentColor' stroke='none'/>\n"
+	     /*  9 upside down triangle */
+	     "\t<use xlink:href='#gpPt7' id='gpPt9' stroke='currentColor' transform='rotate(180)'/>\n"
+	     /*  10 upside down triangle filled */
+	     "\t<use xlink:href='#gpPt9' id='gpPt10' fill='currentColor' stroke='none'/>\n"
+	     /* 11 diamond */
+	     "\t<use xlink:href='#gpPt3' id='gpPt11' stroke='currentColor' transform='rotate(45)'/>\n"
+	     /* 12 diamond               filled */
+	     "\t<use xlink:href='#gpPt11' id='gpPt12' fill='currentColor' stroke='none'/>\n"
+
+	     /* NOTE: Fill patterns must be defined after the stroke color has been
+	      * set to use the correct (current) stroke color. Therefore we can't
+	      * define fill patterns here. */
+
+	     "</defs>\n"
+	     , stroke_width
+	     , stroke_width
+	     , stroke_width
+	     , stroke_width
+	     , stroke_width
+	     , stroke_width
+	     , stroke_width
+	);
+}
+
+/*------------------------------------------------------------------------------------------------------------------------------------
+	SVG_graphics
+------------------------------------------------------------------------------------------------------------------------------------*/
+TERM_PUBLIC void
+SVG_graphics ()
+{
+    /* EAM 5-May-2004 We must force a new group with fill:none in order for  */
+    /* multiple plots per page to work. Otherwise new plots are black-filled */
+    SVG_GroupOpen();
+
+    SVG_fillPattern = -1;
+    SVG_fillPatternIndex = 0;
+    SVG_groupFilledIsOpen = FALSE;
+    SVG_color_mode = TC_DEFAULT;
+    SVG_pathIsOpen = FALSE;
+
+/* reset position*/
+
+    SVG_xLast = SVG_yLast = UINT_MAX;
+}
+
+/*------------------------------------------------------------------------------------------------------------------------------------
+	SVG_text
+------------------------------------------------------------------------------------------------------------------------------------*/
+TERM_PUBLIC void
+SVG_text ()
+{
+    SVG_PathClose ();
+    SVG_GroupClose ();
+}
+
+/*------------------------------------------------------------------------------------------------------------------------------------
+	SVG_reset
+------------------------------------------------------------------------------------------------------------------------------------*/
+TERM_PUBLIC void
+SVG_reset ()
+{
+    fputs("</svg>\n\n", gpoutfile);
+}
+
+/*------------------------------------------------------------------------------------------------------------------------------------
+	SVG_linetype
+------------------------------------------------------------------------------------------------------------------------------------*/
+TERM_PUBLIC void
+SVG_linetype (int linetype)
+{
+    SVG_color_mode = TC_DEFAULT;
+    if (linetype != SVG_LineType) {
+	SVG_PathClose ();
+	SVG_GroupClose ();
+	SVG_LineType = linetype;
+	SVG_GroupOpen ();
+    }
+}
+
+TERM_PUBLIC void
+SVG_fillbox(int style, unsigned int x1, unsigned int y1, unsigned int width, unsigned int height)
+{
+    gpiPoint corner[4];
+
+	corner[0].x = x1;        corner[0].y = y1;
+	corner[1].x = x1+width;  corner[1].y = y1;
+	corner[2].x = x1+width;  corner[2].y = y1+height;
+	corner[3].x = x1;        corner[3].y = y1+height;
+	corner->style = style;
+
+	SVG_filled_polygon(4, corner);
+}
+
+/*------------------------------------------------------------------------------------------------------------------------------------
+	SVG_linewidth - verificare
+------------------------------------------------------------------------------------------------------------------------------------*/
+TERM_PUBLIC void
+SVG_linewidth (double linewidth)
+{
+    if (linewidth != SVG_LineWidth) {
+	short k;
+
+	SVG_LineWidth = linewidth;
+
+	for (k = 0; k < 16; k++)
+	    SVG_pens[k].width = SVG_LineWidth;
+
+	SVG_PathClose ();
+	SVG_GroupClose ();
+	SVG_GroupOpen ();
+    }
+}
+
+/*------------------------------------------------------------------------------------------------------------------------------------
+	SVG_move
+------------------------------------------------------------------------------------------------------------------------------------*/
+TERM_PUBLIC void
+SVG_move (unsigned int x, unsigned int y)
+{
+    if (x != SVG_xLast || y != SVG_yLast)  {
+	SVG_MoveForced(x, y);
+    }
+}
+
+/*------------------------------------------------------------------------------------------------------------------------------------
+	SVG_vector
+------------------------------------------------------------------------------------------------------------------------------------*/
+TERM_PUBLIC void
+SVG_vector (unsigned int x, unsigned int y)
+{
+    if (x != SVG_xLast || y != SVG_yLast) {
+
+	if (!SVG_pathIsOpen) {
+	    /* The SVG 'path' MUST have a 'moveto' as first command. */
+	    SVG_MoveForced(SVG_xLast, SVG_yLast);
+	}
+
+	fprintf (gpoutfile, "L%.1f,%.1f ", X(x), Y(y));
+	SVG_path_count++;
+
+	SVG_PathLimit ();
+
+	SVG_xLast = x;
+	SVG_yLast = y;
+    }
+}
+
+/*------------------------------------------------------------------------------------------------------------------------------------
+	SVG_point
+------------------------------------------------------------------------------------------------------------------------------------*/
+TERM_PUBLIC void
+SVG_point (unsigned int x, unsigned int y, int number)
+{
+    char color_spec[0x40];
+    if (SVG_color_mode == TC_RGB)
+   	sprintf(color_spec, " color='rgb(%3d, %3d, %3d)'",
+		SVG_red, SVG_green, SVG_blue);
+    else if (SVG_color_mode == TC_LT)
+	sprintf(color_spec, " color='%s'", SVG_linecolor);
+    else
+	*color_spec = '\0';
+
+    SVG_PathClose ();
+
+    if (number < 0) {		/* do dot */
+	fprintf (gpoutfile, "\
+\t<use xlink:href='#gpDot' x='%.1f' y='%.1f'%s/>\n",
+		 X(x), Y(y), color_spec);
+    } else {			/* draw a point symbol */
+	fprintf (gpoutfile, "\
+\t<use xlink:href='#gpPt%u' transform='translate(%.1f,%.1f) scale(%.2f)'%s/>\
+\n",
+		 number % 13, X(x), Y(y),
+		 term_pointsize * term->h_tic / (2 * SVG_SCALE),
+		 color_spec);
+    }
+    SVG_xLast = x;
+    SVG_yLast = y;
+}
+
+/*------------------------------------------------------------------------------------------------------------------------------------
+	SVG_justify_text
+------------------------------------------------------------------------------------------------------------------------------------*/
+TERM_PUBLIC int
+SVG_justify_text (enum JUSTIFY mode)
+{
+    SVG_TextJust = mode;
+    return (TRUE);
+}
+
+/*------------------------------------------------------------------------------------------------------------------------------------
+	SVG_text_angle
+------------------------------------------------------------------------------------------------------------------------------------*/
+TERM_PUBLIC int
+SVG_text_angle (int ang)
+{
+    /* Can only do pure horizontal or vertical */
+    SVG_TextAngle = ang;
+    return (TRUE);
+}
+
+/*------------------------------------------------------------------------------------------------------------------------------------
+	SVG_put_text
+------------------------------------------------------------------------------------------------------------------------------------*/
+TERM_PUBLIC void
+SVG_put_text (unsigned int x, unsigned int y, const char *str)
+{
+    char *alignment;
+    int h = x, v = y;
+
+    SVG_PathClose ();
+
+/* horizontal justification*/
+
+    switch (SVG_TextJust) {
+    case LEFT:
+	alignment = "start";
+	break;
+    case CENTRE:
+	alignment = "middle";
+	break;
+    case RIGHT:
+    default:   /* can't happen, just to make gcc happy */
+	alignment = "end";
+	break;
+    }
+
+/* vertical justification*/
+
+    if (SVG_TextAngle % 180) {
+	/* vertical text */
+	h += (SVG_fontAscent - SVG_fontDescent) / 2;
+    } else {
+	/* horizontal text */
+	v -= (SVG_fontAscent - SVG_fontDescent) / 2;
+    }
+
+/* define text position and attributes */
+
+    fprintf (gpoutfile, "\t<g transform=\"translate(%.1f,%.1f)", X(h), Y(v));
+    if (SVG_TextAngle)
+	fprintf (gpoutfile, " rotate(%i)", -SVG_TextAngle);
+    fprintf (gpoutfile, "\" style=\"stroke:none; fill:");
+
+    if (SVG_color_mode == TC_RGB)
+	fprintf (gpoutfile, "rgb(%d,%d,%d)", SVG_red, SVG_green, SVG_blue);
+    else if (SVG_color_mode == TC_LT)
+	fprintf (gpoutfile, "%s", SVG_linecolor);
+    else
+	fprintf (gpoutfile, "%s", SVG_pens[SVG_Pen_RealID (SVG_LineType)].color);
+
+    fprintf (gpoutfile,
+	     "; font-family:%s; font-size:%.2fpt; text-anchor:%s\">\n",
+	     SVG_fontNameCur, SVG_fontSizeCur, alignment);
+
+/* output text (unless the enhanced_text processing is in action) */
+
+    if (strstr(str,"  "))
+	fputs ("\t\t<text xml:space=\"preserve\">", gpoutfile);
+    else
+	fputs ("\t\t<text>", gpoutfile);
+
+    if (!ENHsvg_string_state) {
+
+	while (*str) {
+	    /* Escape SVG reserved characters */
+	    switch (*str) {
+	    case '<':
+		fputs("&lt;", gpoutfile);
+		break;
+	    case '&':
+		if (str[1] == '#' && str[2] == 'x')
+		    fputc(*str, gpoutfile);
+		else
+		    fputs("&amp;", gpoutfile);
+		break;
+	    default:
+		fputc(*str, gpoutfile);
+		break;
+	    }
+
+	    str++;
+	}
+	fputs("</text>\n\t</g>\n", gpoutfile);
+    }
+}
+
+/*------------------------------------------------------------------------------------------------------------------------------------
+	SVG_set_font
+------------------------------------------------------------------------------------------------------------------------------------*/
+TERM_PUBLIC int
+SVG_set_font (const char *font)
+{
+
+    if (!font || !(*font)) {
+	free(SVG_fontNameCur);
+	SVG_fontNameCur = gp_strdup(SVG_fontNameDef);
+	SVG_fontSizeCur = SVG_fontSizeDef;
+    } else {
+	int sep = strcspn(font,",");
+	if (sep > 0) {
+	    free(SVG_fontNameCur);
+	    SVG_fontNameCur = gp_strdup(font);
+	    SVG_fontNameCur[sep] = NUL;
+	}
+	if (font[sep] == ',')
+	    sscanf(font + sep + 1, "%lf", &SVG_fontSizeCur);
+    }
+
+    return (TRUE);
+}
+
+
+/*------------------------------------------------------------------------------------------------------------------------------------
+	SVG_make_palette
+------------------------------------------------------------------------------------------------------------------------------------*/
+TERM_PUBLIC int
+SVG_make_palette(t_sm_palette *palette)
+{
+    SVG_GroupFilledClose();
+    if (palette == NULL) {
+	/* svg can do continuous colors */
+	return 0;
+    }
+
+    /* save mapping formulae needed if SMPAL_COLOR_MODE_RGB */
+    SVG_palette.colorMode = palette->colorMode;
+    SVG_palette.formulaR = palette->formulaR;
+    SVG_palette.formulaG = palette->formulaG;
+    SVG_palette.formulaB = palette->formulaB;
+    SVG_palette.positive = palette->positive;
+
+    return 0;
+}
+
+
+/*------------------------------------------------------------------------------------------------------------------------------------
+	SVG_set_color
+------------------------------------------------------------------------------------------------------------------------------------*/
+TERM_PUBLIC void
+SVG_set_color(t_colorspec *colorspec)
+{
+    rgb255_color rgb255;
+
+    if (colorspec->type == TC_LT) {
+	SVG_linecolor = SVG_pens[SVG_Pen_RealID (colorspec->lt)].color;
+	SVG_color_mode = TC_LT;
+	return;
+    } else if (colorspec->type == TC_FRAC)
+	rgb255maxcolors_from_gray( colorspec->value, &rgb255 );
+    else if (colorspec->type == TC_RGB) {
+	rgb255.r = colorspec->lt >> 16;
+	rgb255.g = colorspec->lt >> 8 & 0xff;
+	rgb255.b = colorspec->lt & 0xff;
+    } else
+	return;
+
+    SVG_color_mode = TC_RGB;
+
+    if (rgb255.r != SVG_red || rgb255.g != SVG_green || rgb255.b != SVG_blue) {
+	/* pm3d color has changed. We've to start a new path
+	 * with a different line color. This is necessary when
+	 * using "linetype palette". */
+	SVG_PathClose();
+	SVG_red = rgb255.r;
+	SVG_green = rgb255.g;
+	SVG_blue = rgb255.b;
+    }
+
+    return;
+}
+
+/*------------------------------------------------------------------------------------------------------------------------------------
+	SVG_previous_palette
+------------------------------------------------------------------------------------------------------------------------------------*/
+TERM_PUBLIC void
+SVG_previous_palette()
+{
+    SVG_GroupFilledClose();
+}
+
+
+/*------------------------------------------------------------------------------------------------------------------------------------
+	SVG_filled_polygon
+------------------------------------------------------------------------------------------------------------------------------------*/
+TERM_PUBLIC void
+SVG_filled_polygon(int points, gpiPoint* corners)
+{
+    int i;
+    int fillpar = corners->style >> 4;
+    int style = corners->style &= 0xf;
+
+    if (style == FS_PATTERN || style == FS_TRANSPARENT_PATTERN) {
+	/* make sure the pattern is defined (with the current stroke color)
+	 * must be defined AFTER the current group is opened with the color
+	 * attribute set, as the patterns use 'currentColor' */
+	SVG_DefineFillPattern(fillpar);
+    }
+
+    SVG_GroupFilledOpen();
+    fputs("\t\t<polygon ", gpoutfile);
+
+    switch (style) {
+	case FS_EMPTY: /* fill with background color */
+	    /* TODO: and what if the background color is not white ? */
+	    fputs(" fill = 'white'", gpoutfile);
+	    break;
+	case FS_SOLID: /* solid fill */
+	case FS_TRANSPARENT_SOLID:
+	    SVG_StyleFillColor();
+	    if (fillpar >= 0 && fillpar < 100)
+		fprintf(gpoutfile, " fill-opacity = '%f'", fillpar * 0.01);
+	    break;
+	case FS_PATTERN: /* pattern fill */
+	case FS_TRANSPARENT_PATTERN:
+	    fprintf(gpoutfile, " fill = 'url(#gpPat%d)'",
+		    SVG_fillPatternIndex);
+	    break;
+	default:
+	    SVG_StyleFillColor();
+	    break;
+    }
+
+    fputs(" points = '", gpoutfile);
+    for (i = 0; i < points; i++)
+        fprintf(gpoutfile, "%.1f,%.1f%s",
+		X(corners[i].x), Y(corners[i].y),
+		i % 16 == 15 ? "\n" : " ");
+    fputs("'/>\n", gpoutfile);
+}
+
+/*------------------------------------------------------------------------------------------------------------------------------------
+	SVG_layer
+------------------------------------------------------------------------------------------------------------------------------------*/
+TERM_PUBLIC void
+SVG_layer(t_termlayer syncpoint)
+{
+    static int plotno = 0;
+
+    /* We must ignore all syncpoints that we don't recognize */
+    switch (syncpoint) {
+
+    	default:
+		break;
+
+	case TERM_LAYER_BEFORE_PLOT:
+		SVG_PathClose();
+		SVG_GroupClose();
+		fprintf(gpoutfile, "\t<a xlink:title=\"Plot #%d\">\n", ++plotno);
+		SVG_LineType = LT_UNDEFINED; /* Force a new group on next stroke */
+		break;
+
+	case TERM_LAYER_AFTER_PLOT:
+		SVG_PathClose();
+		SVG_GroupClose();
+		fprintf(gpoutfile, "\t</a>\n");
+		SVG_LineType = LT_UNDEFINED; /* Force a new group on next stroke */
+		break;
+
+	case TERM_LAYER_RESET:
+		plotno = 0;
+		break;
+    }
+}
+
+
+/* Enhanced text mode support starts here */
+
+static double ENHsvg_base = 0.0;
+static TBOOLEAN ENHsvg_opened_string = FALSE;
+static int ENHsvg_charcount = 0;
+
+TERM_PUBLIC void
+ENHsvg_OPEN(
+    char *fontname,
+    double fontsize, double base,
+    TBOOLEAN widthflag, TBOOLEAN showflag,
+    int overprint)
+{
+    /* overprint = 1 means print the base text (leave position in center)
+     * overprint = 2 means print the overlying text
+     * overprint = 3 means save current position
+     * overprint = 4 means restore saved position
+     * EAM FIXME - Unfortunately I can find no way in the svg spec to do this.
+     * The best I can come up with is to count characters from here and then
+     * try to back up over them.
+     */
+    switch (overprint) {
+    case 2:
+#ifdef CODDLE_NONCOMPLIANT_VIEWERS
+	fprintf(gpoutfile, "<tspan dx=\"-%.1fpt\" dy=\"%.1fpt\">", 
+		0.3 * ENHsvg_charcount * 1.1*SVG_fontSizeCur, ENHsvg_base-base);
+#else
+	fprintf(gpoutfile, "<tspan dx=\"-%.1fem\" dy=\"%.1fpt\">", 
+		0.3 * ENHsvg_charcount, ENHsvg_base-base);
+#endif
+	ENHsvg_base = base;
+	ENHsvg_x_offset = 0.0;
+	enhanced_cur_text = enhanced_text;
+	ENHsvg_charcount = 0;
+	ENHsvg_opened_string = TRUE;
+	break;
+    case 3:
+	ENHsvg_charcount = 0;
+	return;
+    case 4:
+	/* Defer setting the offsets until the text arrives */
+	ENHsvg_x_offset = -0.6 * ENHsvg_charcount;
+	ENHsvg_base -= base;
+	ENHsvg_charcount = 0;
+	return;
+    default:
+	break;
+    }
+
+    if (!ENHsvg_opened_string) {
+	ENHsvg_opened_string = TRUE;
+	enhanced_cur_text = enhanced_text;
+
+	/* Start a new textspan fragment */
+	fputs("<tspan", gpoutfile);
+	if (strcmp(SVG_fontNameCur, fontname)) {
+	    free(SVG_fontNameCur);
+	    SVG_fontNameCur = gp_strdup(fontname);
+	    fprintf(gpoutfile, " style=\"font-family:%s\" ", SVG_fontNameCur);
+	}
+	if (SVG_fontSizeCur != fontsize) {
+	    SVG_fontSizeCur = fontsize;
+	    fprintf(gpoutfile, " font-size=\"%.1fpt\"", SVG_fontSizeCur);
+	}
+	if (ENHsvg_x_offset != 0) {
+#ifdef CODDLE_NONCOMPLIANT_VIEWERS
+	    fprintf(gpoutfile, " dx=\"%.2fpt\"",
+				ENHsvg_x_offset * 1.1*SVG_fontSizeCur);
+#else
+	    fprintf(gpoutfile, " dx=\"%.2fem\"", ENHsvg_x_offset);
+#endif
+	    ENHsvg_x_offset = 0.0;
+	}
+	if (ENHsvg_base != base) {
+	    fprintf(gpoutfile, " dy=\"%.2fpt\"", ENHsvg_base-base);
+	    ENHsvg_base = base;
+	}
+	if (!showflag) {
+	    fprintf(gpoutfile, " fill=\"none\"");
+	}
+	if (ENHsvg_preserve_spaces) {
+	    fprintf(gpoutfile, " xml:space=\"preserve\"");
+	}
+	fputs(">", gpoutfile);
+    }
+
+}
+
+TERM_PUBLIC void
+ENHsvg_FLUSH()
+{
+    if (ENHsvg_opened_string) {
+	ENHsvg_opened_string = FALSE;
+	*enhanced_cur_text = '\0';
+	fprintf(gpoutfile, "%s</tspan>\n\t\t", enhanced_text);
+    }
+}
+
+TERM_PUBLIC void
+ENHsvg_put_text(unsigned int x, unsigned int y, const char *str)
+{
+
+    /* We need local copies of the starting font properties */
+    double fontsize = SVG_fontSizeCur;
+    static char *fontname = NULL;
+
+    free(fontname);
+    fontname = gp_strdup(SVG_fontNameCur);
+
+    /* We need the full set of tags for text, just as normal. But in */
+    /* the case of enhanced text ENHsvg_string_state == 1 tells the  */
+    /* SVG_put_text() to return without actually putting the text.   */
+    if (ignore_enhanced_text) {
+	ENHsvg_string_state = 0;
+	SVG_put_text(x, y, str);
+	return;
+    } else {
+	ENHsvg_string_state = 1;
+	SVG_put_text(x, y, str);
+	ENHsvg_string_state = 0;
+    }
+
+    /* EAM FIXME - This is a total hack, to make up for the fact that all  */
+    /* svg viewers I have tried fail to pick up the xml:space setting from */
+    /* the environment. So it has to be set all over again for each text   */
+    /* fragment. Without this, all whitespace is collapsed to a single ' '.*/
+    if (strstr(str,"  "))
+	ENHsvg_preserve_spaces = TRUE;
+
+    /* Set up global variables needed by enhanced_recursion() */
+    ENHsvg_charcount = 0;
+    enhanced_fontscale = 1.0;
+    strncpy(enhanced_escape_format,"%c",sizeof(enhanced_escape_format));
+
+    while (*(str = enhanced_recursion((char *)str, TRUE,
+			fontname, fontsize, 0.0, TRUE, TRUE, 0))) {
+	(term->enhanced_flush)();
+	enh_err_check(str);
+	if (!*++str)
+	    break; /* end of string */
+    }
+
+    /* Make sure we leave with the same font properties as on entry */
+    free(SVG_fontNameCur);
+    SVG_fontNameCur = fontname;
+    fontname = NULL;
+    if (SVG_fontSizeCur != fontsize || ENHsvg_base != 0) {
+	fprintf(gpoutfile, "<tspan font-size=\"%.1fpt\" dy=\"%.2fpt\"></tspan>",
+		fontsize, ENHsvg_base);
+	SVG_fontSizeCur = fontsize;
+	ENHsvg_base = 0;
+    }
+    ENHsvg_preserve_spaces = FALSE;
+
+    /* Close the text section */
+    fputs("</text>\n\t</g>\n", gpoutfile);
+
+    return;
+}
+
+TERM_PUBLIC void
+ENHsvg_writec(int c)
+{
+    /* Kludge for phantom box accounting */
+    ENHsvg_charcount++;
+
+    /* Escape SVG reserved characters. Are there any besides '<' and '&' ? */
+    switch (c) {
+    case '<':
+		*enhanced_cur_text++ = '&';
+		*enhanced_cur_text++ = 'l';
+		*enhanced_cur_text++ = 't';
+		*enhanced_cur_text++ = ';';
+		break;
+    case '&':
+		*enhanced_cur_text++ = '&';
+		*enhanced_cur_text++ = 'a';
+		*enhanced_cur_text++ = 'm';
+		*enhanced_cur_text++ = 'p';
+		*enhanced_cur_text++ = ';';
+		break;
+    case '\376':
+		/* This is an illegal UTF-8 byte; we use it to escape the reserved '&' */
+		if (encoding == S_ENC_DEFAULT) {
+		    *enhanced_cur_text++ = '&';
+		    break;
+		} /* else fall through */
+    default:
+		*enhanced_cur_text++ = c;
+		break;
+    }
+}
+
+static void
+SVG_load_fontfile(char *fontfile)
+{
+    if (fontfile) {
+	unsigned int linesread = 0;
+	FILE *ffont = NULL;
+	char line[256];
+	char *fontname = NULL;
+#if defined(PIPES)
+	TBOOLEAN ispipe = FALSE;
+#endif
+
+#if defined(PIPES)
+	if ( *fontfile == '<' ) {
+	    ispipe = TRUE;
+	    ffont = popen(fontfile + 1, "r" );
+	    if ( !ffont )
+		int_error(NO_CARET, "Could not execute pipe '%s'",
+			  fontfile + 1 );
+	} else
+#endif
+	{
+	    ffont = fopen(fontfile, "r");
+	    if (!ffont)
+		int_error(NO_CARET, "Font file '%s' not found", fontfile);
+	}
+
+	/* read the file */
+	while (fgets(line,255,ffont)) {
+	    /* Echo fontname to terminal */
+	    if ((fontname = strstr(line,"font-family"))) {
+		fprintf(stderr, "Font file '%s' contains the font '%s'\n",
+				fontfile, fontname);
+	    }
+
+	    /* Copy contents into output file */
+	    fputs(line,gpoutfile);
+
+	    ++linesread;
+	}
+#if defined(PIPES)
+	if ( ispipe ) {
+	    int exitcode;
+	    if ( (exitcode = pclose(ffont)) != 0 )
+		int_error(NO_CARET, "Command '%s' generated error exitcode %d",
+			  fontfile + 1, exitcode);
+	} else
+#endif
+	    fclose(ffont);
+
+	if (linesread == 0) {
+#if defined(PIPES)
+	    if ( ispipe )
+		int_error(NO_CARET,
+		    "Command '%s' generates empty output", fontfile + 1);
+	    else
+#endif
+		int_error(NO_CARET, "Font file '%s' is empty", fontfile);
+	}
+
+    }
+}
+
+TERM_PUBLIC void
+SVG_path(int p)
+{
+    switch (p) {
+	case 1: /* Close path */
+		fputs("Z ", gpoutfile);
+		SVG_PathClose();
+		break;
+	case 0:
+		break;
+    }
+}
+
+
+#undef Y
+#undef X
+#undef CODDLE_NONCOMPLIANT_VIEWERS
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+TERM_TABLE_START (svg_driver)
+    "svg", "W3C Scalable Vector Graphics driver",
+    0 /* xmax */ , 0 /* ymax */ , 0 /* vchar */ , 0 /* hchar */ ,
+    0 /* vtic */ , 0 /* htic */ ,
+    SVG_options, SVG_init, SVG_reset, SVG_text, null_scale, SVG_graphics,
+    SVG_move, SVG_vector, SVG_linetype, SVG_put_text, SVG_text_angle,
+    SVG_justify_text, SVG_point, do_arrow, SVG_set_font, do_pointsize,
+    TERM_CAN_MULTIPLOT | TERM_BINARY | TERM_CAN_DASH | TERM_ALPHA_CHANNEL|TERM_LINEWIDTH,
+    0 /* suspend */, 0 /* resume */ , SVG_fillbox, SVG_linewidth
+#ifdef USE_MOUSE
+   , 0, 0, 0, 0, 0 /* no mouse support for svg */
+#endif
+   , SVG_make_palette,
+   SVG_previous_palette,
+   SVG_set_color,
+   SVG_filled_polygon
+    , NULL	/* image */
+   , ENHsvg_OPEN, ENHsvg_FLUSH, ENHsvg_writec
+   , SVG_layer	/* layer */
+   , SVG_path 	/* path */
+   , SVG_SCALE	/* pixel oversampling scale */
+TERM_TABLE_END (svg_driver)
+
+#undef LAST_TERM
+#define LAST_TERM svg_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(svg)
+"1 svg",
+"?commands set terminal svg",
+"?set terminal svg",
+"?set term svg",
+"?terminal svg",
+"?term svg",
+"?svg",
+" This terminal produces files in the W3C Scalable Vector Graphics format.",
+"",
+" Syntax:",
+"       set terminal svg {size <x>,<y> {|fixed|dynamic}}",
+"                        {{no}enhanced}",
+"                        {fname \"<font>\"} {fsize <fontsize>}",
+"                        {font \"<fontname>{,<fontsize>}\"}",
+"                        {fontfile <filename>}",
+"                        {rounded|butt} {solid|dashed} {linewidth <lw>}",
+"",
+" where <x> and <y> are the size of the SVG plot to generate,",
+" `dynamic` allows a svg-viewer to resize plot, whereas the default",
+" setting, `fixed`, will request an absolute size.",
+"",
+" `linewidth <w>` increases the width of all lines used in the figure",
+" by a factor of <w>.",
+"",
+" <font> is the name of the default font to use (default Arial) and",
+" <fontsize> is the font size (in points, default 12). SVG viewing",
+" programs may substitute other fonts when the file is displayed.",
+"",
+" The svg terminal supports an enhanced text mode, which allows font",
+" and other formatting commands to be embedded in labels and other text",
+" strings. The enhanced text mode syntax is shared with other gnuplot",
+" terminal types. See `enhanced` for more details.",
+"",
+" SVG allows you to embed fonts directly into an SVG document, or to",
+" provide a hypertext link to the desired font. The `fontfile` option",
+" specifies a local file which is copied into the <defs> section of the",
+" resulting SVG output file.  This file may either itself contain a font,",
+" or may contain the records necessary to create a hypertext reference to",
+" the desired font. Gnuplot will look for the requested file using the",
+" directory list in the GNUPLOT_FONTPATH environmental variable.",
+" NB: You must embed an svg font, not a TrueType or PostScript font."
+END_HELP(svg)
+#endif
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/t410x.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/t410x.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/t410x.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/t410x.trm.svn-base	2012-01-03 17:07:44.655782900 -0800
@@ -0,0 +1,328 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: t410x.trm,v 1.16 2006/07/21 02:35:48 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - t410x.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports: Tektronix 410x and 420x series terminals
+ *
+ * AUTHORS
+ *   Colin Kelley, Thomas Williams
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+
+/* Tektronix 410X and 420X driver written by Cary D. Renzema.
+ * email address: caryr@mxim.com
+ *
+ * I've tested this driver on the following terminals: 4106, 4107A, 4109
+ * and 4207.  It should work, without editing, on other terminals in the
+ * 410x and 420x families.  It will probably need to be changed to work
+ * on a 4105 (screen size and character rotation are two guesses).  This
+ * file can also be used as a start for a 411x driver.
+ *
+ * Cary R.
+ * April 5, 1990
+ */
+
+/*
+ * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(tek410x)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void T410X_init __PROTO((void));
+TERM_PUBLIC void T410X_reset __PROTO((void));
+TERM_PUBLIC void T410X_graphics __PROTO((void));
+TERM_PUBLIC void T410X_text __PROTO((void));
+TERM_PUBLIC void T410X_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void T410X_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void T410X_point __PROTO((unsigned int x, unsigned int y, int number));
+TERM_PUBLIC void T410X_linetype __PROTO((int linetype));
+TERM_PUBLIC void T410X_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
+TERM_PUBLIC int T410X_text_angle __PROTO((int ang));
+#define T410XXMAX 4095
+#define T410XYMAX 3131
+
+#define T410XVCHAR	71
+#define T410XHCHAR	51
+#define T410XVTIC	36
+#define T410XHTIC	36
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+static void T410X_encode_x_y __PROTO((unsigned int x, unsigned int y));
+static void T410X_encode_int __PROTO((int number));
+
+
+static int T410X_angle = 0;
+
+TERM_PUBLIC void
+T410X_init()
+{
+    fputs("\033%%!0\033MN0\033MCB7C;\033MQ1\033MT1", gpoutfile);
+    fputs("\033MG1\033RK!\033SK!\033LZ\033%%!1", gpoutfile);
+/*
+	 1. set tek mode
+	 2. set character path to 0 (characters placed equal to rotation)
+	 3. set character size to 59 height
+	 4. set character precision to string
+	 5. set character text index to 1
+	 6. set character write mode to overstrike
+	 7. clear the view
+	 8. clear the segments
+	 9. clear the dialog buffer
+	10. set ansi mode
+*/
+    (void) fflush(gpoutfile);
+}
+
+
+TERM_PUBLIC void
+T410X_reset()
+{
+    fputs("\033%%!0\033LZ\033%%!1", gpoutfile);
+/*
+	1. set tek mode
+	2. clear the dialog buffer
+	3. set ansi mode
+*/
+    (void) fflush(gpoutfile);
+}
+
+
+TERM_PUBLIC void
+T410X_graphics()
+{
+    fputs("\033%%!0\033\014\033LV0", gpoutfile);
+/*
+	1. set tek mode
+	2. clear the screen
+	3. set dialog area invisible
+*/
+    (void) fflush(gpoutfile);
+}
+
+TERM_PUBLIC void
+T410X_text()
+{
+    fputs("\033LV1\033%%!1", gpoutfile);
+/*
+	1. set dialog area visible
+	2. set ansi mode
+*/
+    (void) fflush(gpoutfile);
+}
+
+
+TERM_PUBLIC void
+T410X_move(unsigned int x, unsigned int y)
+{
+    fputs("\033LF", gpoutfile);
+
+    (void) T410X_encode_x_y(x, y);
+    (void) fflush(gpoutfile);
+}
+
+
+TERM_PUBLIC void
+T410X_vector(unsigned int x, unsigned int y)
+{
+    fputs("\033LG", gpoutfile);
+    (void) T410X_encode_x_y(x, y);
+    (void) fflush(gpoutfile);
+}
+
+
+TERM_PUBLIC void
+T410X_point(unsigned int x, unsigned int y, int number)
+{
+    fputs("\033MM", gpoutfile);
+    (void) T410X_encode_int(GPMAX(number, 0) % 11);
+    fputs("\033LH", gpoutfile);
+    (void) T410X_encode_x_y(x, y);
+    (void) fflush(gpoutfile);
+}
+
+
+TERM_PUBLIC void
+T410X_linetype(int linetype)
+{
+    if (linetype < -2)
+	linetype = LT_BLACK;
+
+    switch (linetype) {
+    case LT_AXIS:
+	fputs("\033ML5", gpoutfile);
+	break;
+    case LT_BLACK:
+	fputs("\033ML?", gpoutfile);
+	break;
+    default:
+	fputs("\033ML", gpoutfile);
+	(void) T410X_encode_int(linetype % 14 + 2);
+	break;
+    }
+    fputs("\033MV", gpoutfile);
+    (void) T410X_encode_int(GPMAX(linetype, 0) % 8);
+    (void) fflush(gpoutfile);
+}
+
+
+TERM_PUBLIC void
+T410X_put_text(unsigned int x, unsigned int y, const char str[])
+{
+
+    if (T410X_angle == 0) {
+	(void) T410X_move(x, y - T410XVCHAR / 2 + 6);
+	fputs("\033MR00", gpoutfile);
+    } else {
+	(void) T410X_move(x + T410XHCHAR / 2 - 6, y);
+	fputs("\033MRE:0", gpoutfile);
+    }
+    (void) fputs("\033LT", gpoutfile);
+    (void) T410X_encode_int(strlen(str));
+    (void) fputs(str, gpoutfile);
+    (void) fflush(gpoutfile);
+}
+
+TERM_PUBLIC int
+T410X_text_angle(int ang)
+{
+
+    T410X_angle = ang;
+    return (TRUE);
+}
+
+/* These last two routines are based on fortran code found in the
+ * 4106/4107/4109/CX PROGRAMMERS manual.
+ */
+
+static void
+T410X_encode_x_y(unsigned int x, unsigned int y)
+{
+    static char chix = 0, chiy = 0, cloy = 0, ceb = 0;
+
+    register unsigned int hix, lox, hiy, loy, eb, lx, ly;
+
+    lx = (x <= T410XXMAX) ? x : T410XXMAX;
+    ly = (y <= T410XYMAX) ? y : T410XYMAX;
+
+    hix = lx / 128 + 32;
+    lox = (lx / 4) % 32 + 64;
+    hiy = ly / 128 + 32;
+    loy = (ly / 4) % 32 + 96;
+    eb = (ly % 4) * 4 + lx % 4 + 96;
+
+    if (chiy != hiy)
+	(void) putc(hiy, gpoutfile);
+    if (ceb != eb)
+	(void) putc(eb, gpoutfile);
+    if ((cloy != loy) || (ceb != eb) || (chix != hix))
+	(void) putc(loy, gpoutfile);
+    if (chix != hix)
+	(void) putc(hix, gpoutfile);
+    (void) putc(lox, gpoutfile);
+
+    chix = hix;
+    chiy = hiy;
+    cloy = loy;
+    ceb = eb;
+}
+
+
+static void
+T410X_encode_int(int number)
+{
+    register unsigned int mag, hi1, hi2, lo;
+
+    mag = ABS(number);
+
+    hi1 = mag / 1024 + 64;
+    hi2 = (mag / 16) % 64 + 64;
+    lo = mag % 16 + 32;
+
+    if (number >= 0)
+	lo += 16;
+
+    if (hi1 != 64)
+	(void) putc(hi1, gpoutfile);
+    if ((hi2 != 64) || (hi1 != 64))
+	(void) putc(hi2, gpoutfile);
+    (void) putc(lo, gpoutfile);
+
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(tek410x_driver)
+    "tek410x", "Tektronix 4106, 4107, 4109 and 420X terminals",
+    T410XXMAX, T410XYMAX, T410XVCHAR, T410XHCHAR,
+    T410XVTIC, T410XHTIC, options_null, T410X_init, T410X_reset,
+    T410X_text, null_scale, T410X_graphics, T410X_move, T410X_vector,
+    T410X_linetype, T410X_put_text, T410X_text_angle,
+    null_justify_text, T410X_point, do_arrow, set_font_null
+TERM_TABLE_END(tek410x_driver)
+
+#undef LAST_TERM
+#define LAST_TERM tek410x_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(tek410x)
+"1 tek410x",
+"?commands set terminal tek410x",
+"?set terminal tek410x",
+"?set term tek410x",
+"?terminal tek410x",
+"?term tek410x",
+"?tek410x",
+" The `tek410x` terminal driver supports the 410x and 420x family of Tektronix",
+" terminals.  It has no options."
+END_HELP(tek410x)
+#endif
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/tek.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/tek.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/tek.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/tek.trm.svn-base	2012-01-03 17:07:44.890391300 -0800
@@ -0,0 +1,859 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: tek.trm,v 1.19.2.1 2009/08/14 01:24:05 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - tek.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *  tek40xx, bitgraph, kermit_color_tek40xx, kermit_mono_tek40xx, selanar
+ *  ln03plus, xterm
+ *
+ * AUTHORS
+ *   Colin Kelley, Thomas Williams, Russell Lang
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+
+/*
+ * Modified June 1995 Ian MacPhedran to support newterm format
+ */
+#define TEK
+#define CTEK
+#define VTTEK
+#define XTERM
+
+/* Version 4.3: still available, but no longer built by default */
+#if 0
+#define KERMIT
+#define SELANAR
+#define BITGRAPH
+#endif
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(tek40)
+#ifdef VTTEK
+register_term(vttek)
+#endif
+#ifdef XTERM
+register_term(xterm)
+#endif
+#ifdef KERMIT
+register_term(kc_tek40)
+register_term(km_tek40)
+#endif
+#ifdef SELANAR
+register_term(selanar)
+#endif
+#ifdef BITGRAPH
+register_term(bitgraph)
+#endif
+#endif /* TERM_REGISTER */
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void TEK40init __PROTO((void));
+TERM_PUBLIC void TEK40graphics __PROTO((void));
+TERM_PUBLIC void TEK40text __PROTO((void));
+TERM_PUBLIC void TEK40move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void TEK40vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void TEK40put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
+TERM_PUBLIC void TEK40reset __PROTO((void));
+#ifdef BITGRAPH
+TERM_PUBLIC void BG_text __PROTO((void));
+TERM_PUBLIC void BG_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
+#endif
+#if defined(SELANAR) || defined(BITGRAPH)
+TERM_PUBLIC void TEK40linetype __PROTO((int linetype));
+#endif
+#ifdef KERMIT
+TERM_PUBLIC void KTEK40graphics __PROTO((void));
+TERM_PUBLIC void KTEK40Ctext __PROTO((void));
+TERM_PUBLIC void KTEK40Clinetype __PROTO((int linetype));
+TERM_PUBLIC void KTEK40Mlinetype __PROTO((int linetype));
+TERM_PUBLIC void KTEK40reset __PROTO((void));
+#endif
+#ifdef SELANAR
+TERM_PUBLIC void SEL_init __PROTO((void));
+TERM_PUBLIC void SEL_graphics __PROTO((void));
+TERM_PUBLIC void SEL_text __PROTO((void));
+TERM_PUBLIC void SEL_reset __PROTO((void));
+#endif
+TERM_PUBLIC void VTTEK40init __PROTO((void));
+TERM_PUBLIC void VTTEK40reset __PROTO((void));
+TERM_PUBLIC void VTTEK40linetype __PROTO((int linetype));
+TERM_PUBLIC void VTTEK40put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
+TERM_PUBLIC void XTERM_graphics __PROTO((void));
+TERM_PUBLIC void XTERM_resume __PROTO((void));
+TERM_PUBLIC void XTERM_text __PROTO((void));
+TERM_PUBLIC int  XTERM_set_font __PROTO((const char * fontname));
+TERM_PUBLIC void CTEK_linetype __PROTO((int linetype));
+TERM_PUBLIC void CTEK_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void CTEK_vector __PROTO((unsigned int x, unsigned int y));
+
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+#ifdef TEK
+
+#define TEK40XMAX 1024
+#define TEK40YMAX 780
+
+#define TEK40XLAST (TEK40XMAX - 1)
+#define TEK40YLAST (TEK40YMAX - 1)
+
+#define TEK40VCHAR		25
+#define TEK40HCHAR		14
+#define TEK40VTIC		11
+#define TEK40HTIC		11
+
+#define HX 0x20			/* bit pattern to OR over 5-bit data */
+#define HY 0x20
+#define LX 0x40
+#define LY 0x60
+
+#define LOWER5 31
+#define UPPER5 (31<<5)
+
+
+TERM_PUBLIC void
+TEK40init()
+{
+}
+
+
+TERM_PUBLIC void
+TEK40graphics()
+{
+#ifdef VMS
+    term_pasthru();
+#endif /* VMS */
+    fputs("\033\014", gpoutfile);
+/*                   1
+	1. clear screen
+*/
+    (void) fflush(gpoutfile);
+    sleep(1);
+    /* sleep 1 second to allow screen time to clear on real
+       tektronix terminals */
+}
+
+TERM_PUBLIC void
+TEK40text()
+{
+#ifdef VMS
+    (void) fflush(gpoutfile);	/* finish the graphics */
+#endif
+    TEK40move(0, 12);
+    fputs("\037", gpoutfile);
+/*                   1
+	1. into alphanumerics
+*/
+#ifdef VMS
+    term_nopasthru();
+#endif /* VMS */
+}
+
+
+#if defined(SELANAR) || defined(BITGRAPH)
+TERM_PUBLIC void
+TEK40linetype(int linetype)
+{
+    (void) linetype;
+}
+#endif
+
+TERM_PUBLIC void
+TEK40move(unsigned int x, unsigned int y)
+{
+    (void) putc('\035', gpoutfile);	/* into graphics */
+    TEK40vector(x, y);
+}
+
+
+TERM_PUBLIC void
+TEK40vector(unsigned int x, unsigned int y)
+{
+    (void) putc((HY | (y & UPPER5) >> 5), gpoutfile);
+    (void) putc((LY | (y & LOWER5)), gpoutfile);
+    (void) putc((HX | (x & UPPER5) >> 5), gpoutfile);
+    (void) putc((LX | (x & LOWER5)), gpoutfile);
+}
+
+
+TERM_PUBLIC void
+TEK40put_text(unsigned int x, unsigned int y, const char str[])
+{
+    TEK40move(x, y - 11);
+    fprintf(gpoutfile, "\037%s\n", str);
+}
+
+
+TERM_PUBLIC void
+TEK40reset()
+{
+}
+
+#endif /* TEK */
+
+
+/* thanks to dukecdu!evs (Ed Simpson) for the BBN BitGraph driver */
+
+#ifdef BITGRAPH
+
+#define BG_XMAX			 	768	/* width of plot area */
+#define BG_YMAX			 	768	/* height of plot area */
+#define BG_SCREEN_HEIGHT	1024	/* full screen height */
+
+#define BG_XLAST	 (BG_XMAX - 1)
+#define BG_YLAST	 (BG_YMAX - 1)
+
+#define BG_VCHAR	16
+#define BG_HCHAR	 9
+#define BG_VTIC		 8
+#define BG_HTIC		 8
+
+
+#define BG_init TEK40init
+#define BG_graphics TEK40graphics
+#define BG_linetype TEK40linetype
+#define BG_move TEK40move
+#define BG_vector TEK40vector
+#define BG_reset TEK40reset
+
+
+TERM_PUBLIC void
+BG_text()
+{
+#ifdef VMS
+    (void) fflush(gpoutfile);	/* finish the graphics */
+#endif
+    BG_move(0, BG_SCREEN_HEIGHT - 2 * BG_VCHAR);
+    fputs("\037", gpoutfile);
+/*                   1
+	1. into alphanumerics
+*/
+}
+
+
+TERM_PUBLIC void
+BG_put_text(unsigned int x, unsigned int y, const char str[])
+{
+    BG_move(x, y - 11);
+    fprintf(gpoutfile, "\037%s\n", str);
+}
+
+
+#endif /* BITGRAPH */
+
+
+/* Color and Monochrome specials for the MS-DOS Kermit Tektronix Emulator
+   by Russell Lang,  eln272v@monu1.cc.monash.oz  */
+
+#ifdef KERMIT
+
+#define KTEK40HCHAR		13
+
+TERM_PUBLIC void
+KTEK40graphics()
+{
+#ifdef VMS
+    term_mode_tek();
+    term_pasthru();
+#endif /* VMS */
+    fputs("\033\014", gpoutfile);
+/*                   1
+	1. clear screen
+*/
+    /* kermit tektronix emulation doesn't need to wait */
+}
+
+TERM_PUBLIC void
+KTEK40Ctext()
+{
+    TEK40text();
+    KTEK40Clinetype(0);		/* change to green */
+#ifdef VMS
+    term_nopasthru();
+#endif /* VMS */
+}
+
+/* special color linetypes for MS-DOS Kermit v2.31 tektronix emulator */
+/*	0 = normal, 1 = bright
+	foreground color (30-37) = 30 + colors
+		where colors are   1=red, 2=green, 4=blue */
+static const char *kermit_color[15] =
+{"\033[0;37m", "\033[1;30m",
+ "\033[0;32m", "\033[0;36m", "\033[0;31m", "\033[0;35m",
+ "\033[1;34m", "\033[1;33m", "\033[1;31m", "\033[1;37m",
+ "\033[1;35m", "\033[1;32m", "\033[1;36m", "\033[0;34m",
+ "\033[0;33m"};
+
+TERM_PUBLIC void
+KTEK40Clinetype(int linetype)
+{
+    if (linetype < -2)
+	linetype = LT_BLACK;
+    if (linetype >= 13)
+	linetype %= 13;
+    fprintf(gpoutfile, "%s", kermit_color[linetype + 2]);
+}
+
+
+/* linetypes for MS-DOS Kermit v2.30 tektronix emulator */
+/* `=solid, a=fine dots, b=short dashes, c=dash dot,
+   d=long dash dot, e=dash dot dot */
+static const char *kerm_linetype = "`a`abcde";
+
+TERM_PUBLIC void
+KTEK40Mlinetype(int linetype)
+{
+    if (linetype < -2)
+	linetype = LT_BLACK;
+    if (linetype >= 6)
+	linetype %= 6;
+    fprintf(gpoutfile, "\033%c", kerm_linetype[linetype + 2]);
+}
+
+TERM_PUBLIC void
+KTEK40reset()
+{
+    fputs("\030\n", gpoutfile);	/* turn off Tek emulation */
+#ifdef VMS
+    term_mode_native();
+#endif /* VMS */
+}
+
+#endif /* KERMIT */
+
+
+/* thanks to sask!macphed (Geoff Coleman and Ian Macphedran) for the
+   Selanar driver */
+
+#ifdef SELANAR
+
+TERM_PUBLIC void
+SEL_init()
+{
+    fputs("\033\062", gpoutfile);
+/*					1
+	1. set to ansi mode
+*/
+}
+
+
+TERM_PUBLIC void
+SEL_graphics()
+{
+    fputs("\033[H\033[J\033\061\033\014", gpoutfile);
+/*                   1           2       3
+	1. clear ANSI screen
+	2. set to TEK mode
+	3. clear screen
+*/
+#ifdef VMS
+    term_pasthru();
+#endif /* VMS */
+}
+
+
+TERM_PUBLIC void
+SEL_text()
+{
+#ifdef VMS
+    (void) fflush(gpoutfile);	/* finish the graphics */
+#endif
+    TEK40move(0, 12);
+    fputs("\033\062", gpoutfile);
+/*                   1
+	1. into ANSI mode
+*/
+#ifdef VMS
+    term_nopasthru();
+#endif /* VMS */
+}
+
+TERM_PUBLIC void
+SEL_reset()
+{
+    fputs("\033\061\033\012\033\062\033[H\033[J", gpoutfile);
+/*                   1        2       3      4
+1       set tek mode
+2       clear screen
+3       set ansi mode
+4       clear screen
+*/
+}
+
+#endif /* SELANAR */
+
+#ifdef VTTEK
+
+TERM_PUBLIC void
+VTTEK40init()
+{
+    fputs("\033[?38h", gpoutfile);
+    fflush(gpoutfile);
+    sleep(1);
+    /* sleep 1 second to allow screen time to clear on some terminals */
+#ifdef VMS
+    term_mode_tek();
+#endif /* VMS */
+}
+
+TERM_PUBLIC void
+VTTEK40reset()
+{
+    fputs("\033[?38l", gpoutfile);
+    fflush(gpoutfile);
+    sleep(1);
+    /* sleep 1 second to allow screen time to clear on some terminals */
+#ifdef VMS
+    term_mode_native();
+#endif /* VMS */
+}
+
+/* linetypes for VT-type terminals in tektronix emulator mode */
+/* `=solid, a=fine dots, b=short dashes, c=dash dot,
+   d=long dash dot, h=bold solid, i=bold fine dots, j=bold short dashes,
+   k=bold dash dot, l=bold long dash dot */
+static const char *vt_linetype = "`a`abcdhijkl";
+static int last_vt_linetype = 0;
+
+TERM_PUBLIC void
+VTTEK40linetype(int linetype)
+{
+    if (linetype < -2)
+	linetype = LT_BLACK;
+    if (linetype >= 10)
+	linetype %= 10;
+    fprintf(gpoutfile, "\033%c", vt_linetype[linetype + 2]);
+    last_vt_linetype = linetype;
+}
+
+TERM_PUBLIC void
+VTTEK40put_text(unsigned int x, unsigned int y, const char str[])
+{
+    int linetype;
+    linetype = last_vt_linetype;
+    VTTEK40linetype(0);
+    TEK40put_text(x, y, str);
+    VTTEK40linetype(linetype);
+}
+
+#endif /* VTTEK */
+
+#ifdef XTERM
+
+#define XT_TEK_ESC "\033"
+#define XT_TEK_GFX XT_TEK_ESC "[?38h"
+#define XT_TEK_ANSI XT_TEK_ESC "\003"
+#define XT_TEK_CLR XT_TEK_ESC "\014"
+#define XT_TEK_ALPHA "\037"
+
+static const char *xt_tek_fontsize = "89:;";
+
+TERM_PUBLIC void
+XTERM_graphics()
+{
+    XTERM_resume();
+    fputs(XT_TEK_CLR, gpoutfile);
+}
+
+
+TERM_PUBLIC void
+XTERM_resume()
+{
+    fputs(XT_TEK_GFX, gpoutfile);
+}
+
+
+TERM_PUBLIC void
+XTERM_text()
+{
+    fputs(XT_TEK_ALPHA XT_TEK_ANSI, gpoutfile);
+}
+
+
+TERM_PUBLIC int
+XTERM_set_font(const char *fontname)
+{
+    char size = 0;
+    if (fontname) {
+      size_t lp = strlen(fontname);
+      if (lp>0) size = fontname[lp-1]-'1';
+    }
+    fprintf(gpoutfile, XT_TEK_ESC "%c",
+            xt_tek_fontsize[size>0&&size<4?size:0]);
+
+    return(TRUE);
+}
+
+#endif /* XTERM */
+
+#ifdef LN03P
+
+TERM_PUBLIC void
+LN03Pinit()
+{
+    fputs("\033[?38h", gpoutfile);
+}
+
+TERM_PUBLIC void
+LN03Preset()
+{
+    fputs("\033[?38l", gpoutfile);
+}
+
+#endif /* LN03P */
+
+
+
+/* tek40xx (monochrome) with linetype support by Jay I. Choe */
+#ifdef CTEK
+
+/*#define ABS(A) (((A)>=0)? (A):-(A))*/
+#define SIGN(A) (((A) >= 0)? 1:-1)
+
+static void CT_solid_vector __PROTO((int x, int y));
+static void CT_draw_vpoint __PROTO((int x, int y, int last));
+static void CT_pattern_vector __PROTO((int x1, int y1));
+
+/* CT_lines are line types defined as bit pattern */
+static unsigned long CT_lines[] =
+{~(unsigned long)0,			/* solid line */
+ 0x000fffff,			/* long dash */
+ 0x00ff00ff,			/* short dash */
+ 0x00f00fff,			/* dash-dot */
+ 0x00f07fff,			/* long dash - dot */
+ 0x07070707,
+ 0x07ff07ff,
+ 0x070707ff};
+
+/* current line pattern */
+static unsigned long *CT_pattern = &CT_lines[0];
+
+/* we need to keep track of tek cursor location */
+static int CT_last_linetype = 0, CT_last_x, CT_last_y;
+
+TERM_PUBLIC void
+CTEK_linetype(int linetype)
+{
+    if (linetype < 0)
+	linetype = 0;
+    linetype %= (sizeof(CT_lines) / sizeof(unsigned long));
+    CT_pattern = &CT_lines[linetype];
+    CT_last_linetype = linetype;
+}
+
+TERM_PUBLIC void
+CTEK_move(unsigned int x, unsigned int y)
+{
+    TEK40move(x, y);
+    CT_last_x = x;
+    CT_last_y = y;
+}
+
+static void
+CT_solid_vector(int x, int y)
+{
+    TEK40vector(x, y);
+    CT_last_x = x;
+    CT_last_y = y;
+}
+
+/*
+   simulate pixel draw using tek vector draw.
+   delays actual line drawing until maximum line segment is determined
+   (or first/last point is defined)
+*/
+static int CT_penon = 0;	/* is Pen on? */
+
+static void
+CT_draw_vpoint(int x, int y, int last)
+{
+    static int xx0, yy0, xx1, yy1;
+
+    if ((*CT_pattern) & 1) {
+	if (CT_penon) {		/* This point is a continuation of current line */
+	    xx1 = x;
+	    yy1 = y;
+	} else {		/* beginning of new line */
+	    xx0 = xx1 = x;
+	    yy0 = yy1 = y;
+	    CT_penon = 1;
+	}
+	*CT_pattern = ((*CT_pattern) >> 1) | ((unsigned long)1 << 31);	/* rotate the pattern */
+	if (last) {		/* draw the line anyway if this is the last point */
+	    TEK40move(xx0, yy0);
+	    TEK40vector(xx1, yy1);
+	    CT_penon = 0;
+	}
+    } else {			/* do not draw this pixel */
+	if (CT_penon) {		/* last line segment ended at the previous pixel. */
+	    /* draw the line */
+	    TEK40move(xx0, yy0);
+	    TEK40vector(xx1, yy1);
+	    CT_penon = 0;
+	}
+	*CT_pattern = (*CT_pattern) >> 1;	/* rotate the current pattern */
+    }
+}
+
+/*
+   draw vector line with pattern
+*/
+
+static void
+CT_pattern_vector(int x1, int y1)
+{
+    int op;			/* order parameter */
+    int x0 = CT_last_x;
+    int y0 = CT_last_y;
+    int dx = x1 - x0;
+    int dy = y1 - y0;
+    int ax = ABS(dx) << 1;
+    int ay = ABS(dy) << 1;
+    int sx = SIGN(dx);
+    int sy = SIGN(dy);
+
+    if (ax >= ay) {
+	for (op = ay - (ax >> 1); x0 != x1; x0 += sx, op += ay) {
+	    CT_draw_vpoint(x0, y0, 0);
+	    if (op > 0 || (op == 0 && sx == 1)) {
+		op -= ax;
+		y0 += sy;
+	    }
+	}
+    } else {			/* ax < ay */
+	for (op = ax - (ay >> 1); y0 != y1; y0 += sy, op += ax) {
+	    CT_draw_vpoint(x0, y0, 0);
+	    if (op > 0 || (op == 0 && sy == 1)) {
+		op -= ay;
+		x0 += sx;
+	    }
+	}
+    }
+    CT_draw_vpoint(x0, y0, 1);	/* last point */
+    CT_last_x = x1;
+    CT_last_y = y1;
+}
+
+TERM_PUBLIC void
+CTEK_vector(unsigned int x, unsigned int y)
+{
+    if (CT_last_linetype <= 0)
+	CT_solid_vector(x, y);
+    else
+	CT_pattern_vector(x, y);
+}
+
+#endif /* CTEK */
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+#ifdef CTEK
+TERM_TABLE_START(tek40_driver)
+    "tek40xx", "Tektronix 4010 and others; most TEK emulators",
+    TEK40XMAX, TEK40YMAX, TEK40VCHAR, TEK40HCHAR,
+    TEK40VTIC, TEK40HTIC, options_null, TEK40init, TEK40reset,
+    TEK40text, null_scale, TEK40graphics, CTEK_move, CTEK_vector,
+    CTEK_linetype, TEK40put_text, null_text_angle,
+    null_justify_text, line_and_point, do_arrow, set_font_null
+TERM_TABLE_END(tek40_driver)
+#endif /* CTEK */
+
+#undef LAST_TERM
+#define LAST_TERM tek40_driver
+
+#ifdef VTTEK
+TERM_TABLE_START(vttek_driver)
+    "vttek", "VT-like tek40xx terminal emulator",
+    TEK40XMAX, TEK40YMAX, TEK40VCHAR, TEK40HCHAR,
+    TEK40VTIC, TEK40HTIC, options_null, VTTEK40init, VTTEK40reset,
+    TEK40text, null_scale, TEK40graphics, TEK40move, TEK40vector,
+    VTTEK40linetype, VTTEK40put_text, null_text_angle,
+    null_justify_text, line_and_point, do_arrow, set_font_null
+TERM_TABLE_END(vttek_driver)
+
+#undef LAST_TERM
+#define LAST_TERM vttek_driver
+
+#endif /* VTTEK */
+
+#ifdef XTERM
+TERM_TABLE_START(xterm_driver)
+    "xterm", "Xterm Tektronix 4014 Mode",
+    TEK40XMAX, TEK40YMAX, TEK40VCHAR, TEK40HCHAR,
+    TEK40VTIC, TEK40HTIC, options_null, TEK40init, TEK40reset,
+    XTERM_text, null_scale, XTERM_graphics, TEK40move, TEK40vector,
+    VTTEK40linetype, VTTEK40put_text, null_text_angle,
+    null_justify_text, line_and_point, do_arrow, XTERM_set_font, 0,
+    TERM_CAN_MULTIPLOT|TERM_NO_OUTPUTFILE, XTERM_text, XTERM_resume
+TERM_TABLE_END(xterm_driver)
+
+#undef LAST_TERM
+#define LAST_TERM xterm_driver
+
+#endif /* XTERM */
+
+#ifdef KERMIT
+TERM_TABLE_START(kc_tek40_driver)
+   "kc_tek40xx", "MS-DOS Kermit Tek4010 terminal emulator - color",
+    TEK40XMAX, TEK40YMAX, TEK40VCHAR, KTEK40HCHAR,
+    TEK40VTIC, TEK40HTIC, options_null, TEK40init, KTEK40reset,
+    KTEK40Ctext, null_scale, KTEK40graphics, TEK40move, TEK40vector,
+    KTEK40Clinetype, TEK40put_text, null_text_angle,
+    null_justify_text, do_point, do_arrow, set_font_null
+TERM_TABLE_END(kc_tek40_driver)
+
+#undef LAST_TERM
+#define LAST_TERM kc_tek40_driver
+
+TERM_TABLE_START(km_tek40_driver)
+    "km_tek40xx", "MS-DOS Kermit Tek4010 terminal emulator - monochrome",
+    TEK40XMAX, TEK40YMAX, TEK40VCHAR, KTEK40HCHAR,
+    TEK40VTIC, TEK40HTIC, options_null, TEK40init, KTEK40reset,
+    TEK40text, null_scale, KTEK40graphics, TEK40move, TEK40vector,
+    KTEK40Mlinetype, TEK40put_text, null_text_angle,
+    null_justify_text, line_and_point, do_arrow, set_font_null
+TERM_TABLE_END(km_tek40_driver)
+
+#undef LAST_TERM
+#define LAST_TERM km_tek40_driver
+
+#endif /* KERMIT */
+
+#ifdef SELANAR
+TERM_TABLE_START(selanar_driver)
+    "selanar", "Selanar",
+    TEK40XMAX, TEK40YMAX, TEK40VCHAR, TEK40HCHAR,
+    TEK40VTIC, TEK40HTIC, options_null, SEL_init, SEL_reset,
+    SEL_text, null_scale, SEL_graphics, TEK40move, TEK40vector,
+    TEK40linetype, TEK40put_text, null_text_angle,
+    null_justify_text, line_and_point, do_arrow, set_font_null
+TERM_TABLE_END(selanar_driver)
+
+#undef LAST_TERM
+#define LAST_TERM selanar_driver
+
+#endif /* SELANAR */
+
+#ifdef BITGRAPH
+TERM_TABLE_START(bitgraph_driver)
+    "bitgraph", "BBN Bitgraph Terminal",
+    BG_XMAX, BG_YMAX, BG_VCHAR, BG_HCHAR,
+    BG_VTIC, BG_HTIC, options_null, BG_init, BG_reset,
+    BG_text, null_scale, BG_graphics, BG_move, BG_vector,
+    BG_linetype, BG_put_text, null_text_angle,
+    null_justify_text, line_and_point, do_arrow, set_font_null
+TERM_TABLE_END(bitgraph_driver)
+
+#undef LAST_TERM
+#define LAST_TERM bitgraph_driver
+
+#endif /* BITGRAPH */
+
+#endif /* TERM_TABLE */
+
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(tek40)
+"1 tek40",
+"?commands set terminal tek40xx",
+"?set terminal tek40xx",
+"?set term tek40xx",
+"?terminal tek40xx",
+"?term tek40xx",
+"?tek40",
+"?commands set terminal vttek",
+"?set terminal vttek",
+"?set term vttek",
+"?terminal vttek",
+"?term vttek",
+"?vttek",
+"?commands set terminal xterm",
+"?set terminal xterm",
+"?set term xterm",
+"?terminal xterm",
+"?term xterm",
+"?xterm",
+#ifdef KERMIT
+"?commands set terminal kc-tek40xx",
+"?set terminal kc-tek40xx",
+"?set term kc-tek40xx",
+"?terminal kc-tek40xx",
+"?term kc-tek40xx",
+"?kc-tek40xx",
+"?commands set terminal km-tek40xx",
+"?set terminal km-tek40xx",
+"?set term km-tek40xx",
+"?terminal km-tek40xx",
+"?term km-tek40xx",
+"?km-tek40xx",
+#endif
+#ifdef SELANAR
+"?commands set terminal selanar",
+"?set terminal selanar",
+"?set term selanar",
+"?terminal selanar",
+"?term selanar",
+"?selanar",
+#endif
+#ifdef BITGRAPH
+"?commands set terminal bitgraph",
+"?set terminal bitgraph",
+"?set term bitgraph",
+"?terminal bitgraph",
+"?term bitgraph",
+"?bitgraph",
+#endif
+" This family of terminal drivers supports a variety of VT-like terminals.",
+" `tek40xx` supports Tektronix 4010 and others as well as most TEK emulators.",
+" `vttek` supports VT-like tek40xx terminal emulators.",
+" The following are present only if selected when gnuplot is built:",
+" `kc-tek40xx` supports MS-DOS Kermit Tek4010 terminal emulators in color;",
+" `km-tek40xx` supports them in monochrome. `selanar` supports Selanar graphics.",
+" `bitgraph` supports BBN Bitgraph terminals.",
+" None have any options."
+END_HELP(tek40)
+#endif /* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/texdraw.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/texdraw.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/texdraw.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/texdraw.trm.svn-base	2012-01-03 17:07:45.093919100 -0800
@@ -0,0 +1,388 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: texdraw.trm,v 1.19 2006/07/21 02:35:48 sfeam Exp $
+ */
+
+/* GNUPLOT - texdraw.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *   The TEXDRAW macros for LaTeX.
+ *
+ * AUTHORS
+ *   Khun Yee Fung. Modified from eepic.trm.
+ *   clipper@csd.uwo.ca
+ *   January 20, 1992
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+
+/*
+ *  This file contains the texdraw terminal driver, intended for use with the
+ *  texdraw macro package for LaTeX. This is an alternative to the
+ *  latex driver. You need texdraw.sty, and texdraw.tex in the texdraw package.
+ *
+ */
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(texdraw)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void TEXDRAW_init __PROTO((void));
+TERM_PUBLIC void TEXDRAW_graphics __PROTO((void));
+TERM_PUBLIC void TEXDRAW_text __PROTO((void));
+TERM_PUBLIC void TEXDRAW_linetype __PROTO((int linetype));
+TERM_PUBLIC void TEXDRAW_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void TEXDRAW_point __PROTO((unsigned int x, unsigned int y,
+					int number));
+TERM_PUBLIC void TEXDRAW_vector __PROTO((unsigned int ux, unsigned int uy));
+TERM_PUBLIC void TEXDRAW_arrow __PROTO((unsigned int sx, unsigned int sy,
+					unsigned int ex, unsigned int ey,
+					int head));
+TERM_PUBLIC void TEXDRAW_put_text __PROTO((unsigned int x, unsigned int y,
+					   const char str[]));
+TERM_PUBLIC int TEXDRAW_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC int TEXDRAW_text_angle __PROTO((int ang));
+TERM_PUBLIC void TEXDRAW_reset __PROTO((void));
+
+#define TEXDRAW_PTS_PER_INCH (72.27)
+/* resolution of printer we expect to use */
+#define DOTS_PER_INCH (300)
+/* dot size in pt */
+#define TEXDRAW_UNIT (TEXDRAW_PTS_PER_INCH/DOTS_PER_INCH)
+
+/* 5 inches wide by 3 inches high (default) */
+#define TEXDRAW_XMAX (5*DOTS_PER_INCH)
+#define TEXDRAW_YMAX (3*DOTS_PER_INCH)
+
+#define TEXDRAW_HTIC (5*DOTS_PER_INCH/72)	/* (5./TEXDRAW_UNIT) */
+#define TEXDRAW_VTIC (5*DOTS_PER_INCH/72)	/* (5./TEXDRAW_UNIT) */
+#define TEXDRAW_HCHAR (DOTS_PER_INCH*53/10/72)	/* (5.3/TEXDRAW_UNIT) */
+#define TEXDRAW_VCHAR (DOTS_PER_INCH*11/72)	/* (11./TEXDRAW_UNIT) */
+
+#define GOT_TEXDRAW_PROTO
+#endif
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+static void TEXDRAW_endline __PROTO((void));
+static unsigned int TEXDRAW_posx;
+static unsigned int TEXDRAW_posy;
+static enum JUSTIFY TEXDRAW_justify = LEFT;
+static enum JUSTIFY TEXDRAW_last_justify = LEFT;
+static int TEXDRAW_angle = 0;
+static float TEXDRAW_scalefactor = 0.2409;
+static double TEXDRAW_xscale = 1.0, TEXDRAW_yscale = 1.0;
+
+/* for DOTS point style */
+#define TEXDRAW_TINY_DOT "\\htext{$\\cdot$}"
+
+/* POINTS */
+#define TEXDRAW_POINT_TYPES 12	/* we supply more point types */
+
+static const char GPFAR *GPFAR TEXDRAW_points[] = {
+    "\\rmove(0 4)\\htext{$\\Diamond$}",
+    "\\htext{$+$}",
+    "\\rmove(0 4)\\htext{$\\Box$}",
+    "\\htext{$\\times$}",
+    "\\htext{$\\triangle$}",
+    "\\htext{$\\star$}",
+    "\\lcir r:9",
+    "\\lcir r:12",
+    "\\lcir r:16",
+    "\\fcir f:0.9 r:9",
+    "\\fcir f:0.9 r:12",
+    "\\fcir f:0.9 r:16"
+};
+
+/* LINES */
+#define TEXDRAW_NUMLINES 5	/* number of linetypes below */
+
+static const int TEXDRAW_lines[] = {
+    4,				/* -2 border */
+    3,				/* -1 axes */
+    3,				/*  0 solid thin  */
+    4,				/*  1 solid thick */
+    6,				/*  2 solid Thick */
+};
+
+/* The line type selected most recently */
+static int TEXDRAW_last_type = 0;
+/* current line type */
+static int TEXDRAW_type;
+/* are we in the middle of a line */
+static TBOOLEAN TEXDRAW_inline = FALSE;
+/* terminate any line in progress */
+static void TEXDRAW_endline __PROTO((void));
+/* number of points in line so far */
+static int TEXDRAW_linecount = 0;
+/* max value for linecount */
+#define TEXDRAW_LINEMAX 5
+
+TERM_PUBLIC void
+TEXDRAW_init()
+{
+    TEXDRAW_posx = TEXDRAW_posy = 0;
+    TEXDRAW_linetype(-1);
+    fputs("%% GNUPLOT: LaTeX using TEXDRAW macros\n", gpoutfile);
+}
+
+TERM_PUBLIC void
+TEXDRAW_graphics()
+{
+    static char GPFAR tdg1[] = "\
+\\begin{texdraw}\n\
+\\normalsize\n\
+\\ifx\\pathDEFINED\\relax\\else\\let\\pathDEFINED\\relax\n\
+ \\def\\QtGfr{\\ifx (\\TGre \\let\\YhetT\\cpath\\else\\let\\YhetT\\relax\\fi\\YhetT}\n\
+ \\def\\path (#1 #2){\\move (#1 #2)\\futurelet\\TGre\\QtGfr}\n\
+ \\def\\cpath (#1 #2){\\lvec (#1 #2)\\futurelet\\TGre\\QtGfr}\n\
+\\fi\n\
+\\drawdim pt\n\
+\\setunitscale %2.2f\n\
+\\linewd %d\n\
+\\textref h:L v:C\n";
+    fprintf(gpoutfile, tdg1,
+	    TEXDRAW_scalefactor,
+	    TEXDRAW_lines[2]);
+    TEXDRAW_last_type = 0;
+    TEXDRAW_type = 0;
+}
+
+TERM_PUBLIC void
+TEXDRAW_text()
+{
+    TEXDRAW_endline();
+    fputs("\\end{texdraw}\n", gpoutfile);
+}
+
+TERM_PUBLIC void
+TEXDRAW_linetype(int linetype)
+{
+    TEXDRAW_endline();
+
+    if (linetype >= TEXDRAW_NUMLINES - 2)
+	linetype %= (TEXDRAW_NUMLINES - 2);
+
+    TEXDRAW_type = linetype > -2 ? linetype : LT_BLACK;
+}
+
+TERM_PUBLIC void
+TEXDRAW_move(unsigned int x, unsigned int y)
+{
+    TEXDRAW_endline();
+
+    TEXDRAW_posx = x;
+    TEXDRAW_posy = y;
+}
+
+TERM_PUBLIC void
+TEXDRAW_point(unsigned int x, unsigned int y, int number)
+{
+    TEXDRAW_move(x, y);
+
+    /* Print the character defined by 'number'; number < 0 means
+     * to use a dot, otherwise one of the defined points. */
+    fprintf(gpoutfile, "\\move (%d %d)\n",
+	    (int) ((double) x * TEXDRAW_xscale),
+	    (int) ((double) y * TEXDRAW_yscale));
+    if (TEXDRAW_last_justify != CENTRE) {
+	fprintf(gpoutfile, "\\textref h:C v:C ");
+	TEXDRAW_last_justify = CENTRE;
+    }
+    fprintf(gpoutfile, "%s\n",
+	    (number < 0 ?
+	     TEXDRAW_TINY_DOT :
+	     TEXDRAW_points[number % TEXDRAW_POINT_TYPES]));
+}
+
+TERM_PUBLIC void
+TEXDRAW_vector(unsigned int ux, unsigned int uy)
+{
+    if (!TEXDRAW_inline) {
+	TEXDRAW_inline = TRUE;
+
+	/* Start a new line. This depends on line type */
+	if (TEXDRAW_type != TEXDRAW_last_type) {
+	    if (TEXDRAW_lines[TEXDRAW_type + 2] != TEXDRAW_lines[TEXDRAW_last_type + 2])
+		fprintf(gpoutfile, "\\linewd %d\n",
+			TEXDRAW_lines[TEXDRAW_type + 2]);
+	    TEXDRAW_last_type = TEXDRAW_type;
+	}
+	fprintf(gpoutfile, "\\path (%d %d)",
+		(int) ((double) TEXDRAW_posx * TEXDRAW_xscale),
+		(int) ((double) TEXDRAW_posy * TEXDRAW_yscale));
+	TEXDRAW_linecount = 1;
+    } else {
+	/* Even though we are in middle of a path,
+	 * we may want to start a new path command.
+	 * If they are too long then latex will choke.
+	 */
+	if (TEXDRAW_linecount++ >= TEXDRAW_LINEMAX) {
+	    fputs("\n\\cpath ", gpoutfile);
+	    TEXDRAW_linecount = 1;
+	}
+    }
+    fprintf(gpoutfile, "(%d %d)",
+	    (int) ((double) ux * TEXDRAW_xscale),
+	    (int) ((double) uy * TEXDRAW_yscale));
+    TEXDRAW_posx = ux;
+    TEXDRAW_posy = uy;
+}
+
+static void
+TEXDRAW_endline()
+{
+    if (TEXDRAW_inline) {
+	putc('\n', gpoutfile);
+	TEXDRAW_inline = FALSE;
+    }
+}
+
+TERM_PUBLIC void
+TEXDRAW_arrow(
+    unsigned int sx, unsigned int sy,
+    unsigned int ex, unsigned int ey,
+    int head)
+{
+    char text;
+
+    if (head)
+	text = 'a';
+    else
+	text = 'l';
+    fprintf(gpoutfile, "\\move (%d %d)\\%cvec (%d %d)",
+	    (int) ((double) sx * TEXDRAW_xscale),
+	    (int) ((double) sy * TEXDRAW_yscale),
+	    text,
+	    (int) ((double) ex * TEXDRAW_xscale),
+	    (int) ((double) ey * TEXDRAW_yscale));
+    TEXDRAW_posx = ex;
+    TEXDRAW_posy = ey;
+}
+
+TERM_PUBLIC void
+TEXDRAW_put_text(unsigned int x, unsigned int y, const char str[])
+{
+    char text;
+
+    TEXDRAW_endline();
+
+    fprintf(gpoutfile, "\\move (%d %d)",
+	    (int) ((double) x * TEXDRAW_xscale),
+	    (int) ((double) y * TEXDRAW_yscale));
+
+    if (!TEXDRAW_angle)
+	text = 'h';
+    else
+	text = 'v';
+
+    if (TEXDRAW_last_justify != TEXDRAW_justify) {
+	TEXDRAW_last_justify = TEXDRAW_justify;
+	if (TEXDRAW_justify == LEFT)
+	    fputs("\\textref h:L v:C ", gpoutfile);
+	else if (TEXDRAW_justify == CENTRE)
+	    fputs("\\textref h:C v:C ", gpoutfile);
+	else if (TEXDRAW_justify == RIGHT)
+	    fputs("\\textref h:R v:C ", gpoutfile);
+    }
+    fprintf(gpoutfile, "\\%ctext{%s}\n", text, str);
+}
+
+
+TERM_PUBLIC int
+TEXDRAW_justify_text(enum JUSTIFY mode)
+{
+    TEXDRAW_justify = mode;
+    return (TRUE);
+}
+
+TERM_PUBLIC int
+TEXDRAW_text_angle(int ang)
+{
+    TEXDRAW_angle = ang;
+    return (TRUE);
+}
+
+TERM_PUBLIC void
+TEXDRAW_reset()
+{
+    TEXDRAW_endline();
+    TEXDRAW_posx = TEXDRAW_posy = 0;
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(texdraw_driver)
+    "texdraw",
+    "LaTeX texdraw environment",
+    TEXDRAW_XMAX, TEXDRAW_YMAX, TEXDRAW_VCHAR, TEXDRAW_HCHAR,
+    TEXDRAW_VTIC, TEXDRAW_HTIC, options_null, TEXDRAW_init, TEXDRAW_reset,
+    TEXDRAW_text, null_scale, TEXDRAW_graphics, TEXDRAW_move, TEXDRAW_vector,
+    TEXDRAW_linetype, TEXDRAW_put_text, TEXDRAW_text_angle,
+    TEXDRAW_justify_text, TEXDRAW_point, TEXDRAW_arrow, set_font_null
+TERM_TABLE_END(texdraw_driver)
+
+#undef LAST_TERM
+#define LAST_TERM texdraw_driver
+
+#endif /* TERM_TABLE */
+
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(texdraw)
+"1 texdraw",
+"?commands set terminal texdraw",
+"?set terminal texdraw",
+"?set term texdraw",
+"?terminal texdraw",
+"?term texdraw",
+"?texdraw",
+" The `texdraw` terminal driver supports the LaTeX texdraw environment.  It is",
+" intended for use with \"texdraw.sty\" and \"texdraw.tex\" in the texdraw package.",
+"",
+" Points, among other things, are drawn using the LaTeX commands \"\\Diamond\" and",
+" \"\\Box\".  These commands no longer belong to the LaTeX2e core; they are included",
+" in the latexsym package, which is part of the base distribution and thus part",
+" of any LaTeX implementation.  Please do not forget to use this package.",
+"",
+" It has no options."
+END_HELP(texdraw)
+#endif /* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/tgif.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/tgif.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/tgif.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/tgif.trm.svn-base	2012-01-03 17:07:45.306470300 -0800
@@ -0,0 +1,1788 @@
+/* Hello, Emacs, this is -*-C-*- */
+/* $Id: tgif.trm,v 1.45.2.3 2009/09/13 17:54:09 sfeam Exp $ */
+
+/* GNUPLOT - tgif.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*                                       */
+/* This file is included by ../term.c.                                     */
+/*                                                                         */
+/* This terminal driver supports:                                          */
+/*     TGIF                                                                */
+/*                                                                         */
+/* AUTHORS:                                                                */
+/*  Werner Geppert and Andreas Kuhlewind                                   */
+/*  March, 21st 1995                                                       */
+/*                                                                         */
+/* send your comments or suggestions to werner@mez.ruhr-uni-bochum.de      */
+/*                                                                         */
+/*                                                                         */
+/* MODIFIED May, 11st 1997 by NOVK Levente (novakl@tigris.klte.hu):       */
+/*                                                                         */
+/*          - Modified the default linewidth for borders from 3 to 2       */
+/*          - Modified the default size of markers' bounding box           */
+/*            to allow nicer shapes                                        */
+/*          - Slightly modified the markers and added several new ones,    */
+/*            now we have 64 different pointtypes, the same as for the     */
+/*            PostScript terminal                                          */
+/*          - I left the %.1f format for pixel positions, but I think      */
+/*            Tgif does only calculate with integer positions              */
+/*                                                                         */
+/* Modified  07 July 2000 by Ian MacPhedran                                */
+/*          - added PM3D support                                           */
+/*                                                                         */
+/* Modified  04 February 2002 by Levente Novk                             */
+/*          - break long "polygon()" directives into lines, as it made     */
+/*            Tgif fail polygons had >8 sides                              */
+/*            (e.g. when using "filledcurves")                             */
+/*                                                                         */
+/* Modified  29 November 2004  Shigeharu TAKENO <shige@iee.niit.ac.jp>     */
+/*          - add linewidth and monochrome options                         */
+/*            update option parsing to be order-independent                */
+/*                                                                         */
+/***************************************************************************/
+
+/*}}}  */
+/***************************************************************************/
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(tgif)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void TGIF_options __PROTO((void));
+TERM_PUBLIC void TGIF_init __PROTO((void));
+TERM_PUBLIC void TGIF_reset __PROTO((void));
+TERM_PUBLIC void TGIF_text __PROTO((void));
+TERM_PUBLIC void TGIF_graphics __PROTO((void));
+TERM_PUBLIC void TGIF_move __PROTO((unsigned int ux, unsigned int uy));
+TERM_PUBLIC void TGIF_vector __PROTO((unsigned int ux, unsigned int uy));
+TERM_PUBLIC void TGIF_linetype __PROTO((int linetype));
+TERM_PUBLIC void TGIF_put_text __PROTO((unsigned int ux, unsigned int uy, const char *str));	/* ref point and text */
+TERM_PUBLIC int TGIF_text_angle __PROTO((int ang));
+TERM_PUBLIC int TGIF_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC void TGIF_point __PROTO((unsigned int ux, unsigned int uy, int number));
+TERM_PUBLIC void TGIF_arrow __PROTO((unsigned int sx, unsigned int sy, unsigned int ex, unsigned int ey, int head));
+TERM_PUBLIC int TGIF_set_font __PROTO((const char *font));
+TERM_PUBLIC void TGIF_set_pointsize __PROTO((double size));
+TERM_PUBLIC void TGIF_set_linewidth __PROTO((double size));
+TERM_PUBLIC int TGIF_make_palette (t_sm_palette *);
+TERM_PUBLIC void TGIF_previous_palette (void);
+TERM_PUBLIC void TGIF_set_color (t_colorspec *);
+TERM_PUBLIC void TGIF_fillbox(int style, unsigned int x1, unsigned int y1, 
+			      unsigned int width, unsigned int height);
+TERM_PUBLIC void TGIF_FillSolid(char *curcolor,int fillpar);
+TERM_PUBLIC void TGIF_filled_polygon (int, gpiPoint *);
+/*}}}  */
+/* default length for static strings */
+#define TGIF_STRLEN_MAX 255
+
+/* standard x/y plot size in portrait mode */
+#define TGIF_XMAX 950
+#define TGIF_YMAX 634
+
+/* total available plotting area */
+#define TGIF_XTOT 950
+#define TGIF_YTOT 1400
+
+/* Offset  */
+#define TGIF_XOFF 50
+#define TGIF_YOFF 50
+
+#define TGIF_XSHIFT 1030	/* 80 points skip */
+#define TGIF_YSHIFT 714
+
+#define TGIF_VCHAR 18		/* default is 18 pt       */
+#define TGIF_HCHAR (18*6/10)
+
+#define TGIF_VTIC (TGIF_YMAX/80)
+#define TGIF_HTIC (TGIF_YMAX/80)
+
+#define TGIF_MAXPOLY 100
+/*}}}  */
+#define GOT_TGIF_PROTO
+#endif
+
+#ifndef TERM_PROTO_ONLY
+
+#ifdef TERM_BODY
+/* tgif driver by Werner Geppert, werner@mez.ruhr-uni-bochum.de */
+/***************************************************************************/
+/* Variables:                                                              */
+static unsigned int uLastTgifX, uLastTgifY;	/* last Coordinate         */
+
+static unsigned int uActNr;	/* current elementnumber                   */
+static unsigned int uActPage;	/* current pagenumber                      */
+static unsigned int uActResolution=100;	/* resolution in percent           */
+static unsigned int uActZoom;	/* zoom factor                             */
+static unsigned int uActAngle;	/* current textangle                       */
+static unsigned int uActThick;	/* actual linethickness                    */
+static unsigned int uActPointSize;	/* point size                      */
+static unsigned int uActStyle;	/* actual linestyle                        */
+static unsigned int uActJust;	/* actual textjustification                */
+static unsigned int uXshift;	/* actual shift x                          */
+static unsigned int uYshift;	/* actual shift y                          */
+static unsigned int uTgifPlotCount;	/* counts number of plots          */
+static unsigned int uTgifPlotRow=1, uTgifPlotCol=1;		/* actual plot row and col   */
+static unsigned int uTgif_win_horiz=1, /* number of plots in x and  */
+    uTgif_win_verti=1;	/*      y direction [x,y]         */
+
+static double dActThick_factor=1.0;  /* linewidth factor */
+static double dActThick_default=1.0; /* default linewidth factor */
+static TBOOLEAN TgifUseColor = TRUE;
+
+static char sActColor[TGIF_STRLEN_MAX];		/* current color         */
+static unsigned int uDefaultFontSize = 18;	/* default font size         */
+static unsigned int uActFontSize = 18;	/* current font size         */
+static char sDefaultFont[TGIF_STRLEN_MAX] = "Helvetica";	/* default font          */
+static char sActFont[TGIF_STRLEN_MAX] = "Helvetica";	/* current font          */
+/* static char          sActPointString[TGIF_STRLEN_MAX]; HBB: unused */
+
+static TBOOLEAN TgifSolid = FALSE;
+static TBOOLEAN TgifPortrait = TRUE;
+
+static unsigned int uTgifPlotsPerPage = 1;
+
+/*
+ * 10 different pointtypes need 10 different linetypes
+ */
+
+/* NL: Modified first value to 2 from 3 */
+static unsigned int uLineThick[] = { 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
+static unsigned int uLineStyle[] = { 0, 5, 0, 1, 2, 3, 4, 5, 6, 7, 8, 0 };
+static const char *psColors[] = {
+    "black", "black",		/* border and x/y-zero-axes       */
+    "red", "green", "blue", "magenta", "cyan", "yellow",
+    "DarkSeaGreen", "HotPink", "black", "coral"
+};
+/* for color density */
+static const rgb255_color psColorcomp[] = {
+    {0,0,0}, {0,0,0},
+    {255,0,0}, {0,255,0}, {0,0,255}, {255,0,255}, {0,255,255}, {255,255,0},
+    {143,188,143}, {255,105,180}, {0,0,0}, {255,127,80}
+};
+static rgb255_color rgbActColor;
+
+static unsigned int uFillPattern[] = { 2, 3, 5, 1, 20, 26, 21, 27, 14, 15 };
+#define TGIF_fillpatterns 10
+
+static int iTgifPolyCount;
+static unsigned int uBuffX[TGIF_MAXPOLY], uBuffY[TGIF_MAXPOLY];
+
+enum eState {
+    NEWPOLY = 100, INPOLY
+};
+static enum eState eTgifState = NEWPOLY;
+
+static void TGIF_flush_poly __PROTO((void));
+
+
+
+/*}}}  */
+/***************************************************************************/
+static void
+TGIF_flush_poly()
+{
+    int i;
+
+
+    if (eTgifState == INPOLY) {
+	fprintf(gpoutfile, "poly('%s',%d,[\n\t", sActColor, iTgifPolyCount);
+
+	for (i = 0; i < iTgifPolyCount - 1; i++) {
+	    fprintf(gpoutfile, "%u,%u,", uBuffX[i], uBuffY[i]);
+	    if ((i + 1) % 8 == 0)
+		fputs("\n\t", gpoutfile);
+	}
+
+	fprintf(gpoutfile, "%u,%u],0,%u,1,%u,0,0,%u,0,8,3,0,[\n]).\n",
+		uBuffX[iTgifPolyCount - 1], uBuffY[iTgifPolyCount - 1],
+		uActThick, uActNr, uActStyle);
+
+	uActNr++;
+
+	eTgifState = NEWPOLY;
+	iTgifPolyCount = 0;
+	if (gpoutfile != (FILE *) NULL)
+	    fflush(gpoutfile);
+    }
+}				/* TGIF_flush_poly */
+/*}}}  */
+/***************************************************************************/
+
+enum TGIF_id {
+    TGIF_MONOCHROME, TGIF_COLOR,
+    TGIF_LINEWIDTH,
+    TGIF_PORTRAIT, TGIF_LANDSCAPE,
+    TGIF_GRAPHS,
+    TGIF_SOLID, TGIF_DASHED,
+    TGIF_FONT,
+    TGIF_OTHER,
+    TGIF_DEFAULT
+};
+
+static struct gen_table TGIF_opts[] =
+{
+    {"mo$nochrome", TGIF_MONOCHROME},
+    {"c$olor", TGIF_COLOR},
+    {"c$olour", TGIF_COLOR},
+    {"linew$idth", TGIF_LINEWIDTH},
+    {"lw", TGIF_LINEWIDTH},
+    {"p$ortrait", TGIF_PORTRAIT},
+    {"l$andscape", TGIF_LANDSCAPE},
+    {"[", TGIF_GRAPHS},
+    {"s$olid", TGIF_SOLID},
+    {"d$ashed", TGIF_DASHED},
+    {"font", TGIF_FONT},
+    {"default", TGIF_DEFAULT},
+    {NULL, TGIF_OTHER}
+};
+
+TERM_PUBLIC void
+TGIF_options()
+{
+
+    struct value a, b;
+    double dscaleH, dscaleV;
+    int option;
+
+    while (!END_OF_COMMAND) {
+	option = lookup_table(&TGIF_opts[0],c_token);
+	switch(option) {
+	case TGIF_DEFAULT:
+	    strcpy(sActFont, "Helvetica");
+	    strcpy(sDefaultFont, "Helvetica");
+	    uActFontSize = 18;
+	    uDefaultFontSize = 18;
+	    term->v_char = (unsigned int) (uActFontSize);
+	    term->h_char = (unsigned int) (uActFontSize * 6 / 10);
+
+	    TgifPortrait = TRUE;
+	    TgifUseColor = TRUE;
+	    term->flags &= ~TERM_MONOCHROME;
+	    TgifSolid = FALSE;
+	    uTgifPlotsPerPage = 1;
+	    uTgifPlotRow = 1;
+	    uTgifPlotCol = 1;
+	    uTgif_win_horiz = 1;
+	    uTgif_win_verti = 1;
+	    uActResolution = 100;
+	    dActThick_factor = 1.0;
+	    dActThick_default = 1.0;
+	    c_token++;
+	    break;
+	case TGIF_MONOCHROME:
+	    TgifUseColor = FALSE;
+	    term->flags |= TERM_MONOCHROME;
+	    c_token++;
+	    break;
+	case TGIF_COLOR:
+	    TgifUseColor = TRUE;
+	    term->flags &= ~TERM_MONOCHROME;
+	    c_token++;
+	    break;
+	case TGIF_LINEWIDTH:
+	    c_token++;
+	    if (END_OF_COMMAND) {
+		int_error(c_token, "linewidth: width is not specified.");
+	    } else {
+		if((dActThick_default = real(const_express(&a)))<=0.0){
+		    int_error(c_token-1,"linewidth: out of range");
+		    dActThick_default = 1.0;
+		}
+	    }
+	    break;
+	case TGIF_PORTRAIT:
+	    TgifPortrait = TRUE;
+	    c_token++;
+	    break;
+	case TGIF_LANDSCAPE:
+	    TgifPortrait = FALSE;
+	    /* uActResolution = 140;
+	    */
+	    c_token++;
+	    break;
+	case TGIF_GRAPHS:
+	    c_token++;
+	    if (END_OF_COMMAND) {
+		int_error(c_token, "no. windows: [horizontal,vertical] expected");
+	    } else if (!equals(c_token, ",")) {
+		uTgif_win_horiz = (int) real(const_express(&a));
+	    }
+	    if (!equals(c_token, ","))
+		int_error(c_token, "',' expected");
+	    c_token++;
+	    if (!equals(c_token, "]")) {
+		uTgif_win_verti = (int) real(const_express(&a));
+	    }
+	    if (!equals(c_token, "]"))
+		int_error(c_token, "expecting ']'");
+	    c_token++;
+	    uTgifPlotsPerPage = uTgif_win_verti * uTgif_win_horiz;
+	    break;
+	case TGIF_SOLID:
+	    TgifSolid = TRUE;
+	    c_token++;
+	    break;
+	case TGIF_DASHED:
+	    TgifSolid = FALSE;
+	    c_token++;
+	    break;
+	case TGIF_FONT:
+	    c_token++;
+	    /* Fall through */
+	case TGIF_OTHER:
+	default:
+	{
+	    char *s;
+	    if ((s = try_to_get_string())) {
+		double fontsize;
+		int sep = strcspn(s,",");
+		if (s[sep] == ',' && (1 == sscanf(&s[sep+1],"%lf",&fontsize)))
+		    uActFontSize =  (int)(fontsize+0.5);
+		if (sep > 0) {
+		    strncpy(sActFont, s, sizeof(sActFont));
+		    sActFont[sep] = NUL;
+		}
+		strcpy(sDefaultFont, sActFont);
+		free(s);
+	    } else if (option == TGIF_FONT) {
+		int_error(c_token,"Expecting font name ");
+	    } else {
+		/* We have font size specified */
+		uActFontSize = (unsigned int) real(const_express(&b));
+		uDefaultFontSize = uActFontSize;
+		term->v_char = (unsigned int) (uActFontSize);
+		term->h_char = (unsigned int) (uActFontSize * 6 / 10);
+	    }
+	    break;
+	}
+	}
+    }
+    if (TgifPortrait) {
+	dscaleH = (double) 100.0 *(TGIF_XTOT) / (xsize * (TGIF_XMAX + (uTgif_win_horiz - 1) * TGIF_XSHIFT));
+	dscaleV = (double) 100.0 *(TGIF_YTOT) / (ysize * (TGIF_YMAX + (uTgif_win_verti - 1) * TGIF_YSHIFT));
+	uActResolution = (int) GPMIN(dscaleH, dscaleV);
+	switch (uTgif_win_verti) {
+	case 1:
+	    uActZoom = 0;
+	    break;
+
+	case 2:
+	    uActZoom = 1;
+	    break;
+	default:
+	    uActZoom = 2;
+	    break;
+
+	}
+    } else {
+	dscaleH = (double) 100.0 *(TGIF_YTOT) / (xsize * (TGIF_XMAX + (uTgif_win_horiz - 1) * TGIF_XSHIFT));
+	dscaleV = (double) 100.0 *(TGIF_XTOT) / (ysize * (TGIF_YMAX + (uTgif_win_verti - 1) * TGIF_YSHIFT));
+	uActResolution = (unsigned int) GPMIN(dscaleH, dscaleV);
+
+	switch (uTgif_win_verti) {
+	case 1:
+	    uActZoom = 0;
+	    break;
+
+	case 2:
+	    uActZoom = 1;
+	    break;
+	default:
+	    uActZoom = 2;
+	    break;
+
+	}
+    }
+
+    sprintf(&(term_options[strlen(term_options)]), "%s [%u,%u]",
+	    TgifPortrait ? "portrait" : "landscape",
+	    uTgif_win_horiz, uTgif_win_verti);
+
+    strcat(term_options, TgifUseColor ? " color" : " monochrome");
+    sprintf(&(term_options[strlen(term_options)]), " linewidth %f", 
+	    dActThick_default);
+    sprintf(&(term_options[strlen(term_options)]), " %s \"%s\" %u",
+	    TgifSolid ? "solid" : "dashed",
+	    sActFont, uActFontSize);
+}
+/*}}}  */
+/***************************************************************************/
+TERM_PUBLIC void
+TGIF_init()
+{
+
+    if (multiplot) {
+	/* uActResolution= TgifPortrait ? (unsigned int)100 : (unsigned int)145 ; */
+	uActResolution = (unsigned int) 100;
+
+	if (uTgifPlotsPerPage > 1) {
+	    fputs("warning: using standard multiplot\n", stderr);
+	    uTgifPlotsPerPage = 1;
+	}
+	uActZoom = 1;
+    }
+    fprintf(gpoutfile, "\
+%%TGIF 2.15-p7\n\
+state(%d,30,%u,0,0,%u,16,1,9,1,1,0,0,0,0,1,0,'%s',0,%u,0,0,1,10,0,0,1,1,0,16,0,0,1,1,1).\n\
+%%\n\
+%% @(#)Creator: gnuplot %s patchlevel %s\n\
+%% %%W%%\n\
+%%\n\
+page(1,\"\").\n",
+	    TgifPortrait ? 0 : 1, uActResolution, uActZoom, sActFont, uActFontSize,
+	    gnuplot_version, gnuplot_patchlevel);
+    eTgifState = NEWPOLY;
+    iTgifPolyCount = 0;
+    uTgifPlotCount = 0;
+    uActPage = 1;
+}				/* TGIF_init */
+/*}}}  */
+
+/***************************************************************************/
+TERM_PUBLIC void
+TGIF_graphics()
+{
+
+    TGIF_flush_poly();
+
+    if (multiplot) {
+
+	term->xmax = (TgifPortrait) ? TGIF_XTOT : TGIF_YTOT;
+	term->ymax = (TgifPortrait) ? TGIF_YTOT : TGIF_XTOT;
+	uLastTgifX = (TgifPortrait) ? TGIF_XOFF : TGIF_YOFF;
+	uLastTgifY = (TgifPortrait) ? TGIF_YTOT + TGIF_YOFF : TGIF_XTOT + TGIF_XOFF;
+
+	uYshift = uLastTgifY;
+	uXshift = uLastTgifX;
+
+    } else {
+	if (uTgifPlotCount < uTgifPlotsPerPage)
+	    uTgifPlotCount++;
+	else {
+	    fputs("error: number of plots > plots per page\n", stderr);
+	    return;
+	}
+
+	uXshift = (unsigned int) TGIF_XOFF *100 / uActResolution + (xsize * (uTgifPlotCol - 1) * TGIF_XSHIFT);
+	uYshift = (unsigned int) TGIF_YOFF *100 / uActResolution + (ysize * (TGIF_YMAX +
+									     (uTgifPlotRow - 1) * TGIF_YSHIFT));
+
+	if (uTgifPlotCount % uTgif_win_horiz == 0) {
+	    uTgifPlotCol = 1;
+	    uTgifPlotRow++;
+	} else {
+	    uTgifPlotCol++;
+	}
+
+	uLastTgifX = uXshift;
+	uLastTgifY = uYshift;
+
+    }
+
+
+
+
+
+/* default settings for each plot */
+    iTgifPolyCount = 0;
+    uActNr = 0;
+    uActAngle = 0;
+    uActThick = 1;
+    uActStyle = 0;
+    uActJust = LEFT;
+    strcpy(sActColor,psColors[0]); /* black */
+    rgbActColor = psColorcomp[0];
+
+}				/* TGIF_graphics */
+/*}}}  */
+/***************************************************************************/
+TERM_PUBLIC void
+TGIF_text()
+{
+    TGIF_flush_poly();
+
+
+}				/* TGIF_text */
+
+/*}}}  */
+/***************************************************************************/
+TERM_PUBLIC void
+TGIF_reset()
+{
+    TGIF_flush_poly();
+    iTgifPolyCount = 0;
+    uTgifPlotCount = 0;
+    uTgifPlotRow = 1;
+    uTgifPlotCol = 1;
+
+
+    if (gpoutfile != (FILE *) NULL)
+	fflush(gpoutfile);
+
+}				/* TGIF_reset */
+/*}}}  */
+/***************************************************************************/
+TERM_PUBLIC void
+TGIF_linetype(int linetype)
+{
+    unsigned int ult;
+
+
+    TGIF_flush_poly();
+
+
+    if (linetype >= 0)
+	ult = 2 + linetype % 10;
+    else if (linetype < -2)
+	ult = 0;
+    else
+	ult = linetype + 2;
+
+    if (TgifUseColor == FALSE) {
+	strcpy(sActColor,"black");
+	rgbActColor = psColorcomp[0];
+    }
+    else{
+	strcpy(sActColor, psColors[ult]);
+	rgbActColor = psColorcomp[ult];
+    }
+    uActThick = dActThick_factor * dActThick_default * uLineThick[ult]+0.5;
+    if (!TgifSolid)
+	uActStyle = uLineStyle[ult];
+    else {
+	if (ult == 1)		/* grid */
+	    uActStyle = uLineStyle[ult];
+	else
+	    uActStyle = uLineStyle[2];
+
+    }
+
+}				/* TGIF_linetype */
+/*}}}  */
+/***************************************************************************/
+TERM_PUBLIC void
+TGIF_move(unsigned int ux, unsigned int uy)
+{
+
+    uLastTgifX = ux + uXshift;
+    uLastTgifY = uYshift - uy;
+
+    if (eTgifState == INPOLY)
+	TGIF_flush_poly();
+
+
+
+}				/* TGIF_move */
+/*}}}  */
+/***************************************************************************/
+TERM_PUBLIC void
+TGIF_vector(unsigned int ux, unsigned int uy)
+{
+
+    ux = ux + uXshift;
+    uy = uYshift - uy;
+
+
+
+    if (eTgifState == NEWPOLY) {
+	uBuffX[0] = uLastTgifX;
+	uBuffY[0] = uLastTgifY;
+	iTgifPolyCount = 1;
+	eTgifState = INPOLY;
+    }
+    uBuffX[iTgifPolyCount] = ux;
+    uBuffY[iTgifPolyCount] = uy;
+    uLastTgifX = ux;
+    uLastTgifY = uy;
+    iTgifPolyCount++;
+    eTgifState = INPOLY;
+
+    if (iTgifPolyCount == TGIF_MAXPOLY) {
+	TGIF_flush_poly();
+
+    }
+}				/* TGIF_vector */
+/*}}}  */
+/***************************************************************************/
+TERM_PUBLIC void
+TGIF_arrow(
+    unsigned int sx, unsigned int sy,
+    unsigned int ex, unsigned int ey,
+    int head)
+{
+
+    TGIF_flush_poly();
+
+    sx = sx + uXshift;
+    ex = ex + uXshift;
+    sy = uYshift - sy;
+    ey = uYshift - ey;
+
+
+    if (head) {
+	fprintf(gpoutfile, "\
+poly('%s',%d,[\n\
+\t%u,%u,%u,%u],1,%u,1,%u,0,0,%u,0,8,3,0,[\n]).\n",
+		sActColor, 2, sx, sy, ex, ey, uActThick, uActNr, uActStyle);
+    } else {
+	fprintf(gpoutfile, "\
+poly('%s',%d,[\n\
+\t%u,%u,%u,%u],1,%u,1,%u,0,0,%u,0,8,3,0,[\n]).\n",
+		sActColor, 2, sx, sy, ex, ey, uActThick, uActNr, uActStyle);
+    }
+
+    uActNr++;
+
+
+
+    uLastTgifX = ex;
+    uLastTgifY = ey;
+
+}				/* TGIF_arrow */
+/*}}}  */
+/***************************************************************************/
+TERM_PUBLIC void
+TGIF_put_text(unsigned int ux, unsigned int uy, const char *str)
+{
+
+    unsigned int x, y;
+    struct termentry *t = term;
+
+    TGIF_flush_poly();
+
+    x = ux + uXshift;
+    y = uYshift - uy - t->v_char / 2;
+
+    if (strlen(str) == 0)
+	return;
+
+    fprintf(gpoutfile, "\
+text('%s',%u,%u,'%s',0,%u,1,%u,%u,1,55,119,%u,0,15,4,0,0,0,0,[\n\t\"%s\"]).\n",
+	    sActColor, x, y, sActFont, uActFontSize,
+	    (uActAngle ? CENTRE : uActJust), uActAngle,
+	    uActNr, str);
+
+    uActNr += 2;
+
+
+}				/* TGIF_put_text */
+/*}}}  */
+/***************************************************************************/
+TERM_PUBLIC int
+TGIF_text_angle(int ang)
+{
+    switch (ang) {
+	case   90:	uActAngle = 3; break;
+	case  180:
+	case -180:	uActAngle = 2; break;
+	case  -90:
+	case  270:	uActAngle = 1; break;
+	default:	uActAngle = 0; break;
+    }
+    return (TRUE);
+}				/* TGIF_text_angle */
+
+/*}}}  */
+/***************************************************************************/
+TERM_PUBLIC int
+TGIF_justify_text(enum JUSTIFY mode)
+{
+    uActJust = mode;
+    return (TRUE);
+}				/* TGIF_justify_text */
+
+/*}}}  */
+/***************************************************************************/
+TERM_PUBLIC void
+TGIF_point(unsigned int ux, unsigned int uy, int number)
+{
+    double p;		/* all pointtypes fit in a (x +/-p)x(y +/-p) box */
+
+    double x, y;
+
+
+
+    x = (double) (ux + uXshift);
+    y = (double) (uYshift - uy);
+
+    p = pointsize * 8.0;	/* NL: Increased the bounding box (p value) from 4.0 to 8.0 */
+    if (p == (double) 0.0)
+	p = 0.1;
+
+    TGIF_flush_poly();
+
+    if (number != -1)
+	number = number % 63;
+    switch (number) {
+    case -1:
+	/* HBB: corrected format string, shuts up gcc -Wall */
+	fprintf(gpoutfile, "\
+poly('%s',2,[\n\t%.1f,%.1f,%.1f,%.1f],0,1,1,%u,0,0,0,0,8,3,0,[\n]).\n",
+		sActColor, x, y, x + 1, y + 1, uActNr++);
+	break;
+    case 0:
+	/* plus */
+	/* taking thickness 2 for cross & plus & star */
+	fprintf(gpoutfile, "\
+group([\n\
+poly('%s',2,[\n\t%.1f,%.1f,%.1f,%.1f],0,2,1,%u,0,0,0,0,8,3,0,[\n]),\n\
+poly('%s',2,[\n\t%.1f,%.1f,%.1f,%.1f],0,2,1,%u,0,0,0,0,8,3,0,[\n])\n",
+		sActColor, x, y - p - 1, x, y + p + 1, uActNr+1,
+		sActColor, x - p - 1, y, x + p + 1, y, uActNr+2);
+	uActNr += 4;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 1:
+	/* cross */
+	/* taking thickness 2 for cross & plus & star */
+	fprintf(gpoutfile, "\
+group([\n\
+poly('%s',2,[\n\t%.1f,%.1f,%.1f,%.1f],0,2,1,%u,0,0,0,0,8,3,0,[\n]).\n\
+poly('%s',2,[\n\t%.1f,%.1f,%.1f,%.1f],0,2,1,%u,0,0,0,0,8,3,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr+1,
+		sActColor, x - p, y + p, x + p, y - p, uActNr+2);
+	uActNr += 4;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 2:
+	/* star */
+	/* taking thickness 2 for cross & plus & star */
+	fputs("group([\n", gpoutfile);
+	fprintf(gpoutfile, "\
+poly('%s',2,[\n\t%.1f,%.1f,%.1f,%.1f],0,2,1,%u,0,0,0,0,8,3,0,[\n]),\n",
+		sActColor, x, y - p - 1, x, y + p + 1, uActNr++);
+	fprintf(gpoutfile, "\
+poly('%s',2,[\n\t%.1f,%.1f,%.1f,%.1f],0,2,1,%u,0,0,0,0,8,3,0,[\n])\n",
+		sActColor, x - p - 1, y, x + p + 1, y, uActNr++);
+	fprintf(gpoutfile, "\
+poly('%s',2,[\n\t%.1f,%.1f,%.1f,%.1f],0,2,1,%u,0,0,0,0,8,3,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr++);
+	fprintf(gpoutfile, "\
+poly('%s',2,[\n\t%.1f,%.1f,%.1f,%.1f],0,2,1,%u,0,0,0,0,8,3,0,[\n]).\n",
+		sActColor, x - p, y + p, x + p, y - p, uActNr++);
+	uActNr += 4;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 3:
+	/* box */
+	fprintf(gpoutfile, "\
+box('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr);
+	uActNr++;
+	break;
+	/*}}}  */
+    case 4:
+	/* filled box */
+	fprintf(gpoutfile, "\
+box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr);
+	uActNr++;
+	break;
+	/*}}}  */
+    case 5:
+	/* circle */
+	fprintf(gpoutfile, "\
+oval('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr);
+	uActNr++;
+	break;
+	/*}}}  */
+    case 6:
+	/* filled circle */
+	fprintf(gpoutfile, "\
+oval('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr);
+	uActNr++;
+	break;
+	/*}}}  */
+    case 7:
+	/* triangle up */
+	fprintf(gpoutfile, "\
+polygon('%s',4,[\n\
+%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x, y - p, x + p, y + 0.75 * p, x - p, y + 0.75 * p,
+		x, y - p, uActNr);
+	uActNr++;
+	break;
+	/*}}}  */
+    case 8:
+	/* filled triangle up */
+	fprintf(gpoutfile, "\
+polygon('%s',4,[\n\
+%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x, y - p, x + p, y + 0.75 * p, x - p, y + 0.75 * p,
+		x, y - p, uActNr);
+	uActNr++;
+	break;
+	/*}}}  */
+    case 9:
+	/* triangle down */
+	fprintf(gpoutfile, "\
+polygon('%s',4,[\n\
+%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x, y + p, x - p, y - 0.75 * p, x + p, y - 0.75 * p,
+		x, y + p, uActNr);
+	uActNr++;
+	break;
+	/*}}}  */
+    case 10:
+	/* filled triangle down */
+	fprintf(gpoutfile, "\
+polygon('%s',4,[\n\
+%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x, y + p, x - p, y - 0.75 * p, x + p, y - 0.75 * p,
+		x, y + p, uActNr);
+	uActNr++;
+	break;
+	/*}}}  */
+    case 11:
+	/* diamond */
+	fprintf(gpoutfile, "\
+polygon('%s',5,[\n\
+%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n\
+]).\n",
+		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p,
+		uActNr);
+	uActNr++;
+	break;
+	/*}}}  */
+    case 12:
+	/* filled diamond */
+	fprintf(gpoutfile, "\
+polygon('%s',5,[\n\
+%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n\
+]).\n",
+		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p,
+		uActNr);
+	uActNr++;
+	break;
+	/*}}}  */
+    case 13:
+	/* pentagon */
+	fprintf(gpoutfile, "\
+polygon('%s',6,[\n\
+%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x, y - p, x + p, y - p / 4, x + 0.625 * p, y + p,
+		x - 0.625 * p, y + p, x - p, y - p / 4, x, y - p, uActNr);
+	uActNr++;
+	break;
+	/*}}}  */
+    case 14:
+	/* filled pentagon */
+	fprintf(gpoutfile, "\
+polygon('%s',6,[\n\
+%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x, y - p, x + p, y - p / 4, x + 0.625 * p, y + p,
+		x - 0.625 * p, y + p, x - p, y - p / 4, x, y - p, uActNr);
+	uActNr++;
+	break;
+	/*}}}  */
+    case 15:
+	/* circle1 */
+	fputs("group([\n", gpoutfile);
+	fprintf(gpoutfile, "\
+oval('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n\
+]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr++);
+	fprintf(gpoutfile, "\
+arc('%s',1,1,1,0,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,0,%.1f,%.1f,4480,2560,%u,0,0,8,3,0,[\n]).\n",
+		sActColor, x - p, y - p, x, y, x + p * 0.342, y - p * 0.94,
+		x - p * 0.342, y - p * 0.94, 2 * p, 2 * p, uActNr++);
+	uActNr += 2;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 16:
+	/* circle2 */
+	fputs("group([\n", gpoutfile);
+	fprintf(gpoutfile, "\
+oval('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr++);
+	fprintf(gpoutfile, "\
+arc('%s',1,1,1,0,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,0,%.1f,%.1f,0,5760,%u,0,0,8,3,0,[\n]).\n",
+		sActColor, x - p, y - p, x, y, x + p, y, x, y - p, 2 * p,
+		2 * p, uActNr++);
+	uActNr += 2;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 17:
+	/* circle3 */
+	fputs("group([\n", gpoutfile);
+	fprintf(gpoutfile, "\
+oval('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr++);
+	fprintf(gpoutfile, "\
+arc('%s',1,1,1,0,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,0,%.1f,%.1f,5760,5760,%u,0,0,8,3,0,[\n]).\n",
+		sActColor, x - p, y - p, x, y, x, y - p, x - p, y, 2 * p,
+		2 * p, uActNr++);
+	uActNr += 2;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 18:
+	/* circle4 */
+	fputs("group([\n", gpoutfile);
+	fprintf(gpoutfile, "\
+oval('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr++);
+	fprintf(gpoutfile, "\
+arc('%s',1,1,1,0,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,0,%.1f,%.1f,0,11520,%u,0,0,8,3,0,[\n]).\n",
+		sActColor, x - p, y - p, x, y, x + p, y, x - p, y, 2 * p,
+		2 * p, uActNr++);
+	uActNr += 2;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 19:
+	/* circle5 */
+	fputs("group([\n", gpoutfile);
+	fprintf(gpoutfile, "\
+oval('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr++);
+	fprintf(gpoutfile, "\
+arc('%s',1,1,1,0,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,0,%.1f,%.1f,11520,5760,%u,0,0,8,3,0,[\n]).\n",
+		sActColor, x - p, y - p, x, y, x - p, y, x, y + p, 2 * p,
+		2 * p, uActNr++);
+	uActNr += 2;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 20:
+	/* circle6 */
+	fputs("group([\n", gpoutfile);
+	fprintf(gpoutfile, "\
+oval('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr++);
+	fprintf(gpoutfile, "\
+arc('%s',1,1,1,0,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,0,%.1f,%.1f,0,5760,%u,0,0,8,3,0,[\n]).\n",
+		sActColor, x - p, y - p, x, y, x + p, y, x, y - p, 2 * p,
+		2 * p, uActNr++);
+	fprintf(gpoutfile, "\
+arc('%s',1,1,1,0,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,0,%.1f,%.1f,11520,5760,%u,0,0,8,3,0,[\n]).\n",
+		sActColor, x - p, y - p, x, y, x - p, y, x, y + p, 2 * p,
+		2 * p, uActNr++);
+	uActNr += 3;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 21:
+	/* circle7 */
+	fputs("group([\n", gpoutfile);
+	fprintf(gpoutfile, "\
+oval('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr++);
+	fprintf(gpoutfile, "\
+arc('%s',1,1,1,0,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,0,%.1f,%.1f,5760,11520,%u,0,0,8,3,0,[\n]).\n",
+		sActColor, x - p, y - p, x, y, x, y - p, x, y + p, 2 * p,
+		2 * p, uActNr++);
+	uActNr += 2;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 22:
+	/* circle8 */
+	fputs("group([\n", gpoutfile);
+	fprintf(gpoutfile, "\
+oval('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr++);
+	fprintf(gpoutfile, "\
+arc('%s',1,1,1,0,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,0,%.1f,%.1f,0,17280,%u,0,0,8,3,0,[\n]).\n",
+		sActColor, x - p, y - p, x, y, x + p, y, x, y + p, 2 * p,
+		2 * p, uActNr++);
+	uActNr += 2;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 23:
+	/* circle9 */
+	fputs("group([\n", gpoutfile);
+	fprintf(gpoutfile, "\
+oval('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr++);
+	fprintf(gpoutfile, "\
+arc('%s',1,1,1,0,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,0,%.1f,%.1f,17280,5760,%u,0,0,8,3,0,[\n]).\n",
+		sActColor, x - p, y - p, x, y, x, y + p, x + p, y, 2 * p,
+		2 * p, uActNr++);
+	uActNr += 2;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 24:
+	/* circle10 */
+	fputs("group([\n", gpoutfile);
+	fprintf(gpoutfile, "\
+oval('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr++);
+	fprintf(gpoutfile, "\
+arc('%s',1,1,1,0,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,0,%.1f,%.1f,17280,11520,%u,0,0,8,3,0,[\n]).\n",
+		sActColor, x - p, y - p, x, y, x, y + p, x, y - p, 2 * p,
+		2 * p, uActNr++);
+	uActNr += 2;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 25:
+	/* circle11 */
+	fputs("group([\n", gpoutfile);
+	fprintf(gpoutfile, "\
+oval('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr++);
+	fprintf(gpoutfile, "\
+arc('%s',1,1,1,0,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,0,%.1f,%.1f,5760,5760,%u,0,0,8,3,0,[\n]).\n",
+		sActColor, x - p, y - p, x, y, x, y - p, x - p, y, 2 * p,
+		2 * p, uActNr++);
+	fprintf(gpoutfile, "\
+arc('%s',1,1,1,0,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,0,%.1f,%.1f,17280,5760,%u,0,0,8,3,0,[\n]).\n",
+		sActColor, x - p, y - p, x, y, x, y + p, x + p, y, 2 * p,
+		2 * p, uActNr++);
+	uActNr += 3;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 26:
+	/* circle12 */
+	fprintf(gpoutfile, "group([\n");
+	fprintf(gpoutfile, "oval('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr++);
+	fprintf(gpoutfile,
+		"arc('%s',1,1,1,0,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,0,%.1f,%.1f,17280,17280,%u,0,0,8,3,0,[\n]).\n",
+		sActColor, x - p, y - p, x, y, x, y + p, x - p, y, 2 * p, 2 * p, uActNr++);
+	uActNr += 2;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 27:
+	/* circle13 */
+	fprintf(gpoutfile, "group([\n");
+	fprintf(gpoutfile, "oval('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr++);
+	fprintf(gpoutfile,
+		"arc('%s',1,1,1,0,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,0,%.1f,%.1f,11520,11520,%u,0,0,8,3,0,[\n]).\n",
+		sActColor, x - p, y - p, x, y, x - p, y, x + p, y, 2 * p, 2 * p, uActNr++);
+	uActNr += 2;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 28:
+	/* circle14 */
+	fprintf(gpoutfile, "group([\n");
+	fprintf(gpoutfile, "oval('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr++);
+	fprintf(gpoutfile,
+		"arc('%s',1,1,1,0,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,0,%.1f,%.1f,11520,17280,%u,0,0,8,3,0,[\n]).\n",
+		sActColor, x - p, y - p, x, y, x - p, y, x, y - p, 2 * p, 2 * p, uActNr++);
+	uActNr += 2;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 29:
+	/* circle15 */
+	fprintf(gpoutfile, "group([\n");
+	fprintf(gpoutfile, "oval('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr++);
+	fprintf(gpoutfile,
+		"arc('%s',1,1,1,0,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,0,%.1f,%.1f,5760,17280,%u,0,0,8,3,0,[\n]).\n",
+		sActColor, x - p, y - p, x, y, x, y - p, x + p, y, 2 * p, 2 * p, uActNr++);
+	uActNr += 2;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 30:
+	/* circle16 */
+	fprintf(gpoutfile, "oval('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr);
+	uActNr++;
+	break;
+	/*}}}  */
+    case 31:
+	/* box1 */
+	fprintf(gpoutfile, "group([\n");
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr++);
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p / 4, y - p, x + p / 4, y, uActNr++);
+	uActNr += 2;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 32:
+	/* box2 */
+	fprintf(gpoutfile, "group([\n");
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr++);
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x, y - p, x + p, y, uActNr++);
+	uActNr += 2;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 33:
+	/* box3 */
+	fprintf(gpoutfile, "group([\n");
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr++);
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x, y, uActNr++);
+	uActNr += 2;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 34:
+	/* box4 */
+	fprintf(gpoutfile, "group([\n");
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr++);
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y, uActNr++);
+	uActNr += 2;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 35:
+	/* box5 */
+	fprintf(gpoutfile, "group([\n");
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr++);
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y, x, y + p, uActNr++);
+	uActNr += 2;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 36:
+	/* box6 */
+	fprintf(gpoutfile, "group([\n");
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr++);
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x, y - p, x + p, y, uActNr++);
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y, x, y + p, uActNr++);
+	uActNr += 3;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 37:
+	/* box7 */
+	fprintf(gpoutfile, "group([\n");
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr++);
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x, y + p, uActNr++);
+	uActNr += 2;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 38:
+	/* box8 */
+	fprintf(gpoutfile, "group([\n");
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr++);
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y, uActNr++);
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y, x, y + p, uActNr++);
+	uActNr += 3;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 39:
+	/* box9 */
+	fprintf(gpoutfile, "group([\n");
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr++);
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x, y, x + p, y + p, uActNr++);
+	uActNr += 2;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 40:
+	/* box10 */
+	fprintf(gpoutfile, "group([\n");
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr++);
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x, y - p, x + p, y + p, uActNr++);
+	uActNr += 2;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 41:
+	/* box11 */
+	fprintf(gpoutfile, "group([\n");
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr++);
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x, y, uActNr++);
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x, y, x + p, y + p, uActNr++);
+	uActNr += 3;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 42:
+	/* box12 */
+	fprintf(gpoutfile, "group([\n");
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr++);
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y, uActNr++);
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x, y, x + p, y + p, uActNr++);
+	uActNr += 3;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 43:
+	/* box13 */
+	fprintf(gpoutfile, "group([\n");
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr++);
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y, x + p, y + p, uActNr++);
+	uActNr += 2;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 44:
+	/* box14 */
+	fprintf(gpoutfile, "group([\n");
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr++);
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x, y - p, x + p, y, uActNr++);
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y, x + p, y + p, uActNr++);
+	uActNr += 3;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 45:
+	/* box15 */
+	fprintf(gpoutfile, "group([\n");
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,2,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr++);
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x, y, uActNr++);
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y, x + p, y + p, uActNr++);
+	uActNr += 3;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 46:
+	/* box16 */
+	fprintf(gpoutfile, "box('%s',%.1f,%.1f,%.1f,%.1f,1,1,1,%u,0,0,0,[\n]).\n",
+		sActColor, x - p, y - p, x + p, y + p, uActNr);
+	uActNr++;
+	break;
+	/*}}}  */
+    case 47:
+	/* diamond1 */
+	fprintf(gpoutfile, "group([\n");
+	fprintf(gpoutfile,
+		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p, uActNr);
+	fprintf(gpoutfile,
+		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x - 0.625 * p, y - 0.375 * p, x - 0.375 * p, y - 0.625 * p, x + p / 8,
+		y - p / 8, x - p / 8, y + p / 8, x - 0.625 * p, y - 0.375 * p, uActNr);
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	uActNr += 2;
+	break;
+	/*}}}  */
+    case 48:
+	/* diamond2 */
+	fprintf(gpoutfile, "group([\n");
+	fprintf(gpoutfile,
+		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p, uActNr);
+	fprintf(gpoutfile,
+		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x - p / 2, y - p / 2, x, y - p, x + p / 2, y - p / 2, x, y, x - p / 2,
+		y - p / 2, uActNr);
+	uActNr += 2;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 49:
+	/* diamond3 */
+	fprintf(gpoutfile, "group([\n");
+	fprintf(gpoutfile,
+		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p, uActNr);
+	fprintf(gpoutfile,
+		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x - p, y, x - p / 2, y - p / 2, x, y, x - p / 2, y + p / 2, x - p, y, uActNr);
+	uActNr += 2;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 50:
+	/* diamond4 */
+	fprintf(gpoutfile, "group([\n");
+	fprintf(gpoutfile,
+		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p, uActNr);
+	fprintf(gpoutfile,
+		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x - p, y, x, y - p, x + p / 2, y - p / 2, x - p / 2, y + p / 2, x - p,
+		y, uActNr);
+	uActNr += 2;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 51:
+	/* diamond5 */
+	fprintf(gpoutfile, "group([\n");
+	fprintf(gpoutfile,
+		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p, uActNr);
+	fprintf(gpoutfile,
+		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x - p / 2, y + p / 2, x, y, x + p / 2, y + p / 2, x, y + p, x - p / 2,
+		y + p / 2, uActNr);
+	uActNr += 2;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 52:
+	/* diamond6 */
+	fprintf(gpoutfile, "group([\n");
+	fprintf(gpoutfile,
+		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p, uActNr);
+	fprintf(gpoutfile,
+		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x - p / 2, y - p / 2, x, y - p, x + p / 2, y - p / 2, x, y, x - p / 2,
+		y - p / 2, uActNr);
+	fprintf(gpoutfile,
+		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x - p / 2, y + p / 2, x, y, x + p / 2, y + p / 2, x, y + p, x - p / 2,
+		y + p / 2, uActNr);
+	uActNr += 3;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 53:
+	/* diamond7 */
+	fprintf(gpoutfile, "group([\n");
+	fprintf(gpoutfile,
+		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p, uActNr);
+	fprintf(gpoutfile,
+		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x - p, y, x - p / 2, y - p / 2, x + p / 2, y + p / 2, x, y + p, x - p,
+		y, uActNr);
+	uActNr += 2;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 54:
+	/* diamond8 */
+	fprintf(gpoutfile, "group([\n");
+	fprintf(gpoutfile,
+		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p, uActNr);
+	fprintf(gpoutfile,
+		"polygon('%s',7,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x - p, y, x, y - p, x + p / 2, y - p / 2, x, y, x + p / 2, y + p / 2,
+		x, y + p, x - p, y, uActNr);
+	uActNr += 2;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 55:
+	/* diamond9 */
+	fprintf(gpoutfile, "group([\n");
+	fprintf(gpoutfile,
+		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p, uActNr);
+	fprintf(gpoutfile,
+		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x, y, x + p / 2, y - p / 2, x + p, y, x + p / 2, y + p / 2, x, y, uActNr);
+	uActNr += 2;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 56:
+	/* diamond10 */
+	fprintf(gpoutfile, "group([\n");
+	fprintf(gpoutfile,
+		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p, uActNr);
+	fprintf(gpoutfile,
+		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x - p / 2, y - p / 2, x, y - p, x + p, y, x + p / 2, y + p / 2, x - p /
+		2, y - p / 2, uActNr);
+	uActNr += 2;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 57:
+	/* diamond11 */
+	fprintf(gpoutfile, "group([\n");
+	fprintf(gpoutfile,
+		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p, uActNr);
+	fprintf(gpoutfile,
+		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x - p, y, x - p / 2, y - p / 2, x, y, x - p / 2, y + p / 2, x - p, y, uActNr);
+	fprintf(gpoutfile,
+		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x, y, x + p / 2, y - p / 2, x + p, y, x + p / 2, y + p / 2, x, y, uActNr);
+	uActNr += 3;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 58:
+	/* diamond12 */
+	fprintf(gpoutfile, "group([\n");
+	fprintf(gpoutfile,
+		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p, uActNr);
+	fprintf(gpoutfile,
+		"polygon('%s',7,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x - p, y, x, y - p, x + p, y, x + p / 2, y + p / 2, x, y, x - p / 2, y
+		+ p / 2, x - p, y, uActNr);
+	uActNr += 2;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 59:
+	/* diamond13 */
+	fprintf(gpoutfile, "group([\n");
+	fprintf(gpoutfile,
+		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p, uActNr);
+	fprintf(gpoutfile,
+		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x - p / 2, y + p / 2, x + p / 2, y - p / 2, x + p, y, x, y + p, x - p /
+		2, y + p / 2, uActNr);
+	uActNr += 2;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 60:
+	/* diamond14 */
+	fprintf(gpoutfile, "group([\n");
+	fprintf(gpoutfile,
+		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p, uActNr);
+	fprintf(gpoutfile,
+		"polygon('%s',7,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x - p / 2, y - p / 2, x, y - p, x + p, y, x, y + p, x - p / 2, y + p /
+		2, x, y, x - p / 2, y - p / 2, uActNr);
+	uActNr += 2;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 61:
+	/* diamond15 */
+	fprintf(gpoutfile, "group([\n");
+	fprintf(gpoutfile,
+		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],0,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p, uActNr);
+	fprintf(gpoutfile,
+		"polygon('%s',7,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x - p, y, x - p / 2, y - p / 2, x, y, x + p / 2, y - p / 2, x + p, y,
+		x, y + p, x - p, y, uActNr);
+	uActNr += 2;
+	fprintf(gpoutfile, "],\n%u,0,[\n]).\n", uActNr++);
+	break;
+	/*}}}  */
+    case 62:
+	/* diamond16 */
+	fprintf(gpoutfile,
+		"polygon('%s',5,[\n%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f],1,1,1,0,%u,0,0,0,0,0,[\n]).\n",
+		sActColor, x, y + p, x + p, y, x, y - p, x - p, y, x, y + p, uActNr);
+	uActNr++;
+	break;
+	/*}}}  */
+
+    }				/* switch */
+}				/* TGIF_point */
+
+/*}}}  */
+/***************************************************************************/
+TERM_PUBLIC void
+TGIF_set_pointsize(double size)
+{
+    uActPointSize = size < 0. ? 1. : size;
+}
+
+TERM_PUBLIC void
+TGIF_set_linewidth(double size)
+{
+    dActThick_factor = size < 0. ? 1. : size;
+}
+
+/*}}}  */
+/***************************************************************************/
+TERM_PUBLIC int
+TGIF_set_font(const char *font)
+{
+    int sep;
+
+    if (!font || !(*font))
+        font = sDefaultFont;
+    sep = strcspn(font, ",");
+    if (sep > 0) {
+	strncpy(sActFont, font, sep);
+	sActFont[sep] = NUL;
+    }
+    sscanf(&(font[sep + 1]), "%d", &uActFontSize);
+    return TRUE;
+}
+
+TERM_PUBLIC int
+TGIF_make_palette(t_sm_palette *palette)
+{
+    return 0; 
+    /* can do continuous colors */
+}
+
+TERM_PUBLIC void 
+TGIF_previous_palette(void)
+{
+    /* do nothing */
+}
+
+TERM_PUBLIC void
+TGIF_set_color(t_colorspec *colorspec)
+{
+    if (colorspec->type == TC_LT) {
+	TGIF_linetype(colorspec->lt);
+    } else if (colorspec->type == TC_FRAC) {
+	rgb255maxcolors_from_gray(colorspec->value, &rgbActColor);
+	sprintf(sActColor, "#%.2x%.2x%.2x", 
+		rgbActColor.r, rgbActColor.g, rgbActColor.b);
+    } else if (colorspec->type == TC_RGB) {
+	rgbActColor.r = colorspec->lt >> 16 & 0xff;
+	rgbActColor.g = colorspec->lt >> 8 & 0xff;
+	rgbActColor.b = colorspec->lt & 0xff;
+	sprintf(sActColor, "#%.2x%.2x%.2x", 
+		rgbActColor.r, rgbActColor.g, rgbActColor.b);
+    }
+}
+
+TERM_PUBLIC void
+TGIF_fillbox(int style, unsigned int x1, unsigned int y1, 
+	     unsigned int width, unsigned int height)
+{
+    gpiPoint corner[4];
+
+	corner[0].x = x1;        corner[0].y = y1;
+	corner[1].x = x1+width;  corner[1].y = y1;
+	corner[2].x = x1+width;  corner[2].y = y1+height;
+	corner[3].x = x1;        corner[3].y = y1+height;
+	corner->style = style;
+
+	TGIF_filled_polygon(4, corner);
+}
+
+TERM_PUBLIC void
+TGIF_FillSolid(char *curcolor,int fillpar)
+{
+    int red, green, blue;
+    double fact = (double)(100 - fillpar) * 0.01;
+
+    if (fact < 0.0) fact = 0.0;
+    else if (fact > 1.0) fact = 1.0;
+    red   = rgbActColor.r + (0xff - rgbActColor.r) * fact;
+    green = rgbActColor.g + (0xff - rgbActColor.g) * fact;
+    blue  = rgbActColor.b + (0xff - rgbActColor.b) * fact;
+    sprintf(curcolor,"#%.2x%.2x%.2x", red, green, blue);
+}
+
+TERM_PUBLIC void
+TGIF_filled_polygon(int points, gpiPoint *corners)
+{
+    int i,pattern;
+    int fillpar = corners->style >> 4;
+    int style = corners->style & 0xf;
+    char curcolor[TGIF_STRLEN_MAX];
+
+    if (eTgifState == INPOLY)
+	TGIF_flush_poly(); /* Clean up current data */
+
+    switch (style) {
+    case FS_EMPTY:
+	pattern=uFillPattern[0];
+	strcpy(curcolor,"white");
+	break;
+    case FS_TRANSPARENT_PATTERN:
+    case FS_PATTERN:
+	pattern=uFillPattern[fillpar % TGIF_fillpatterns];
+	strcpy(curcolor,sActColor);
+	break;
+    case FS_TRANSPARENT_SOLID:
+    case FS_SOLID:
+	pattern=1;
+	TGIF_FillSolid(curcolor,fillpar);
+	break;
+    default:
+	pattern=1;
+	strcpy(curcolor,sActColor);
+    }
+
+    fprintf(gpoutfile, "polygon('%s',%d,[\n\t",curcolor,points+1);
+    /* loop through points, do the first one last as well as first */
+    fprintf(gpoutfile,"%u,%u,", corners[0].x+uXshift, uYshift-corners[0].y);
+    for (i = 1; i < points; i++) {
+	fprintf(gpoutfile, "%u,%u,",
+		corners[i].x+uXshift, uYshift-corners[i].y);
+	/* LN: Break long lines as Tgif is rather picky about them */
+        if ((i + 1) % 8 == 0)
+	    fputs("\n\t", gpoutfile);
+    }
+    fprintf(gpoutfile, "%u,%u", corners[0].x+uXshift, uYshift-corners[0].y);
+    fprintf(gpoutfile, "],%d,1,0,0,%u,0,0,0,0,[\n]).\n", pattern, uActNr);
+    uActNr++;
+}
+
+/*}}}  */
+/***************************************************************************/
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(tgif_driver)
+    "tgif",
+    "TGIF X11 [mode] [x,y] [dashed] [\042font\042 [fontsize]]",
+    TGIF_XMAX, TGIF_YMAX, TGIF_VCHAR, TGIF_HCHAR,
+    TGIF_VTIC, TGIF_HTIC, TGIF_options, TGIF_init, TGIF_reset,
+    TGIF_text, null_scale, TGIF_graphics, TGIF_move, TGIF_vector,
+    TGIF_linetype, TGIF_put_text, TGIF_text_angle,
+    TGIF_justify_text, TGIF_point, TGIF_arrow, TGIF_set_font,
+    TGIF_set_pointsize, 
+    TERM_CAN_MULTIPLOT|TERM_CAN_DASH|TERM_LINEWIDTH, 
+    0, 0, TGIF_fillbox,
+    TGIF_set_linewidth
+#ifdef USE_MOUSE
+    ,0, 0, 0, 0, 0 /* no mouse support for the tgif terminal */
+#endif
+    , TGIF_make_palette, TGIF_previous_palette, TGIF_set_color, 
+    TGIF_filled_polygon
+TERM_TABLE_END(tgif_driver)
+
+#undef LAST_TERM
+#define LAST_TERM tgif_driver
+
+#endif /* TERM_TABLE */
+
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(tgif)
+"1 tgif",
+"?commands set terminal tgif",
+"?set terminal tgif",
+"?set term tgif",
+"?terminal tgif",
+"?term tgif",
+"?tgif",
+" Tgif is an X11-based drawing tool---it has nothing to do with GIF.",
+"",
+" The `tgif` driver supports different pointsizes (with `set pointsize`),",
+" different label fonts and font sizes (e.g. `set label \"Hallo\" at x,y font",
+" \"Helvetica,34\"`) and multiple graphs on the page.  The proportions of the",
+" axes are not changed.",
+"",
+" Syntax:",
+"       set terminal tgif {portrait | landscape | default} {<[x,y]>}",
+"                         {monochrome | color}",
+"                         {{linewidth | lw} <LW>}",
+"                         {solid | dashed}",
+"                         {font \"<fontname>\"} {<fontsize>}",
+"",
+" where <[x,y]> specifies the number of graphs in the x and y directions on the",
+" page, `color` enables color, `linewidth` scales all linewidths by <LW>,",
+" \"<fontname>\" is the name of a valid PostScript font, and <fontsize>",
+" specifies the size of the PostScript font.",
+" `defaults` sets all options to their defaults: `portrait`, `[1,1]`, `color`,",
+" `linwidth 1.0`, `dashed`, `\"Helvetica\"`, and `18`.",
+"",
+" The `solid` option is usually prefered if lines are colored, as they often",
+" are in the editor.  Hardcopy will be black-and-white, so `dashed` should be",
+" chosen for that.",
+"",
+" Multiplot is implemented in two different ways.",
+"",
+" The first multiplot implementation is the standard gnuplot multiplot feature:",
+"",
+"       set terminal tgif",
+"       set output \"file.obj\"",
+"       set multiplot",
+"       set origin x01,y01",
+"       set size  xs,ys",
+"       plot ...",
+"            ...",
+"       set origin x02,y02",
+"       plot ...",
+"       unset multiplot",
+"",
+" See `set multiplot` for further information.",
+"",
+" The second version is the [x,y] option for the driver itself.  The advantage",
+" of this implementation is that everything is scaled and placed automatically",
+" without the need for setting origins and sizes; the graphs keep their natural",
+" x/y proportions of 3/2 (or whatever is fixed by `set size`).",
+"",
+" If both multiplot methods are selected, the standard method is chosen and a",
+" warning message is given.",
+"",
+" Examples of single plots (or standard multiplot):",
+"       set terminal tgif                  # defaults",
+"       set terminal tgif \"Times-Roman\" 24",
+"       set terminal tgif landscape",
+"       set terminal tgif landscape solid",
+"",
+" Examples using the built-in multiplot mechanism:",
+"       set terminal tgif portrait [2,4]  # portrait; 2 plots in the x-",
+"                                         # and 4 in the y-direction",
+"       set terminal tgif [1,2]           # portrait; 1 plot in the x-",
+"                                         # and 2 in the y-direction",
+"       set terminal tgif landscape [3,3] # landscape; 3 plots in both",
+"                                         # directions"
+END_HELP(tgif)
+#endif
+/*{{{}}}*/
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/tkcanvas.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/tkcanvas.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/tkcanvas.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/tkcanvas.trm.svn-base	2012-01-03 17:07:45.582185300 -0800
@@ -0,0 +1,665 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: tkcanvas.trm,v 1.28 2006/08/27 22:10:46 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - tkcanvas.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *  Tk/Tcl canvas widgets
+ *
+ * AUTHORS - original dxy.trm
+ *  Martin Yii, eln557h@monu3.OZ
+ *  Further modified Jan 1990 by Russell Lang, rjl@monu1.cc.monash.oz
+ *
+ * Port to the Tk/Tcl canvas widget
+ *  D. Jeff Dionne, July 1995 jeff@ryeham.ee.ryerson.ca
+ *  Alex Woo, woo@playfair.stanford.edu
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+
+/*
+ * adapted to the new terminal layout by Alex Woo (Sept. 1996)
+ */
+
+/*
+ * extended interactive Tk/Tcl capabilities
+ * Thomas Sefzick, March 1999, t.sefzick@fz-juelich.de
+ *
+ * added the perltk.trm code written by Slaven Rezic <eserte@cs.tu-berlin.de>,
+ * the variable 'tk_perl' switches between tcl/tk and perltk code.
+ * 'linewidth' and 'justify text' added, ends of plotted lines are now rounded.
+ * Thomas Sefzick, May 1999, t.sefzick@fz-juelich.de
+ *
+ * scale plot to fit into the actual size of the canvas as reported by
+ * the window manager (the canvas itself doesn't report its real size).
+ * Matt Willis, October 1999, mattbwillis@my-deja.com
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(tkcanvas)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void TK_options __PROTO((void));
+TERM_PUBLIC void TK_init __PROTO((void));
+TERM_PUBLIC void TK_graphics __PROTO((void));
+TERM_PUBLIC void TK_text __PROTO((void));
+TERM_PUBLIC void TK_linetype __PROTO((int linetype));
+TERM_PUBLIC void TK_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void TK_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void TK_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC void TK_reset __PROTO((void));
+TERM_PUBLIC int TK_justify_text __PROTO((enum JUSTIFY));
+TERM_PUBLIC int TK_set_font __PROTO((const char *font));
+TERM_PUBLIC void TK_linewidth __PROTO((double linewidth));
+
+#define TK_XMAX 1000
+#define TK_YMAX 1000
+
+#define TK_XLAST (TK_XMAX - 1)
+#define TK_YLAST (TK_XMAX - 1)
+
+#define TK_VCHAR	(25)	/* double actual height of characters */
+#define TK_HCHAR	(16)	/* actual width including spacing */
+#define TK_VTIC	(18)
+#define TK_HTIC	(18)
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+/* axis.c */
+/* FIXME HBB 20000725: "Never use extern in a source file". This needs
+ * to be fixed.  As is, this driver causes the terminal layer to
+ * depend on several other core modules. The lack of proper #include's
+ * partly hides this, but it's still a design bug. "term" is supposed
+ * a 'frontier' layer: it should not be dependant on any other code
+ * inside gnuplot */
+extern AXIS axis_array[];
+/* command.c */
+extern TBOOLEAN is_3d_plot;
+
+/* static int tk_angle = 0; unused, for now */
+static int tk_lastx;
+static int tk_lasty;
+static int tk_color = 0;
+static char tk_anchor[7] = "w";
+static double tk_linewidth = 1.0;
+static int tk_perl = 0;
+static int tk_interactive = 0;
+static const char *tk_colors[] = {
+    "black", "gray", "red", "blue", "green", "brown", "magenta", "cyan"
+};
+
+enum TK_id { TK_PERLTK, TK_INTERACTIVE, TK_OTHER };
+
+static struct gen_table TK_opts[] =
+{
+    { "p$erltk", TK_PERLTK },
+    { "i$nteractive", TK_INTERACTIVE },
+    { NULL, TK_OTHER }
+};
+
+TERM_PUBLIC void
+TK_options()
+{
+    tk_perl = 0;
+    tk_interactive = 0;
+
+    while (!END_OF_COMMAND) {
+	switch(lookup_table(&TK_opts[0],c_token)) {
+	case TK_PERLTK:
+	    tk_perl = 1;
+	    c_token++;
+	    break;
+	case TK_INTERACTIVE:
+	    tk_interactive = 1;
+	    c_token++;
+	    break;
+	case TK_OTHER:
+	default:
+	    c_token++;
+	    break;
+	}
+    }
+
+    sprintf(term_options, "%s %s",
+	    tk_perl ? "perltk" : "",
+	    tk_interactive ? "interactive" : "");
+}
+
+TERM_PUBLIC void
+TK_init()
+{
+}
+
+TERM_PUBLIC void
+TK_graphics()
+{
+	/*
+	 * the resulting tcl or perl code takes the actual width and height
+	 * of the defined canvas and scales the plot to fit.
+	 * => NOTE: this makes 'set size' useless !!!
+	 * unless the original width and height is taken into account
+	 * by some tcl or perl code, that's why the 'gnuplot_plotarea' and
+	 * 'gnuplot_axisranges' procedures are supplied.
+	 */
+    if (tk_perl) {
+	fputs("\
+sub {\n\
+my($can) = @_;\n\
+$can->delete('all');\n\
+my $cmx = $can->width - 2 * $can->cget(-border) - 2 * $can->cget(-highlightthickness);\n\
+if ($cmx <= 1) {\n$cmx = ($can->cget(-width));\n}\n\
+my $cmy = $can->height - 2 * $can->cget(-border) - 2 * $can->cget(-highlightthickness);\n\
+if ($cmy <= 1) {\n$cmy = ($can->cget(-height));\n}\n",
+	      gpoutfile);
+    } else {
+	fputs("\
+proc gnuplot can {\n\
+$can delete all\n\
+set cmx [expr [winfo width $can]-2*[$can cget -border]-2*[$can cget -highlightthickness]]\n\
+if {$cmx <= 1} {set cmx [$can cget -width]}\n\
+set cmy [expr [winfo height $can]-2*[$can cget -border]-2*[$can cget -highlightthickness]]\n\
+if {$cmy <= 1} {set cmy [$can cget -height]}\n",
+	      gpoutfile);
+    }
+    tk_lastx = tk_lasty = tk_color = 0;
+}
+
+TERM_PUBLIC void
+TK_reset()
+{
+}
+
+TERM_PUBLIC void
+TK_linetype(int linetype)
+{
+    if (linetype < -2)
+	linetype = LT_BLACK;
+    tk_color = (linetype + 2) & 7;
+}
+
+TERM_PUBLIC void
+TK_linewidth(double linewidth)
+{
+    tk_linewidth = linewidth;
+}
+
+TERM_PUBLIC void
+TK_move(unsigned int x, unsigned int y)
+{
+    tk_lastx = x;
+    tk_lasty = 1000 - y;
+}
+
+/* FIXME HBB 20000725: should use AXIS_UNDO_LOG() macro... */
+#define TK_REAL_VALUE(value,axis)				\
+(axis_array[axis].log)						\
+    ? pow(axis_array[axis].base, axis_array[axis].min		\
+	  + value*(axis_array[axis].max-axis_array[axis].min))	\
+	: axis_array[axis].min					\
+          + value*(axis_array[axis].max-axis_array[axis].min)
+
+#define TK_X_VALUE(value) \
+ (double)(value-plot_bounds.xleft)/(double)(plot_bounds.xright-plot_bounds.xleft)
+
+#define TK_Y_VALUE(value) \
+ (double)((TK_YMAX-value)-plot_bounds.ybot)/(double)(plot_bounds.ytop-plot_bounds.ybot)
+
+TERM_PUBLIC void
+TK_vector(unsigned int x, unsigned int y)
+{
+	/*
+	 * this is the 1st part of the wrapper around the 'create line' command
+	 * used to bind some actions to a line segment:
+	 * bind {
+	 *      normal create line command
+	 *      } gnuplot_xy(some coordinates)
+	 */
+    if (tk_interactive && !is_3d_plot) {
+	if (tk_perl)
+	    fprintf(gpoutfile, "$can->bind(");
+	else
+	    fprintf(gpoutfile, "$can bind [\n");
+    }
+	/*
+	 * end of 1st part of wrapper
+	 */
+    y = 1000 - y;
+	/*
+	 * here is the basic well-known command for plotting a line segment
+	 */
+    if (tk_perl) {
+	fprintf(gpoutfile,"\
+$can->createLine(\
+$cmx * %d / 1000, \
+$cmy * %d / 1000, \
+$cmx * %d / 1000, \
+$cmy * %d / 1000, -fill => q{%s}, -width => %f, -capstyle => q{round})",
+		tk_lastx, tk_lasty, x, y, tk_colors[tk_color], tk_linewidth);
+    } else {
+	fprintf(gpoutfile,"\
+$can create line \
+[expr $cmx * %d /1000] \
+[expr $cmy * %d /1000] \
+[expr $cmx * %d /1000] \
+[expr $cmy * %d /1000] -fill %s -width %f -capstyle round\n",
+		tk_lastx, tk_lasty, x, y, tk_colors[tk_color], tk_linewidth);
+    }
+
+	/*
+	 * this is the 2nd part of the wrapper around the 'create line'
+         * command it generates a mechanism which calls 'gnuplot_xy' for
+         * the line segment pointed to by the mouse cursor when a mouse
+         * button is pressed
+	 */
+    if (tk_interactive && !is_3d_plot) {
+	if (tk_perl) {
+	    /* Ev('W') not needed here, supplied anyhow, WHY ??? */
+	    fprintf(gpoutfile,"\
+, '<Button>' => \
+[\\&gnuplot_xy, %f, %f, %f, %f, %f, %f, %f, %f,",
+		    TK_REAL_VALUE(TK_X_VALUE(tk_lastx), FIRST_X_AXIS),
+		    TK_REAL_VALUE(TK_Y_VALUE(tk_lasty), FIRST_Y_AXIS),
+		    TK_REAL_VALUE(TK_X_VALUE(tk_lastx), SECOND_X_AXIS),
+		    TK_REAL_VALUE(TK_Y_VALUE(tk_lasty), SECOND_Y_AXIS),
+		    TK_REAL_VALUE(TK_X_VALUE(x), FIRST_X_AXIS),
+		    TK_REAL_VALUE(TK_Y_VALUE(y), FIRST_Y_AXIS),
+		    TK_REAL_VALUE(TK_X_VALUE(x), SECOND_X_AXIS),
+		    TK_REAL_VALUE(TK_Y_VALUE(y), SECOND_Y_AXIS));
+	    if (axis_array[FIRST_X_AXIS].log) {
+		fprintf(gpoutfile, " %f,",
+			TK_REAL_VALUE(TK_X_VALUE(0.5 * (x + tk_lastx)), FIRST_X_AXIS));
+	    } else {
+		fprintf(gpoutfile, " \"\",");
+	    }
+	    if (axis_array[FIRST_Y_AXIS].log) {
+		fprintf(gpoutfile, " %f,",
+			TK_REAL_VALUE(TK_Y_VALUE(0.5 * (y + tk_lasty)), FIRST_Y_AXIS));
+	    } else {
+		fprintf(gpoutfile, " \"\",");
+	    }
+	    if (axis_array[SECOND_X_AXIS].log) {
+		fprintf(gpoutfile, " %f,",
+			TK_REAL_VALUE(TK_X_VALUE(0.5 * (x + tk_lastx)), SECOND_X_AXIS));
+	    } else {
+		fprintf(gpoutfile, " \"\",");
+	    }
+	    if (axis_array[SECOND_Y_AXIS].log) {
+		fprintf(gpoutfile, " %f",
+			TK_REAL_VALUE(TK_Y_VALUE(0.5 * (y + tk_lasty)), SECOND_Y_AXIS));
+	    } else {
+		fprintf(gpoutfile, " \"\"");
+	    }
+	    fprintf(gpoutfile, "]);\n");
+	} else {
+	    fprintf(gpoutfile,"\
+] <Button> \
+\"gnuplot_xy %%W %f %f %f %f %f %f %f %f",
+		    TK_REAL_VALUE(TK_X_VALUE(tk_lastx), FIRST_X_AXIS),
+		    TK_REAL_VALUE(TK_Y_VALUE(tk_lasty), FIRST_Y_AXIS),
+		    TK_REAL_VALUE(TK_X_VALUE(tk_lastx), SECOND_X_AXIS),
+		    TK_REAL_VALUE(TK_Y_VALUE(tk_lasty), SECOND_Y_AXIS),
+		    TK_REAL_VALUE(TK_X_VALUE(x), FIRST_X_AXIS),
+		    TK_REAL_VALUE(TK_Y_VALUE(y), FIRST_Y_AXIS),
+		    TK_REAL_VALUE(TK_X_VALUE(x), SECOND_X_AXIS),
+		    TK_REAL_VALUE(TK_Y_VALUE(y), SECOND_Y_AXIS));
+	    if (axis_array[FIRST_X_AXIS].log) {
+		fprintf(gpoutfile, " %f",
+			TK_REAL_VALUE(TK_X_VALUE(0.5 * (x + tk_lastx)), FIRST_X_AXIS));
+	    } else {
+		fprintf(gpoutfile, " {}");
+	    }
+	    if (axis_array[FIRST_Y_AXIS].log) {
+		fprintf(gpoutfile, " %f",
+			TK_REAL_VALUE(TK_Y_VALUE(0.5 * (y + tk_lasty)), FIRST_Y_AXIS));
+	    } else {
+		fprintf(gpoutfile, " {}");
+	    }
+	    if (axis_array[SECOND_X_AXIS].log) {
+		fprintf(gpoutfile, " %f",
+			TK_REAL_VALUE(TK_X_VALUE(0.5 * (x + tk_lastx)), SECOND_X_AXIS));
+	    } else {
+		fprintf(gpoutfile, " {}");
+	    }
+	    if (axis_array[SECOND_Y_AXIS].log) {
+		fprintf(gpoutfile, " %f",
+			TK_REAL_VALUE(TK_Y_VALUE(0.5 * (y + tk_lasty)), SECOND_Y_AXIS));
+	    } else {
+		fprintf(gpoutfile, " {}");
+	    }
+	    fprintf(gpoutfile, "\"\n");
+	}
+    } else {
+	if (tk_perl) {
+	    fprintf(gpoutfile, ";\n");
+	}
+    }
+	/*
+	 * end of the wrapper
+	 */
+    tk_lastx = x;
+    tk_lasty = y;
+}
+
+#undef TK_REAL_VALUE
+#undef TK_X_VALUE
+#undef TK_Y_VALUE
+
+TERM_PUBLIC void
+TK_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    y = 1000 - y;
+    if (tk_perl) {
+	fprintf(gpoutfile,"\
+$can->createText($cmx * %d / 1000, $cmy * %d / 1000, -text => q{%s}, \
+-fill => q{%s}, -anchor => '%s', (defined $font ? (-font => $font) : ()));\n",
+		x, y, str, tk_colors[tk_color], tk_anchor);
+    } else {
+        /* Have to quote-protect '[' and ']' characters */
+        int i, newsize = 0;
+        char *quoted_str;
+
+        for (i=0; str[i] != '\0'; i++) {
+            if ((str[i] == '[') || (str[i] == ']'))
+                newsize++;
+            newsize++;
+        }
+        quoted_str = gp_alloc(newsize + 1, "TK_put_text: quoted string");
+
+        for (i=0, newsize = 0; str[i] != '\0'; i++) {
+            if ((str[i] == '[') || (str[i] == ']'))
+                quoted_str[newsize++] = '\\';
+            quoted_str[newsize++] = str[i];
+        }
+        quoted_str[newsize] = '\0';
+	fprintf(gpoutfile,"\
+eval $can create text \
+[expr $cmx * %d /1000] \
+[expr $cmy * %d /1000] \
+-text \\{%s\\} -fill %s -anchor %s\
+ [expr [info exists font]?\"-font \\$font\":{}]\n",
+		x, y, quoted_str, tk_colors[tk_color], tk_anchor);
+       free(quoted_str);
+    } /* else (!tk_perl) */
+}
+
+TERM_PUBLIC int
+TK_justify_text(enum JUSTIFY anchor)
+{
+    int return_value;
+
+    switch (anchor) {
+    case RIGHT:
+	strcpy(tk_anchor, "e");
+	return_value = TRUE;
+	break;
+    case CENTRE:
+	strcpy(tk_anchor, "center");
+	return_value = TRUE;
+	break;
+    case LEFT:
+	strcpy(tk_anchor, "w");
+	return_value = TRUE;
+	break;
+    default:
+	strcpy(tk_anchor, "w");
+	return_value = FALSE;
+    }
+    return return_value;
+}
+
+TERM_PUBLIC int
+TK_set_font(const char *font)
+{
+    if (!font || *font == NUL) {
+	if (tk_perl)
+	    fputs("undef $font;\n", gpoutfile);
+	else
+	    fputs("catch {unset $font}\n", gpoutfile);
+    } else {
+	char *name;
+	int size = 0;
+	size_t sep = strcspn(font, ",");
+
+	name = malloc(sep + 1);
+	if (!name)
+	    return FALSE;
+	strncpy(name, font, sep);
+	name[sep] = NUL;
+	if (sep < strlen(font))
+	    sscanf(&(font[sep + 1]), "%d", &size);
+	if (tk_perl) {
+	    fprintf(gpoutfile,"\
+if ($can->can('fontCreate')) {\n\
+$font = $can->fontCreate(-family => q{%s}",
+		    name);
+	    if (size)
+		fprintf(gpoutfile, ", -size => %d", size);
+	    fputs(");\n}\n", gpoutfile);
+	} else {
+	    fprintf(gpoutfile, "set font [font create -family %s", name);
+	    if (size)
+		fprintf(gpoutfile, " -size %d", size);
+	    fputs("]\n", gpoutfile);
+	}
+	free(name);
+    }
+    return TRUE;
+}
+
+TERM_PUBLIC void
+TK_text()
+{
+	/*
+	 * when switching back to text mode some procedures are generated which
+	 * return important information about plotarea size and axis ranges:
+	 * 'gnuplot_plotarea' returns the plotarea size in tkcanvas units
+	 * 'gnuplot_axisranges' returns the min. and max. values of the axis
+	 * these are essentially needed to set the size of the canvas when the
+	 * axis scaling is important.
+	 * moreover, a procedure 'gnuplot_xy' is created which contains the
+	 * actions bound to line segments (see the above 'TK_vector' code):
+	 * if the user has defined a procedure named 'user_gnuplot_coordinates'
+	 * then 'gnuplot_xy' calls this procedure, otherwise is writes the
+	 * coordinates of the line segment the mouse cursor is pointing to
+	 * to standard output.
+	 */
+    if (tk_perl) {
+	fputs("};\n", gpoutfile);
+	if (!is_3d_plot) {
+	    fputs("sub gnuplot_plotarea {\n", gpoutfile);
+	    fprintf(gpoutfile,
+		    "return (%d, %d, %d, %d);\n",
+		    plot_bounds.xleft, plot_bounds.xright, 1000 - plot_bounds.ytop, 1000 - plot_bounds.ybot);
+	    fputs("};\n", gpoutfile);
+	    fputs("sub gnuplot_axisranges {\n", gpoutfile);
+	    fprintf(gpoutfile,
+		    "return (%f, %f, %f, %f, %f, %f, %f, %f);\n",
+		    axis_array[FIRST_X_AXIS].min, axis_array[FIRST_X_AXIS].max,
+		    axis_array[FIRST_Y_AXIS].min, axis_array[FIRST_Y_AXIS].max,
+		    axis_array[SECOND_X_AXIS].min, axis_array[SECOND_X_AXIS].max,
+		    axis_array[SECOND_Y_AXIS].min, axis_array[SECOND_Y_AXIS].max);
+	    fputs("};\n", gpoutfile);
+	    if (tk_interactive) {
+		fputs("sub gnuplot_xy {\n",
+		      gpoutfile);
+		fputs("my ($win, $x1s, $y1s, $x2s, $y2s, $x1e, $y1e, $x2e, $y2e, $x1m, $y1m, $x2m, $y2m) = @_;\n",
+		      gpoutfile);
+		fputs("if (defined &user_gnuplot_coordinates) {\n",
+		      gpoutfile);
+		fputs("my $id = $win->find('withtag', 'current');\n",
+		      gpoutfile);
+		fputs("user_gnuplot_coordinates $win, $id, $x1s, $y1s, $x2s, $y2s, $x1e, $y1e, $x2e, $y2e, $x1m, $y1m, $x2m, $y2m\n",
+		      gpoutfile);
+		fputs("} else {\n",
+		      gpoutfile);
+		fputs("if (length($x1m)>0) {print \" $x1m\";} else {print \" \", 0.5*($x1s+$x1e);}\n",
+		      gpoutfile);
+		fputs("if (length($y1m)>0) {print \" $y1m\";} else {print \" \", 0.5*($y1s+$y1e);}\n",
+		      gpoutfile);
+		fputs("if (length($x2m)>0) {print \" $x2m\";} else {print \" \", 0.5*($x2s+$x2e);}\n",
+		      gpoutfile);
+		fputs("if (length($y2m)>0) {print \" $y2m\";} else {print \" \", 0.5*($y2s+$y2e);}\n",
+		      gpoutfile);
+		fputs("print \"\\n\"\n",
+		      gpoutfile);
+		fputs("}\n",
+		      gpoutfile);
+		fputs("};\n", gpoutfile);
+	    }
+	}
+    } else {
+	fputs("}\n", gpoutfile);
+	if (!is_3d_plot) {
+	    fputs("proc gnuplot_plotarea {} {\n", gpoutfile);
+	    fprintf(gpoutfile,
+		    "return {%d %d %d %d}\n",
+		    plot_bounds.xleft, plot_bounds.xright, 1000 - plot_bounds.ytop, 1000 - plot_bounds.ybot);
+	    fputs("}\n", gpoutfile);
+	    fputs("proc gnuplot_axisranges {} {\n", gpoutfile);
+	    fprintf(gpoutfile,
+		    "return {%f %f %f %f %f %f %f %f}\n",
+		    axis_array[FIRST_X_AXIS].min, axis_array[FIRST_X_AXIS].max,
+		    axis_array[FIRST_Y_AXIS].min, axis_array[FIRST_Y_AXIS].max,
+		    axis_array[SECOND_X_AXIS].min, axis_array[SECOND_X_AXIS].max,
+		    axis_array[SECOND_Y_AXIS].min, axis_array[SECOND_Y_AXIS].max);
+	    fputs("}\n", gpoutfile);
+	    if (tk_interactive) {
+		fputs("proc gnuplot_xy {win x1s y1s x2s y2s x1e y1e x2e y2e x1m y1m x2m y2m} {\n",
+		      gpoutfile);
+		fputs("if {([llength [info commands user_gnuplot_coordinates]])} {\n",
+		      gpoutfile);
+		fputs("set id [$win find withtag current]\n",
+		      gpoutfile);
+		fputs("user_gnuplot_coordinates $win $id $x1s $y1s $x2s $y2s $x1e $y1e $x2e $y2e $x1m $y1m $x2m $y2m\n",
+		      gpoutfile);
+		fputs("} else {\n", gpoutfile);
+		fputs("if {[string length $x1m]>0} {puts -nonewline \" $x1m\"} else {puts -nonewline \" [expr 0.5*($x1s+$x1e)]\"}\n",
+		      gpoutfile);
+		fputs("if {[string length $y1m]>0} {puts -nonewline \" $y1m\"} else {puts -nonewline \" [expr 0.5*($y1s+$y1e)]\"}\n",
+		      gpoutfile);
+		fputs("if {[string length $x2m]>0} {puts -nonewline \" $x2m\"} else {puts -nonewline \" [expr 0.5*($x2s+$x2e)]\"}\n",
+		      gpoutfile);
+		fputs("if {[string length $y2m]>0} {puts \" $y2m\"} else {puts \" [expr 0.5*($y2s+$y2e)]\"}\n",
+		      gpoutfile);
+		fputs("}\n", gpoutfile);
+		fputs("}\n", gpoutfile);
+	    }
+	}
+    }
+    fflush(gpoutfile);
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(tkcanvas)
+    "tkcanvas", "Tk/Tcl canvas widget [perltk] [interactive]",
+    TK_XMAX, TK_YMAX, TK_VCHAR, TK_HCHAR,
+    TK_VTIC, TK_HTIC, TK_options, TK_init, TK_reset,
+    TK_text, null_scale, TK_graphics, TK_move, TK_vector,
+    TK_linetype, TK_put_text, null_text_angle,
+    TK_justify_text, do_point, do_arrow, TK_set_font,
+    NULL, 0, NULL, NULL, NULL, TK_linewidth
+TERM_TABLE_END(tkcanvas)
+#undef LAST_TERM
+#define LAST_TERM tkcanvas
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(tkcanvas)
+"1 tkcanvas",
+"?commands set terminal tkcanvas",
+"?set terminal tkcanvas",
+"?set term tkcanvas",
+"?terminal tkcanvas",
+"?term tkcanvas",
+"?tkcanvas",
+" This terminal driver generates Tk canvas widget commands based on Tcl/Tk",
+" (default) or Perl.  To use it, rebuild `gnuplot` (after uncommenting or",
+" inserting the appropriate line in \"term.h\"), then",
+"",
+"  gnuplot> set term tkcanvas {perltk} {interactive}",
+"  gnuplot> set output 'plot.file'",
+"",
+" After invoking \"wish\", execute the following sequence of Tcl/Tk commands:",
+"",
+"  % source plot.file",
+"  % canvas .c",
+"  % pack .c",
+"  % gnuplot .c",
+"",
+" Or, for Perl/Tk use a program like this:",
+"",
+"  use Tk;",
+"  my $top = MainWindow->new;",
+"  my $c = $top->Canvas->pack;",
+"  my $gnuplot = do \"plot.pl\";",
+"  $gnuplot->($c);",
+"  MainLoop;",
+"",
+" The code generated by `gnuplot` creates a procedure called \"gnuplot\"",
+" that takes the name of a canvas as its argument.  When the procedure is",
+" called, it clears the canvas, finds the size of the canvas and draws the plot",
+" in it, scaled to fit.",
+"",
+" For 2-dimensional plotting (`plot`) two additional procedures are defined:",
+" \"gnuplot_plotarea\" will return a list containing the borders of the plotting",
+" area \"xleft, xright, ytop, ybot\" in canvas screen coordinates, while the ranges",
+" of the two axes \"x1min, x1max, y1min, y1max, x2min, x2max, y2min, y2max\" in plot",
+" coordinates can be obtained calling \"gnuplot_axisranges\".",
+" If the \"interactive\" option is specified, mouse clicking on a line segment",
+" will print the coordinates of its midpoint to stdout. Advanced actions",
+" can happen instead if the user supplies a procedure named",
+" \"user_gnuplot_coordinates\", which takes the following arguments:",
+" \"win id x1s y1s x2s y2s x1e y1e x2e y2e x1m y1m x2m y2m\",",
+" the name of the canvas and the id of the line segment followed by the",
+" coordinates of its start and end point in the two possible axis ranges; the",
+" coordinates of the midpoint are only filled for logarithmic axes.",
+"",
+" The current version of `tkcanvas` supports neither `multiplot` nor `replot`."
+END_HELP(tkcanvas)
+#endif
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/tpic.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/tpic.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/tpic.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/tpic.trm.svn-base	2012-01-03 17:07:45.795739100 -0800
@@ -0,0 +1,968 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: tpic.trm,v 1.21 2006/07/21 02:35:48 sfeam Exp $
+ */
+
+/* GNUPLOT - tpic.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *   The tpic \specials (version 2.2) for LaTeX.
+ *
+ * AUTHORS
+ *   Oh-Yeah?   3 Sep. 1992 (closely following eepic.trm by David Kotz)
+ *   A. Woo     5 Oct. 1992 (removed ansi prototypes for braindead compilers)
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+/*
+ *  This file contains the tpic terminal driver for use with LaTeX.
+ *  This is an alternative to the latex and eepic drivers. You need
+ *  a printer driver that supports the tpic \specials version 2.2.
+ *
+ * Comparison with the eepic driver (eepic.trm):
+ *  Merits
+ *    - More point and line types
+ *    - Options to change point size, linewidth, dot & dash intervals
+ *    - Dotted and dashed lines for high-sample-rate curves (but may
+ *      depend on tpic (da & dt) implementation of your dvi driver :-)
+ *    - Overlapped points made fancier by tpic shading facility
+ *    - Optional comments for trimming figure margins
+ *    - No need for epic and eepic macros
+ *  Drawback
+ *    - You cannot use eepicemu macro for non-tpic-support dvi drivers
+ *
+ * LATEX must also be defined.
+ */
+
+
+/* These parameters can be modified as you like, through options.  Say
+   "set terminal tpic <pointsize> <linewidth> <interval>".  <pointsize>
+   and <linewidth> are integers in milli-inches; <interval> is a float
+   in inches.  If non-positive value is specified, the default (below)
+   is chosen.
+*/
+
+/*
+ * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(tpic)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void TPIC_options __PROTO((void));		/* get size options */
+TERM_PUBLIC void TPIC_init __PROTO((void));
+TERM_PUBLIC void TPIC_reset __PROTO((void));
+TERM_PUBLIC void TPIC_text __PROTO((void));
+TERM_PUBLIC void TPIC_graphics __PROTO((void));
+TERM_PUBLIC void TPIC_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void TPIC_vector __PROTO((unsigned int ux, unsigned int uy));
+TERM_PUBLIC void TPIC_linetype __PROTO((int linetype));
+TERM_PUBLIC void TPIC_put_text __PROTO((unsigned int x, unsigned int y, const char *str));	/* ref point and text */
+TERM_PUBLIC int TPIC_text_angle __PROTO((int ang));
+TERM_PUBLIC int TPIC_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC void TPIC_point __PROTO((unsigned int x, unsigned int y, int number));
+TERM_PUBLIC void TPIC_arrow __PROTO((unsigned int sx, unsigned int sy, unsigned int ex, unsigned int ey, int head));
+
+/* tpic \specials unit in inches (1 milli-inch) */
+#define TPIC_UNIT 0.001
+
+/* 5 inches wide by 3 inches high (default) */
+#define TPIC_XMAX (unsigned int) (5 / TPIC_UNIT)
+#define TPIC_YMAX (unsigned int) (3 / TPIC_UNIT)
+#define TPIC_PTS_PER_UNIT (72.27 * TPIC_UNIT)
+#define TPIC_HTIC  (unsigned int) ( 5.0 / TPIC_PTS_PER_UNIT)	/* 5pt */
+#define TPIC_VTIC  (unsigned int) ( 5.0 / TPIC_PTS_PER_UNIT)	/* 5pt */
+#define TPIC_HCHAR (unsigned int) ( 5.3 / TPIC_PTS_PER_UNIT)	/* 5.3pt */
+#define TPIC_VCHAR (unsigned int) (11.0 / TPIC_PTS_PER_UNIT)	/* 11pt */
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+static int tpic_pointsize = 40;	/* min point radius   (in milli-inches) */
+static int tpic_linewidth = 6;	/* min line thickness (in milli-inches) */
+static double tpic_interval = 0.1;	/* min dot & dash intervals (in inches) */
+
+/* ARROWS: same code as for LATEX */
+/* figure out the best arrow. in latex.trm */
+static void best_latex_arrow __PROTO((int sx, int sy, int ex, int ey, int who, int head));
+
+/* all prototypes ... */
+static void tpic_startline __PROTO((void));
+static void tpic_endline __PROTO((void));
+static void tpic_pushpath __PROTO((unsigned int x, unsigned int y));
+static void tpic_scanpath __PROTO((void));
+static void tpic_diamond __PROTO((int size));
+static void tpic_plus __PROTO((int size));
+static void tpic_box __PROTO((int size));
+static void tpic_times __PROTO((int size));
+static void tpic_triangle __PROTO((int size));
+static void tpic_star __PROTO((int size));
+static void tpic_hexagon __PROTO((int size));
+static void tpic_circle __PROTO((int size));
+static void tpic_doublecircle __PROTO((int size));
+static void tpic_vercircle __PROTO((int size));	/* circle with | */
+static void tpic_horcircle __PROTO((int size));	/* circle with - */
+static void tpic_pluscircle __PROTO((int size));	/* circle with + */
+static void tpic_timescircle __PROTO((int size));	/* circle with times */
+static void tpic_starcircle __PROTO((int size));	/* circle with star */
+static void tpic_dotcircle __PROTO((int size));	/* circle with dot (black circle) */
+static void tpic_diamondcircle __PROTO((int size)); /* circle with black diamond */
+static void tpic_boxcircle __PROTO((int size));	/* circle with black box */
+static void tpic_trianglecircle __PROTO((int size));	/* circle with black triangle */
+static void tpic_hexagoncircle __PROTO((int size));	/* circle with black hexagon */
+static void tpic_plustimescircle __PROTO((int size));	/* no more idea ... with plus & times */
+static void tpic_abspath __PROTO((unsigned int x, unsigned int y));	/* absolute coord */
+static void tpic_path __PROTO((int x, int y));
+static void tpic_flush __PROTO((void));
+static void tpic_arc __PROTO((int radius));	/* actually, draw a full circle */
+static void tpic_shade __PROTO((double grayscale));
+static void tpic_pen __PROTO((int thickness));
+static void tpic_dottedflush __PROTO((double interval));
+static void tpic_dashedflush __PROTO((double interval));
+
+typedef enum {
+    tpic_none, tpic_white, tpic_gray, tpic_black
+} tpic_shadestyle;
+typedef enum {
+    tpic_nosize, tpic_small, tpic_medium, tpic_large
+} tpic_size;
+typedef void (*tpic_function) __PROTO((int size));
+
+typedef struct {
+    tpic_shadestyle shadestyle;
+    tpic_size size;
+    tpic_function function;
+} tpic_point_info;
+
+/* POINTS */
+static /*GPFAR */ tpic_point_info GPFAR tpic_point[] =
+{
+    {tpic_white, tpic_medium, tpic_diamond},
+    {tpic_none, tpic_medium, tpic_plus},
+    {tpic_white, tpic_medium, tpic_box},
+    {tpic_none, tpic_medium, tpic_times},
+    {tpic_white, tpic_medium, tpic_triangle},
+    {tpic_none, tpic_medium, tpic_star},
+    {tpic_white, tpic_small, tpic_circle},
+    {tpic_white, tpic_medium, tpic_circle},
+    {tpic_white, tpic_large, tpic_circle},
+    {tpic_black, tpic_small, tpic_circle},
+    {tpic_black, tpic_medium, tpic_circle},
+    {tpic_black, tpic_large, tpic_circle},
+    {tpic_black, tpic_medium, tpic_diamond},
+    {tpic_black, tpic_medium, tpic_box},
+    {tpic_black, tpic_medium, tpic_triangle},
+    {tpic_white, tpic_medium, tpic_hexagon},
+    {tpic_black, tpic_medium, tpic_hexagon},
+    {tpic_white, tpic_medium, tpic_doublecircle},
+    {tpic_white, tpic_medium, tpic_vercircle},
+    {tpic_white, tpic_medium, tpic_horcircle},
+    {tpic_white, tpic_medium, tpic_pluscircle},
+    {tpic_white, tpic_medium, tpic_timescircle},
+    {tpic_white, tpic_medium, tpic_starcircle},
+    {tpic_black, tpic_medium, tpic_doublecircle},
+    {tpic_white, tpic_medium, tpic_dotcircle},
+    {tpic_white, tpic_medium, tpic_diamondcircle},
+    {tpic_white, tpic_medium, tpic_boxcircle},
+    {tpic_white, tpic_medium, tpic_trianglecircle},
+    {tpic_white, tpic_medium, tpic_hexagoncircle},
+    {tpic_white, tpic_medium, tpic_plustimescircle}
+};
+
+typedef enum {
+    tpic_solid, tpic_dotted, tpic_dashed,
+    tpic_dashed_sdot, tpic_dashed_ddot
+} tpic_linestyle;
+typedef struct {
+    tpic_size thickness, interval;
+    tpic_linestyle linestyle;
+} tpic_line_info;
+
+/* LINES */
+static /*GPFAR */ tpic_line_info GPFAR tpic_line[] =
+{
+    {tpic_medium, tpic_nosize, tpic_solid},	/* -2 border */
+    {tpic_small, tpic_small, tpic_dashed},	/* -1 axes */
+    {tpic_small, tpic_nosize, tpic_solid},
+    {tpic_medium, tpic_nosize, tpic_solid},
+    {tpic_large, tpic_nosize, tpic_solid},
+    {tpic_small, tpic_small, tpic_dotted},
+    {tpic_medium, tpic_small, tpic_dotted},
+    {tpic_large, tpic_small, tpic_dotted},
+    {tpic_small, tpic_small, tpic_dashed},
+    {tpic_medium, tpic_small, tpic_dashed},
+    {tpic_large, tpic_small, tpic_dashed},
+    {tpic_small, tpic_small, tpic_dashed_sdot},		/* dash with single dots */
+    {tpic_medium, tpic_small, tpic_dashed_sdot},
+    {tpic_large, tpic_small, tpic_dashed_sdot},
+    {tpic_small, tpic_small, tpic_dashed_ddot},		/* dash with double dots */
+    {tpic_medium, tpic_small, tpic_dashed_ddot},
+    {tpic_large, tpic_small, tpic_dashed_ddot},
+    {tpic_small, tpic_medium, tpic_dotted},
+    {tpic_medium, tpic_medium, tpic_dotted},
+    {tpic_large, tpic_medium, tpic_dotted},
+    {tpic_small, tpic_medium, tpic_dashed},
+    {tpic_medium, tpic_medium, tpic_dashed},
+    {tpic_large, tpic_medium, tpic_dashed},
+    {tpic_small, tpic_medium, tpic_dashed_sdot},
+    {tpic_medium, tpic_medium, tpic_dashed_sdot},
+    {tpic_large, tpic_medium, tpic_dashed_sdot},
+    {tpic_small, tpic_medium, tpic_dashed_ddot},
+    {tpic_medium, tpic_medium, tpic_dashed_ddot},
+    {tpic_large, tpic_medium, tpic_dashed_ddot},
+    {tpic_small, tpic_large, tpic_dotted},
+    {tpic_medium, tpic_large, tpic_dotted},
+    {tpic_large, tpic_large, tpic_dotted},
+    {tpic_small, tpic_large, tpic_dashed},
+    {tpic_medium, tpic_large, tpic_dashed},
+    {tpic_large, tpic_large, tpic_dashed},
+    {tpic_small, tpic_large, tpic_dashed_sdot},
+    {tpic_medium, tpic_large, tpic_dashed_sdot},
+    {tpic_large, tpic_large, tpic_dashed_sdot},
+    {tpic_small, tpic_large, tpic_dashed_ddot},
+    {tpic_medium, tpic_large, tpic_dashed_ddot},
+    {tpic_large, tpic_large, tpic_dashed_ddot}
+};
+
+TERM_PUBLIC void
+TPIC_options()
+{				/* get size options */
+    struct value a;
+    int ptsize, linewidth;
+    double interval;
+
+    if (!END_OF_COMMAND) {
+	ptsize = (int) real(const_express(&a));
+	if (ptsize > 0)
+	    tpic_pointsize = ptsize;
+    }
+    if (!END_OF_COMMAND) {
+	linewidth = (int) real(const_express(&a));
+	if (linewidth > 0)
+	    tpic_linewidth = linewidth;
+    }
+    if (!END_OF_COMMAND) {
+	interval = (double) real(const_express(&a));
+	if (interval > 0)
+	    tpic_interval = interval;
+    }
+    sprintf(term_options, "%d %d %f", tpic_pointsize, tpic_linewidth,
+	    tpic_interval);
+}
+
+static unsigned int tpic_posx;	/* current position */
+static unsigned int tpic_posy;
+static int tpic_point_types;
+static int tpic_numlines;
+
+TERM_PUBLIC void
+TPIC_init()
+{
+    static char GPFAR tpic1[] = "\
+%% GNUPLOT: LaTeX picture using tpic \\specials\n\
+%%          with %d point types and %d line types\n\
+%% Options: pointsize = %d, linewidth = %d, interval = %f\n\
+%% To change above options, say:\n\
+%% set terminal tpic pointsize_value linewidth_value interval_value\n\
+%% (pointsize and linewidth - integers in milli-inches.\n\
+%%  interval - a float in inches.  If zero is specified, \n\
+%%  the default value is chosen.)\n\
+\\setlength{\\unitlength}{%fin}%%\n";
+    tpic_point_types = sizeof(tpic_point) / sizeof(tpic_point[0]);
+    tpic_numlines = sizeof(tpic_line) / sizeof(tpic_line[0]);
+
+    tpic_posx = tpic_posy = 0;
+    TPIC_linetype(-1);
+    fprintf(gpoutfile, tpic1,
+	    tpic_point_types, tpic_numlines - 2,
+	    tpic_pointsize, tpic_linewidth, tpic_interval,
+	    TPIC_UNIT);
+}
+
+TERM_PUBLIC void
+TPIC_reset()
+{
+    tpic_endline();
+    tpic_posx = tpic_posy = 0;
+}
+
+TERM_PUBLIC void
+TPIC_text()
+{
+    tpic_endline();
+    fputs("\\end{picture}\n", gpoutfile);
+}
+
+TERM_PUBLIC void
+TPIC_graphics()
+{
+    register struct termentry *t = term;
+    int left, right, top, bottom;	/* margins */
+    static char GPFAR begin[] = "%s\\begin{picture}(%d,%d)(%d,%d)%% %s\n";
+
+    fprintf(gpoutfile, begin, "", t->xmax, t->ymax, 0, 0, "");
+
+    /* the following is dependent on boundary() function in graphics.c */
+    left = TPIC_HCHAR * 12;
+    right = TPIC_HCHAR * 2 + TPIC_HTIC;
+    bottom = TPIC_VCHAR * 7 / 2 + 1;
+    top = TPIC_VCHAR * 5 / 2 - 1;
+    fprintf(gpoutfile, begin, "%% ", t->xmax - left, t->ymax, left, 0,
+	    "trim left margin");
+    fprintf(gpoutfile, begin, "%% ", t->xmax - right, t->ymax, 0, 0,
+	    "trim right margin");
+    fprintf(gpoutfile, begin, "%% ", t->xmax - left - right, t->ymax, left, 0,
+	    "trim left & right margins");
+    fprintf(gpoutfile, begin, "%% ", t->xmax, t->ymax - top, 0, 0,
+	    "trim top margin");
+    fprintf(gpoutfile, begin, "%% ", t->xmax, t->ymax - bottom, 0, bottom,
+	    "trim bottom margin");
+    fprintf(gpoutfile, begin, "%% ", t->xmax, t->ymax - top - bottom, 0, bottom,
+	    "trim top & bottom margins");
+
+    fputs("\\footnotesize%\n", gpoutfile);
+}
+
+TERM_PUBLIC void
+TPIC_move(unsigned int x, unsigned int y)
+{
+    tpic_endline();
+    tpic_posx = x;
+    tpic_posy = y;
+}
+
+#define TPIC_LINEMAX 100	/* max value for linecount */
+static TBOOLEAN tpic_inline = FALSE;	/* are we in the middle of a line */
+static int tpic_linecount = 0;	/* number of points in line so far */
+
+TERM_PUBLIC void
+TPIC_vector(unsigned int ux, unsigned int uy)
+{
+    if (!tpic_inline) {
+	tpic_startline();
+    } else if (tpic_linecount >= TPIC_LINEMAX) {
+	/* Even though we are in middle of a path, we may start a new path
+	   command once in a while; if they are too long, latex will choke. */
+	tpic_endline();
+	tpic_startline();
+    }
+    tpic_pushpath(ux, uy);
+    tpic_posx = ux;
+    tpic_posy = uy;
+}
+
+static int tpic_linetype;	/* current line type */
+
+static void
+tpic_startline()
+{				/* private */
+    int thickness = 1;
+
+    tpic_inline = TRUE;
+    switch (tpic_line[tpic_linetype + 2].thickness) {
+    case tpic_small:
+	thickness = tpic_linewidth;
+	break;
+    case tpic_medium:
+	thickness = (int) (tpic_linewidth * 3);
+	break;
+    case tpic_large:
+	thickness = (int) (tpic_linewidth * 5);
+	break;
+    default:
+	break;
+    }
+    tpic_pen(thickness);
+    tpic_linecount = 0;
+    tpic_pushpath(tpic_posx, tpic_posy);
+    return;
+}
+
+static void
+tpic_endline()
+{				/* private */
+    double interval = 1;
+
+    if (tpic_inline) {
+	tpic_scanpath();	/* draw actually */
+	switch (tpic_line[tpic_linetype + 2].interval) {
+	case tpic_small:
+	    interval = tpic_interval;
+	    break;
+	case tpic_medium:
+	    interval = tpic_interval * 2;
+	    break;
+	case tpic_large:
+	    interval = tpic_interval * 3;
+	    break;
+	case tpic_nosize:
+	    break;
+	}
+	switch (tpic_line[tpic_linetype + 2].linestyle) {
+	case tpic_solid:
+	    tpic_flush();
+	    break;
+	case tpic_dotted:
+	    tpic_dottedflush(interval);
+	    break;
+	case tpic_dashed:
+	    tpic_dashedflush(interval);
+	    break;
+	case tpic_dashed_sdot:	/* dashed with single dots in between */
+	    tpic_dashedflush(interval);
+	    tpic_scanpath();	/* draw again */
+	    tpic_dottedflush(interval / 2);
+	    break;
+	case tpic_dashed_ddot:	/* dashed with double dots in between */
+	    tpic_dashedflush(interval);
+	    tpic_scanpath();	/* draw again */
+	    tpic_dottedflush(interval / 3);
+	    break;
+	}
+	tpic_inline = FALSE;
+    }
+    return;
+}
+
+/* private: stack functions */
+static unsigned int pathpoint[TPIC_LINEMAX][2];		/* point stack */
+
+static void
+tpic_pushpath(unsigned int x, unsigned int y)
+{
+    if (tpic_linecount < TPIC_LINEMAX) {
+	pathpoint[tpic_linecount][0] = x;
+	pathpoint[tpic_linecount][1] = y;
+	tpic_linecount++;
+    }
+    return;
+}
+
+static void
+tpic_scanpath()
+{
+    int i;
+
+    for (i = 0; i < tpic_linecount; i++)
+	tpic_abspath(pathpoint[i][0], pathpoint[i][1]);
+    return;
+}
+
+TERM_PUBLIC void
+TPIC_linetype(int linetype)
+{
+    tpic_endline();
+    if (linetype < -2)
+	linetype = LT_BLACK;
+    if (linetype >= tpic_numlines - 2)
+	linetype %= (tpic_numlines - 2);
+    tpic_linetype = linetype;
+}
+
+static int tpic_angle = 0;	/* 0 = horizontal, 1 = vertical */
+static enum JUSTIFY tpic_justify = LEFT;
+
+TERM_PUBLIC void
+TPIC_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    char *justify = NULL;
+
+    tpic_endline();
+    fprintf(gpoutfile, "\\put(%d,%d)", x, y);
+
+    if ((str[0] == '{') || (str[0] == '[')) {
+	fprintf(gpoutfile, "{\\makebox(0,0)%s}\n", str);
+    } else
+	switch (tpic_angle) {
+	case 0:		/* horizontal */
+	    switch (tpic_justify) {
+	    case LEFT:
+		justify = "[l]";
+		break;
+	    case CENTRE:
+		justify = "";
+		break;
+	    case RIGHT:
+		justify = "[r]";
+		break;
+	    }
+	    fprintf(gpoutfile, "{\\makebox(0,0)%s{%s}}\n", justify, str);
+	    break;
+	case 1:		/* vertical */
+	    /* we can't really write text vertically, but will put the ylabel
+	       centred at the left of the plot, and then we'll make a \shortstack */
+	    switch (tpic_justify) {
+	    case LEFT:
+		justify = "[lb]";
+		break;
+	    case CENTRE:
+		justify = "[l]";
+		break;
+	    case RIGHT:
+		justify = "[lt]";
+		break;
+	    }
+	    fprintf(gpoutfile, "{\\makebox(0,0)%s{\\shortstack{%s}}}\n",
+		    justify, str);
+	    break;
+	}
+}
+
+TERM_PUBLIC int
+TPIC_text_angle(int ang)
+{
+    tpic_angle = (ang ? 1 : 0);
+    return (TRUE);
+}
+
+TERM_PUBLIC int
+TPIC_justify_text(enum JUSTIFY mode)
+{
+    tpic_justify = mode;
+    return (TRUE);
+}
+
+TERM_PUBLIC void
+TPIC_point(unsigned int x, unsigned int y, int number)
+{
+    int size = 0;
+
+    TPIC_move(x, y);
+
+    /* Print the character defined by 'number'; number < 0 means
+       to use a dot, otherwise one of the defined points. */
+
+    fprintf(gpoutfile, "\\put(%d,%d){", x, y);	/* start putting */
+
+    if (number < 0) {
+	fputs("\\rule{.1pt}{.1pt}", gpoutfile);	/* tiny dot */
+    } else {
+	number %= tpic_point_types;
+	switch (tpic_point[number].shadestyle) {
+	case tpic_white:
+	    tpic_pen(tpic_linewidth);	/* set it thin */
+	    tpic_shade(0.0);
+	    break;
+	case tpic_gray:
+	    tpic_pen(tpic_linewidth);
+	    tpic_shade(0.5);
+	    break;
+	case tpic_black:
+	    tpic_pen(tpic_linewidth);
+	    tpic_shade(1.0);
+	    break;
+	case tpic_none:
+	    tpic_pen(tpic_linewidth * 3);	/* set it thick */
+	    break;
+	}
+	switch (tpic_point[number].size) {
+	case tpic_small:
+	    size = tpic_pointsize;
+	    break;
+	case tpic_medium:
+	    size = (int) (tpic_pointsize * 1.4142);
+	    break;
+	case tpic_large:
+	    size = (int) (tpic_pointsize * 2.0);
+	    break;
+	default:
+	    break;
+	}
+	(tpic_point[number].function) (size);
+    }
+
+    fputs("}%%\n", gpoutfile);	/* end putting */
+}
+
+TERM_PUBLIC void
+TPIC_arrow(
+    unsigned int sx, unsigned int sy,
+    unsigned int ex, unsigned int ey,
+    int head)
+{
+    best_latex_arrow(sx, sy, ex, ey, 1, head);	/* call latex routine */
+    tpic_posx = ex;
+    tpic_posy = ey;
+}
+
+/* private: draw points with tpic commands */
+
+static void
+tpic_diamond(int size)
+{
+    size = (int) (size * 1.4142);	/* spread by sqrt(2) */
+
+    tpic_path(0, size);
+    tpic_path(-size, 0);
+    tpic_path(0, -size);
+    tpic_path(size, 0);
+    tpic_path(0, size);
+    tpic_flush();
+    return;
+}
+
+static void
+tpic_plus(int size)
+{
+    tpic_path(0, size);
+    tpic_path(0, -size);
+    tpic_flush();
+    tpic_path(size, 0);
+    tpic_path(-size, 0);
+    tpic_flush();
+    return;
+}
+
+static void
+tpic_box(int size)
+{
+    tpic_path(size, size);
+    tpic_path(-size, size);
+    tpic_path(-size, -size);
+    tpic_path(size, -size);
+    tpic_path(size, size);
+    tpic_flush();
+    return;
+}
+
+static void
+tpic_times(int size)
+{
+    size = (int) (size / 1.4142);	/* reduce by sqrt(2) */
+
+    tpic_path(size, size);
+    tpic_path(-size, -size);
+    tpic_flush();
+    tpic_path(size, -size);
+    tpic_path(-size, size);
+    tpic_flush();
+    return;
+}
+
+static void
+tpic_triangle(int size)
+{
+    int x;
+
+    size = (int) (size / 1.6119);	/* reduce by sqrt(3 * sqrt(3) / 2) */
+    x = (int) (size * 1.7321);
+
+    tpic_path(0, -size * 2);
+    tpic_path(-x, size);
+    tpic_path(x, size);
+    tpic_path(0, -size * 2);
+    tpic_flush();
+    return;
+}
+
+static void
+tpic_star(int size)
+{
+    int x;
+
+    size = (int) (size / 2);	/* reduce by 2 */
+    x = (int) (size * 1.7321);
+
+    tpic_path(0, size * 2);
+    tpic_path(0, -size * 2);
+    tpic_flush();
+    tpic_path(x, size);
+    tpic_path(-x, -size);
+    tpic_flush();
+    tpic_path(x, -size);
+    tpic_path(-x, size);
+    tpic_flush();
+    return;
+}
+
+static void
+tpic_hexagon(int size)
+{
+    int x;
+
+    size = (int) (size / 2);	/* reduce by 2 */
+    x = (int) (size * 1.7321);
+
+    tpic_path(0, size * 2);
+    tpic_path(-x, size);
+    tpic_path(-x, -size);
+    tpic_path(0, -size * 2);
+    tpic_path(x, -size);
+    tpic_path(x, size);
+    tpic_path(0, size * 2);
+    tpic_flush();
+    return;
+}
+
+static void
+tpic_circle(int size)
+{
+    tpic_arc(size);
+    return;
+}
+
+static void
+tpic_doublecircle(int size)
+{
+    tpic_arc(size);
+    tpic_shade(0.0);
+    tpic_arc(size / 2);
+    return;
+}
+
+static void
+tpic_vercircle(int size)			/* circle with | */
+{
+    tpic_arc(size);
+    tpic_path(0, size);
+    tpic_path(0, -size);
+    tpic_flush();
+    return;
+}
+
+static void
+tpic_horcircle(int size)			/* circle with - */
+{
+    tpic_arc(size);
+    tpic_path(size, 0);
+    tpic_path(-size, 0);
+    tpic_flush();
+    return;
+}
+
+static void
+tpic_pluscircle(int size)			/* circle with + */
+{
+    tpic_arc(size);
+    tpic_plus(size);
+    return;
+}
+
+static void
+tpic_timescircle(int size)			/* circle with times */
+{
+    tpic_arc(size);
+    tpic_times(size);
+    return;
+}
+
+static void
+tpic_starcircle(int size)			/* circle with star */
+{
+    tpic_arc(size);
+    tpic_star(size);
+    return;
+}
+
+static void
+tpic_dotcircle(int size)			/* circle with dot (black circle) */
+{
+    tpic_arc(size);
+    tpic_shade(1.0);
+    tpic_arc(size / 2);
+    return;
+}
+
+static void
+tpic_diamondcircle(int size)			/* not enough? circle with black diamond */
+{
+    tpic_arc(size);
+    tpic_shade(1.0);
+    tpic_diamond((int) (size / 1.5));
+    return;
+}
+
+static void
+tpic_boxcircle(int size)			/* need more? circle with black box */
+{
+    tpic_arc(size);
+    tpic_shade(1.0);
+    tpic_box((int) (size / 1.5));
+    return;
+}
+
+static void
+tpic_trianglecircle(int size)			/* circle with black triangle */
+{
+    tpic_arc(size);
+    tpic_shade(1.0);
+    tpic_triangle((int) (size / 1.5));
+    return;
+}
+
+static void
+tpic_hexagoncircle(int size)			/* how about circle with black hexagon? */
+{
+    tpic_arc(size);
+    tpic_shade(1.0);
+    tpic_hexagon((int) (size / 1.2));
+    return;
+}
+
+static void
+tpic_plustimescircle(int size)			/* no more idea ... with plus & times */
+{
+    tpic_arc(size);
+    tpic_plus(size);
+    tpic_times(size);
+    return;
+}
+
+/* private: draw lines */
+
+static void
+tpic_abspath(unsigned int x, unsigned int y)
+{
+    tpic_path(x, -y);
+    fputs("%\n", gpoutfile);
+    return;
+}
+
+/* private: tpic primitive functions */
+
+static void
+tpic_path(int x, int y)
+{
+    fprintf(gpoutfile, "\\special{pa %d %d}", x, y);
+    return;
+}
+
+static void
+tpic_flush()
+{
+    fputs("\\special{fp}%\n", gpoutfile);
+    return;
+}
+
+static void
+tpic_arc(int radius)
+{
+    /* actually, draw a full circle */
+    fprintf(gpoutfile, "\\special{ar 0 0 %d %d 0 7}", radius, radius);
+    return;
+}
+
+static void
+tpic_shade(double grayscale)
+{
+    fprintf(gpoutfile, "\\special{sh %f}", grayscale);
+    return;
+}
+
+static void
+tpic_pen(int thickness)
+{
+    fprintf(gpoutfile, "\\special{pn %d}", thickness);
+    return;
+}
+
+static void
+tpic_dottedflush(double interval)
+{
+    fprintf(gpoutfile, "\\special{dt %f}%%\n", interval);
+    return;
+}
+
+static void
+tpic_dashedflush(double interval)
+{
+    fprintf(gpoutfile, "\\special{da %f}%%\n", interval);
+    return;
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(tpic_driver)
+    "tpic", "TPIC -- LaTeX picture environment with tpic \\specials",
+    TPIC_XMAX, TPIC_YMAX, TPIC_VCHAR, TPIC_HCHAR,
+    TPIC_VTIC, TPIC_HTIC, TPIC_options, TPIC_init, TPIC_reset,
+    TPIC_text, null_scale, TPIC_graphics, TPIC_move, TPIC_vector,
+    TPIC_linetype, TPIC_put_text, TPIC_text_angle,
+    TPIC_justify_text, TPIC_point, TPIC_arrow, set_font_null
+TERM_TABLE_END(tpic_driver)
+
+#undef LAST_TERM
+#define LAST_TERM tpic_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(tpic)
+"1 tpic",
+"?commands set terminal tpic",
+"?set terminal tpic",
+"?set term tpic",
+"?terminal tpic",
+"?term tpic",
+"?tpic",
+" The `tpic` terminal driver supports the LaTeX picture environment with tpic",
+" \\specials.  It is an alternative to the `latex` and `eepic` terminal drivers.",
+" Options are the point size, line width, and dot-dash interval.",
+"",
+" Syntax:",
+"       set terminal tpic <pointsize> <linewidth> <interval>",
+"",
+" where `pointsize` and `linewidth` are integers in milli-inches and `interval`",
+" is a float in inches.  If a non-positive value is specified, the default is",
+" chosen: pointsize = 40, linewidth = 6, interval = 0.1.",
+"",
+" All drivers for LaTeX offer a special way of controlling text positioning:",
+" If any text string begins with '{', you also need to include a '}' at the",
+" end of the text, and the whole text will be centered both horizontally",
+" and vertically by LaTeX. --- If the text string begins with '[', you need",
+" to continue it with: a position specification (up to two out of t,b,l,r),",
+" ']{', the text itself, and finally, '}'. The text itself may be anything",
+" LaTeX can typeset as an LR-box. \\rule{}{}'s may help for best positioning.",
+"",
+" Examples:",
+" About label positioning:",
+" Use gnuplot defaults (mostly sensible, but sometimes not really best):",
+"        set title '\\LaTeX\\ -- $ \\gamma $'",
+" Force centering both horizontally and vertically:",
+"        set label '{\\LaTeX\\ -- $ \\gamma $}' at 0,0",
+" Specify own positioning (top here):",
+"        set xlabel '[t]{\\LaTeX\\ -- $ \\gamma $}'",
+" The other label -- account for long ticlabels:",
+"        set ylabel '[r]{\\LaTeX\\ -- $ \\gamma $\\rule{7mm}{0pt}}'"
+END_HELP(tpic)
+#endif /* TERM_TABLE */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/unixpc.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/unixpc.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/unixpc.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/unixpc.trm.svn-base	2012-01-03 17:07:46.167703700 -0800
@@ -0,0 +1,628 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: unixpc.trm,v 1.14 2006/07/21 02:35:48 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - unixpc.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *  Unix PC's (ATT 3b1)
+ *
+ * AUTHORS
+ *    John Campbell
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+
+/*
+>From: John Campbell (...!arizona!naucse!jdc)
+
+I originally ported gnuplot to the ATT 3b1 (ATT7300) on 12/4/88, and then
+added the minimal code needed to bring it up to 2.0 level on 1/28/90.  The
+3b1, as I view it, is a 720x300 bitmapped, monochrome display (often people
+don't use the top 12 scan lines and thus the effective size is 720x288).  I
+tried to maximize the size of the graph area, by using these top 12 lines
+(normally reserved) and set up a signal handler to restore them upon exit,
+abort, etc.
+
+Line styles were "fudged" (they do not know the aspect ratio).  The same
+line style may look different depending upon the slope of the curve.  Due to
+this only 4 line styles were implemented.  While more line types are possible,
+the current styles were chosen as distinguishable.
+
+The 3b1 has 4 "special" rows at the bottom that I could not use in graphics
+mode.  It has been suggested that we use these lines for command prompting.
+Others have requested that we have a graphics window and a command window.
+My experience with gnuplot only includes relatively dumb graphics devices--
+hence gnuplot "looks and feels" normal to me the way I implemented it.
+I welcome either of these changes from someone else, however.
+*/
+
+/*
+ * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(unixpc)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void uPC_init __PROTO((void));
+TERM_PUBLIC void uPC_graphics __PROTO((void));
+TERM_PUBLIC void uPC_text __PROTO((void));
+TERM_PUBLIC void uPC_linetype __PROTO((int linetype));
+TERM_PUBLIC void uPC_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void uPC_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void uPC_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
+TERM_PUBLIC int uPC_text_angle __PROTO((int ang));
+TERM_PUBLIC void uPC_reset __PROTO((void));
+#define uPC_XMAX 720
+#define uPC_YMAX 300
+#define uPC_VCHAR FNT5X9_VCHAR
+#define uPC_HCHAR FNT5X9_HCHAR
+#define uPC_VTIC  uPC_VCHAR/2	/* Was 8  */
+#define uPC_HTIC  uPC_HCHAR	/* Was 12 */
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+void uPC_fixwind __PROTO((int signo));
+void uPC_putc __PROTO((unsigned int x, unsigned int y, int c, int angle));
+void uPC_plot_word __PROTO((unsigned short *a, unsigned short b));
+#include <sys/window.h>		/* Started with tam.h--too much trouble. */
+#include <sys/signal.h>
+#include <errno.h>
+
+#define uPC_HIGH_BIT    (0x8000)
+
+typedef unsigned short Scr_type;
+typedef unsigned char Scr_kluge;
+
+
+#define uPC_XSIZE       45	/* Short ints. */
+#define uPC_YSIZE uPC_YMAX
+
+Scr_type uPC_display[uPC_YSIZE][uPC_XSIZE];
+int uPC_width = 2 * uPC_XSIZE;
+int uPC_sx = 0, uPC_sy = 0;
+int uPC_cur_linetype = 0;
+int uPC_angle = 0;
+unsigned short uPC_raster_count = 0;
+static Scr_type lookup[] =
+{
+    0x0001, 0x0002, 0x0004, 0x0008,
+    0x0010, 0x0020, 0x0040, 0x0080,
+    0x0100, 0x0200, 0x0400, 0x0800,
+    0x1000, 0x2000, 0x4000, 0x8000,
+};
+
+#define uPC_XLAST (uPC_XMAX - 1)
+#define uPC_YLAST (uPC_YMAX - 1)
+
+
+static struct urdata uPC_ur = {
+    (unsigned short *) uPC_display,
+    2 * uPC_XSIZE, 0, 0, 0, 0, 0, 0,
+    uPC_XMAX, uPC_YMAX, SRCSRC, DSTOR, 0
+};
+
+#define IfErrOut(e1,e2,s1,s2) if (e1 e2) {				\
+    fprintf(stderr, "%s:: %s %s\n", sys_errlist[errno], s1, s2);	\
+    uPC_fixwind(0);							\
+    exit(-1);								\
+}
+
+TERM_PUBLIC void
+uPC_init()
+{
+    /* This routine will ioctl to change 0 size */
+    int i;
+    struct uwdata uw;
+    int uPC_fixwind();
+    short gw;
+
+    /* Check that we are on the bitmapped window. */
+    if (iswind() != 0) {
+	fputs("Sorry--must run from the bitmapped terminal\n", stderr);
+	exit(-1);
+    }
+    for (i = 1; i <= 16; i++) {
+	if (i != SIGINT && i != SIGFPE)		/* Two are caught in plot.c */
+	    signal(i, uPC_fixwind);
+    }
+
+/* Increase the screen size */
+    uw.uw_x = 0;
+    uw.uw_y = 0;		/* Leave room for top status line. */
+    uw.uw_width = uPC_XMAX;	/* 720 */
+    uw.uw_height = uPC_YMAX;	/* 288 normal--we clobber 12 (top row) */
+    uw.uw_uflags = 1;		/* Creates with no border */
+
+    IfErrOut(ioctl(1, WIOCSETD, &uw), <0, "ioctl failed on", "WIOCSETD");
+}
+
+
+TERM_PUBLIC void
+uPC_graphics()
+{
+/* This routine will clear the uPC_display buffer and window. */
+    register Scr_type *j;
+    register int i;
+
+    j = (Scr_type *) uPC_display;
+    i = uPC_YSIZE * uPC_XSIZE + 1;
+
+    while (--i)
+	*j++ = 0;
+   /* Position the cursor to the bottom of the screen so when we come back to
+    * text mode we are just below the graph.
+    */
+    fputs("\033[25;1H", stdout);
+
+    uPC_ur.ur_dstop = DSTSRC;	/* replace (clear screen). */
+    IfErrOut(ioctl(1, WIOCRASTOP, &uPC_ur), <0,
+	     "ioctl failed", "WIOCRASTOP");
+    uPC_ur.ur_dstop = DSTOR;	/* Or in (show text) */
+}
+
+
+TERM_PUBLIC void
+uPC_text()
+{
+/* This routine will flush the display. */
+
+    IfErrOut(ioctl(1, WIOCRASTOP, &uPC_ur), <0,
+	     "ioctl failed", "WIOCRASTOP");
+}
+
+
+TERM_PUBLIC void
+uPC_linetype(int linetype)
+{
+/* This routine records the current linetype. */
+    if (uPC_cur_linetype != linetype) {
+	uPC_raster_count = 0;
+	uPC_cur_linetype = linetype;
+    }
+}
+
+
+TERM_PUBLIC void
+uPC_move(unsigned int x, unsigned int y)
+{
+/* This routine just records x and y in uPC_sx, uPC_sy */
+    uPC_sx = x;
+    uPC_sy = y;
+}
+
+
+/* Was just (*(a)|=(b)) */
+#define uPC_PLOT(a,b)   (uPC_cur_linetype != 0 ? uPC_plot_word (a,b) :\
+                                (*(a)|=(b)))
+
+/*
+   Weak attempt to make line styles.  The real problem is the aspect
+   ratio.  This routine is called only when a bit is to be turned on in
+   a horizontal word.  A better line style routine would know something
+   about the slope of the line around the current point (in order to
+   change weighting).
+
+   This yields 3 working linetypes plus a usable axis line type.
+*/
+void
+uPC_plot_word(Scr_type *a, Scr_type b)
+{
+    /* Various line types */
+    switch (uPC_cur_linetype) {
+    case LT_AXIS:
+	/* Distinguish between horizontal and vertical axis. */
+	if (uPC_sx > uPC_XMAX / 8 && uPC_sx < 7 * uPC_XMAX / 8) {
+	    /* Fuzzy tolerance because we don't know exactly where the y axis is */
+	    if (++uPC_raster_count % 2 == 0)
+		*(a) |= b;
+	} else {
+	    /* Due to aspect ratio, take every other y pixel and every third x. */
+	    *(a) |= (b & 0x9999);
+	}
+	break;
+    case 1:
+    case 5:
+	/* Make a |    |----|    |----| type of line. */
+	if ((1 << uPC_raster_count) & 0xF0F0)
+	    *(a) |= b;
+	if (++uPC_raster_count > 15)
+	    uPC_raster_count = 0;
+	break;
+    case 2:
+    case 6:
+	/* Make a |----|----|----|--- |    | type of line. */
+	if ((1 << uPC_raster_count) & 0x0EFFF)
+	    *(a) |= b;
+	if (++uPC_raster_count > 19)
+	    uPC_raster_count = 0;
+	break;
+    case 3:
+    case 7:
+	/* Make a | -  | -  | -  | -  | type of line. */
+	if ((1 << uPC_raster_count) & 0x4444)
+	    *(a) |= b;
+	if (++uPC_raster_count > 15)
+	    uPC_raster_count = 0;
+	break;
+    case 4:
+    case 8:
+    default:
+	*(a) |= b;
+	break;
+    }
+}
+
+TERM_PUBLIC void
+uPC_vector(unsigned int x, unsigned int y)
+{
+/* This routine calls line with x,y */
+    int x1 = uPC_sx, y1 = uPC_sy, x2 = x, y2 = y;
+    register int c, e, dx, dy, width;
+    register Scr_type mask, *a;
+
+/* Record new sx, sy for next call to the vector routine. */
+    uPC_sx = x2;
+    uPC_sy = y2;
+
+    a = &uPC_display[(uPC_YSIZE - 1) - y1][x1 >> 4];
+    mask = lookup[x1 & 0x0f];
+    width = uPC_width;
+
+    if ((dx = x2 - x1) > 0) {
+	if ((dy = y2 - y1) > 0) {
+	    if (dx > dy) {	/* dx > 0, dy > 0, dx > dy */
+		dy <<= 1;
+		e = dy - dx;
+		c = dx + 2;
+		dx <<= 1;
+
+		while (--c) {
+		    uPC_PLOT(a, mask);
+		    if (e >= 0) {
+			(Scr_kluge *) a -= width;
+			e -= dx;
+		    }
+		    if (mask & uPC_HIGH_BIT) {
+			mask = 1;
+			a++;
+		    } else
+			mask <<= 1;
+		    e += dy;
+		}
+	    } else {		/* dx > 0, dy > 0, dx <= dy */
+		dx <<= 1;
+		e = dx - dy;
+		c = dy + 2;
+		dy <<= 1;
+
+		while (--c) {
+		    uPC_PLOT(a, mask);
+		    if (e >= 0) {
+			if (mask & uPC_HIGH_BIT) {
+			    mask = 1;
+			    a++;
+			} else
+			    mask <<= 1;
+			e -= dy;
+		    }
+		    (Scr_kluge *) a -= width;
+		    e += dx;
+		}
+	    }
+	} else {
+	    dy = -dy;
+	    if (dx > dy) {	/* dx > 0, dy <= 0, dx > dy */
+		dy <<= 1;
+		e = dy - dx;
+		c = dx + 2;
+		dx <<= 1;
+
+		while (--c) {
+		    uPC_PLOT(a, mask);
+		    if (e >= 0) {
+			(Scr_kluge *) a += width;
+			e -= dx;
+		    }
+		    if (mask & uPC_HIGH_BIT) {
+			mask = 1;
+			a++;
+		    } else
+			mask <<= 1;
+		    e += dy;
+		}
+	    } else {		/* dx > 0, dy <= 0, dx <= dy */
+		dx <<= 1;
+		e = dx - dy;
+		c = dy + 2;
+		dy <<= 1;
+
+		while (--c) {
+		    uPC_PLOT(a, mask);
+		    if (e >= 0) {
+			if (mask & uPC_HIGH_BIT) {
+			    mask = 1;
+			    a++;
+			} else
+			    mask <<= 1;
+			e -= dy;
+		    }
+		    (Scr_kluge *) a += width;
+		    e += dx;
+		}
+	    }
+	}
+    } else {
+	dx = -dx;
+	if ((dy = y2 - y1) > 0) {
+	    if (dx > dy) {	/* dx <= 0, dy > 0, dx > dy */
+		dy <<= 1;
+		e = dy - dx;
+		c = dx + 2;
+		dx <<= 1;
+
+		while (--c) {
+		    uPC_PLOT(a, mask);
+		    if (e >= 0) {
+			(Scr_kluge *) a -= width;
+			e -= dx;
+		    }
+		    if (mask & 1) {
+			mask = uPC_HIGH_BIT;
+			a--;
+		    } else
+			mask >>= 1;
+		    e += dy;
+		}
+	    } else {		/* dx <= 0, dy > 0, dx <= dy */
+		dx <<= 1;
+		e = dx - dy;
+		c = dy + 2;
+		dy <<= 1;
+
+		while (--c) {
+		    uPC_PLOT(a, mask);
+		    if (e >= 0) {
+			if (mask & 1) {
+			    mask = uPC_HIGH_BIT;
+			    a--;
+			} else
+			    mask >>= 1;
+			e -= dy;
+		    }
+		    (Scr_kluge *) a -= width;
+		    e += dx;
+		}
+	    }
+	} else {
+	    dy = -dy;
+	    if (dx > dy) {	/* dx <= 0, dy <= 0, dx > dy */
+		dy <<= 1;
+		e = dy - dx;
+		c = dx + 2;
+		dx <<= 1;
+
+		while (--c) {
+		    uPC_PLOT(a, mask);
+		    if (e >= 0) {
+			(Scr_kluge *) a += width;
+			e -= dx;
+		    }
+		    if (mask & 1) {
+			mask = uPC_HIGH_BIT;
+			a--;
+		    } else
+			mask >>= 1;
+		    e += dy;
+		}
+	    } else {		/* dx <= 0, dy <= 0, dx <= dy */
+		dx <<= 1;
+		e = dx - dy;
+		c = dy + 2;
+		dy <<= 1;
+
+		while (--c) {
+		    uPC_PLOT(a, mask);
+		    if (e >= 0) {
+			if (mask & 1) {
+			    mask = uPC_HIGH_BIT;
+			    a--;
+			} else
+			    mask >>= 1;
+			e -= dy;
+		    }
+		    (Scr_kluge *) a += width;
+		    e += dx;
+		}
+	    }
+	}
+    }
+}
+
+
+#ifdef uPC_NOT_USED
+
+/* Added by Russell Lang, eln272v@monu1.cc.monash.oz
+   This placement to the nearest character cell worked, and I'm leaving
+   it here so the calculations involved won't be lost!  (jdc)
+*/
+TERM_PUBLIC void
+uPC_put_text(unsigned int x, unsigned int y, const char str[])
+{
+    /* This routine puts the text at the cursor location nearest
+       to (x,y).  Obviously the exact postion would look better */
+
+    /* Just use the ANSI escape sequence CUP (iswind said that was ok!) */
+    printf("\033[%d;%dH%s\033[25;1H",
+	   (int) (24 - (y - uPC_VCHAR / 2) * 25 / uPC_YMAX),
+	   (int) (x * 80 / uPC_XMAX), str);
+    fflush(stdout);
+}
+
+#endif
+
+
+TERM_PUBLIC void
+uPC_put_text(unsigned int x, unsigned int y, const char str[])
+{
+    if (uPC_angle == 1)
+	x += uPC_VCHAR / 2;
+    else
+	y -= uPC_VCHAR / 2;
+
+    switch (uPC_angle) {
+    case 0:
+	for (; *str; ++str, x += uPC_HCHAR)
+	    uPC_putc(x, y, *str, uPC_angle);
+	break;
+    case 1:
+	for (; *str; ++str, y += uPC_HCHAR)
+	    uPC_putc(x, y, *str, uPC_angle);
+	break;
+    }
+}
+
+
+/*
+   Put a character at an x,y location in the bit map (using the fnt5x9
+   array.  This is mostly just copied from the bitmap.c driver.
+*/
+void
+uPC_putc(unsigned int x, unsigned int y, int c, int angle)
+{
+    int i, j, k;
+    register Scr_type mask, *a;
+    char_row fc;
+    unsigned int pixelon;
+
+    i = c - ' ';
+    for (j = 0; j < FNT5X9_VBITS; j++) {
+	fc = fnt5x9[i][j];
+	for (k = 0; k < FNT5X9_HBITS; k++) {
+	    pixelon = ((unsigned int) (fc)) >> k & 1;
+	    if (pixelon) {
+		switch (angle) {
+		case 0:
+		    mask = lookup[x + k + 1 & 0x0f];
+		    a = &uPC_display[(uPC_YSIZE - 1) - (y + j)][(x + k + 1) >> 4];
+		    break;
+		case 1:
+		    mask = lookup[x - j & 0x0f];
+		    a = &uPC_display[(uPC_YSIZE - 1) - (y + k + 1)][(x - j) >> 4];
+		    break;
+		}
+		*(a) |= (mask);	/* see uPC_PLOT macro */
+	    }
+	}
+    }
+}
+
+
+TERM_PUBLIC int
+uPC_text_angle(int ang)
+{
+    uPC_angle = (ang ? 1 : 0);
+    return TRUE;
+}
+
+
+TERM_PUBLIC void
+uPC_reset()
+{
+    /* Reset window to normal size. */
+    uPC_fixwind(0);
+}
+
+
+
+void
+uPC_fixwind(int signo)
+{
+    static struct uwdata wreset =
+    {0, 12, 720, 288, 0x1};
+    struct utdata ut;
+
+/* Reset the window to the right size. */
+    ioctl(1, WIOCSETD, &wreset);	/* 0, not wncur here! */
+
+/* Scroll the screen once. (avoids typing over the same line) */
+    putc('\n', stderr);
+
+    if (signo) {
+	if (signo == SIGILL || signo == SIGTRAP || signo == SIGPWR)
+	    signal(signo, SIG_DFL);
+	kill(0, signo);		/* Redo the signal (as if we never trapped it). */
+    }
+}
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(unixpc_driver)
+    "unixpc", "AT&T 3b1 or AT&T 7300 Unix PC",
+    uPC_XMAX, uPC_YMAX, uPC_VCHAR, uPC_HCHAR,
+    uPC_VTIC, uPC_HTIC, options_null, uPC_init, uPC_reset,
+    uPC_text, null_scale, uPC_graphics, uPC_move, uPC_vector,
+    uPC_linetype, uPC_put_text, uPC_text_angle,
+    null_justify_text, line_and_point, do_arrow, set_font_null
+TERM_TABLE_END(unixpc_driver)
+
+#undef LAST_TERM
+#define LAST_TERM unixpc_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(unixpc)
+"1 unixpc",
+"?commands set terminal unixpc",
+"?set terminal unixpc",
+"?set term unixpc",
+"?terminal unixpc",
+"?term unixpc",
+"?unixpc",
+" The `unixpc` terminal driver supports AT&T 3b1 and AT&T 7300 Unix PC.  It has",
+" no options."
+END_HELP(unixpc)
+#endif /* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/unixplot.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/unixplot.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/unixplot.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/unixplot.trm.svn-base	2012-01-03 17:07:46.390280900 -0800
@@ -0,0 +1,193 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: unixplot.trm,v 1.16 2006/07/21 02:35:48 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT -- unixplot.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *  Unix plot(5) graphics language
+ *
+ * AUTHORS
+ *  Colin Kelley, Thomas Williams, Russell Lang
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+
+/*
+ * Unixplot library writes to stdout.  A fix was put in place by
+ * ..!arizona!naucse!jdc to let set term and set output redirect
+ * stdout.  All other terminals write to gpoutfile.
+*/
+
+/*
+ * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(unixplot)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void UP_init __PROTO((void));
+TERM_PUBLIC void UP_graphics __PROTO((void));
+TERM_PUBLIC void UP_text __PROTO((void));
+TERM_PUBLIC void UP_linetype __PROTO((int linetype));
+TERM_PUBLIC void UP_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void UP_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void UP_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
+TERM_PUBLIC void UP_reset __PROTO((void));
+
+#define UP_XMAX 4096
+#define UP_YMAX 4096
+
+#define UP_XLAST (UP_XMAX - 1)
+#define UP_YLAST (UP_YMAX - 1)
+
+#define UP_VCHAR (UP_YMAX/30)	/* just a guess--no way to know this! */
+#define UP_HCHAR (UP_XMAX/60)	/* just a guess--no way to know this! */
+#define UP_VTIC (UP_YMAX/80)
+#define UP_HTIC (UP_XMAX/80)
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+TERM_PUBLIC void
+UP_init()
+{
+    openpl();
+    space(0, 0, UP_XMAX, UP_YMAX);
+}
+
+
+TERM_PUBLIC void
+UP_graphics()
+{
+    erase();
+}
+
+
+TERM_PUBLIC void
+UP_text()
+{
+    /* empty */
+}
+
+
+TERM_PUBLIC void
+UP_linetype(int linetype)
+{
+    static char *lt[2 + 5] = {"solid", "longdashed", "solid", "dotted",
+     "shortdashed", "dotdashed", "longdashed"};
+
+    if (linetype < -2)
+	linetype = LT_BLACK;
+
+    if (linetype >= 5)
+	linetype %= 5;
+
+    linemod(lt[linetype + 2]);
+}
+
+
+TERM_PUBLIC void
+UP_move(unsigned int x, unsigned int y)
+{
+    move(x, y);
+}
+
+
+TERM_PUBLIC void
+UP_vector(unsigned int x, unsigned int y)
+{
+    cont(x, y);
+}
+
+
+TERM_PUBLIC void
+UP_put_text(unsigned int x, unsigned int y, const char str[])
+{
+    UP_move(x + UP_HCHAR / 2, y + UP_VCHAR / 5);
+    label(str);
+}
+
+TERM_PUBLIC void
+UP_reset()
+{
+    closepl();
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+TERM_TABLE_START(unixplot_driver)
+    "unixplot", "Unix plotting standard (see plot(1))",
+    UP_XMAX, UP_YMAX, UP_VCHAR, UP_HCHAR,
+    UP_VTIC, UP_HTIC, options_null, UP_init, UP_reset,
+    UP_text, null_scale, UP_graphics, UP_move, UP_vector,
+    UP_linetype, UP_put_text, null_text_angle,
+    null_justify_text, line_and_point, do_arrow, set_font_null
+TERM_TABLE_END(unixplot_driver)
+
+#undef LAST_TERM
+#define LAST_TERM unixplot_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+
+#ifdef TERM_HELP
+#ifndef TERM_HELP_GNUGRAPH
+START_HELP(unixplot)
+"1 unixplot",
+"?commands set terminal unixplot",
+"?set terminal unixplot",
+"?set term unixplot",
+"?terminal unixplot",
+"?term unixplot",
+"?unixplot",
+" The `unixplot` terminal driver generates output in the Unix \"plot\" graphics",
+" language.  It has no options.",
+"",
+" This terminal cannot be compiled if the GNU version of plot is to be used;",
+" in that case, use the `gnugraph` terminal instead."
+END_HELP(unixplot)
+#endif
+#endif
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/v384.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/v384.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/v384.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/v384.trm.svn-base	2012-01-03 17:07:46.599824300 -0800
@@ -0,0 +1,207 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: v384.trm,v 1.12 2006/07/21 02:35:48 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - v384.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *  Vectrix 384 - works with tandy color printer as well
+ *
+ * AUTHORS
+ *   roland@moncskermit.OZ (Roland Yap)
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+
+/*
+ *	Vectrix 384 driver - works with tandy color printer as well
+ *  in reverse printing 8 color mode.
+ *  This doesn't work on Vectrix 128 because it redefines the
+ *  color table. It can be hacked to work on the 128 by changing
+ *  the colours but then it will probably not print best. The color
+ *  table is purposely designed so that it will print well
+ *
+ */
+
+/*
+ * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(vx384)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void V384_init __PROTO((void));
+TERM_PUBLIC void V384_graphics __PROTO((void));
+TERM_PUBLIC void V384_text __PROTO((void));
+TERM_PUBLIC void V384_linetype __PROTO((int linetype));
+TERM_PUBLIC void V384_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void V384_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void V384_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
+TERM_PUBLIC void V384_reset __PROTO((void));
+
+#define V384_XMAX 630
+#define V384_YMAX 480
+
+#define V384_XLAST (V384_XMAX - 1)
+#define V384_YLAST (V384_YMAX - 1)
+
+#define V384_VCHAR	12
+#define V384_HCHAR	7
+#define V384_VTIC	8
+#define V384_HTIC	7
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+TERM_PUBLIC void
+V384_init()
+{
+    fprintf(gpoutfile, "%c%c  G0   \n\
+Q 0 8\n\
+0 0 0\n\
+255 0 0\n\
+0 255 0\n\
+0 0 255\n\
+0 255 255\n\
+255 0 255\n\
+255 255 0\n\
+255 255 255\n",
+	    27, 18);
+}
+
+
+TERM_PUBLIC void
+V384_graphics()
+{
+    fprintf(gpoutfile, "%c%c E0 RE N 65535\n", 27, 18);
+}
+
+
+TERM_PUBLIC void
+V384_text()
+{
+    fprintf(gpoutfile, "%c%c\n", 27, 17);
+}
+
+
+TERM_PUBLIC void
+V384_linetype(int linetype)
+{
+    static int color[] =
+    {
+	1 /* red */ ,
+	2 /* green */ ,
+	3 /* blue */ ,
+	4 /* cyan */ ,
+	5 /* magenta */ ,
+	6 /* yellow */ ,	/* not a good color so not in use at the moment */
+	7 /* white */
+    };
+
+    if (linetype < 0)
+	linetype = 6;
+    else
+	linetype %= 5;
+
+    fprintf(gpoutfile, "C %d\n", color[linetype]);
+}
+
+
+TERM_PUBLIC void
+V384_move(unsigned int x, unsigned int y)
+{
+    fprintf(gpoutfile, "M %d %d\n", x + 20, y);
+}
+
+
+TERM_PUBLIC void
+V384_vector(unsigned int x, unsigned int y)
+{
+    fprintf(gpoutfile, "L %d %d\n", x + 20, y);
+}
+
+
+TERM_PUBLIC void
+V384_put_text(unsigned int x, unsigned int y, const char str[])
+{
+    V384_move(x, y + V384_VCHAR / 2);
+    fprintf(gpoutfile, "$%s\n", str);
+}
+
+
+TERM_PUBLIC void
+V384_reset()
+{
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+TERM_TABLE_START(vx384_driver)
+    "vx384", "Vectrix 384 and Tandy color printer",
+    V384_XMAX, V384_YMAX, V384_VCHAR, V384_HCHAR,
+    V384_VTIC, V384_HTIC, options_null, V384_init, V384_reset,
+    V384_text, null_scale, V384_graphics, V384_move, V384_vector,
+    V384_linetype, V384_put_text, null_text_angle,
+    null_justify_text, do_point, do_arrow, set_font_null
+TERM_TABLE_END(vx384_driver)
+
+#undef LAST_TERM
+#define LAST_TERM vx384_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(vx384)
+"1 vx384",
+"?commands set terminal vx384",
+"?set terminal vx384",
+"?set term vx384",
+"?terminal vx384",
+"?term vx384",
+"?vx384",
+" The `vx384` terminal driver supports the Vectrix 384 and Tandy color",
+" printers.  It has no options."
+END_HELP(vx384)
+#endif
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/vgagl.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/vgagl.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/vgagl.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/vgagl.trm.svn-base	2012-01-03 17:07:46.848469100 -0800
@@ -0,0 +1,1611 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: vgagl.trm,v 1.20 2006/07/21 02:35:48 sfeam Exp $
+ */
+
+#if defined(USE_MOUSE)
+/* GNUPLOT - vgagl.trm */
+
+/*[
+ * Copyright 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+ ]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports SVGA in the following modes:
+ *
+ *  G1024x768x256,
+ *  G800x600x256,
+ *  G640x480x256,
+ *  G320x200x256,
+ *  G1280x1024x256,
+ *  G1152x864x256,
+ *  G1360x768x256,
+ *  G1600x1200x256,
+ *
+ *
+ * AUTHOR
+ *  Johannes Zellner <johannes@zellner.org>
+ *  the code is based on the `linux' driver.
+ *  The first version dated January 2000.
+ */
+
+/*
+ * Compile with -l3kit -lvgagl -lvga
+ */
+
+#define VGAGL_DEBUGGING
+
+#ifdef TERM_REGISTER
+register_term(vgagl)
+#endif
+
+#ifdef TERM_PROTO
+
+#define VGAGL_VCHAR FNT5X9_VCHAR
+#define VGAGL_HCHAR FNT5X9_HCHAR
+#define VGAGL_VTIC 5
+#define VGAGL_HTIC 5
+#define VGAGL_XMAX 0		/* These two entries are just place holders. */
+#define VGAGL_YMAX 0		/* The actual values will be filled in init. */
+
+TERM_PUBLIC void VGAGL_options __PROTO((void));
+TERM_PUBLIC int VGAGL_get_mode __PROTO((void));
+TERM_PUBLIC void VGAGL_init __PROTO((void));
+TERM_PUBLIC void VGAGL_reset __PROTO((void));
+TERM_PUBLIC void VGAGL_text __PROTO((void));
+TERM_PUBLIC void VGAGL_graphics __PROTO((void));
+TERM_PUBLIC void VGAGL_linetype __PROTO((int linetype));
+TERM_PUBLIC void VGAGL_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void VGAGL_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC int VGAGL_text_angle __PROTO((int ang));
+TERM_PUBLIC void VGAGL_put_text_with_color __PROTO((unsigned int x, unsigned int y, const char* str, int color));
+TERM_PUBLIC void VGAGL_put_text __PROTO((unsigned int x, unsigned int y, const char* str));
+TERM_PUBLIC void VGAGL_suspend __PROTO((void));
+TERM_PUBLIC void VGAGL_resume __PROTO((void));
+
+
+void VGAGL_eventually_process_graphics_events __PROTO((void));
+TERM_PUBLIC void VGAGL_draw_cursor __PROTO((int x, int y));
+TERM_PUBLIC void VGAGL_set_ruler __PROTO((int, int));
+TERM_PUBLIC void VGAGL_set_cursor __PROTO((int, int, int));
+TERM_PUBLIC void VGAGL_put_tmptext __PROTO((int, const char str[]));
+TERM_PUBLIC void VGAGL_set_clipboard __PROTO((const char[]));
+TERM_PUBLIC void VGAGL_init_keytable __PROTO((void));
+TERM_PUBLIC void VGAGL_xor_pixel __PROTO((int x, int y));
+TERM_PUBLIC void VGAGL_xor_pixel_wrapper __PROTO((int x, int y, int color));
+TERM_PUBLIC void VGAGL_hline_xor __PROTO((int x1, int x2, int y));
+TERM_PUBLIC void VGAGL_vline_xor __PROTO((int y1, int y2, int x));
+#if 0
+TERM_PUBLIC void VGAGL_line_xor __PROTO((unsigned int x1, unsigned int y1, unsigned int x2, unsigned int y2));
+#endif
+TERM_PUBLIC void VGAGL_zoombox __PROTO((int x, int y));
+TERM_PUBLIC void VGAGL_update_zoombox __PROTO((int x, int y));
+TERM_PUBLIC void VGAGL_update_cursor __PROTO((int x, int y));
+TERM_PUBLIC void VGAGL_signal_handler __PROTO((int signum));
+TERM_PUBLIC void VGAGL_setpalettecolor __PROTO((int index, double red, double green, double blue));
+TERM_PUBLIC void VGAGL_set_black_and_white __PROTO((void));
+TERM_PUBLIC void VGAGL_set_line_colors __PROTO((void));
+TERM_PUBLIC void VGAGL_putc __PROTO((unsigned int x, unsigned int y, int c, int ang, int color));
+void (*VGAGL_old_handler) __PROTO((int));
+#ifdef VGAGL_DEBUGGING
+TERM_PUBLIC void VGAGL_write_dump_file __PROTO((void));
+#endif
+
+TERM_PUBLIC int VGAGL_make_palette __PROTO((t_sm_palette*));
+TERM_PUBLIC void VGAGL_set_color __PROTO((t_colorspec *));
+TERM_PUBLIC void VGAGL_filled_polygon __PROTO((int, gpiPoint*));
+
+static const int VGAGL_8bit_colors = 240;
+static const int pm3d_color_offset = 16; /* 0xff - VGAGL_8bit_colors + 1 */
+
+static int VGAGL_pm3d_colors;
+static int VGAGL_pm3d_colors_; /* VGAGL_pm3d_colors - 1 */
+static t_sm_palette VGAGL_save_pal = {
+    -1, -1, -1, -1, -1, -1, -1, -1,
+    (rgb_color*) 0, -1, -1
+};
+static double VGAGL_gray = 0;
+
+#ifdef VGAGL_ENABLE_TRUECOLOR
+#define VGAGL_tri_colors 4096
+static TBOOLEAN VGAGL_truecolor = FALSE;
+static unsigned short VGAGL_line_cmap[0xf];
+static unsigned short VGAGL_cmap[VGAGL_tri_colors];
+#endif
+
+#ifdef VGAGL_DEBUGGING
+static char* VGAGL_dump_file = (char*) 0;
+static unsigned char VGAGL_palette[0x100][3];
+#endif
+
+#endif /* TERM_PROTO */
+
+#ifdef TERM_BODY
+
+#include <signal.h>
+
+#define _STRING_H_
+/* according to the vga_waitevent() man page */
+#include <sys/time.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <vga.h>
+#include <vgagl.h>
+#include <3dkit.h>
+#include <vgamouse.h>
+#include <vgakeyboard.h>
+
+#define VGA_FPRINTF(x) fprintf x
+#define Y(y) (vgagl_lasty - y)
+
+static TBOOLEAN VGAGL_processing_graphics_events = FALSE;
+static TBOOLEAN VGAGL_interpolate = TRUE;
+static GraphicsContext backscreen;
+static GraphicsContext physicalscreen;
+static int current_color = 7;
+#ifdef SCANCODE_RIGHTWIN
+#   define KEYTABLE_SIZE (SCANCODE_RIGHTWIN + 1)
+#else
+#   define KEYTABLE_SIZE (128) /* should be sufficient (joze) */
+#endif
+static int VGAGL_Keytable[KEYTABLE_SIZE];
+static int VGAGL_modifier_mask = 0;
+static int VGAGL_last_cursorx = -1;
+static int VGAGL_last_cursory = -1;
+static int VGAGL_cursorx;
+static int VGAGL_cursory;
+static int VGAGL_ruler_x = -1;
+static int VGAGL_ruler_y = -1;
+typedef struct VGAGL_zoom_t {
+    int startx;
+    int starty;
+    int currentx;
+    int currenty;
+    char xstr[2][0xff];
+    char ystr[2][0xff];
+    char current_xstr[2][0xff];
+    char current_ystr[2][0xff];
+} VGAGL_zoom_t;
+static VGAGL_zoom_t VGAGL_zoom = {
+    -1, -1, -1, -1,
+    { "", "" },
+    { "", "" },
+    { "", "" },
+    { "", "" }
+};
+static TBOOLEAN VGAGL_cursor_drawn = FALSE;
+static unsigned char VGAGL_bg_red = 0x0;
+static unsigned char VGAGL_bg_green = 0x0;
+static unsigned char VGAGL_bg_blue = 0x0;
+static unsigned char VGAGL_xor_red = 0xff;
+static unsigned char VGAGL_xor_green = 0xff;
+static unsigned char VGAGL_xor_blue = 0xff;
+static TBOOLEAN VGAGL_need_update = TRUE;
+static char VGAGL_savedstr[0xff] = "";
+
+static int vgagl_vmode = -1; /* default mode */
+static TBOOLEAN VGAGL_graphics_on = FALSE;
+static vga_modeinfo *modeinfo;
+static int VGAGL_startx, VGAGL_starty, vgagl_lasty, vgagl_lastx;
+static int VGAGL_angle = 0;
+
+
+void
+VGAGL_init_keytable()
+{
+    int i;
+    for (i = 0; i < KEYTABLE_SIZE; i++) {
+	VGAGL_Keytable[i] = -1;
+    }
+    VGAGL_Keytable[SCANCODE_1] = '1';
+    VGAGL_Keytable[SCANCODE_2] = '2';
+    VGAGL_Keytable[SCANCODE_3] = '3';
+    VGAGL_Keytable[SCANCODE_4] = '4';
+    VGAGL_Keytable[SCANCODE_5] = '5';
+    VGAGL_Keytable[SCANCODE_6] = '6';
+    VGAGL_Keytable[SCANCODE_7] = '7';
+    VGAGL_Keytable[SCANCODE_8] = '8';
+    VGAGL_Keytable[SCANCODE_9] = '9';
+    VGAGL_Keytable[SCANCODE_0] = '0';
+
+    VGAGL_Keytable[SCANCODE_A] = 'a';
+    VGAGL_Keytable[SCANCODE_B] = 'b';
+    VGAGL_Keytable[SCANCODE_C] = 'c';
+    VGAGL_Keytable[SCANCODE_D] = 'd';
+    VGAGL_Keytable[SCANCODE_E] = 'e';
+    VGAGL_Keytable[SCANCODE_F] = 'f';
+    VGAGL_Keytable[SCANCODE_G] = 'g';
+    VGAGL_Keytable[SCANCODE_H] = 'h';
+    VGAGL_Keytable[SCANCODE_I] = 'i';
+    VGAGL_Keytable[SCANCODE_J] = 'j';
+    VGAGL_Keytable[SCANCODE_K] = 'k';
+    VGAGL_Keytable[SCANCODE_L] = 'l';
+    VGAGL_Keytable[SCANCODE_M] = 'm';
+    VGAGL_Keytable[SCANCODE_N] = 'n';
+    VGAGL_Keytable[SCANCODE_O] = 'o';
+    VGAGL_Keytable[SCANCODE_P] = 'p';
+    VGAGL_Keytable[SCANCODE_Q] = 'q';
+    VGAGL_Keytable[SCANCODE_R] = 'r';
+    VGAGL_Keytable[SCANCODE_S] = 's';
+    VGAGL_Keytable[SCANCODE_T] = 't';
+    VGAGL_Keytable[SCANCODE_U] = 'u';
+    VGAGL_Keytable[SCANCODE_V] = 'v';
+    VGAGL_Keytable[SCANCODE_W] = 'w';
+    VGAGL_Keytable[SCANCODE_X] = 'x';
+    VGAGL_Keytable[SCANCODE_Y] = 'y';
+    VGAGL_Keytable[SCANCODE_Z] = 'z';
+
+    VGAGL_Keytable[SCANCODE_BRACKET_LEFT] = '[';
+    VGAGL_Keytable[SCANCODE_BRACKET_RIGHT] = ']';
+    VGAGL_Keytable[SCANCODE_MINUS] = '-';
+    VGAGL_Keytable[SCANCODE_EQUAL] = '=';
+    VGAGL_Keytable[SCANCODE_SEMICOLON] = ';';
+    VGAGL_Keytable[SCANCODE_APOSTROPHE] = '\'';
+    VGAGL_Keytable[SCANCODE_GRAVE] = '^';
+    VGAGL_Keytable[SCANCODE_BACKSLASH] = '\\';
+    VGAGL_Keytable[SCANCODE_COMMA] = ',';
+    VGAGL_Keytable[SCANCODE_PERIOD] = '.';
+    VGAGL_Keytable[SCANCODE_SLASH] = '/';
+    VGAGL_Keytable[SCANCODE_SPACE] = ' ';
+
+    VGAGL_Keytable[SCANCODE_BACKSPACE] = GP_BackSpace;
+    VGAGL_Keytable[SCANCODE_TAB] = GP_Tab;
+    VGAGL_Keytable[SCANCODE_ENTER] = GP_Return;
+    VGAGL_Keytable[SCANCODE_ESCAPE] = GP_Escape;
+
+    /* VGAGL_Keytable[SCANCODE_LEFTCONTROL] */
+    /* VGAGL_Keytable[SCANCODE_RIGHTCONTROL] */
+    /* VGAGL_Keytable[SCANCODE_CONTROL] */
+    /* VGAGL_Keytable[SCANCODE_LEFTSHIFT] */
+    /* VGAGL_Keytable[SCANCODE_RIGHTSHIFT] */
+    /* VGAGL_Keytable[SCANCODE_LEFTALT] */
+    /* VGAGL_Keytable[SCANCODE_RIGHTALT] */
+    /* VGAGL_Keytable[SCANCODE_CAPSLOCK] */
+
+    VGAGL_Keytable[SCANCODE_NUMLOCK] = GP_Scroll_Lock;
+    /* VGAGL_Keytable[SCANCODE_SCROLLLOCK] = GP_Numlock; */
+
+    VGAGL_Keytable[SCANCODE_KEYPADMULTIPLY] = GP_KP_Multiply;
+
+    VGAGL_Keytable[SCANCODE_F1] = GP_F1;
+    VGAGL_Keytable[SCANCODE_F2] = GP_F2;
+    VGAGL_Keytable[SCANCODE_F3] = GP_F3;
+    VGAGL_Keytable[SCANCODE_F4] = GP_F4;
+    VGAGL_Keytable[SCANCODE_F5] = GP_F5;
+    VGAGL_Keytable[SCANCODE_F6] = GP_F6;
+    VGAGL_Keytable[SCANCODE_F7] = GP_F7;
+    VGAGL_Keytable[SCANCODE_F8] = GP_F8;
+    VGAGL_Keytable[SCANCODE_F9] = GP_F9;
+    VGAGL_Keytable[SCANCODE_F10] = GP_F10;
+    VGAGL_Keytable[SCANCODE_F11] = GP_F11;
+    VGAGL_Keytable[SCANCODE_F12] = GP_F12;
+
+    VGAGL_Keytable[SCANCODE_KEYPAD0] = GP_KP_0;
+    VGAGL_Keytable[SCANCODE_KEYPAD1] = GP_KP_1;
+    VGAGL_Keytable[SCANCODE_KEYPAD2] = GP_KP_2;
+    VGAGL_Keytable[SCANCODE_KEYPAD3] = GP_KP_3;
+    VGAGL_Keytable[SCANCODE_KEYPAD4] = GP_KP_4;
+    VGAGL_Keytable[SCANCODE_KEYPAD5] = GP_KP_5;
+    VGAGL_Keytable[SCANCODE_KEYPAD6] = GP_KP_6;
+    VGAGL_Keytable[SCANCODE_KEYPAD7] = GP_KP_7;
+    VGAGL_Keytable[SCANCODE_KEYPAD8] = GP_KP_8;
+    VGAGL_Keytable[SCANCODE_KEYPAD9] = GP_KP_9;
+
+    /* KEYPAD */
+    VGAGL_Keytable[SCANCODE_KEYPADMINUS] = GP_KP_Subtract;
+    VGAGL_Keytable[SCANCODE_KEYPADPLUS] = GP_KP_Add;
+    VGAGL_Keytable[SCANCODE_KEYPADPERIOD] = GP_KP_Delete;
+    VGAGL_Keytable[SCANCODE_KEYPADENTER] = GP_KP_Enter;
+    VGAGL_Keytable[SCANCODE_KEYPADDIVIDE] = GP_KP_Divide;
+
+    VGAGL_Keytable[SCANCODE_CURSORUPLEFT] = GP_KP_Home;
+    VGAGL_Keytable[SCANCODE_CURSORUP] = GP_KP_Up;
+    VGAGL_Keytable[SCANCODE_CURSORUPRIGHT] = GP_KP_Page_Up;
+    VGAGL_Keytable[SCANCODE_CURSORLEFT] = GP_KP_Left;
+    VGAGL_Keytable[SCANCODE_CURSORRIGHT] = GP_KP_Right;
+    VGAGL_Keytable[SCANCODE_CURSORDOWNLEFT] = GP_KP_End;
+    VGAGL_Keytable[SCANCODE_CURSORDOWN] = GP_KP_Down;
+    VGAGL_Keytable[SCANCODE_CURSORDOWNRIGHT] = GP_KP_Page_Down;
+
+    VGAGL_Keytable[SCANCODE_LESS] = GP_KP_Begin;
+
+#if 0
+    VGAGL_Keytable[SCANCODE_PRINTSCREEN] = GP_Begin;
+    VGAGL_Keytable[SCANCODE_BREAK] = GP_Begin;
+    VGAGL_Keytable[SCANCODE_BREAK_ALTERNATIVE] = GP_Begin;
+#endif
+
+    /* 3 * 2 block (usually above arrow keys) */
+    VGAGL_Keytable[SCANCODE_INSERT] = GP_Insert;
+    VGAGL_Keytable[SCANCODE_HOME] = GP_Home;
+    VGAGL_Keytable[SCANCODE_PAGEUP] = GP_PageUp;
+
+    VGAGL_Keytable[SCANCODE_REMOVE] = GP_Delete;
+    VGAGL_Keytable[SCANCODE_END] = GP_End;
+    VGAGL_Keytable[SCANCODE_PAGEDOWN] = GP_PageDown;
+
+    /* arrow keys */
+    VGAGL_Keytable[SCANCODE_CURSORBLOCKUP] = GP_Up;
+    VGAGL_Keytable[SCANCODE_CURSORBLOCKLEFT] = GP_Left;
+    VGAGL_Keytable[SCANCODE_CURSORBLOCKRIGHT] = GP_Right;
+    VGAGL_Keytable[SCANCODE_CURSORBLOCKDOWN] = GP_Down;
+
+    /* VGAGL_Keytable[SCANCODE_RIGHTWIN] */
+    /* VGAGL_Keytable[SCANCODE_LEFTWIN] */
+}
+
+enum {
+    VGAGL_INVALID = -1,
+    VGAGL_BACKGROUND = 1,
+    VGAGL_UNIFORM,
+    VGAGL_INTERPOLATE,
+    VGAGL_DUMP
+};
+
+static struct gen_table VGAGL_opts[] = {
+    { "ba$ckground", VGAGL_BACKGROUND },
+    { "bg", VGAGL_BACKGROUND },
+    { "un$iform", VGAGL_UNIFORM },
+    { "in$terpolate", VGAGL_INTERPOLATE },
+#ifdef VGAGL_DEBUGGING
+    { "dump", VGAGL_DUMP },
+#endif
+    { NULL, VGAGL_INVALID }
+};
+
+/* parse driver optinos. This is done when the
+ * user types `set term vgagl [options ...]'. */
+TERM_PUBLIC
+void VGAGL_options()
+{
+    if (!LINUX_graphics_allowed) {
+	int_error(NO_CARET, "vgagl terminal driver not available");
+	return;
+    }
+
+#ifdef VGAGL_DEBUGGING
+#if 0
+    if (VGAGL_dump_file)
+	free(VGAGL_dump_file);
+    VGAGL_dump_file = (char*) 0;
+#endif
+#endif
+
+    if (END_OF_COMMAND) {
+	/* defaults */
+	vgagl_vmode = -1; /* get default mode */
+	VGAGL_bg_red = 0;
+	VGAGL_bg_green = 0;
+	VGAGL_bg_blue = 0;
+	VGAGL_interpolate = TRUE;
+    }
+
+    while (!END_OF_COMMAND) {
+	switch (lookup_table(VGAGL_opts, c_token)) {
+	    case VGAGL_BACKGROUND:
+		{
+		    struct value a;
+		    int i, c[3];
+		    ++c_token;
+		    for (i = 0; i < 3; i++) {
+			if (END_OF_COMMAND) {
+			    break;
+			}
+			c[i] = (int)real(const_express(&a));
+			if (c[i] < 0 || c[i] > 255) {
+			    fprintf(stderr, "color ranges from 0 to 255\n");
+			    return;
+			}
+		    }
+		    if (!i) {
+			fprintf(stderr, "background requires arguments\n");
+		    } else if (i < 3) {
+			c[1] = c[0];
+			c[2] = c[0];
+		    }
+		    VGAGL_bg_red = c[0];
+		    VGAGL_bg_green = c[1];
+		    VGAGL_bg_blue = c[2];
+		}
+		break;
+	    case VGAGL_UNIFORM:
+		VGAGL_interpolate = FALSE;
+		++c_token;
+		break;
+	    case VGAGL_INTERPOLATE:
+		VGAGL_interpolate = TRUE;
+		++c_token;
+		break;
+#ifdef VGAGL_DEBUGGING
+	    case VGAGL_DUMP:
+		/* since this is not documented it won't hurt too much to leave it in. */
+		++c_token;
+		if (isstring(c_token)) {
+		    if (VGAGL_dump_file)
+			free(VGAGL_dump_file);
+		    /* get text */
+		    VGAGL_dump_file = gp_alloc(token_len(c_token), "vgagl->dump_file");
+		    quote_str(VGAGL_dump_file, c_token, token_len(c_token));
+		    ++c_token;
+		} else {
+		    int_error(NO_CARET, "expecting string value");
+		    return;
+		}
+		break;
+#endif
+	    default:
+		{
+		    /* VGA MODE */
+		    char x[0x40];
+		    int imode;
+		    copy_str(x, c_token, 0x3f);
+		    imode = vga_getmodenumber(x);
+		    if (-1 != imode) {
+			if (vga_hasmode(imode)) {
+			    vgagl_vmode = imode;
+			} else {
+			    fprintf(stderr, "mode %s not available\n",
+				vga_getmodename(imode));
+			}
+		    }
+		    c_token++;
+		}
+		if (VGAGL_graphics_on) {
+		    VGAGL_processing_graphics_events = FALSE;
+		    VGAGL_reset();
+		}
+		break;
+	}
+    }
+    if (VGAGL_graphics_on) {
+	VGAGL_set_black_and_white();
+    }
+    VGAGL_get_mode(); /* check availability of mode */
+    sprintf(term_options, "%s bg %d %d %d %s",
+	vga_getmodename(vgagl_vmode),
+	VGAGL_bg_red, VGAGL_bg_green, VGAGL_bg_blue,
+	TRUE == VGAGL_interpolate ? "interpolate" : "uniform");
+}
+
+void
+VGAGL_setpalettecolor(int index, double red, double green, double blue)
+{
+#ifdef VGAGL_DEBUGGING
+    assert(index >= 0 && index < 0x100);
+    assert(red >= 0 && red <= 1);
+    assert(green >= 0 && green <= 1);
+    assert(blue >= 0 && blue <= 1);
+    VGAGL_palette[index][0] = (unsigned char) floor(red * 255.999);
+    VGAGL_palette[index][1] = (unsigned char) floor(green * 255.999);
+    VGAGL_palette[index][2] = (unsigned char) floor(blue * 255.999);
+#endif
+    gl_setpalettecolor(index, red * 63.999, green * 63.999, blue * 63.999);
+}
+
+/* set the background color (default is black) and choose
+ * the primary foreground and xor colors appropriately */
+TERM_PUBLIC void
+VGAGL_set_black_and_white()
+{
+    /* background */
+#ifdef VGAGL_ENABLE_TRUECOLOR
+    switch (VGAGL_truecolor) {
+	case TRUE:
+	    VGAGL_line_cmap[0] = gl_rgbcolor(VGAGL_bg_red, VGAGL_bg_green, VGAGL_bg_blue);
+	    break;
+	default:
+#endif
+	    VGAGL_setpalettecolor(0,
+		(double) VGAGL_bg_red / (double) 0xff,
+		(double) VGAGL_bg_green / (double) 0xff,
+		(double) VGAGL_bg_blue / (double) 0xff);
+#ifdef VGAGL_ENABLE_TRUECOLOR
+    }
+#endif
+    if (VGAGL_bg_red + VGAGL_bg_green + VGAGL_bg_blue > 0x180) {
+	/* light background */
+#ifdef VGAGL_ENABLE_TRUECOLOR
+	switch (VGAGL_truecolor) {
+	    case TRUE:
+		VGAGL_line_cmap[1] = gl_rgbcolor(0x00, 0x00, 0x00);
+		break;
+	    default:
+#endif
+		VGAGL_setpalettecolor(1, 0, 0, 0); /* black */
+#ifdef VGAGL_ENABLE_TRUECOLOR
+	}
+#endif
+	VGAGL_xor_red = 0xa0;
+	VGAGL_xor_green = 0xa0;
+	VGAGL_xor_blue = 0xa0;
+	/* TODO  need to allocate a colormap entry for the xor color ? */
+#if 0
+	VGAGL_xor_red = ~VGAGL_bg_red;
+	VGAGL_xor_green = ~VGAGL_bg_green;
+	VGAGL_xor_blue = ~VGAGL_bg_blue;
+	fprintf(stderr, "(VGAGL_set_black_and_white) VGAGL_xor_red = %d\n", VGAGL_xor_red);
+	fprintf(stderr, "(VGAGL_set_black_and_white) VGAGL_xor_green = %d\n", VGAGL_xor_green);
+	fprintf(stderr, "(VGAGL_set_black_and_white) VGAGL_xor_blue = %d\n", VGAGL_xor_blue);
+#endif
+    } else {
+	/* dark background */
+#ifdef VGAGL_ENABLE_TRUECOLOR
+	switch (VGAGL_truecolor) {
+	    case TRUE:
+		VGAGL_line_cmap[1] = gl_rgbcolor(0xff, 0xff, 0xff);
+		break;
+	    default:
+#endif
+		VGAGL_setpalettecolor(1, 1, 1, 1); /* white */
+#ifdef VGAGL_ENABLE_TRUECOLOR
+	}
+#endif
+	VGAGL_xor_red = 0xff;
+	VGAGL_xor_green = 0xff;
+	VGAGL_xor_blue = 0xff;
+	/* TODO  need to allocate a colormap entry for the xor color ? */
+    }
+}
+
+/* set up line colors */
+TERM_PUBLIC void
+VGAGL_set_line_colors()
+{
+    gl_setrgbpalette();
+    VGAGL_set_black_and_white();
+#ifdef VGAGL_ENABLE_TRUECOLOR
+    switch (VGAGL_truecolor) {
+	case TRUE:
+	    VGAGL_line_cmap[2]  = gl_rgbcolor(0x80, 0x80, 0x80); /* gray */
+	    VGAGL_line_cmap[3]  = gl_rgbcolor(0x00, 0xff, 0x00); /* green */
+	    VGAGL_line_cmap[4]  = gl_rgbcolor(0x00, 0xff, 0xff); /* cyan */
+	    VGAGL_line_cmap[5]  = gl_rgbcolor(0xff, 0x00, 0x00); /* red */
+	    VGAGL_line_cmap[6]  = gl_rgbcolor(0xff, 0x00, 0xff); /* magenta */
+	    VGAGL_line_cmap[7]  = gl_rgbcolor(0x00, 0x00, 0xff); /* blue */
+	    VGAGL_line_cmap[8]  = gl_rgbcolor(0xff, 0xff, 0x00); /* yellow */
+	    VGAGL_line_cmap[9]  = gl_rgbcolor(0xff, 0x80, 0x80); /* light red */
+	    VGAGL_line_cmap[10] = gl_rgbcolor(0xff, 0xff, 0xff); /* white */
+	    VGAGL_line_cmap[11] = gl_rgbcolor(0xff, 0x80, 0xff); /* light magenta */
+	    VGAGL_line_cmap[12] = gl_rgbcolor(0x80, 0xff, 0x80); /* light green */
+	    VGAGL_line_cmap[13] = gl_rgbcolor(0x80, 0xff, 0xff); /* light cyan */
+	    VGAGL_line_cmap[14] = gl_rgbcolor(0x80, 0x80, 0xff); /* light blue */
+	    break;
+	default:
+#endif
+	    VGAGL_setpalettecolor(2, 0.5, 0.5, 0.5); /* gray */
+	    VGAGL_setpalettecolor(3, 0.0, 1.0, 0.0); /* green */
+	    VGAGL_setpalettecolor(4, 0.0, 1.0, 1.0); /* cyan */
+	    VGAGL_setpalettecolor(5, 1.0, 0.0, 0.0); /* red */
+	    VGAGL_setpalettecolor(6, 1.0, 0.0, 1.0); /* magenta */
+	    VGAGL_setpalettecolor(7, 0.0, 0.0, 1.0); /* blue */
+	    VGAGL_setpalettecolor(8, 1.0, 1.0, 0.0); /* yellow */
+	    VGAGL_setpalettecolor(9, 1.0, 0.5, 0.5); /* light red */
+	    VGAGL_setpalettecolor(10, 1.0, 1.0, 1.0); /* white */
+	    VGAGL_setpalettecolor(11, 1.0, 0.5, 1.0); /* light magenta */
+	    VGAGL_setpalettecolor(12, 0.5, 1.0, 0.5); /* light green */
+	    VGAGL_setpalettecolor(13, 0.5, 1.0, 1.0); /* light cyan */
+	    VGAGL_setpalettecolor(14, 0.5, 0.5, 1.0); /* light blue */
+#ifdef VGAGL_ENABLE_TRUECOLOR
+    }
+#endif
+}
+
+TERM_PUBLIC int
+VGAGL_get_mode()
+{
+    int *iptr;
+
+    static int default_modes[] = {
+	0, /* to be filled with the user defined mode */
+	0, /* to be filled with the default mode */
+	G1024x768x256, /* hopefully available on all modern graphics boards */
+	G800x600x256,
+	G640x480x256,
+	G320x200x256,
+	G1280x1024x256,
+#ifdef G1152x864x256
+	G1152x864x256,
+#endif
+#ifdef G1360x768x256
+	G1360x768x256,
+#endif
+#ifdef G1600x1200x256
+	G1600x1200x256,
+#endif
+	TEXT
+    };
+
+    if (VGAGL_graphics_on) {
+	return 1; /* success ??? */
+    }
+
+    /* the user supplied mode will be checked first */
+    default_modes[0] = vgagl_vmode;
+
+    /* get the default mode from SVGALIB_DEFAULT_MODE, if available */
+    default_modes[1] = vga_getdefaultmode();
+
+    for (iptr = default_modes; TEXT != *iptr; iptr++) {
+	if (-1 != *iptr && vga_hasmode(*iptr)) {
+	    vgagl_vmode = *iptr;
+	    break;
+	}
+    }
+
+    if (TEXT == *iptr) {
+	vgagl_vmode = TEXT;
+	int_error(NO_CARET, "vgagl terminal driver not available");
+	return 0;
+    }
+
+    modeinfo = vga_getmodeinfo(vgagl_vmode);
+
+#ifdef VGAGL_ENABLE_TRUECOLOR
+    VGAGL_truecolor = FALSE;
+#endif
+    VGAGL_pm3d_colors = VGAGL_8bit_colors;
+    VGAGL_pm3d_colors_ = VGAGL_pm3d_colors - 1;
+
+    if (modeinfo->colors != 256) {
+	int_error(NO_CARET, "Error: need a 256 color mode but got %d colors\n",
+	    modeinfo->colors);
+	return 0;
+#ifdef VGAGL_ENABLE_TRUECOLOR
+    } else if (modeinfo->colors > 256) {
+	VGAGL_truecolor = TRUE;
+	VGAGL_pm3d_colors = VGAGL_tri_colors;
+	VGAGL_pm3d_colors_ = VGAGL_pm3d_colors - 1;
+#endif
+    }
+    return 1; /* success */
+}
+
+TERM_PUBLIC void
+VGAGL_init()
+{
+    static TBOOLEAN keytable_initialized = FALSE;
+
+    if (!VGAGL_graphics_on) {
+
+	/* initialize keyboard tranlation table, only done once */
+	if (!keytable_initialized) {
+	    VGAGL_init_keytable();
+	    keytable_initialized = TRUE;
+	}
+
+	if (!VGAGL_get_mode()) {
+	    return;
+	}
+
+    }
+    term->xmax = modeinfo->width;
+    term->ymax = modeinfo->height;
+    vgagl_lasty = modeinfo->height - 1;
+    vgagl_lastx = modeinfo->width - 1;
+#if 0
+    gl_setfont(8, 8, gl_font8x8);
+    gl_setwritemode(WRITEMODE_MASKED + FONT_COMPRESSED);
+    fprintf(stderr, "(VGAGL_init) width, height = %d, %d\n", term->xmax, term->ymax);
+#endif
+}
+
+TERM_PUBLIC void
+VGAGL_reset()
+{
+    if (VGAGL_graphics_on && !VGAGL_processing_graphics_events) {
+	keyboard_close();                  /* switch back to cooked mode          */
+	vga_setmousesupport(0);            /* turn off mouse                      */
+	vga_setmode(TEXT);                 /* switch to text mode                 */
+	VGAGL_save_pal.colorFormulae = -1; /* force later reallocation of palette */
+	VGAGL_graphics_on = FALSE;
+    }
+}
+
+/* copy virtual screen to physical screen and process
+   input events until the user leaves the graphics mode */
+TERM_PUBLIC void
+VGAGL_text()
+{
+    if (!VGAGL_cursor_drawn) {
+	VGAGL_draw_cursor(VGAGL_cursorx, VGAGL_cursory); /* actually draws the first time the cursor */
+	VGAGL_cursor_drawn = TRUE;
+	if (VGAGL_ruler_x >= 0) {
+	    VGAGL_set_ruler(VGAGL_ruler_x, VGAGL_ruler_y);
+	}
+    }
+
+    gl_copyscreen(&physicalscreen);
+
+    /* this is dirty but should work. The purpose is to force
+     * gnuplot to call VGAGL_graphics() before redrawing. */
+    term_graphics = FALSE;
+
+    if (!VGAGL_graphics_on || VGAGL_processing_graphics_events) {
+	return;
+    }
+
+    /* go to the input event loop */
+    VGAGL_eventually_process_graphics_events();
+
+    /* switch to TEXT mode */
+    VGAGL_reset();
+}
+
+TERM_PUBLIC void
+VGAGL_graphics()
+{
+    if (!VGAGL_graphics_on) {
+	vga_setmousesupport(1);
+	if (gl_setcontextvgavirtual(vgagl_vmode)) {
+	    fprintf(stderr, "(VGAGL_graphics) unable to set virtual context\n");
+	}
+	gl_getcontext(&backscreen);
+	vga_setmode(vgagl_vmode);
+	gl_setcontextvga(vgagl_vmode); /* Physical screen context. */
+	gl_getcontext(&physicalscreen);
+	gl_setcontext(&backscreen);
+	gl_clearscreen(0); /* clear backscreen; we'll draw there */
+	gl_enableclipping();
+	VGAGL_set_line_colors();
+
+	/* center the cursor on startup */
+	VGAGL_cursorx = WIDTH / 2;
+	VGAGL_cursory = HEIGHT / 2;
+
+	VGAGL_graphics_on = TRUE;
+    } else {
+	/* graphics is already on; clear previous plot */
+	gl_clearscreen(0);
+    }
+    supply_extended_color_specs = 1;
+    VGAGL_cursor_drawn = FALSE;
+    VGAGL_savedstr[0] = '\0';
+#if 0
+    {
+	int avail = vga_ext_set(VGA_EXT_AVAILABLE, VGA_AVAIL_ACCEL);
+	fprintf(stderr, "ACCELFLAG_FILLBOX %s\n", (avail & ACCELFLAG_FILLBOX) ? "yes" : "no");
+	fprintf(stderr, "ACCELFLAG_SCREENCOPY %s\n", (avail & ACCELFLAG_SCREENCOPY) ? "yes" : "no");
+	fprintf(stderr, "ACCELFLAG_PUTIMAGE %s\n", (avail & ACCELFLAG_PUTIMAGE) ? "yes" : "no");
+	fprintf(stderr, "ACCELFLAG_DRAWLINE %s\n", (avail & ACCELFLAG_DRAWLINE) ? "yes" : "no");
+	fprintf(stderr, "ACCELFLAG_SETFGCOLOR %s\n", (avail & ACCELFLAG_SETFGCOLOR) ? "yes" : "no");
+	fprintf(stderr, "ACCELFLAG_SETBGCOLOR %s\n", (avail & ACCELFLAG_SETBGCOLOR) ? "yes" : "no");
+	fprintf(stderr, "ACCELFLAG_SETTRANSPARENCY %s\n", (avail & ACCELFLAG_SETTRANSPARENCY) ? "yes" : "no");
+	fprintf(stderr, "ACCELFLAG_SETRASTEROP %s\n", (avail & ACCELFLAG_SETRASTEROP) ? "yes" : "no");
+	fprintf(stderr, "ACCELFLAG_PUTBITMAP %s\n", (avail & ACCELFLAG_PUTBITMAP) ? "yes" : "no");
+	fprintf(stderr, "ACCELFLAG_SCREENCOPYBITMAP %s\n", (avail & ACCELFLAG_SCREENCOPYBITMAP) ? "yes" : "no");
+	fprintf(stderr, "ACCELFLAG_DRAWHLINELIST %s\n", (avail & ACCELFLAG_DRAWHLINELIST) ? "yes" : "no");
+	fprintf(stderr, "ACCELFLAG_SETMODE %s\n", (avail & ACCELFLAG_SETMODE) ? "yes" : "no");
+	fprintf(stderr, "ACCELFLAG_SYNC %s\n", (avail & ACCELFLAG_SYNC) ? "yes" : "no");
+    }
+#endif
+}
+
+TERM_PUBLIC void
+VGAGL_suspend()
+{
+#if 1
+    VGA_FPRINTF((stderr, "(VGAGL_suspend) \n"));
+    keyboard_close();                  /* switch back to cooked mode          */
+    vga_setmousesupport(0);            /* turn off mouse                      */
+    vga_flip();
+#endif
+}
+
+TERM_PUBLIC void
+VGAGL_resume()
+{
+#if 1
+    VGA_FPRINTF((stderr, "(VGAGL_resume) \n"));
+    vga_flip();
+    keyboard_init();                  /* put keyboard to raw mode */
+    vga_setmousesupport(1);           /* turn mouse on            */
+#endif
+}
+
+TERM_PUBLIC void
+VGAGL_linetype(int linetype)
+{
+    if (linetype < -3)
+	linetype = LT_NODRAW;
+
+#ifdef VGAGL_ENABLE_TRUECOLOR
+    switch (VGAGL_truecolor) {
+	case TRUE:
+	    current_color = VGAGL_line_cmap[(linetype + 3) % 13];
+	    break;
+	default:
+#endif
+	    current_color = (linetype + 3) % 13;
+#ifdef VGAGL_ENABLE_TRUECOLOR
+    }
+#endif
+}
+
+TERM_PUBLIC void
+VGAGL_move(unsigned int x, unsigned int y)
+{
+    VGAGL_startx = x;
+    VGAGL_starty = Y(y);
+}
+
+TERM_PUBLIC void
+VGAGL_vector(unsigned int x, unsigned int y)
+{
+    /* fprintf(stderr, "(VGAGL_vector) x, y = %d %d\n", x, y); */
+    int sy = Y(y);
+    gl_line(VGAGL_startx, VGAGL_starty, x, sy, current_color);
+    VGAGL_startx = x;
+    VGAGL_starty = sy;
+}
+
+TERM_PUBLIC int
+VGAGL_text_angle(int ang)
+{
+    VGAGL_angle = (ang ? 1 : 0);
+    return TRUE;
+}
+
+/* driver's coordinate system */
+void
+VGAGL_xor_pixel_wrapper(int x, int y, int color)
+{
+    /* discard color */
+    VGAGL_xor_pixel(x, y);
+}
+
+/* driver's coordinate system */
+static void
+VGAGL_putc(unsigned int x, unsigned int y, int c, int ang, int color)
+{
+    int i, j, k;
+    void (*pixelfun)(int, int, int);
+
+    i = (int) (c) - 32;
+
+    switch (color) {
+	case -1:
+	    pixelfun = VGAGL_xor_pixel_wrapper;
+	    break;
+	default:
+	    pixelfun = gl_setpixel;
+    }
+
+    switch (ang) {
+	case 0: /* horizontal */
+	    for (x++, j = 0; j < FNT5X9_VBITS; j++, y--) {
+		for (k = 0; k < FNT5X9_HBITS; k++) {
+		    if ((((unsigned int) (fnt5x9[i][j])) >> k & 1)) {
+			pixelfun(x + k, y, current_color);
+		    }
+		}
+	    }
+	    break;
+	case 1: /* vertical */
+	    for (y--, j = 0; j < FNT5X9_VBITS; j++, x--) {
+		for (k = 0; k < FNT5X9_HBITS; k++) {
+		    if ((((unsigned int) (fnt5x9[i][j])) >> k & 1)) {
+			pixelfun(x, y - k, current_color);
+		    }
+		}
+	    }
+	    break;
+	default:
+	    fprintf(stderr, "(VGAGL_putc) angle %d not implemented\n",
+		VGAGL_angle);
+    }
+}
+
+/* driver's coordinate system */
+TERM_PUBLIC void
+VGAGL_put_text_with_color(
+    unsigned int x, unsigned int y,
+    const char *str,
+    int color)
+{
+    const char* ptr;
+
+    switch (VGAGL_angle) {
+	case 0:
+	    y += VGAGL_VCHAR / 2;
+	    break;
+	case 1:
+	    x += VGAGL_VCHAR / 2;
+	    break;
+    }
+
+    for (ptr = str; *ptr; ptr++) {
+	VGAGL_putc(x, y, *ptr, VGAGL_angle, color);
+	switch (VGAGL_angle) {
+	    case 0:
+		x += VGAGL_HCHAR;
+		break;
+	    case 1:
+		y -= VGAGL_HCHAR;
+		break;
+	    default:
+		fprintf(stderr, "(VGAGL_put_text) angle %d not implemented\n",
+		    VGAGL_angle);
+	}
+    }
+    VGAGL_need_update = TRUE;
+}
+
+/* gnuplot's coordinate system */
+TERM_PUBLIC void
+VGAGL_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    VGAGL_put_text_with_color(x, Y(y), str, current_color);
+}
+
+void
+VGAGL_xor_pixel(int x, int y)
+{
+    int r, g, b;
+    gl_getpixelrgb(x, y, &r, &g, &b);
+    r ^= VGAGL_xor_red;
+    g ^= VGAGL_xor_green;
+    b ^= VGAGL_xor_blue;
+#if 0
+    fprintf(stderr, " xor: %3d %3d %3d\n", r, g, b);
+#endif
+    gl_setpixelrgb(x, y, r, g, b);
+}
+void
+VGAGL_hline_xor(int x1, int x2, int y)
+{
+    int i;
+    if (x1 > x2) {
+	int tmp = x1;
+	x1 = x2;
+	x2 = tmp;
+    }
+    for (i = x1; i <= x2; i++) {
+	VGAGL_xor_pixel(i, y);
+    }
+}
+void
+VGAGL_vline_xor(int y1, int y2, int x)
+{
+    if (y1 > y2) {
+	/* swap */
+	int tmp = y1;
+	y1 = y2;
+	y2 = tmp;
+    }
+    if (-1 == vga_accel(ACCEL_SETRASTEROP, ROP_XOR)) {
+	/* vga_accel(ACCEL_SETRASTEROP, ROP_XOR) is not available */
+	int i;
+	for (i = y1; i <= y2; i++) {
+	    VGAGL_xor_pixel(x, i);
+	}
+    } else {
+	fprintf(stderr, "(VGAGL_vline_xor) accelerated xor was never tested\n");
+	gl_line(x, y1, x, y2, 1);
+	vga_accel(ACCEL_SETRASTEROP, ROP_COPY); /* switching back */
+    }
+}
+
+#if 0
+void
+VGAGL_line_xor(unsigned int x1, unsigned int y1, unsigned int x2, unsigned int y2)
+{
+    if (x1 == x2) {
+	VGAGL_vline_xor(y1, y2, x1);
+    } else if (y1 == y2) {
+	VGAGL_hline_xor(x1, x2, y1);
+    } else {
+	fprintf(stderr, "(VGAGL_line_xor) vertical lines not implemented\n");
+    }
+}
+#endif
+
+TERM_PUBLIC void
+VGAGL_draw_cursor(int x, int y)
+{
+    static const int cursorsize = 5;
+    VGAGL_hline_xor(x - cursorsize, x + cursorsize, y);
+    VGAGL_vline_xor(y - cursorsize, y + cursorsize, x);
+    VGAGL_last_cursorx = x;
+    VGAGL_last_cursory = y;
+}
+
+void
+VGAGL_zoombox(int x, int y)
+{
+    VGAGL_hline_xor(VGAGL_zoom.startx, x, VGAGL_zoom.starty);
+    VGAGL_hline_xor(VGAGL_zoom.startx, x, y);
+    VGAGL_vline_xor(VGAGL_zoom.starty, y, VGAGL_zoom.startx);
+    VGAGL_vline_xor(VGAGL_zoom.starty, y, x);
+
+    if (*VGAGL_zoom.current_xstr && *VGAGL_zoom.current_ystr) {
+
+	int ty;
+
+	/* first corner (static) */
+	ty = VGAGL_zoom.starty - VGAGL_VCHAR / 2;
+	VGAGL_put_text_with_color(VGAGL_zoom.startx, ty, VGAGL_zoom.current_xstr[0], -1);
+	VGAGL_put_text_with_color(VGAGL_zoom.startx, ty + VGAGL_VCHAR, VGAGL_zoom.current_ystr[0], -1);
+
+	/* second corner (at the curser) */
+	ty = y - VGAGL_VCHAR / 2;
+	VGAGL_put_text_with_color(x, ty, VGAGL_zoom.current_xstr[1], -1);
+	VGAGL_put_text_with_color(x, ty + VGAGL_VCHAR, VGAGL_zoom.current_ystr[1], -1);
+    }
+
+    VGAGL_zoom.currentx = x;
+    VGAGL_zoom.currenty = y;
+}
+
+void
+VGAGL_update_zoombox(int x, int y)
+{
+    if (VGAGL_zoom.startx >= 0) {
+	VGAGL_zoombox(VGAGL_zoom.currentx, VGAGL_zoom.currenty); /* erase old box */
+	strcpy(VGAGL_zoom.current_xstr[0], VGAGL_zoom.xstr[0]);
+	strcpy(VGAGL_zoom.current_ystr[0], VGAGL_zoom.ystr[0]);
+	strcpy(VGAGL_zoom.current_xstr[1], VGAGL_zoom.xstr[1]);
+	strcpy(VGAGL_zoom.current_ystr[1], VGAGL_zoom.ystr[1]);
+	VGAGL_zoombox(x, y); /* draw new box */
+	VGAGL_need_update = TRUE;
+    }
+}
+
+void
+VGAGL_update_cursor(int x, int y)
+{
+    VGAGL_draw_cursor(VGAGL_last_cursorx, VGAGL_last_cursory); /* erase old cursor */
+    VGAGL_draw_cursor(x, y); /* draw new cursor */
+    VGAGL_need_update = TRUE;
+}
+
+void
+VGAGL_signal_handler(int signum)
+{
+    struct gp_event_t ge = {-1, -1, -1, -1, -1, ""};
+    ge.type = GE_modifier;
+    ge.par1 = 0; /* release all modifiers */
+    do_event(&ge);
+    VGAGL_processing_graphics_events = FALSE;
+    signal(SIGINT, VGAGL_old_handler); /* reset signal handler */
+    VGAGL_reset();
+}
+
+void
+VGAGL_eventually_process_graphics_events()
+{
+    /*
+       VGA_FPRINTF((stderr, "(VGAGL_eventually_process_graphics_events) \n"));
+     */
+    if (VGAGL_graphics_on && !VGAGL_processing_graphics_events) {
+
+	int lastbutton = 0;
+	struct gp_event_t ge = {-1, -1, -1, -1, -1, ""};
+	TBOOLEAN loop = TRUE;
+	int yinv;
+
+	VGAGL_processing_graphics_events = TRUE;
+
+	/* set up a signal hander, so that SIGINT
+	 * can restore a clean terminal state */
+	VGAGL_old_handler = signal(SIGINT, VGAGL_signal_handler);
+
+	keyboard_init(); /* put keyboard to raw mode */
+
+	/* put the mouse pointer to the center */
+	mouse_setposition(VGAGL_cursorx, VGAGL_cursory);
+
+	while (VGAGL_graphics_on && loop) {
+
+	    int button;
+	    int motion;
+	    int ret;
+
+	    event_plotdone();
+	    if (VGAGL_need_update) {
+		gl_copyscreen(&physicalscreen);
+		VGAGL_need_update = FALSE;
+	    }
+
+	    ret = vga_waitevent(VGA_MOUSEEVENT | VGA_KEYEVENT,
+		(fd_set*) 0, (fd_set*) 0, (fd_set*) 0, (struct timeval*) 0);
+
+	    VGAGL_cursorx = mouse_getx();
+	    VGAGL_cursory = mouse_gety();
+	    yinv = term->ymax - VGAGL_cursory;
+	    button = mouse_getbutton();
+	    motion = (-1 != ge.mx && (VGAGL_cursorx != ge.mx || yinv != ge.my));
+	    ge.mx = VGAGL_cursorx;
+	    ge.my = yinv;
+
+	    if (ret < 0) {
+		/* error */
+		loop = FALSE;
+	    }
+	    if ((ret & VGA_MOUSEEVENT)) {
+
+		if (button != lastbutton) {
+		    /* button changed (either pressed or released */
+		    int button_changed;
+		    if (button) {
+			/* button press event */
+			ge.type = GE_buttonpress;
+			button_changed = button;
+		    } else {
+			/* button release event */
+			button_changed = lastbutton;
+			ge.type = GE_buttonrelease;
+		    }
+		    if (button_changed & MOUSE_LEFTBUTTON)
+			ge.par1 = 1;
+		    else if (button_changed & MOUSE_MIDDLEBUTTON)
+			ge.par1 = 2;
+		    else if (button_changed & MOUSE_RIGHTBUTTON)
+			ge.par1 = 3;
+
+		    do_event(&ge);
+		    lastbutton = button;
+		}
+
+		if (motion) {
+		    /* fprintf(stderr, "(motion) VGAGL_cursorx, VGAGL_cursory = %d %d\n", VGAGL_cursorx, VGAGL_cursory); */
+		    ge.type = GE_motion;
+		    do_event(&ge);
+		    VGAGL_update_cursor(VGAGL_cursorx, VGAGL_cursory);
+		    VGAGL_update_zoombox(VGAGL_cursorx, VGAGL_cursory);
+		}
+	    }
+	    if (ret & VGA_KEYEVENT) {
+		/* int c = vga_getch(); */
+		char* state = keyboard_getstate();
+		int mask = 0;
+		int i;
+		/* keyboard_translatekeys() */
+		if (state[SCANCODE_LEFTCONTROL] || state[SCANCODE_RIGHTCONTROL]) {
+		    mask |= Mod_Ctrl;
+		}
+		if (state[SCANCODE_LEFTALT] || state[SCANCODE_RIGHTALT]) {
+		    mask |= Mod_Alt;
+		}
+		if (state[SCANCODE_LEFTSHIFT] || state[SCANCODE_RIGHTSHIFT]) {
+		    mask |= Mod_Shift;
+		}
+		if (mask) {
+		    ge.type = GE_modifier;
+		    ge.par1 = mask;
+		    do_event(&ge);
+		} else if (VGAGL_modifier_mask) {
+		    /* modifiers were released */
+		    ge.type = GE_modifier;
+		    ge.par1 = 0;
+		    do_event(&ge);
+		}
+		VGAGL_modifier_mask = mask;
+
+		for (i = 0; i < KEYTABLE_SIZE; i++) {
+		    if (state[i] && -1 != VGAGL_Keytable[i]) {
+			if (' ' == VGAGL_Keytable[i] || 'q' == VGAGL_Keytable[i]) {
+			    loop = FALSE;
+			    break;
+			}
+#ifdef VGAGL_DEBUGGING
+			if (GP_KP_Delete == VGAGL_Keytable[i] && VGAGL_dump_file) {
+			    VGAGL_draw_cursor(VGAGL_last_cursorx, VGAGL_last_cursory); /* erase cursor */
+			    VGAGL_write_dump_file();
+			    VGAGL_draw_cursor(VGAGL_last_cursorx, VGAGL_last_cursory); /* draw cursor */
+			    break;
+			}
+#endif
+			ge.type = GE_keypress;
+			ge.par1 = VGAGL_Keytable[i];
+			ge.par2 = 0;
+			do_event(&ge);
+		    }
+		}
+	    } /* VGA_KEYEVENT */
+	} /* while(1) */
+	VGAGL_processing_graphics_events = FALSE;
+	signal(SIGINT, VGAGL_old_handler);
+    } /* VGAGL_graphics_on */
+}
+
+TERM_PUBLIC void
+VGAGL_put_tmptext(int i, const char str[])
+{
+    int y = 0;
+    int x;
+    char* second;
+
+    switch (i) {
+	case 0:
+	    /* erase old text */
+	    for (i = 0, y = 0, x = VGAGL_HCHAR; VGAGL_savedstr[i]; i++) {
+		VGAGL_putc(x, Y(y), VGAGL_savedstr[i], 0, -1);
+		x += VGAGL_HCHAR;
+	    }
+	    strcpy(VGAGL_savedstr, str);
+	    for (i = 0, y = 0, x = VGAGL_HCHAR; str[i]; i++) {
+		VGAGL_putc(x, Y(y), str[i], 0, -1);
+		x += VGAGL_HCHAR;
+	    }
+	    VGAGL_need_update = TRUE;
+	    break;
+	case 1:
+	case 2:
+	    --i;
+	    second = (char*) strchr(str, '\r');
+	    if (second == NULL) {
+		VGAGL_zoom.xstr[i][0] = '\0';
+		VGAGL_zoom.ystr[i][0] = '\0';
+		break;
+	    }
+	    *second = '\0'; /* XXX this assumes that str is writable XXX */
+	    second++;
+	    /* if (VGAGL_zoombox_on) DrawBox(plot); */
+	    strcpy(VGAGL_zoom.xstr[i], str);
+	    strcpy(VGAGL_zoom.ystr[i], second);
+	    /* if (plot->zoombox_on) DrawBox(plot); */
+	    VGAGL_need_update = TRUE;
+	    break;
+    }
+    return;
+}
+
+TERM_PUBLIC void
+VGAGL_set_ruler(int x, int y)
+{
+    if (x < 0) {
+	/* erase last ruler */
+	VGAGL_hline_xor(0, vgagl_lastx, Y(VGAGL_ruler_y));
+	VGAGL_vline_xor(0, vgagl_lasty, VGAGL_ruler_x);
+	VGAGL_ruler_x = -1;
+    } else {
+	VGAGL_ruler_x = x;
+	VGAGL_ruler_y = y;
+	VGAGL_hline_xor(0, vgagl_lastx, Y(VGAGL_ruler_y));
+	VGAGL_vline_xor(0, vgagl_lasty, VGAGL_ruler_x);
+    }
+    VGAGL_need_update = TRUE;
+    return;
+}
+
+TERM_PUBLIC void
+VGAGL_set_cursor(int c, int x, int y)
+{
+    /* VGA_FPRINTF((stderr, "(VGAGL_set_cursor) \n")); */
+    switch (c) {
+	case -2: /* warp pointer */
+	    /* TODO */
+	    break;
+	case -1: /* starting zoombox */
+	    VGAGL_zoom.startx = x;
+	    VGAGL_zoom.starty = Y(y);
+
+	    VGAGL_zoom.currentx = VGAGL_zoom.startx;
+	    VGAGL_zoom.currenty = VGAGL_zoom.starty;
+
+	    VGAGL_zoombox(VGAGL_zoom.currentx, VGAGL_zoom.currenty);
+
+	    break;
+	case 0:  /* standard cross-hair cursor */
+	    if (VGAGL_zoom.startx >= 0) {
+		VGAGL_zoombox(VGAGL_zoom.currentx, VGAGL_zoom.currenty);
+		VGAGL_zoom.startx = -1; /* turn zoom box off */
+	    }
+	    break;
+	case 1:  /* cursor during rotation */
+	    /* TODO */
+	    break;
+	case 2:  /* cursor during scaling */
+	    /* TODO */
+	    break;
+	case 3:  /* cursor during zooming */
+	    /* TODO */
+	    break;
+	default:
+	    fprintf(stderr, "(VGAGL_set_cursor) %s:%d protocol error\n", __FILE__, __LINE__);
+	    break;
+    }
+    return;
+}
+
+TERM_PUBLIC void
+VGAGL_set_clipboard(const char s[])
+{
+    (void) s;			/* avoid -Wunused */
+    return;			/* does nothing. */
+}
+
+TERM_PUBLIC int
+VGAGL_make_palette(t_sm_palette *palette)
+{
+    /* only reallocate colors, if the color spec has changed */
+    if (palette && (VGAGL_save_pal.colorFormulae < 0
+	    || palette->colorFormulae != VGAGL_save_pal.colorFormulae
+	    || palette->colorMode != VGAGL_save_pal.colorMode
+	    || palette->formulaR != VGAGL_save_pal.formulaR
+	    || palette->formulaG != VGAGL_save_pal.formulaG
+	    || palette->formulaB != VGAGL_save_pal.formulaB
+	    || palette->positive != VGAGL_save_pal.positive)) {
+	int i, j;
+#ifdef VGAGL_ENABLE_TRUECOLOR
+	switch (VGAGL_truecolor) {
+	    case TRUE:
+		for (i = 0; i <= VGAGL_tri_colors; i++) {
+		    VGAGL_cmap[i] = gl_rgbcolor
+			((int)floor(palette->color[i].r * 255.999),
+			 (int)floor(palette->color[i].g * 255.999),
+			 (int)floor(palette->color[i].b * 255.999));
+		    gl_trisetcolorlookup(i, VGAGL_cmap[i]);
+		}
+		break;
+	    default:
+#endif
+		for (j = 0, i = pm3d_color_offset; i <= 0xff; i++, j++) {
+		    VGAGL_setpalettecolor(i, palette->color[j].r,
+			palette->color[j].g, palette->color[j].b);
+		}
+#ifdef VGAGL_ENABLE_TRUECOLOR
+	}
+#endif
+	VGAGL_save_pal = *palette;
+	return 0;
+    } else {
+	return VGAGL_pm3d_colors;
+    }
+}
+
+/* set color for subsequent VGAGL_filled_polygon() calls. */
+TERM_PUBLIC void
+VGAGL_set_color(t_colorspec *colorspec)
+{
+    int color;
+    double gray = colorspec->value;
+
+    if (colorspec->type != TC_FRAC)
+	return;
+
+    /* Note that the gray value is supplied for each vertex.
+     * This is only for routines which don't draw interpolated
+     * triangles. These routines should supply a negative
+     * valued as corners[0].spec.gray, if they really want
+     * this color to be taken. */
+    color = (gray <= 0) ? 0 : (int)(gray * VGAGL_pm3d_colors);
+    if (color >= VGAGL_pm3d_colors)
+	color = VGAGL_pm3d_colors_;
+    current_color = pm3d_color_offset + color;
+    VGAGL_gray = gray;
+}
+
+TERM_PUBLIC void
+VGAGL_filled_polygon(int points, gpiPoint *corners)
+{
+    int i;
+    int y[4];
+    if (4 != points) {
+	fprintf(stderr, "(VGAGL_filled_polygon) can only plot with 4 points\n");
+	return;
+    }
+    if (!VGAGL_interpolate || corners[0].spec.gray < 0) {
+	/* draw a solid colored triangle */
+	int color;
+	double gray = 0;
+#if 0
+	fprintf(stderr, "(VGAGL_filled_polygon) gray = %f\n",
+	    corners[0].spec.gray);
+#endif
+	if (corners[0].spec.gray < 0) {
+	    for (i = 0; i < 4; i++) {
+		y[i] = Y(corners[i].y);
+	    }
+	    gray = VGAGL_gray;
+	} else {
+	    for (i = 0; i < 4; i++) {
+		y[i] = Y(corners[i].y);
+		gray += corners[0].spec.gray;
+	    }
+	    gray *= 0.25;
+	}
+#ifdef VGAGL_ENABLE_TRUECOLOR
+	switch (VGAGL_truecolor) {
+	    case TRUE:
+		/* TODO: this does not work */
+		color = VGAGL_line_cmap[(int)(gray * VGAGL_pm3d_colors_)];
+		break;
+	    default:
+#endif
+		color = pm3d_color_offset + (int)(gray * VGAGL_pm3d_colors_);
+#ifdef VGAGL_ENABLE_TRUECOLOR
+	}
+#endif
+	gl_striangle(corners[0].x, y[0], corners[1].x, y[1],
+	    corners[2].x, y[2], color, -1);
+	gl_striangle(corners[2].x, y[2], corners[3].x, y[3],
+	    corners[0].x, y[0], color, -1);
+    } else {
+	/* draw color interpolated triangle */
+	int color[4];
+#ifdef VGAGL_ENABLE_TRUECOLOR
+	switch (VGAGL_truecolor) {
+	    case TRUE:
+		for (i = 0; i < 4; i++) {
+		    y[i] = Y(corners[i].y);
+		    color[i] = (int)(corners[i].spec.gray * VGAGL_pm3d_colors_);
+		}
+		break;
+	    default:
+#endif
+		for (i = 0; i < 4; i++) {
+		    y[i] = Y(corners[i].y);
+		    color[i] = pm3d_color_offset + (int)(corners[i].spec.gray * VGAGL_pm3d_colors_);
+		}
+#ifdef VGAGL_ENABLE_TRUECOLOR
+	}
+#endif
+	gl_triangle
+	    (corners[0].x, y[0], color[0],
+	     corners[1].x, y[1], color[1],
+	     corners[2].x, y[2], color[2], -1);
+	gl_triangle
+	    (corners[2].x, y[2], color[2],
+	     corners[3].x, y[3], color[3],
+	     corners[0].x, y[0], color[0], -1);
+    }
+}
+#ifdef VGAGL_DEBUGGING
+void
+VGAGL_write_dump_file()
+{
+    FILE* fp;
+    unsigned char* buf;
+    unsigned char* bufptr;
+    int x, y, index;
+    char thisfile[0xff];
+    static int thisfileno = 0;
+    if (!VGAGL_dump_file) {
+	return;
+    }
+    sprintf(thisfile, "%s%05d.ppm", VGAGL_dump_file, thisfileno++);
+    fp = fopen(thisfile, "w");
+    if (!fp) {
+	free(VGAGL_dump_file);
+	VGAGL_dump_file = 0;
+    }
+    fprintf(fp, "P6\n");
+    fprintf(fp, "%d %d\n", modeinfo->width, modeinfo->height);
+    fprintf(fp, "255\n");
+    buf = gp_alloc(modeinfo->width * modeinfo->height * 3, "vgagl->buf");
+    bufptr = buf;
+    for (y = 0; y < modeinfo->height; y++) {
+	for (x = 0; x < modeinfo->width; x++) {
+	    index = gl_getpixel(x, y);
+	    while (index < 0) {
+		/* this is a kludge, as gl_getpixel() seems to
+		 * return pixels > 128 as the negative complement */
+		index += 256;
+	    }
+	    *bufptr++ = VGAGL_palette[index][0];
+	    *bufptr++ = VGAGL_palette[index][1];
+	    *bufptr++ = VGAGL_palette[index][2];
+	}
+    }
+    fwrite(buf, 3, modeinfo->width * modeinfo->height, fp);
+    fclose(fp);
+}
+#endif
+
+#undef Y
+
+#endif
+
+#ifdef TERM_TABLE
+TERM_TABLE_START(vgagl_driver)
+    "vgagl", "vgagl driver with mouse support and smooth colors",
+    VGAGL_XMAX, VGAGL_YMAX, VGAGL_VCHAR, VGAGL_HCHAR,
+    VGAGL_VTIC, VGAGL_HTIC, VGAGL_options, VGAGL_init, VGAGL_reset,
+    VGAGL_text, null_scale, VGAGL_graphics, VGAGL_move, VGAGL_vector,
+    VGAGL_linetype, VGAGL_put_text, VGAGL_text_angle,
+    null_justify_text, do_point, do_arrow, set_font_null,
+    0,				/* pointsize */
+    TERM_CAN_MULTIPLOT, VGAGL_suspend, VGAGL_resume
+    , 0, 0 /* fillbox, linewidth */
+# ifdef USE_MOUSE
+    , 0 /* VGAGL_waitforinput */, VGAGL_put_tmptext, VGAGL_set_ruler,
+    VGAGL_set_cursor, VGAGL_set_clipboard
+# endif
+    , VGAGL_make_palette,
+    0 /* VGAGL_previous_palette */,
+    VGAGL_set_color,
+    VGAGL_filled_polygon
+TERM_TABLE_END(vgagl_driver)
+#undef LAST_TERM
+#define LAST_TERM vgagl_driver
+#endif
+
+#ifdef TERM_HELP
+START_HELP(vgagl)
+"1 vgagl",
+"?commands set terminal vgagl",
+"?set terminal vgagl",
+"?set term vgagl",
+"?terminal vgagl",
+"?term vgagl",
+"?vgagl",
+" The `vgagl` driver is a fast linux console driver with full mouse and pm3d",
+" support.  It looks at the environment variable SVGALIB_DEFAULT_MODE for the",
+" default mode; if not set, it uses a 256 color mode with the highest",
+" available resolution.",
+"",
+" Syntax:",
+"    set terminal vgagl \\",
+"                 background [red] [[green] [blue]] \\",
+"                 [uniform | interpolate] \\",
+#if 0
+"                 [dump \"file\"] \\",
+#endif
+"                 [mode]",
+"",
+" The color mode can also be given with the mode option. Both Symbolic",
+" names as G1024x768x256 and integers are allowed. The `background` option",
+" takes either one or three integers in the range [0, 255]. If only one",
+" integers is supplied, it is taken as gray value for the background.",
+" If three integers are present, the background gets the corresponding",
+" color.",
+" The (mutually exclusive) options `interpolate` and `uniform` control",
+" if color interpolation is done while drawing triangles (on by default).",
+#if 0
+"",
+" A `screen dump file` can be specified with the `dump \"file\"` option.",
+" If this option is present, (i.e the dump file name is not empty) pressing",
+" the key KP_Delete will write the file.  This action cannot and cannot be",
+" rebound. The file is written in raw ppm (P6) format. Note that this option",
+" is reset each time the `set term` command is issued.",
+#endif
+"",
+" To get high resolution modes, you will probably have to modify the",
+" configuration file of libvga, usually /etc/vga/libvga.conf.  Using",
+" the VESA fb is a good choice, but this needs to be compiled in the",
+" kernel.",
+"",
+" The vgagl driver uses the first *available* vga mode from the following list:",
+"  - the driver which was supplied when setting vgagl, e.g. `set term vgagl",
+"    G1024x768x256` would first check, if the G1024x768x256 mode is available.",
+"  - the environment variable SVGALIB_DEFAULT_MODE",
+"  - G1024x768x256",
+"  - G800x600x256",
+"  - G640x480x256",
+"  - G320x200x256",
+"  - G1280x1024x256",
+"  - G1152x864x256",
+"  - G1360x768x256",
+"  - G1600x1200x256",
+""
+END_HELP(vgagl)
+#endif
+#endif /* defined(USE_MOUSE) */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/vws.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/vws.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/vws.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/vws.trm.svn-base	2012-01-03 17:07:47.646538700 -0800
@@ -0,0 +1,491 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: vws.trm,v 1.19 2007/10/16 21:19:45 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - vws.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * AUTHORS
+ *   Walter Speth
+ *           BITNET: SPETH@DBNPIB5
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+/*
+ * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
+ * adapted to VAX VMS 4.7, VAX C 2.4 and activated the INTENSITY and COLOR
+ * monitor features (Lucas P. Hart, June 1997)
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(vws)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void VWS_init __PROTO((void));
+TERM_PUBLIC void VWS_reset __PROTO((void));
+TERM_PUBLIC void VWS_graphics __PROTO((void));
+TERM_PUBLIC void VWS_text __PROTO((void));
+TERM_PUBLIC void VWS_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void VWS_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void VWS_linetype __PROTO((int lt));
+TERM_PUBLIC void VWS_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC int VWS_text_angle __PROTO((int ang));
+TERM_PUBLIC int VWS_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC void VWS_point __PROTO((unsigned int x, unsigned int y, int point));
+TERM_PUBLIC void VWS_arrow __PROTO((unsigned int sx, unsigned int sy,
+				    unsigned int ex, unsigned int ey, int head));
+
+#define VWS_XMAX 1024
+#define VWS_YMAX 780		/* VAXstation 2000 is 864 */
+#define VWS_VCHAR 25
+#define VWS_HCHAR 15
+#define VWS_VTIC 10
+#define VWS_HTIC 10
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+void VWS_resize_ast __PROTO((void));
+
+#include <ssdef.h>
+/* */
+#include <descrip.h>
+
+#include <uisentry.h>
+#include <uisusrdef.h>
+
+#define DEFAULT_ATTR 0
+#define OVER_ATTR 1
+#define ERAS_ATTR 2
+#define BIS_ATTR 3
+#define COLOR_ATTR 4
+#define TEXT_ATTR 5
+#define LINE_ATTR 6
+#define BACK_ATTR 7
+
+float current_x, current_y;
+
+int vd_id, wd_id;
+int vcm_id, ws_type;
+
+static $DESCRIPTOR(ws_devname, "SYS$WORKSTATION");
+static $DESCRIPTOR(vd_title, "gnuplot");
+
+static float x0, y0, xsiz, ysiz, wc_xmin_new, wc_ymin_new, wc_xmax_new, wc_ymax_new, wc_xmin,
+wc_ymin, wc_xmax, wc_ymax, vd_width, vd_height;
+
+void
+VWS_resize_ast()
+{
+    uis$resize_window(&vd_id, &wd_id, &x0, &y0, &xsiz, &ysiz,
+		      &wc_xmin, &wc_ymin, &wc_xmax, &wc_ymax);
+    replotrequest();
+}
+
+/****************************************************************************/
+TERM_PUBLIC void
+VWS_init()
+{
+    int i;
+    int cattr;
+    $DESCRIPTOR(a_font, "DTABER0003WK00PG0001UZZZZ02A000");
+    const int i0 = 0, i1 = 1, i2 = 2, i3 = 3, i4 = 4, i5 = 5, i6 = 6, i7 = 7, i8 = 8;
+    const float p0 = 0.0, p1 = 0.1, p2 = 0.2, p3 = 0.3, p4 = 0.4;
+    const float p5 = 0.5, p6 = 0.6, p7 = 0.7, p8 = 0.8, p9 = 0.9;
+    const int n1 = 0xFFFFFFFF;
+    const int uis$c_mode_over = UIS$C_MODE_OVER;
+    const int uis$c_mode_eras = UIS$C_MODE_ERAS;
+    const int uis$c_mode_bis = UIS$C_MODE_BIS;
+    const float vws_hchar = (float) VWS_HCHAR;
+    const float vws_vchar = (float) VWS_VCHAR;
+    const int default_attr = DEFAULT_ATTR;
+    const int over_attr = OVER_ATTR;
+    const int eras_attr = ERAS_ATTR;
+    const int bis_attr = BIS_ATTR;
+    const int color_attr = COLOR_ATTR;
+    const int text_attr = TEXT_ATTR;
+    const int line_attr = LINE_ATTR;
+    const int back_attr = BACK_ATTR;
+
+/* lph:  the similar notation may lead to some confusion
+ * attributes are grouped in "attribute block" data structures
+ * which are referenced by block number
+ * attribute block 0 contains default attribute settings
+ *
+ * To customize settings, a function will read the source
+ * attribute block, set the particular attribute, and
+ * write to the destination attribute block.
+ * Both the block number and attribute are integers, so it
+ * is easy to confuse an attribute and an attribute blcok
+ */
+
+/*  lph:  Color map corresponding to an example in
+ *  MicroVMS Graphics Progamming Guide (V3.0) */
+
+    const float r_map[8] = { 0.40, 0.50, 0.50, 0.00, 0.25, 0.90, 0.80, 0.35 };
+    const float g_map[8] = { 0.30, 0.50, 0.25, 0.70, 0.25, 0.50, 0.30, 0.65 };
+    const float b_map[8] = { 0.00, 0.50, 0.50, 0.30, 0.90, 0.00, 0.00, 0.95 };
+
+/* the array format is easier to customize */
+
+    vd_width = 14;
+    vd_height = 10;		/* aspect sqrt(2) as DIN A paper */
+
+    wc_xmin = 0.0;
+    wc_ymin = 0.0;
+    wc_xmax = (float) VWS_XMAX;
+    wc_ymax = (float) VWS_YMAX;
+
+    vcm_id = uis$create_color_map(&i8);
+
+    vd_id = uis$create_display(&wc_xmin, &wc_ymin, &wc_xmax, &wc_ymax,
+			       &vd_width, &vd_height, &vcm_id);
+    uis$get_hw_color_info(&ws_devname, &ws_type);
+
+/* lph: ws's color table for monochrome  */
+/* by default,  color table index 0 is backgound, and 1 is foregound */
+/* a color {index into the color table} is assigned to the active line */
+/* in VWS_linetype */
+
+    if (ws_type == UIS$C_DEV_MONO) {
+	uis$set_color(&vd_id, &i0, &p5, &p5, &p5);
+	uis$set_color(&vd_id, &i1, &p0, &p0, &p0);
+	uis$set_color(&vd_id, &i2, &p0, &p0, &p0);
+	uis$set_color(&vd_id, &i3, &p0, &p0, &p0);
+	uis$set_color(&vd_id, &i4, &p0, &p0, &p0);
+	uis$set_color(&vd_id, &i5, &p0, &p0, &p0);
+	uis$set_color(&vd_id, &i6, &p0, &p0, &p0);
+	uis$set_color(&vd_id, &i7, &p0, &p0, &p0);
+    } else if (ws_type == UIS$C_DEV_INTENSITY) {
+        /* Intensity scale, untested */
+	uis$set_color(&vd_id, &i2, &p2, &p2, &p2);
+	uis$set_color(&vd_id, &i3, &p3, &p3, &p3);
+	uis$set_color(&vd_id, &i4, &p4, &p4, &p4);
+	uis$set_color(&vd_id, &i5, &p5, &p5, &p5);
+	uis$set_color(&vd_id, &i6, &p6, &p6, &p6);
+	uis$set_color(&vd_id, &i7, &p7, &p7, &p7);
+    }
+    /* ws: perhaps better for color terms (which I do not have) */
+
+    else if (ws_type == UIS$C_DEV_COLOR) {
+/* */
+	uis$set_color(&vd_id, &i0, &p0, &p0, &p0);
+	uis$set_color(&vd_id, &i1, &p9, &p0, &p0);
+	uis$set_color(&vd_id, &i2, &p0, &p9, &p0);
+	uis$set_color(&vd_id, &i3, &p9, &p9, &p0);
+	uis$set_color(&vd_id, &i4, &p0, &p0, &p9);
+	uis$set_color(&vd_id, &i5, &p9, &p0, &p9);
+	uis$set_color(&vd_id, &i6, &p0, &p9, &p9);
+	uis$set_color(&vd_id, &i7, &p9, &p9, &p9);
+	/*
+	   * lph: Another way to set up the color table is to use arrays,
+	   * which simplifies customizing the appearance.
+	   *
+	   uis$set_colors(&vd_id, &i0, &i8, &r_map, &g_map, &b_map);
+	 */
+    }
+    uis$disable_display_list(&vd_id);
+
+    wd_id = uis$create_window(&vd_id, &ws_devname, &vd_title,
+			      &wc_xmin, &wc_ymin, &wc_xmax, &wc_ymax,
+			      &vd_width, &vd_height);
+
+    uis$set_resize_ast(&vd_id, &wd_id, &VWS_resize_ast, &i0,
+		       &x0, &y0, &xsiz, &ysiz,
+		       &wc_xmin_new, &wc_ymin_new, &wc_xmax_new, &wc_ymax_new);
+/*
+ * lph: This sets up three different attribute blocks, each having a different
+ * mode, but they are never utilized and it is not clear when they might
+ * be of use.
+ * The attribute blocks used for writing are line_attr, text_attr.
+ *
+  uis$set_writing_mode(&vd_id, &default_attr, &over_attr, &uis$c_mode_over);
+  uis$set_writing_mode(&vd_id, &default_attr, &eras_attr, &uis$c_mode_eras);
+  uis$set_writing_mode(&vd_id, &default_attr, &bis_attr, &uis$c_mode_bis);
+ */
+
+/* lph:  this was commented out;  it changes the COLOR_ATTR BLOCK and
+ * the following BLOCKS
+ *
+if (ws_type >=  UIS$C_DEV_INTENSITY) {
+  for (i=0; i<8; i++) {
+  cattr = COLOR_ATTR+i;
+  uis$set_writing_index(&vd_id, &default_attr, &cattr, &i);
+  }
+  }
+ *
+  */
+
+/* lph: default value for the background index into the virtual color
+ * table is 0, and the back_attr block is never used
+ *
+  uis$set_background_index(&vd_id, &default_attr, &back_attr, &i0);
+ *
+ * the rest look OK, setting up the two attribute blocks
+ */
+    uis$set_writing_mode(&vd_id, &default_attr, &text_attr, &uis$c_mode_over);
+    uis$set_font(&vd_id, &text_attr, &text_attr, &a_font);
+    uis$set_char_size(&vd_id, &text_attr, &text_attr, &i0, &vws_hchar, &vws_vchar);
+    uis$set_line_style(&vd_id, &line_attr, &line_attr, &n1);
+}
+
+/****************************************************************************/
+
+TERM_PUBLIC void
+VWS_reset()
+{
+    uis$delete_display(&vd_id);
+}
+
+/****************************************************************************/
+TERM_PUBLIC void
+VWS_graphics()
+{
+    uis$erase(&vd_id, &wc_xmin, &wc_ymin, &wc_xmax, &wc_ymax);
+}
+
+/****************************************************************************/
+TERM_PUBLIC void
+VWS_text()
+{
+}
+
+/****************************************************************************/
+TERM_PUBLIC void
+VWS_move(unsigned int x, unsigned int y)
+{
+    current_x = (float) (x);
+    current_y = (float) (y);
+}
+
+/****************************************************************************/
+TERM_PUBLIC void
+VWS_vector(unsigned int x, unsigned int y)
+{
+    int col;
+    int line_attr = LINE_ATTR;
+    float fx, fy;
+    fx = (float) x;
+    fy = (float) y;
+
+    uis$line(&vd_id, &line_attr, &current_x, &current_y, &fx, &fy);
+    VWS_move(x, y);
+}
+
+/****************************************************************************/
+TERM_PUBLIC void
+VWS_linetype(int lt)
+{
+    const int n1 = 0xFFFFFFFF;
+    /* indices into the color map */
+    const int i[8] = {0, 1, 2, 3, 4, 5, 6, 7};
+    const float p15 = 2.0, p20 = 3.0, p10 = 1.0;
+    long int lstyle[9] =
+    {0xffffffff,
+     0Xff00ff00,
+     0xffffff00,
+     0xffff0000,
+     0xf0f0f0f0,
+     0Xfff0fff0,
+     0xf000f000,
+     0xa5a5a5af,
+     0xf00f00f0
+    };
+    int line_attr = LINE_ATTR;
+    /* use multiplier of normal line width; default is width in pixels */
+    const int uis$c_width_world = UIS$C_WIDTH_WORLD;
+
+    if (lt < 0) {
+	switch (lt) {
+	case LT_AXIS:		/* used for axis */
+	    uis$set_line_style(&vd_id, &line_attr, &line_attr, &n1);
+	    uis$set_line_width(&vd_id, &line_attr, &line_attr, &p15,
+			       &uis$c_width_world);
+	    if (ws_type >= UIS$C_DEV_INTENSITY) {
+		uis$set_writing_index(&vd_id, &line_attr, &line_attr, &i[1]);
+	    }
+	    break;
+	case LT_BLACK:		/* the borders */
+	    uis$set_line_style(&vd_id, &line_attr, &line_attr, &n1);
+	    uis$set_line_width(&vd_id, &line_attr, &line_attr, &p20,
+			       &uis$c_width_world);
+	    if (ws_type >= UIS$C_DEV_INTENSITY) {
+		uis$set_writing_index(&vd_id, &line_attr, &line_attr, &i[1]);
+	    }
+	    break;
+	default:		/* else a thick line ? */
+	    uis$set_line_style(&vd_id, &line_attr, &line_attr, &n1);
+	    uis$set_line_width(&vd_id, &line_attr, &line_attr, &p20,
+			       &uis$c_width_world);
+	    if (ws_type >= UIS$C_DEV_INTENSITY) {
+		uis$set_writing_index(&vd_id, &line_attr, &line_attr,
+				      &i[1 + ((-lt) % 7)]);
+	    }
+	    break;
+	}
+    } else {
+/* assign the color index (excluding the background index, 0*/
+	if (ws_type >= UIS$C_DEV_INTENSITY) {
+	    uis$set_writing_index(&vd_id, &line_attr, &line_attr, &i[1 + lt % 7]);
+	}
+/* assign the line style
+    uis$set_line_style(&vd_id,&line_attr,&line_attr,&lstyle[lt % 8]);
+ * ws: makes part of curve disappear on my workstation
+ * lph: also observed w/ VS2000 and 4 plane graphics coprocesssor; line
+ * types change appropriately, but has problems as pixels/line segment
+ * decreases.  Better with full screen display and "set samples" smaller
+ * but start out with only solid lines
+  */
+	uis$set_line_style(&vd_id, &line_attr, &line_attr, &n1);
+
+	uis$set_line_width(&vd_id, &line_attr, &line_attr, &p10,
+			   &uis$c_width_world);
+    }
+}
+
+/****************************************************************************/
+static int justify_mode = CENTRE, up;
+
+TERM_PUBLIC void
+VWS_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    float fx, fy, thih, twid;
+    int text_attr = TEXT_ATTR;
+
+    /* uis$text parameter is descriptor string not character string */
+
+    struct dsc$descriptor_s textline =
+    {0, DSC$K_DTYPE_T, DSC$K_CLASS_S, ""};
+
+
+    textline.dsc$a_pointer = str;
+    textline.dsc$w_length = strlen(textline.dsc$a_pointer);
+    uis$measure_text(&vd_id, &text_attr, &textline, &twid, &thih);
+    fx = (float) x;
+    fy = (float) y;
+
+    switch (justify_mode) {
+    case LEFT:
+	fy += thih / 2.;
+	break;
+    case RIGHT:
+	fy += thih / 2.;
+	fx -= twid;
+	break;
+
+    case CENTRE:
+	fy += thih / 2.;
+	fx -= twid / 2;
+	break;
+    };
+
+    uis$text(&vd_id, &text_attr, &textline, &fx, &fy);
+    /* write to Example Viewport window */
+
+
+}
+/****************************************************************************/
+TERM_PUBLIC int
+VWS_text_angle(int ang)
+{
+    float degrees;
+    int text_attr = TEXT_ATTR;
+    up = (ang ? 1 : 0);
+    degrees = 90. * up;
+    uis$set_text_slope(&vd_id, &text_attr, &text_attr, &degrees);
+    return TRUE;
+}
+/****************************************************************************/
+TERM_PUBLIC int
+VWS_justify_text(enum JUSTIFY mode)
+{
+    justify_mode = mode;
+    return TRUE;
+}
+/****************************************************************************/
+TERM_PUBLIC void
+VWS_point(unsigned int x, unsigned int y, int point)
+{
+    do_point(x, y, point);
+}
+
+/****************************************************************************/
+TERM_PUBLIC void
+VWS_arrow(
+    unsigned int sx, unsigned int sy,
+    unsigned int ex, unsigned int ey,
+    int head)
+{
+    do_arrow(sx, sy, ex, ey, head);
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(vws_driver)
+    "VWS", "VAX Windowing System (UIS)",
+    VWS_XMAX, VWS_YMAX, VWS_VCHAR, VWS_HCHAR,
+    VWS_VTIC, VWS_HTIC, options_null, VWS_init, VWS_reset,
+    VWS_text, null_scale, VWS_graphics, VWS_move, VWS_vector,
+    VWS_linetype, VWS_put_text, VWS_text_angle,
+    VWS_justify_text, do_point, do_arrow, set_font_null
+TERM_TABLE_END(vws_driver)
+
+#undef LAST_TERM
+#define LAST_TERM vws_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(VWS)
+"1 VWS",
+"?commands set terminal VWS",
+"?set terminal VWS",
+"?set term VWS",
+"?terminal VWS",
+"?term VWS",
+"?VWS",
+" The `VWS` terminal driver supports the VAX Windowing System.  It has",
+" no options.  It will sense the display type (monochrome, gray scale,",
+" or color.)  All line styles are plotted as solid lines."
+END_HELP(VWS)
+#endif /* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/win.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/win.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/win.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/win.trm.svn-base	2012-01-03 17:07:47.828009300 -0800
@@ -0,0 +1,1191 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: win.trm,v 1.65.2.11 2010/02/24 20:41:29 sfeam Exp $
+ */
+
+/* GNUPLOT - win.trm */
+
+/*[
+ * Copyright 1992 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ *
+ * AUTHORS
+ *
+ *   Gnuplot for Windows:
+ *       Maurice Castro, Russell Lang
+ *
+ */
+
+
+/* This file implements the terminal and printer display for gnuplot  */
+/* under Microsoft Windows.                                           */
+/*                                                                    */
+/* The modifications to allow Gnuplot to run under Windows were made  */
+/* by Maurice Castro (maurice@bruce.cs.monash.edu.au)                 */
+/* and Russell Lang (rjl@monu1.cc.monash.edu.au)         19 Nov 1992  */
+/*                                                                    */
+
+/* Edit this file with tabstop=4 (vi :se ts=4)                        */
+
+/*
+ * adapted to the new terminal layout by Stefan Bodewig (Dec. 1995)
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(windows)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void WIN_options __PROTO((void));
+TERM_PUBLIC void WIN_init __PROTO((void));
+TERM_PUBLIC void WIN_reset __PROTO((void));
+TERM_PUBLIC void WIN_text __PROTO((void));
+TERM_PUBLIC void WIN_graphics __PROTO((void));
+TERM_PUBLIC void WIN_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void WIN_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void WIN_linetype __PROTO((int lt));
+TERM_PUBLIC void WIN_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC int WIN_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC int WIN_text_angle __PROTO((int ang));
+TERM_PUBLIC void WIN_point __PROTO((unsigned int x, unsigned int y, int number));
+TERM_PUBLIC void WIN_resume __PROTO((void));
+TERM_PUBLIC void WIN_set_pointsize __PROTO((double));
+TERM_PUBLIC void WIN_linewidth __PROTO((double linewidth));
+#ifdef USE_MOUSE
+TERM_PUBLIC void WIN_set_ruler __PROTO((int, int));
+TERM_PUBLIC void WIN_set_cursor __PROTO((int, int, int));
+TERM_PUBLIC void WIN_put_tmptext __PROTO((int, const char str[]));
+TERM_PUBLIC void WIN_set_clipboard __PROTO((const char[]));
+TERM_PUBLIC int WIN_waitforinput __PROTO((void));
+#endif
+TERM_PUBLIC int WIN_make_palette __PROTO((t_sm_palette *palette));
+TERM_PUBLIC void WIN_set_color __PROTO((t_colorspec *));
+TERM_PUBLIC void WIN_filled_polygon __PROTO((int points, gpiPoint *corners));
+TERM_PUBLIC void WIN_boxfill __PROTO((int, unsigned int, unsigned int, unsigned int, unsigned int));
+/* To support "set term win enhanced" */
+TERM_PUBLIC int WIN_set_font __PROTO((const char *font));
+TERM_PUBLIC void WIN_enhanced_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC void WIN_enhanced_open __PROTO((char * fontname, double fontsize,
+	    		double base, TBOOLEAN widthflag, TBOOLEAN showflag,
+			int overprint));
+TERM_PUBLIC void WIN_enhanced_flush __PROTO((void));
+TERM_PUBLIC void WIN_image __PROTO((unsigned int, unsigned int, coordval *, gpiPoint *, t_imagecolor));
+
+
+/* Initialization values - Guess Now Scale later */
+#define WIN_XMAX (24000)
+#define WIN_YMAX (18000)
+#define WIN_HCHAR (WIN_XMAX/75)
+#define WIN_VCHAR (WIN_YMAX/25)
+#define WIN_HTIC (WIN_XMAX/160)
+#define WIN_VTIC WIN_HTIC
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+#include <windows.h>
+#include "win/winmain.h"
+
+#ifdef __MSC__
+#include <io.h>			/* for mktemp() */
+#endif
+
+#define WIN_POINT_TYPES 15	/* 20010411: raised */
+
+/* Interface routines - create list of actions for Windows */
+
+enum WIN_id { WIN_DEFAULT, WIN_MONOCHROME, WIN_COLOR, WIN_GTITLE,
+	      WIN_ENHANCED, WIN_NOENHANCED, WIN_FONT, WIN_SIZE, 
+	      WIN_POSITION, WIN_CLOSE, WIN_OTHER };
+
+static struct gen_table WIN_opts[] =
+{
+    { "d$efault", WIN_DEFAULT },
+    { "m$onochrome", WIN_MONOCHROME },
+    { "c$olor", WIN_COLOR },
+    { "c$olour", WIN_COLOR },
+    { "noenh$anced", WIN_NOENHANCED },
+    { "enh$anced", WIN_ENHANCED },
+    { "font", WIN_FONT },
+    { "ti$tle", WIN_GTITLE },
+    { "siz$e", WIN_SIZE },
+    { "pos$ition", WIN_POSITION },
+    { "cl$ose", WIN_CLOSE },
+    { NULL, WIN_OTHER }
+};
+
+static char *WIN_gtitle = NULL;
+
+static int WIN_last_linetype = LT_NODRAW; /* HBB 20000813: linetype caching */
+
+/* these variables are needed for enhanced text only */
+
+/* FIXME: these are duplicates of struct graphwin members */
+static char WIN_font[MAXFONTNAME] = WINFONT; 
+static int WIN_fontsize = WINFONTSIZE;
+static double WIN_angle = 0.;  /* unit is radian */
+
+/* FIXME: these should most likely be members of struct graphwin */
+static unsigned int WIN_x = 0;
+static unsigned int WIN_y = 0;
+static enum JUSTIFY WIN_justification = LEFT;
+
+/* state variables for enhanced text processing */
+static TBOOLEAN ENHwin_opened_string;
+static TBOOLEAN ENHwin_show = TRUE;
+static int ENHwin_overprint = 0;
+static TBOOLEAN ENHwin_widthflag = TRUE;
+static TBOOLEAN ENHwin_sizeonly = FALSE;
+static double ENHwin_base;
+
+
+TERM_PUBLIC void
+WIN_options()
+{
+    char *s;
+    TBOOLEAN set_font = FALSE, set_fontsize = FALSE;
+    TBOOLEAN set_title=FALSE, set_close = FALSE;
+    /* shige */
+    static int readinit=0;
+
+    if (!readinit){
+	ReadGraphIni(&graphwin);
+	readinit=1;
+    }
+
+    while (!END_OF_COMMAND) {
+	switch(lookup_table(&WIN_opts[0],c_token)) {
+	case WIN_DEFAULT:
+	    graphwin.color = TRUE;
+	    strcpy(graphwin.fontname, WINFONT);
+	    graphwin.fontsize = WINFONTSIZE;
+	    strcpy(graphwin.deffontname, WINFONT);
+	    graphwin.deffontsize = WINFONTSIZE;
+	    graphwin.Title = WINGRAPHTITLE;
+	    set_title = TRUE;
+	    c_token++;
+	    break;
+	case WIN_MONOCHROME:
+	    graphwin.color = FALSE;
+	    term->flags |= TERM_MONOCHROME;
+	    c_token++;
+	    break;
+	case WIN_SIZE:
+	{
+	    int win_width = 0;
+	    int win_height = 0;
+	    c_token++;
+	    if (END_OF_COMMAND)
+		int_error(c_token,"size requires 'width,heigth'");
+	    win_width = real_expression();
+	    if (!equals(c_token++,","))
+		int_error(c_token,"size requires 'width,heigth'");
+	    win_height = real_expression();
+	    if (win_width < 1 || win_height < 1)
+		int_error(c_token, "size is out of range");
+	    
+	    graphwin.Size.x = win_width;
+	    graphwin.Size.y = win_height + graphwin.statuslineheight;
+	    break;
+	}
+	case WIN_POSITION:
+	{
+	    int win_x = 0;
+	    int win_y = 0;
+	    c_token++;
+	    if (END_OF_COMMAND)
+		int_error(c_token,"position requires 'x,y'");
+	    win_x = real_expression();
+	    if (!equals(c_token++,","))
+		int_error(c_token,"position requires 'x,y'");
+	    win_y = real_expression();
+	    if (win_x < 1 || win_y < 1)
+		int_error(c_token, "position is out of range");
+	    
+	    graphwin.Origin.x = win_x;
+	    graphwin.Origin.y = win_y;
+	    break;
+	}
+	case WIN_COLOR:
+	    graphwin.color = TRUE;
+	    term->flags &= ~TERM_MONOCHROME;
+	    c_token++;
+	    break;
+	case WIN_ENHANCED:
+	    c_token++;
+	    term->put_text = WIN_enhanced_put_text;
+	    term->flags |= TERM_ENHANCED_TEXT;
+	    break;
+	case WIN_NOENHANCED:
+	    c_token++;
+	    term->put_text = WIN_put_text;
+	    term->flags &= ~TERM_ENHANCED_TEXT;
+	    break;
+	case WIN_GTITLE:
+	    c_token++;
+	    set_title = TRUE;
+	    free(WIN_gtitle);
+	    WIN_gtitle = try_to_get_string();
+	    break;
+	case WIN_CLOSE:
+	    c_token++;
+	    set_close = TRUE;
+	    break;
+	case WIN_FONT:
+	    c_token++;
+	    /* Fall through to attempt to read font name */
+	case WIN_OTHER:
+	default:
+	    /* Code copied from ps.trm and modified for windows terminal */
+	    if ((s = try_to_get_string())) {
+		char *comma;
+		if (set_font)
+		    int_error(c_token,
+			      "extraneous argument in set terminal %s",
+			      term->name);
+		set_font = TRUE;
+	        comma = strrchr(s,',');
+	        if (comma && (1 == sscanf(comma+1,"%i", &graphwin.fontsize))) {
+		    graphwin.deffontsize = graphwin.fontsize;
+		    set_fontsize = TRUE;
+		    *comma = '\0';
+		}
+		if (*s) {
+		    strncpy(graphwin.fontname, s, MAX_ID_LEN);
+		    strcpy(graphwin.deffontname, graphwin.fontname);
+		    free(s);
+    		}
+	    } else {
+		if (set_fontsize)
+		    int_error(c_token,
+			      "extraneous argument in set terminal %s",
+			      term->name);
+		set_fontsize = TRUE;
+		/* We have font size specified */
+		graphwin.fontsize = int_expression();
+		graphwin.deffontsize = graphwin.fontsize;
+	    }
+	    break;
+	}
+    }
+
+    if (graphwin.fontname[0] == '\0')
+	sprintf(term_options, "%s %s", 
+		graphwin.color ? "color" : "monochrome", 
+		term->flags & TERM_ENHANCED_TEXT ? "enhanced" : "noenhanced");
+    else
+	sprintf(term_options, "%s %s font \"%s, %d\"",
+		graphwin.color ? "color" : "monochrome",
+		term->flags & TERM_ENHANCED_TEXT ? "enhanced" : "noenhanced",
+		graphwin.fontname, graphwin.fontsize);
+
+    if (set_close) {
+	win_close_terminal_window(&graphwin);
+	return;
+    }
+
+    if (IsWindow(graphwin.hWndGraph) && IsIconic(graphwin.hWndGraph))
+	ShowWindow(graphwin.hWndGraph, SW_SHOWNORMAL);
+
+    graphwin.Title = (WIN_gtitle ? WIN_gtitle : WINGRAPHTITLE);
+    if (set_title) GraphChangeTitle(&graphwin);
+
+    GraphRedraw(&graphwin);
+}
+
+/* We don't actually do scaling, but we need to fix up the text size
+ * if the user has resized the window.
+ * Routine unused -- terminals are not allowed to do their own scale().
+ */
+#if 0
+int
+WIN_scale()
+{
+    term->h_char = graphwin.hchar;
+    term->v_char = graphwin.vchar;
+    term->h_tic = graphwin.htic;
+    term->v_tic = graphwin.vtic;
+    sprintf(term_options, "%s \"%s\" %d",
+	    graphwin.color ? "color" : "monochrome",
+	    graphwin.fontname, graphwin.fontsize);
+    return FALSE;		/* can't be done */
+}
+#endif
+
+TERM_PUBLIC void
+WIN_init()
+{
+    if (!graphwin.hWndGraph) {
+	graphwin.xmax = WIN_XMAX;
+	graphwin.ymax = WIN_YMAX;
+	graphwin.htic = WIN_HTIC;
+	graphwin.vtic = WIN_VTIC;
+	GraphInit(&graphwin);
+#ifdef WIN32
+	SetClassLong(graphwin.hWndGraph, GCL_HICON, (LONG) LoadIcon(graphwin.hInstance, "GRPICON"));
+#else
+	SetClassWord(graphwin.hWndGraph, GCW_HICON, LoadIcon(graphwin.hInstance, "GRPICON"));
+#endif
+	graphwin.resized = FALSE;
+    }
+    WIN_last_linetype = LT_NODRAW;	/* HBB 20000813: linetype caching */
+}
+
+
+TERM_PUBLIC void
+WIN_reset()
+{
+}
+
+TERM_PUBLIC void
+WIN_text()
+{
+    GraphEnd(&graphwin);
+}
+
+TERM_PUBLIC void
+WIN_graphics()
+{
+    GraphStart(&graphwin, pointsize);
+    WIN_last_linetype = LT_NODRAW;		/* HBB 20000813: linetype caching */
+}
+
+TERM_PUBLIC void
+WIN_move(unsigned int x, unsigned int y)
+{
+    /* Notice HBB 20010208: on Win32 platforms, passing int or
+     * unsigned int arguments to GraphOp() might cause problems: int
+     * is 32bits, but GraphOp() args are 16bit WORDS. */
+    GraphOp(&graphwin, W_move, x, y, NULL);
+
+    /* save current position, only needed for enhanced text */
+    WIN_x = x; 
+    WIN_y = y;
+}
+
+TERM_PUBLIC void
+WIN_vector(unsigned int x, unsigned int y)
+{
+    /* Notice HBB 20010208: --> WIN_move() */
+    GraphOp(&graphwin, W_vect, x, y, NULL);
+}
+
+TERM_PUBLIC void
+WIN_linetype(int lt)
+{
+    if (lt != WIN_last_linetype) {
+	/* Notice HBB 20010208: --> see WIN_move() */
+    	GraphOp(&graphwin, W_line_type, lt, 0, NULL);
+	WIN_last_linetype = lt;
+    }
+}
+
+TERM_PUBLIC void
+WIN_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    /* Notice HBB 20010208: --> WIN_move() */
+    GraphOp(&graphwin, W_put_text, x, y, str);
+}
+
+TERM_PUBLIC int
+WIN_justify_text(enum JUSTIFY mode)
+{
+    /* Notice HBB 20010208: --> WIN_move() */
+    GraphOp(&graphwin, W_justify, mode, 0, NULL);
+    /* store text justification, only needed for enhanced text */
+    WIN_justification = mode;
+    return (TRUE);
+}
+
+TERM_PUBLIC int
+WIN_text_angle(int ang)
+{
+    if (graphwin.rotate) {
+	/* Notice HBB 20010208: --> WIN_move() */
+ 	GraphOp(&graphwin, W_text_angle, ang, 0, NULL);
+
+        /* store text angle, only needed for enhanced text */
+	WIN_angle = (double)ang * M_PI / 180.;
+    }
+    return graphwin.rotate;
+}
+
+TERM_PUBLIC void
+WIN_point(unsigned int x, unsigned int y, int number)
+{
+    /* draw point shapes later to save memory */
+    /* size of point symbols */
+    graphwin.htic = pointsize * term->h_tic / 2;
+    graphwin.vtic = pointsize * term->v_tic / 2;
+    /* HBB 20010411: secure against pointtype -1 or lower */
+    if (number < -1)
+	number = -1;		/* refuse nonsense values */
+    if (number >= 0)
+	number %= WIN_POINT_TYPES;
+    number += 1;
+    /* Notice HBB 20010208: --> WIN_move() */
+    GraphOp(&graphwin, W_dot + number, x, y, NULL);
+}
+
+TERM_PUBLIC void
+WIN_resume()
+{
+    GraphResume(&graphwin);
+}
+
+TERM_PUBLIC void
+WIN_set_pointsize(double s)
+{
+    /* Save new pointsize as string */
+    char scale[30];
+
+    if (s < 0)
+	s = 1;
+    sprintf(scale, "%.15g", s);
+#if 1
+    /* HBB 980309: it seems passing it as a string is a bad idea
+     * in Win16: it means the wgnuplot.dll has to parse the string
+     * via sscanf(), leading to crash (by stack overflow?). Alternative:
+     * pass it as a scaled-up integer. For the sake of compatibility,
+     * pass the string as well. */
+    /* Notice HBB 20010208: --> WIN_move() */
+    GraphOp(&graphwin, W_pointsize, (int) 100 * s, 0, scale);
+#else
+    GraphOp(&graphwin, W_pointsize, 0, 0, scale);
+#endif
+}
+
+TERM_PUBLIC void
+WIN_linewidth(double linewidth)
+{
+    /* HBB 20000813: New routine */
+    WIN_last_linetype = LT_NODRAW;        /* invalidate cached linetype */
+    /* Notice HBB 20010208: --> WIN_move() */
+    GraphOp(&graphwin, W_line_width, (int) 100 * linewidth, 0, NULL);
+}
+
+#ifdef USE_MOUSE
+
+/* Implemented by Petr Mikulik, February 2001 --- the best Windows solutions
+ * come from OS/2 :-))
+ */
+
+TERM_PUBLIC void
+WIN_put_tmptext ( int i, const char str[] )
+{
+    Graph_put_tmptext(&graphwin, i, str );
+}
+
+TERM_PUBLIC void
+WIN_set_ruler ( int x, int y )
+{
+    Graph_set_ruler(&graphwin, x, y );
+}
+
+TERM_PUBLIC void
+WIN_set_cursor ( int c, int x, int y )
+{
+    Graph_set_cursor(&graphwin, c, x, y );
+}
+
+TERM_PUBLIC void
+WIN_set_clipboard ( const char s[] )
+{
+    Graph_set_clipboard(&graphwin, s);
+}
+
+#ifdef WGP_CONSOLE
+
+TERM_PUBLIC int
+WIN_waitforinput  ()
+{
+    return ConsoleGetch();
+}
+
+#endif /* WGP_CONSOLE */
+
+#endif /* USE_MOUSE */
+
+
+/* Note: this is a verbatim copy of PM_image (pm.trm) with only minor changes */
+
+TERM_PUBLIC void
+WIN_image(unsigned int M, unsigned int N, coordval *image,
+	  gpiPoint *corner, t_imagecolor color_mode)
+{
+    PBYTE rgb_image;
+    unsigned int image_size;
+    unsigned int pad_bytes;
+
+    /* IC_PALETTE and IC_RGB images are converted to a 24bit RGB format
+       suitable for Windows:
+        - sequence of lines is reversed 
+        - each line starts at a 4 byte boundary
+    */
+
+    /* fprintf(stderr, "WIN_image: %i x %i, mode=%s\n", M, N, color_mode==IC_RGB?"IC_RGB":"IC_PALETTE" ); */
+    pad_bytes = (4 - (3 * M) % 4) % 4; /* scan lines start on ULONG boundaries */
+
+    image_size = (M + pad_bytes ) * N * 3;
+    rgb_image = (PBYTE) gp_alloc(image_size, "WIN RGB image");
+
+    if (color_mode == IC_PALETTE) {
+    	unsigned int x, y;
+
+	rgb_image += N * (3 * M + pad_bytes);
+	for (y=0; y<N; y++) {
+	    rgb_image -= 3 * M + pad_bytes;
+	    for(x=0; x<M; x++) {
+		rgb255_color rgb255;
+		rgb255maxcolors_from_gray(*image++, &rgb255);
+		*(rgb_image++) = rgb255.b;
+		*(rgb_image++) = rgb255.g;
+		*(rgb_image++) = rgb255.r;
+	    }
+	    rgb_image -= 3 * M;
+	}
+    } else if (color_mode == IC_RGB) {
+    	unsigned int x, y;
+
+	rgb_image += N * (3 * M + pad_bytes);
+	for (y=0; y<N; y++) {
+	    rgb_image -= 3 * M + pad_bytes;
+	    for(x=0; x<M; x++) {
+		rgb255_color rgb255;
+		rgb255.r = (BYTE) (*image++ * 255 + 0.5);
+		rgb255.g = (BYTE) (*image++ * 255 + 0.5);
+		rgb255.b = (BYTE) (*image++ * 255 + 0.5);
+		*(rgb_image++) = rgb255.b;
+		*(rgb_image++) = rgb255.g;
+		*(rgb_image++) = rgb255.r;
+	    }
+	    rgb_image -= 3 * M;
+	}
+#if (0) /* Alpha channel transparency not implemented  yet */
+    } else if (color_mode == IC_RGBA) {
+    	unsigned int x, y;
+
+	rgb_image += N * (3 * M + pad_bytes);
+	for (y=0; y<N; y++) {
+	    rgb_image -= 3 * M + pad_bytes;
+	    for(x=0; x<M; x++) {
+		rgb255_color rgb255;
+		rgb255.r = (BYTE) (*image++ * 255 + 0.5);
+		rgb255.g = (BYTE) (*image++ * 255 + 0.5);
+		rgb255.b = (BYTE) (*image++ * 255 + 0.5);
+		image++; /* Throw away alpha channel */
+		*(rgb_image++) = rgb255.b;
+		*(rgb_image++) = rgb255.g;
+		*(rgb_image++) = rgb255.r;
+	    }
+	    rgb_image -= 3 * M;
+	}
+#endif
+    }
+
+    /* squeze all the information into the buffer */
+    if ((color_mode == IC_PALETTE) || (color_mode == IC_RGB)) {
+        GraphOp(&graphwin, W_image, corner[0].x, corner[0].y, NULL);
+        GraphOp(&graphwin, W_image, corner[1].x, corner[1].y, NULL);
+        GraphOp(&graphwin, W_image, corner[2].x, corner[2].y, NULL);
+        GraphOp(&graphwin, W_image, corner[3].x, corner[3].y, NULL);
+	/* GraphOp() cannot be used here since the image might 
+	   contain char(0), so use  GraphOpSize() instead */
+        GraphOpSize(&graphwin, W_image, M, N, rgb_image, image_size);
+    }
+
+    free(rgb_image);
+}
+
+
+TERM_PUBLIC int
+WIN_make_palette(t_sm_palette *palette)
+{
+    /* Win can do continuous colors. However, we round them only to WIN_PAL_COLORS levels
+     * in order to pass an integer to GraphOp; it also reasonably limits
+     * the number of colors if "copy to clipboard" is used.
+     * EAM: Would it be better to use the approximate_palette() mechanism instead,
+     * like the x11 terminal?
+     */
+    return WIN_PAL_COLORS;
+}
+
+TERM_PUBLIC void
+WIN_set_color(t_colorspec *colorspec)
+{
+    switch (colorspec->type ) {
+	case TC_FRAC:
+	    GraphOp(&graphwin, W_pm3d_setcolor, (int)(WIN_PAL_COLORS*colorspec->value), 0, NULL);
+	    break;
+	case TC_RGB:
+	    GraphOp(&graphwin, W_pm3d_setcolor, (colorspec->lt) & 0xffff, 0xff00 | ((colorspec->lt >> 16) & 0x00ff), NULL);
+	    break;
+	case TC_LT:
+	    GraphOp(&graphwin, W_pm3d_setcolor, colorspec->lt, TC_LT << 8, NULL);
+	    break;
+    }
+    WIN_last_linetype = LT_NODRAW;
+}
+
+TERM_PUBLIC void
+WIN_filled_polygon(int points, gpiPoint *corners)
+{
+    int i;
+    /* FIXME:  fillstyle is ignored by the polygon code in wgraph.c
+     * This is an experiment to see if we can piggyback on the fillbox() code
+     * to set a pattern brush that will stay in effect for the polygon fill.
+     */
+    if (corners->style != FS_OPAQUE)
+	WIN_boxfill(corners->style, corners->x, corners->y, 0, 1);
+
+    for (i=0; i<points; i++)
+    	GraphOp(&graphwin, W_pm3d_filled_polygon_pt, corners[i].x, corners[i].y, NULL);
+    /* finish series: */
+    GraphOp(&graphwin, W_pm3d_filled_polygon_draw, points, 0, NULL);
+}
+
+TERM_PUBLIC void
+WIN_boxfill(
+    int style,
+    unsigned int xleft, unsigned int ybottom,
+    unsigned int width, unsigned int height)
+{
+    /* split into multiple commands to squeeze through all the necessary info */
+    GraphOp(&graphwin, W_fillstyle, style, 0, NULL);
+    GraphOp(&graphwin, W_move, xleft, ybottom, NULL);
+    GraphOp(&graphwin, W_boxfill, width, height, NULL);
+}
+
+
+TERM_PUBLIC int
+WIN_set_font(const char *font)
+{
+    char fontname[MAXFONTNAME];
+    int  fontsize;
+
+    if (font != NULL) {
+	if (font[0] == '\0') {
+	    strcpy(fontname, graphwin.deffontname);
+	    fontsize = graphwin.deffontsize;
+	} else {
+	    char *size;
+
+	    size = strrchr(font, ',');
+	    if (size == NULL) {
+		/* only font name given */
+		strcpy(fontname, font);
+    		fontsize = graphwin.deffontsize;
+	    } else if (size == font) {
+		/* only font size given */
+		strcpy(fontname, graphwin.deffontname);
+		sscanf(size+1,"%i", &fontsize);
+	    } else {
+		/* full font information supplied */
+		strncpy(fontname, font, size-font);
+		fontname[size-font] = '\0';
+		sscanf(size+1,"%i", &fontsize);
+	    }
+	}
+    }
+
+    if (font != NULL) {
+	GraphOp(&graphwin, W_font, fontsize, 0, fontname);
+        strcpy(WIN_font, fontname);
+        WIN_fontsize = fontsize;
+    }
+    else {
+	GraphOp(&graphwin, W_font, 0, 0, "");
+        strcpy(WIN_font, graphwin.deffontname);
+        WIN_fontsize = graphwin.deffontsize;
+    }
+    return TRUE;
+}
+
+
+TERM_PUBLIC void
+WIN_enhanced_open(
+    char *fontname,
+    double fontsize, double base,
+    TBOOLEAN widthflag, TBOOLEAN showflag,
+    int overprint)
+{
+    static const int win_scale = 40; /* scaling of base offset */  
+    static unsigned int ENHwin_xsave, ENHwin_ysave;
+    char *fontstring;
+
+    /* There are two special cases:
+     * overprint = 3 means save current position
+     * overprint = 4 means restore saved position
+     */
+    if (overprint == 3) {
+	ENHwin_xsave = WIN_x;
+	ENHwin_ysave = WIN_y;
+	return;
+    } else if (overprint == 4) {
+	WIN_x = ENHwin_xsave;
+	WIN_y = ENHwin_ysave;
+	return;
+    }
+
+    if (!ENHwin_opened_string) {
+	ENHwin_opened_string = TRUE;
+
+	/* Start new text fragment */
+	enhanced_cur_text = &enhanced_text[0];
+
+	/* Keep track of whether we are supposed to show this string */
+	ENHwin_show = showflag;
+
+	/* 0/1/2  no overprint / 1st pass / 2nd pass */
+	ENHwin_overprint = overprint;
+
+	/* widthflag FALSE means do not update text position after printing */
+	ENHwin_widthflag = widthflag;
+
+	/* Scale fractional font height to vertical units of display */
+	/* FIXME:	
+		Font scaling is not done properly (yet) and will lead to
+		non-optimal results for most font and size selections.
+		OUTLINEFONTMETRICS could be used for better here.
+	*/
+	ENHwin_base = win_scale * base;
+	 
+ 	/* Select font */
+	/* FIXME: It would be nice to have fractional font sizes 
+	          for super- and subscripts. */
+	/* FIXME: sometimes fontname has zero length */
+	if ((fontname != NULL) && strlen(fontname) > 0) {
+	    fontstring = malloc(strlen(fontname) + 16);
+	    sprintf(fontstring, "%s,%i", fontname, (int)fontsize);
+	} else {
+	    fontstring = malloc( strlen(graphwin.deffontname) + 16 );
+	    sprintf( fontstring, "%s,%i", graphwin.deffontname, (int)fontsize);
+	}
+	WIN_set_font( fontstring );
+	free( fontstring );
+   }
+}
+
+
+TERM_PUBLIC void
+WIN_enhanced_flush()
+{
+    static unsigned int ENHwin_xsave, ENHwin_ysave;
+
+    if (ENHwin_opened_string) {
+	int width, height;
+	unsigned int x, y, len;
+
+	*enhanced_cur_text = '\0';
+	
+	/* print the string fragment, perhaps invisibly */
+	/* NB: base expresses offset from current y pos */
+	x = WIN_x - ENHwin_base * sin(WIN_angle);
+	y = WIN_y + ENHwin_base * cos(WIN_angle);
+
+	/* calculate length of string first */
+    	len = GraphGetTextLength(&graphwin, enhanced_text, WIN_font, WIN_fontsize);
+	width = cos(WIN_angle) * len;
+	height = sin(WIN_angle) * len;
+
+	if (ENHwin_show && !ENHwin_sizeonly) {
+	    /* display string */
+	    GraphOp(&graphwin, W_put_text, x, y, enhanced_text);
+	}
+
+	/* update drawing position according to len */
+	if (!ENHwin_widthflag) {
+	    width = 0; 
+	    height = 0;
+	}
+	if (ENHwin_sizeonly) {
+	    /* This is the first pass for justified printing.        */
+	    /* We just adjust the starting position for second pass. */
+	    if (WIN_justification == RIGHT) {
+		WIN_x -= width;
+		WIN_y -= height;
+	    }
+	    else if (WIN_justification == CENTRE) {
+		WIN_x -= width / 2;
+		WIN_y -= height / 2;
+	    }
+	    /* nothing to do for LEFT justified text */
+	}
+	else if (ENHwin_overprint == 1) {
+	    /* Save current position */
+	    ENHwin_xsave = WIN_x + width;
+	    ENHwin_ysave = WIN_y + height;
+	    /* First pass of overprint, leave position in center of fragment */
+	    WIN_x += width / 2;
+	    WIN_y += height / 2;
+	}
+	else if (ENHwin_overprint == 2) {
+	    /* Restore current position,                          */
+	    /* this sets the position behind the overprinted text */
+	    WIN_x = ENHwin_xsave;
+	    WIN_y = ENHwin_ysave;
+	}
+	else {
+	    /* Normal case is to update position to end of fragment */
+	    WIN_x += width;
+	    WIN_y += height;
+	}
+
+	ENHwin_opened_string = FALSE;
+    }
+}
+
+
+TERM_PUBLIC void
+WIN_enhanced_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    char *original_string = (char *)str;
+    unsigned int pass, num_passes;
+    char* copy_WIN_font;
+
+    /* If no enhanced text processing is needed, we can use the plain  */
+    /* vanilla put_text() routine instead of this fancy recursive one. */
+    if (ignore_enhanced_text || !strpbrk(str, "{}^_@&~")) {
+	WIN_put_text(x,y,str);
+	return;
+    }
+
+    /* Set up global variables needed by enhanced_recursion() */
+    ENHwin_opened_string = FALSE;
+    enhanced_fontscale = 1.0;
+    strncpy(enhanced_escape_format,"%c",sizeof(enhanced_escape_format));
+
+    /* Tell the terminal to move the drawing position */
+    /* we store the current position to WIN_x and WIN_y */
+    WIN_x = x; 
+    WIN_y = y;
+
+    /* Text justification requires two passes. During the first pass we */
+    /* don't draw anything, we just measure the space it will take.     */
+    /* Without justification one pass is enough                         */
+    if (WIN_justification == LEFT) {
+	num_passes = 1;
+    }
+    else {
+	num_passes = 2;
+	ENHwin_sizeonly = TRUE; 
+    }
+
+    /* make a backup copy of the fontname to use 
+       for enhanced recursion */
+    copy_WIN_font = strdup(WIN_font);
+    
+    for( pass=1; pass <= num_passes; pass++ ) {
+
+	/* Set the recursion going. We say to keep going until a
+	* closing brace, but we don't really expect to find one.
+	* If the return value is not the nul-terminator of the
+	* string, that can only mean that we did find an unmatched
+	* closing brace in the string. We increment past it (else
+	* we get stuck in an infinite loop) and try again.
+	*/
+	while (*(str = enhanced_recursion((char *)str, TRUE,
+			copy_WIN_font, WIN_fontsize,
+			0.0, TRUE, TRUE, 0))) {
+	    (term->enhanced_flush)();
+
+	    /* I think we can only get here if *str == '}' */
+	    enh_err_check(str);
+
+	    if (!*++str)
+	    	break; /* end of string */
+
+	    /* else carry on and process the rest of the string */
+	}
+
+	/* In order to do text justification we need to do a second pass that */
+	/* uses information stored during the first pass.                     */
+	/* see WIN_enhanced_flush()                                           */
+	if (pass == 1) {
+	    /* do the actual printing in the next pass */
+	    ENHwin_sizeonly = FALSE;
+	    str = original_string;
+
+	    /* temporarily switch to left alignment since we do it ourselves */
+	    GraphOp(&graphwin, W_justify, LEFT, 0, NULL);
+	}
+    }
+    free(copy_WIN_font);
+
+    /* restore default font */
+    WIN_set_font(NULL); 
+
+    /* restore text alignment */
+    if (num_passes > 1)
+        GraphOp(&graphwin, W_justify, WIN_justification, 0, NULL);
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(win_driver)
+    "windows", "Microsoft Windows",
+    WIN_XMAX, WIN_YMAX, WIN_VCHAR, WIN_HCHAR,
+    WIN_VTIC, WIN_HTIC, WIN_options, WIN_init, WIN_reset,
+    WIN_text, null_scale, WIN_graphics, WIN_move, WIN_vector,
+    WIN_linetype, WIN_put_text, WIN_text_angle,
+    WIN_justify_text, WIN_point, do_arrow, WIN_set_font,
+    WIN_set_pointsize, TERM_CAN_MULTIPLOT|TERM_NO_OUTPUTFILE,
+    WIN_text /* suspend */ , WIN_resume,
+    WIN_boxfill, WIN_linewidth
+#ifdef USE_MOUSE
+# ifdef WGP_CONSOLE
+    , WIN_waitforinput , 
+# else
+    , 0 /* WIN_waitforinput */,
+# endif /* WGP_CONSOLE */
+    WIN_put_tmptext, WIN_set_ruler, WIN_set_cursor, WIN_set_clipboard
+#endif
+    , WIN_make_palette, 0 /* previous_palette */,
+    WIN_set_color, WIN_filled_polygon
+    , WIN_image
+    , WIN_enhanced_open, WIN_enhanced_flush, do_enh_writec
+TERM_TABLE_END(win_driver)
+
+#undef LAST_TERM
+#define LAST_TERM win_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(windows)
+"1 windows",
+"?commands set terminal windows",
+"?set terminal windows",
+"?set term windows",
+"?terminal windows",
+"?term windows",
+"?windows",
+" Three options may be set in the `windows` terminal driver.",
+"",
+" Syntax:",
+"       set terminal windows {color | monochrome}",
+"                            {enhanced | noenhanced}",
+"                            {{font} \"fontname{,fontsize}\" {<fontsize>}}",
+"                            {title \"Plot Window Title\"}",
+"                            {size <width>,<height>}",
+"                            {position <x>,<y>}",
+"                            {close}",
+"",
+" where `color` and `monochrome` select colored or mono output,", 
+" `enhanced` enables enhanced text mode features (subscripts,",
+" superscripts and mixed fonts). See `enhanced` for more information.",
+" `\"<fontname>\"` is the name of a valid Windows font, and `<fontsize>`",
+" is the size of the font in points.",
+" `size` defines the width and height of the window in pixel and `position`",
+" the origin of the window i.e. the position of the top left corner on the",
+" screen (again in pixel). Both these options override the default settings",
+" from the WGNUPLOT.INI file (see below).",
+"",
+" Other options may be set with the graph-menu or the initialization file.",
+"",
+" The Windows version normally terminates immediately as soon as the end of",
+" any files given as command line arguments is reached (i.e. in non-interactive",
+" mode), unless you specify `-` as the last command line option.",
+" It will also not show the text-window at all, in this mode, only the plot.",
+" By giving the optional argument `-persist` (same as for gnuplot under x11;",
+" former Windows-only options `/noend` or `-noend` are still accepted as well),",
+" will not close gnuplot. Contrary to gnuplot on other operating systems,",
+" gnuplot's interactive command line is accessible after the -persist option.",
+"",
+" The plot window remains open even when the gnuplot driver is changed to a",
+" different device. The plot window can be close with `set term windows close`",
+"2 graph-menu",
+"?commands set terminal windows graph-menu",
+"?set terminal windows graph-menu",
+"?set term windows graph-menu",
+"?windows graph-menu",
+"?graph-menu",
+" The `gnuplot graph` window has the following options on a pop-up menu",
+" accessed by pressing the right mouse button or selecting `Options` from the",
+" system menu:",
+"",
+" `Bring to Top` when checked brings the graph window to the top after every",
+" plot.",
+"",
+" `Color` when checked enables color linestyles.  When unchecked it forces",
+" monochrome linestyles.",
+"",
+" `Copy to Clipboard` copies a bitmap and an enhanced Metafile picture.",
+"",
+" `Save as EMF...` allows the user to save the current graph window as enhanced metafile",
+"",
+" `Background...` sets the window background color.",
+"",
+" `Choose Font...` selects the font used in the graphics window.",
+"",
+" `Line Styles...` allows customization of the line colors and styles.",
+"",
+" `Print...` prints the graphics windows using a Windows printer driver and",
+" allows selection of the printer and scaling of the output.  The output",
+" produced by `Print` is not as good as that from `gnuplot`'s own printer",
+" drivers.",
+"",
+" `Update wgnuplot.ini` saves the current window locations, window sizes, text",
+" window font, text window font size, graph window font, graph window font",
+" size, background color and linestyles to the initialization file",
+" `WGNUPLOT.INI`.",
+"2 printing",
+"?commands set terminal windows printing",
+"?set terminal windows printing",
+"?set term windows printing",
+"?windows printing",
+"?printing",
+" In order of preference, graphs may be be printed in the following ways.",
+"",
+" `1.` Use the `gnuplot` command `set terminal` to select a printer and `set",
+" output` to redirect output to a file.",
+"",
+" `2.` Select the `Print...` command from the `gnuplot graph` window.  An extra",
+" command `screendump` does this from the text window.",
+"",
+" `3.` If `set output \"PRN\"` is used, output will go to a temporary file.  When",
+" you exit from `gnuplot` or when you change the output with another `set",
+" output` command, a dialog box will appear for you to select a printer port.",
+" If you choose OK, the output will be printed on the selected port, passing",
+" unmodified through the print manager.  It is possible to accidentally (or",
+" deliberately) send printer output meant for one printer to an incompatible",
+" printer.",
+"2 text-menu",
+"?commands set terminal windows text-menu",
+"?set terminal windows text-menu",
+"?set term windows text-menu",
+"?windows text-menu",
+"?text-menu",
+" The `gnuplot text` window has the following options on a pop-up menu accessed",
+" by pressing the right mouse button or selecting `Options` from the system",
+" menu:",
+"",
+" `Copy to Clipboard` copies marked text to the clipboard.",
+"",
+" `Paste` copies text from the clipboard as if typed by the user.",
+"",
+" `Choose Font...` selects the font used in the text window.",
+"",
+" `System Colors` when selected makes the text window honor the System Colors",
+" set using the Control Panel.  When unselected, text is black or blue on a",
+" white background.",
+"",
+" `Update wgnuplot.ini` saves the current text window location, text window",
+" size, text window font and text window font size to the initialisation file",
+" `WGNUPLOT.INI`.",
+"",
+" `MENU BAR`",
+"",
+" If the menu file `WGNUPLOT.MNU` is found in the same directory as",
+" WGNUPLOT.EXE, then the menu specified in `WGNUPLOT.MNU` will be loaded.",
+" Menu commands:",
+"",
+" [Menu] starts a new menu with the name on the following line.",
+"",
+" [EndMenu] ends the current menu.",
+"",
+" [--] inserts a horizontal menu separator.",
+"",
+" [|] inserts a vertical menu separator.",
+"",
+" [Button] puts the next macro on a push button instead of a menu.",
+"",
+" Macros take two lines with the macro name (menu entry) on the first line and",
+" the macro on the second line.  Leading spaces are ignored.  Macro commands:",
+"",
+" [INPUT] --- Input string with prompt terminated by [EOS] or {ENTER}",
+"",
+" [EOS] --- End Of String terminator.  Generates no output.",
+"",
+" [OPEN] --- Get name of file to open from list box, with title of list box",
+" terminated by [EOS], followed by default filename terminated by [EOS] or",
+" {ENTER}.",
+"",
+" [SAVE] --- Get name of file to save.  Similar to [OPEN]",
+"",
+" Macro character substitutions:",
+"",
+" {ENTER} --- Carriage Return '\\r'",
+"",
+" {TAB} --- Tab '\\011'",
+"",
+" {ESC} --- Escape '\\033'",
+"",
+" {^A} --- '\\001'",
+"",
+" ...",
+"",
+" {^_} --- '\\031'",
+"",
+" Macros are limited to 256 characters after expansion.",
+"2 wgnuplot.ini",
+"?commands set terminal windows wgnuplot.ini",
+"?set terminal windows wgnuplot.ini",
+"?set term windows wgnuplot.ini",
+"?windows wgnuplot.ini",
+"?wgnuplot.ini",
+" Windows `gnuplot` will read some of its options from the `[WGNUPLOT]` section",
+" of `WGNUPLOT.INI` in user's %APPDATA% directory.  A sample `WGNUPLOT.INI` file:",
+"",
+"       [WGNUPLOT]",
+"       TextOrigin=0 0",
+"       TextSize=640 150",
+"       TextFont=Terminal,9",
+"       GraphOrigin=0 150",
+"       GraphSize=640 330",
+"       GraphFont=Arial,10",
+"       GraphColor=1",
+"       GraphToTop=1",
+"       GraphBackground=255 255 255",
+"       Border=0 0 0 0 0",
+"       Axis=192 192 192 2 2",
+"       Line1=0 0 255 0 0",
+"       Line2=0 255 0 0 1",
+"       Line3=255 0 0 0 2",
+"       Line4=255 0 255 0 3",
+"       Line5=0 0 128 0 4",
+"",
+" The `GraphFont` entry specifies the font name and size in points.  The five",
+" numbers given in the `Border`, `Axis` and `Line` entries are the `Red`",
+" intensity (0--255), `Green` intensity, `Blue` intensity, `Color Linestyle`",
+" and `Mono Linestyle`.  `Linestyles` are 0=SOLID, 1=DASH, 2=DOT, 3=DASHDOT,",
+" 4=DASHDOTDOT.  In the sample `WGNUPLOT.INI` file above, Line 2 is a green",
+" solid line in color mode, or a dashed line in monochrome mode.  The default",
+" line width is 1 pixel.  If `Linestyle` is negative, it specifies the width of",
+" a SOLID line in pixels.  Line1 and any linestyle used with the `points` style",
+" must be SOLID with unit width."
+END_HELP(windows)
+#endif /* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/wxt.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/wxt.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/wxt.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/wxt.trm.svn-base	2012-01-03 17:07:48.019505900 -0800
@@ -0,0 +1,490 @@
+/*
+ * $Id: wxt.trm,v 1.24 2009/03/26 00:49:27 sfeam Exp $
+ */
+
+/* GNUPLOT - wxt.trm */
+
+/*[
+ * Copyright 2005,2006   Timothee Lecomte
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/* ------------------------------------------------------
+ * Here you will find the terminal table, filled
+ * with C++ functions defined in wxt_gui.cpp,
+ * where the wxWidgets terminal is mainly implemented.
+ * See wxt_gui.cpp for details about this terminal.
+ * ------------------------------------------------------*/
+
+#ifdef TERM_REGISTER
+register_term (wxt)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void wxt_options __PROTO ((void));
+TERM_PUBLIC void wxt_text_wrapper __PROTO ((void));
+#endif /* TERM_PROTO */
+
+#ifndef TERM_PROTO_ONLY
+
+#ifdef TERM_BODY
+
+#include "wxterminal/wxt_term.h"
+
+/* terminal state, defined extern in wxt_term.h */
+int wxt_window_number = 0;
+TBOOLEAN wxt_enhanced_enabled = FALSE;
+int wxt_persist = UNSET;
+int wxt_raise = UNSET;
+int wxt_ctrl = UNSET;
+int wxt_rounded = no;
+/* default text font family: */
+char wxt_set_fontname[MAX_ID_LEN + 1] = "";
+/* default text size*/
+int wxt_set_fontsize = 0;
+/* window title */
+char wxt_title[MAX_ID_LEN + 1] = "";
+/* size of the plot area, in pixels
+ * (window is bigger, includes toolbar and status bar) */
+int wxt_width = 640;
+int wxt_height = 384;
+
+/* These are used to pass axis scaling information at the end of each plot */
+int wxt_axis_mask;
+wxt_axis_state_t wxt_axis_state[4];
+
+enum WXT_id {
+    WXT_FONT,
+    WXT_ENHANCED,
+    WXT_NOENHANCED,
+    WXT_SIZE,
+    WXT_PERSIST,
+    WXT_NOPERSIST,
+    WXT_RAISE,
+    WXT_NORAISE,
+    WXT_CTRL,
+    WXT_NOCTRL,
+    WXT_TITLE,
+    WXT_CLOSE,
+    WXT_ROUNDED,
+    WXT_BUTT,
+    WXT_OTHER
+};
+
+static struct gen_table wxt_opts[] = {
+    {"font",   WXT_FONT},
+    {"enh$anced", WXT_ENHANCED},
+    {"noenh$anced", WXT_NOENHANCED},
+    {"s$ize", WXT_SIZE},
+    {"per$sist", WXT_PERSIST},
+    {"noper$sist", WXT_NOPERSIST},
+    {"rai$se", WXT_RAISE},
+    {"norai$se", WXT_NORAISE},
+    {"ct$rlq", WXT_CTRL},
+    {"noct$rlq", WXT_NOCTRL},
+    {"ti$tle", WXT_TITLE},
+    {"cl$ose", WXT_CLOSE},
+    {"round$ed", WXT_ROUNDED},
+    {"butt", WXT_BUTT},
+    {NULL, WXT_OTHER}
+};
+
+
+/* "Called when terminal type is selected. This procedure should parse options on the command line.
+* A list of the currently selected options should be stored in term_options[],
+* in a form suitable for use with the set term command.
+* term_options[] is used by the save command.  Use options_null() if no options are available." */
+TERM_PUBLIC void wxt_options()
+{
+	char *s = NULL;
+	char *font_setting = NULL;
+	int sep;
+	TBOOLEAN duplication = FALSE;
+	TBOOLEAN set_enhanced = FALSE, set_font = FALSE;
+	TBOOLEAN set_persist = FALSE, set_number = FALSE;
+	TBOOLEAN set_raise = FALSE, set_ctrl = FALSE;
+	TBOOLEAN set_title = FALSE, set_close = FALSE;
+	TBOOLEAN set_capjoin = FALSE, set_size = FALSE;
+
+	while (!END_OF_COMMAND) {
+		FPRINTF((stderr, "processing token\n"));
+		switch (lookup_table(&wxt_opts[0], c_token)) {
+		case WXT_FONT:
+			c_token++;
+			if (!(s = try_to_get_string()))
+				int_error(c_token,"font: expecting string");
+			if (!(*s)) {
+				strcpy (wxt_set_fontname, "");
+				wxt_set_fontsize = 0;
+			} else {
+				sep = strcspn(s,",");
+				if (sep > 0) {
+					strncpy(wxt_set_fontname, s, sep);
+					wxt_set_fontname[sep] = '\0';
+				}
+				if (s[sep] == ',')
+					sscanf(&(s[sep+1]), "%d", &wxt_set_fontsize);
+			}
+			font_setting = (char*) gp_alloc(strlen(s) + 1,"wxt font");
+			strcpy(font_setting,s);
+			free(s);
+			if (set_font) duplication=TRUE;
+			set_font = TRUE;
+			break;
+		case WXT_ENHANCED:
+			c_token++;
+			wxt_enhanced_enabled = TRUE;
+			term->flags |= TERM_ENHANCED_TEXT;
+			if (set_enhanced) duplication=TRUE;
+			set_enhanced = TRUE;
+			break;
+		case WXT_NOENHANCED:
+			c_token++;
+			wxt_enhanced_enabled = FALSE;
+			term->flags &= ~TERM_ENHANCED_TEXT;
+			if (set_enhanced) duplication=TRUE;
+			set_enhanced = TRUE;
+			break;
+		case WXT_SIZE:
+			c_token++;
+			if (END_OF_COMMAND)
+				int_error(c_token,"size requires 'width,heigth'");
+			wxt_width = real_expression();
+			if (!equals(c_token++,","))
+				int_error(c_token,"size requires 'width,heigth'");
+			wxt_height = real_expression();
+			if (wxt_width < 1 || wxt_height < 1)
+				int_error(c_token, "size is out of range");
+			if (set_size) duplication=TRUE;
+			set_size = TRUE;
+			break;
+		case WXT_PERSIST:
+			c_token++;
+			wxt_persist = yes;
+			if (set_persist) duplication=TRUE;
+			set_persist = TRUE;
+			break;
+		case WXT_NOPERSIST:
+			c_token++;
+			wxt_persist = no;
+			if (set_persist) duplication=TRUE;
+			set_persist = TRUE;
+			break;
+		case WXT_RAISE:
+			c_token++;
+			wxt_raise = yes;
+			if (set_raise) duplication=TRUE;
+			set_raise = TRUE;
+			break;
+		case WXT_NORAISE:
+			c_token++;
+			wxt_raise = no;
+			if (set_raise) duplication=TRUE;
+			set_raise = TRUE;
+			break;
+		case WXT_CTRL:
+			c_token++;
+			wxt_ctrl = yes;
+			if (set_ctrl) duplication=TRUE;
+			set_ctrl = TRUE;
+			break;
+		case WXT_NOCTRL:
+			c_token++;
+			wxt_ctrl = no;
+			if (set_ctrl) duplication=TRUE;
+			set_ctrl = TRUE;
+			break;
+		case WXT_TITLE:
+			c_token++;
+			if (!(s = try_to_get_string()))
+				int_error(c_token,"title: expecting string");
+			if (*s)
+				strncpy(wxt_title, s, sizeof(wxt_title));
+			free(s);
+			if (set_title) duplication=TRUE;
+			set_title = TRUE;
+			break;
+		case WXT_CLOSE:
+			c_token++;
+			if (set_close) duplication=TRUE;
+			set_close = TRUE;
+			break;
+		case WXT_ROUNDED:
+			c_token++;
+			if (set_capjoin) duplication=TRUE;
+			wxt_rounded = yes;
+			set_capjoin = TRUE;
+			break;
+		case WXT_BUTT:
+			c_token++;
+			if (set_capjoin) duplication=TRUE;
+			wxt_rounded = no;
+			set_capjoin = TRUE;
+			break;
+		case WXT_OTHER:
+		default:
+			wxt_window_number = int_expression();
+			if (set_number) duplication=TRUE;
+			set_number = TRUE;
+			/*int_error(c_token, "unrecognized terminal option");*/
+			break;
+		}
+
+		if (duplication)
+			int_error(c_token-1, "Duplicated or contradicting arguments in wxt term options.");
+	}
+
+	/* Save options back into options string in normalized format */
+	snprintf(term_options, sizeof(term_options)-strlen(term_options),
+		"%d", wxt_window_number);
+
+	if (set_title) {
+		strncat(term_options, " title \"", sizeof(term_options)-strlen(term_options));
+		strncat(term_options, wxt_title, sizeof(term_options)-strlen(term_options));
+		strncat(term_options, "\"", sizeof(term_options)-strlen(term_options));
+		wxt_update_title(wxt_window_number);
+	}
+
+	if (set_size) {
+		char tmp_term_options[MAX_LINE_LEN+1] = "";
+		snprintf(tmp_term_options, sizeof(tmp_term_options),
+			  " size %d, %d", wxt_width, wxt_height);
+		strncat(term_options, tmp_term_options, sizeof(term_options)-strlen(term_options));
+		wxt_update_size(wxt_window_number);
+	}
+
+	if (set_enhanced)
+		strncat(term_options,
+			wxt_enhanced_enabled ? " enhanced" : " noenhanced",
+			sizeof(term_options)-strlen(term_options));
+
+	if (set_font) {
+		strncat(term_options, " font \"", sizeof(term_options)-strlen(term_options));
+		strncat(term_options, font_setting, sizeof(term_options)-strlen(term_options));
+		strncat(term_options, "\"", sizeof(term_options)-strlen(term_options));
+		free(font_setting);
+	}
+
+	if (set_capjoin)
+		strncat(term_options, wxt_rounded ? " rounded" : " butt",
+			sizeof(term_options)-strlen(term_options));
+
+	if (set_persist)
+		strncat(term_options,
+			(wxt_persist==yes) ? " persist" : " nopersist",
+			sizeof(term_options)-strlen(term_options));
+
+	if (set_raise)
+		strncat(term_options,
+			(wxt_raise==yes) ? " raise" : " noraise",
+			sizeof(term_options)-strlen(term_options));
+
+	if (set_ctrl)
+		strncat(term_options,
+			(wxt_ctrl==yes) ? " ctrl" : " noctrl",
+			sizeof(term_options)-strlen(term_options));
+
+	if (set_close)
+		wxt_close_terminal_window(wxt_window_number);
+}
+
+/* wxt_text() will do most of the work, but we have to pass it axis scaling
+ * info via a global structure that is loaded here.  The axis scaling is
+ * so that subsequent mouse events can be transformed into plot
+ * coordinates even though the plot is no longer active.
+ */
+TERM_PUBLIC void wxt_text_wrapper()
+{
+    int i;
+
+#ifdef USE_MOUSE
+	int axis_order[4] = {FIRST_X_AXIS, FIRST_Y_AXIS, SECOND_X_AXIS, SECOND_Y_AXIS};
+	wxt_axis_mask = 0;
+
+	for (i=0; i<4; i++) {
+		if (axis_array[axis_order[i]].ticmode != NO_TICS)
+		    wxt_axis_mask |= (1 << i);
+	}
+
+	for (i=0; i<4; i++) {
+		wxt_axis_state[i].min = axis_array[axis_order[i]].min;
+		wxt_axis_state[i].term_lower = axis_array[axis_order[i]].term_lower;
+		wxt_axis_state[i].term_scale = axis_array[axis_order[i]].term_scale;
+		wxt_axis_state[i].logbase = axis_array[axis_order[i]].log
+			? axis_array[axis_order[i]].log_base : 0;
+	}
+#endif
+
+    wxt_text();
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+TERM_TABLE_START (wxt_driver)
+    "wxt", "wxWidgets cross-platform windowed terminal",
+    /* the following values are overriden by wxt_graphics */
+    1 /* xmax */ , 1 /* ymax */ , 1 /* vchar */ , 1 /* hchar */ ,
+    1 /* vtic */ , 1 /* htic */ ,
+    wxt_options, wxt_init, wxt_reset, wxt_text_wrapper, null_scale, wxt_graphics,
+    wxt_move, wxt_vector, wxt_linetype, wxt_put_text,
+    wxt_text_angle, wxt_justify_text,
+    wxt_point, do_arrow, wxt_set_font,
+    wxt_pointsize,
+    TERM_CAN_MULTIPLOT|TERM_NO_OUTPUTFILE|TERM_ALPHA_CHANNEL,
+    wxt_text /* suspend */, 0 /* resume */, wxt_fillbox, wxt_linewidth
+#ifdef USE_MOUSE
+    , wxt_waitforinput, wxt_put_tmptext, wxt_set_ruler, wxt_set_cursor, wxt_set_clipboard
+#endif
+    , wxt_make_palette, 0 /* wxt_previous_palette */, wxt_set_color, wxt_filled_polygon
+    , wxt_image
+    , wxt_enhanced_open, wxt_enhanced_flush, wxt_enhanced_writec
+TERM_TABLE_END (wxt_driver)
+
+#undef LAST_TERM
+#define LAST_TERM wxt_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(wxt)
+"1 wxt",
+"?set terminal wxt",
+"?terminal wxt",
+"?set term wxt",
+"?term wxt",
+"?wxt",
+" The `wxt` terminal device generates output in a separate window. The window",
+" is created by the wxWidgets library, where the 'wxt' comes from. The actual",
+" drawing is done via cairo, a 2D graphics library, and pango, a library for",
+" laying out and rendering text.",
+"",
+" Syntax:",
+"         set term wxt {<n>}",
+"                      {size <width>,<height>}",
+"                      {{no}enhanced}",
+"                      {font <font>}",
+"                      {title \"title\"}",
+"                      {{no}persist}",
+"                      {{no}raise}",
+"                      {{no}ctrl}",
+"                      {close}",
+"",
+" Multiple plot windows are supported: `set terminal wxt <n>` directs the",
+" output to plot window number n.",
+"",
+" The default window title is based on the window number. This title can also",
+" be specified with the keyword \"title\".",
+"",
+" Plot windows remain open even when the `gnuplot` driver is changed to a",
+" different device.  A plot window can be closed by pressing the letter 'q'",
+" while that window has input focus, by choosing `close` from a window",
+" manager menu, or with `set term wxt <n> close`.",
+"",
+" The size of the plot area is given in pixels, it defaults to 640x384.",
+" In addition to that, the actual size of the window also includes the space",
+" reserved for the toolbar and the status bar.",
+" When you resize a window, the plot is immediately scaled to fit in the",
+" new size of the window. Unlike other interactive terminals, the `wxt`",
+" terminal scales the whole plot, including fonts and linewidths, and keeps",
+" its global aspect ratio constant, leaving an empty space painted in gray.",
+" If you type `replot`, click the `replot` icon in the terminal toolbar or",
+" type a new `plot` command, the new plot will completely fit in the window",
+" and the font size and the linewidths will be reset to their defaults.",
+"",
+" The active plot window (the one selected by `set term wxt <n>`) is",
+" interactive. Its behaviour is shared with other terminal types. See `mouse`",
+" for details. It also has some extra icons, which are supposed to be",
+" self-explanatory.",
+"",
+" This terminal supports an enhanced text mode, which allows font and other",
+" formatting commands (subscripts, superscripts, etc.) to be embedded in labels",
+" and other text strings. The enhanced text mode syntax is shared with other",
+" gnuplot terminal types. See `enhanced` for more details.",
+"",
+" <font> is in the format \"FontFace,FontSize\", i.e. the face and the size",
+" comma-separated in a single string. FontFace is a usual font face name, such",
+" as \'Arial\'. If you do not provide FontFace, the wxt terminal will use",
+" \'Sans\'. FontSize is the font size, in points. If you do not provide it,",
+" the wxt terminal will use a size of 10 points.",
+"    For example :",
+"       set term wxt font \"Arial,12\"",
+"       set term wxt font \"Arial\" # to change the font face only",
+"       set term wxt font \",12\" # to change the font size only",
+"       set term wxt font \"\" # to reset the font name and size",
+"",
+" The fonts are retrieved from the usual fonts subsystems. Under Windows,",
+" those fonts are to be found and configured in the entry \"Fonts\" of the",
+" control panel. Under UNIX, they are handled by \"fontconfig\".",
+"",
+" Pango, the library used to layout the text, is based on utf-8. Thus, the wxt",
+" terminal has to convert from your encoding to utf-8. The default input",
+" encoding is based on your \'locale\'. If you want to use another encoding,",
+" make sure gnuplot knows which one you are using. See `encoding` for more",
+" details.",
+"",
+" Pango may give unexpected results with fonts that do not respect the unicode",
+" mapping. With the Symbol font, for example, the wxt terminal will use the map",
+" provided by http://www.unicode.org/ to translate character codes to unicode.",
+" Pango will do its best to find a font containing this character, looking for",
+" your Symbol font, or other fonts with a broad unicode coverage, like the",
+" DejaVu fonts. Note that \"the Symbol font\" is to be understood as the Adobe",
+" Symbol font, distributed with Acrobat Reader as \"SY______.PFB\".",
+" Alternatively, the OpenSymbol font, distributed with OpenOffice.org as",
+" \"opens___.ttf\", offers the same characters. Microsoft has distributed a",
+" Symbol font (\"symbol.ttf\"), but it has a different character set with",
+" several missing or moved mathematic characters. If you experience problems",
+" with your default setup (if the demo enhancedtext.dem is not displayed",
+" properly for example), you probably have to install one of the Adobe or",
+" OpenOffice Symbol fonts, and remove the Microsoft one.",
+" Other non-conform fonts, such as \"wingdings\" have been observed working.",
+"",
+" The rendering of the plot can be altered with a dialog available from the",
+" toolbar. To obtain the best output possible, the rendering involves three",
+" mechanisms : antialiasing, oversampling and hinting.",
+" Antialiasing allows to display non-horizontal and non-vertical lines",
+" smoother.",
+" Oversampling combined with antialiasing provides subpixel accuracy,",
+" so that gnuplot can draw a line from non-integer coordinates. This avoids",
+" wobbling effects on diagonal lines ('plot x' for example).",
+" Hinting avoids the blur on horizontal and vertical lines caused by",
+" oversampling. The terminal will snap these lines to integer coordinates so",
+" that a one-pixel-wide line will actually be drawn on one and only one pixel.",
+"",
+" By default, the window is raised to the top of your desktop when a plot is",
+" drawn. This can be controlled with the keyword \"raise\".",
+" The keyword \"persist\" will prevent gnuplot from exiting before you",
+" explicitely close all the plot windows.",
+" Finally, by default the key <space> raises the gnuplot console window, and",
+" 'q' closes the plot window. The keyword \"ctrl\" allows you to replace those",
+" bindings by <ctrl>+<space> and <ctrl>+'q', respectively.",
+" These three keywords (raise, persist and ctrl) can also be set and remembered",
+" between sessions through the configuration dialog."
+END_HELP(wxt)
+#endif /* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/x11.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/x11.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/x11.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/x11.trm.svn-base	2012-01-03 17:07:48.220025900 -0800
@@ -0,0 +1,2664 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: x11.trm,v 1.184.2.1 2009/09/13 17:54:09 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - x11.trm */
+
+/*[
+ * Copyright 1986 - 1993, 1998, 2004   Thomas Williams, Colin Kelley
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ *    x11.trm  --- inboard terminal driver for X11
+ */
+
+/* Petr Mikulik and Johannes Zellner: added mouse support (October 1999)
+ * Implementation and functionality is based on pm.trm
+ */
+
+/* X11 support for Petr Mikulik's pm3d
+ * by Johannes Zellner <johannes@zellner.org>
+ * (November 1999 - January 2000)
+ */
+
+/* Dynamic font support, enhanced text mode support,
+ * additional feedback from outboard driver
+ * Ethan A Merritt <merritt@u.washington.edu>
+ * 2003
+ */
+
+/* Daniel Sebald: added X11 support for images. (27 February 2003)
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(x11)
+#endif
+
+#ifdef TERM_PROTO
+int X11_args __PROTO((int argc, char *argv[]));
+
+TERM_PUBLIC void X11_options __PROTO((void));
+TERM_PUBLIC void X11_init __PROTO((void));
+TERM_PUBLIC void X11_graphics __PROTO((void));
+TERM_PUBLIC void X11_text __PROTO((void));
+TERM_PUBLIC int  X11_set_font __PROTO((const char * fontname));
+TERM_PUBLIC void X11_reset __PROTO((void));
+TERM_PUBLIC void X11_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void X11_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void X11_linewidth __PROTO((double lw));
+TERM_PUBLIC void X11_pointsize __PROTO((double ps));
+TERM_PUBLIC void X11_linetype __PROTO((int lt));
+TERM_PUBLIC void X11_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
+TERM_PUBLIC int X11_text_angle __PROTO((int i));
+TERM_PUBLIC int X11_justify_text __PROTO((enum JUSTIFY mode));
+TERM_PUBLIC void X11_point __PROTO((unsigned int x, unsigned int y, int number));
+TERM_PUBLIC void X11_fillbox __PROTO((int style, unsigned int x, unsigned int y, unsigned int width, unsigned int height));
+
+TERM_PUBLIC void X11_send_endianess __PROTO((void));
+
+# ifdef USE_MOUSE
+TERM_PUBLIC int X11_waitforinput __PROTO((void));
+TERM_PUBLIC void X11_set_ruler __PROTO((int, int));
+TERM_PUBLIC void X11_set_cursor __PROTO((int, int, int));
+TERM_PUBLIC void X11_put_tmptext __PROTO((int, const char str[]));
+TERM_PUBLIC void X11_set_clipboard __PROTO((const char[]));
+# endif
+
+TERM_PUBLIC void X11_update_opts __PROTO((void));
+TERM_PUBLIC int X11_make_palette __PROTO((t_sm_palette *));
+TERM_PUBLIC void X11_set_color __PROTO((t_colorspec *));
+TERM_PUBLIC void X11_filled_polygon __PROTO((int, gpiPoint *));
+
+TERM_PUBLIC void X11_image __PROTO((unsigned int, unsigned int, coordval *, gpiPoint *, t_imagecolor));
+
+/* To support "set term x11 enhanced" */
+TERM_PUBLIC void ENHX11_put_text __PROTO((unsigned int x, unsigned int y, const char str[]));
+TERM_PUBLIC void ENHX11_OPEN __PROTO((char * fontname, double fontsize,
+				double base, TBOOLEAN widthflag, TBOOLEAN showflag,
+				int overprint));
+TERM_PUBLIC void ENHX11_FLUSH __PROTO((void));
+
+# define X11_XMAX 4096
+# define X11_YMAX 4096
+
+static int X11_SIZE_X = 640;
+static int X11_SIZE_Y = 450;
+static int X11_POSITION_X = 0;
+static int X11_POSITION_Y = 0;
+
+/* approximations for typical font/screen sizes */
+# define X11_VCHAR (X11_YMAX/25)
+# define X11_HCHAR (X11_XMAX/100)
+# define X11_VTIC (X11_YMAX/100)
+# define X11_HTIC (X11_XMAX/150)
+#endif	/* TERM_PROTO */
+
+
+#ifndef TERM_PROTO_ONLY
+
+#ifdef TERM_BODY
+
+#include "gplt_x11.h"
+
+/* non-zero if '-display' found on command line */
+static int X11_Display = 0;
+
+/* Fonts can have very long names */
+/* EAM FIXME - these should be dynamically allocated */
+#define X11_MAX_FONTNAME_LENGTH 255
+static char X11_default_font[X11_MAX_FONTNAME_LENGTH+1] = {'\0'};
+static int  X11_default_fontsize = 12;
+static char X11_last_font_used[X11_MAX_FONTNAME_LENGTH+1] = {'\01','\0'};
+static char X11_next_font_used[X11_MAX_FONTNAME_LENGTH+1] = {'\0'};
+static enum JUSTIFY X11_last_justification = LEFT;
+
+static void X11_atexit __PROTO((void));
+static void X11_set_default_font __PROTO((void));
+
+static void transmit_gradient __PROTO((gradient_struct *gradient, int cnt));
+
+/* Merged the old char X11_opts[] and int X11_optarg[]
+ * into one array of structs.
+ * Loosely based on XrmOptionDescRec, the use of which
+ * would probably be overkill here. */
+typedef enum { hasNoArg, hasArg } OptionArg;
+
+static struct x11opt {
+    const char *option;		/* Name of option */
+    OptionArg arg;		/* Whether option has argument */
+} X11_cmdopts[] = {
+    { "-mono", hasNoArg}, { "-gray", hasNoArg}, { "-clear", hasNoArg},
+    { "-tvtwm", hasNoArg}, { "-pointsize", hasArg},
+    { "-iconic", hasNoArg}, { "-rv", hasNoArg},
+    { "-reverse", hasNoArg}, { "+rv", hasNoArg},
+    { "-synchronous", hasNoArg},
+    { "-display", hasArg}, { "-geometry", hasArg}, { "-bg", hasArg},
+    { "-background", hasArg}, { "-bd", hasArg},
+    { "-bordercolor", hasArg}, { "-bw", hasArg},
+    { "-borderwidth", hasArg}, { "-fg", hasArg},
+    { "-foreground", hasArg}, { "-fn", hasArg}, { "-font", hasArg},
+    { "-name", hasArg},
+    { "-selectionTimeout", hasArg}, { "-title", hasArg},
+    { "-xnllanguage", hasArg}, { "-xrm", hasArg},
+    { "-raise", hasNoArg}, { "-noraise", hasNoArg},
+    { "-solid", hasNoArg}, { "-dashed", hasNoArg}
+#ifdef USE_MOUSE
+    , { "-nofeedback", hasNoArg}
+    , { "-noevents", hasNoArg}
+    , { "-ctrlq", hasNoArg}
+#endif
+};
+
+#define X11_nopts (sizeof(X11_cmdopts) / sizeof(X11_cmdopts[0]))
+
+static FILE *X11_ipc = (FILE *) 0;
+#ifdef PIPE_IPC
+#define X11_ipc_back_fd ipc_back_fd
+#endif
+
+static char **xargv = (char **) NULL;
+/* reserve a minimum 10 driver opts */
+static char *optvec[2 * X11_nopts + 1 + 10];
+
+/* gnuplot_x11 has extension .exe on OS/2 and Windows (and on RSX/VMS, but
+   these construct their own full path GNUPLOT_X11 in their build script).
+*/
+# if defined(OS2) || defined(_Windows)
+#   ifndef GNUPLOT_X11
+static char X11_default_command[] = "gnuplot_x11.exe";
+#   else
+static char X11_default_command[] = GNUPLOT_X11 ".exe";
+#   endif
+# else  /* thus !OS/2 && !Windows */
+#   ifndef GNUPLOT_X11
+static char X11_default_command[] = "gnuplot_x11";
+#   else
+static char X11_default_command[] = GNUPLOT_X11;
+#   endif
+# endif	/* OS/2 || Windows */
+
+static char *X11_command = X11_default_command;
+static char *X11_command_parsed = NULL;
+static char *X11_full_command_path = NULL;
+
+/* must match the definition in src/gplt_x11.c: */
+static int persist = UNSET;
+static int do_raise = UNSET;
+static int dashedlines = UNSET;
+static int ctrlq = UNSET;
+static int set_size = UNSET;
+static int set_position = UNSET;
+
+/* driver properties managed by x11.trm rather than gnuplot_x11 */
+static double X11_linewidth_multiplier = 1.0;
+
+#ifdef USE_MOUSE
+/* Interlock to prevent the mouse channel from being coopted more than
+ * once per plot by the gnuplot_x11<->x11.trm font information query.
+ */
+static TBOOLEAN default_font_size_known = FALSE;
+static TBOOLEAN X11_MOUSE_FEEDBACK = TRUE;
+#endif
+#ifdef PIPE_IPC
+static TBOOLEAN IPC_LOCK = FALSE;
+#endif
+
+static int parse_driver __PROTO((const char *));
+
+static int
+parse_driver(const char *cmd)
+{
+    int nr = 0;
+    char *ptr;
+
+    /* make a copy of cmd, as parsing will modify the string */
+    X11_command_parsed = gp_realloc(X11_command_parsed,
+				    strlen(cmd) + 1, "x11->parse_driver");
+    strcpy(X11_command_parsed, X11_command);
+    ptr = X11_command_parsed;
+
+    while (*ptr != '\0' && nr < sizeof(optvec) / sizeof(char)) {
+
+	/* Strip whitespace.  Use nulls, so that
+	 * the previous argument is terminated
+	 * automatically.
+	 */
+	while (isspace((unsigned char)*ptr))
+	    *ptr++ = '\0';
+
+	if (!(*ptr))		/* don't count the terminating NULL */
+	    break;
+
+	/* Save the argument. */
+	optvec[nr++] = ptr;
+
+	/* Skip over the argument. */
+	while ('\0' != *ptr && !isspace((unsigned char)*ptr)) {
+	    ptr++;
+	}
+    }
+
+    /* HBB 20020214: new code to prepend the environment X11_DRIVER_DIR
+     * to the command name, if it doesn't contain any slashes yet */
+    if (!strchr(optvec[0],'/')) {
+	char *dir = getenv("GNUPLOT_DRIVER_DIR");
+
+	if (!dir)
+	    dir = X11_DRIVER_DIR;
+#ifndef OS2
+	if (dir[0] != '/' && dir[0] != '.') {
+	    /* Can't call int_error because longjump has not been set up yet */
+	    int_warn(NO_CARET, "Illegal X11 driver directory name! Using default");
+	    dir = "";
+	}
+#endif
+	X11_full_command_path = gp_realloc(X11_full_command_path,
+					   strlen(dir) + strlen(optvec[0]) + 2,
+					   "x11 driver pathname");
+	/* optvec[0] = X11_full_command_path; */
+	if (*dir)
+	    sprintf(X11_full_command_path, "%s/%s", dir, optvec[0]);
+	else
+	    sprintf(X11_full_command_path, "%s", optvec[0]);
+    }
+
+    return nr;
+}
+
+/*   X11_args - scan gnuplot command line for standard X Toolkit options
+ * called from plot.c so must not be TERM_PUBLIC (which may be static)
+ */
+
+int
+X11_args(int argc, char *argv[])
+{
+    int nx11 = 0, i, n;
+
+    xargv = (char **) gp_alloc(argc * sizeof(char *), "<xargv>");
+
+    if (!xargv) {
+	fputs("not enough memory to copy argv - quitting\n", stderr);
+	exit(EXIT_FAILURE);
+    }
+
+    /* We make a copy of the argument vector because
+     * argv is modified later. */
+    memcpy(xargv, argv, argc * sizeof(char *));
+    i = parse_driver(X11_command);
+
+    if (persist_cl) {
+	optvec[i++] = "-persist";
+    }
+
+    while (++argv, ++xargv, --argc > 0) {
+	if (!strcmp(*argv,"--persist") || !strncmp(*argv,"-p",2)) {
+	    nx11++;
+	    continue;
+	}
+	for (n = 0; n < X11_nopts; n++) {
+	    if (strcmp(*argv, X11_cmdopts[n].option) == 0) {
+		optvec[i++] = *xargv;
+#ifdef USE_MOUSE
+		if (strcmp(*argv, "-nofeedback") == 0)
+		    X11_MOUSE_FEEDBACK = FALSE;
+#endif
+		if (strcmp(*argv, "-display") == 0)
+		    X11_Display++;
+		if (X11_cmdopts[n].arg == hasArg) {
+		    if (--argc <= 0)
+			return nx11;
+		    optvec[i++] = *++xargv, ++argv;
+		    nx11++;
+		}
+		if (i >= (sizeof(optvec) / sizeof(char))) {
+		    fprintf(stderr, "warning: X11 options will be truncated\n");
+		    return nx11;	/* optvec is full */
+		}
+		nx11++;
+		break;
+	    }
+	}
+	if (n == X11_nopts)
+	    break;
+    }
+
+    return (nx11);
+}
+
+
+enum X11_id {
+    X11_RESET,
+    X11_CLOSE,
+    X11_PERSIST,
+    X11_NOPERSIST,
+    X11_RAISE,
+    X11_NORAISE,
+    X11_FONT,
+    X11_TITLE,
+    X11_ENHANCED,
+    X11_NOENHANCED,
+    X11_SOLID,
+    X11_DASHED,
+    X11_LINEWIDTH,
+    X11_CTRLQ,
+    X11_NOCTRLQ,
+    X11_SIZE,
+    X11_POSITION,
+#ifdef EXTERNAL_X11_WINDOW
+    X11_WINDOW,
+#endif
+    X11_OTHER
+};
+
+static struct gen_table X11_opts[] = {
+    {"res$et", X11_RESET},
+    {"cl$ose", X11_CLOSE},
+    {"per$sist", X11_PERSIST},
+    {"noper$sist", X11_NOPERSIST},
+    {"rai$se", X11_RAISE},
+    {"norai$se", X11_NORAISE},
+    {"font",   X11_FONT},
+    {"fn$ame", X11_FONT},
+    {"ti$tle", X11_TITLE},
+    {"enh$anced", X11_ENHANCED},
+    {"noenh$anced", X11_NOENHANCED},
+    {"solid", X11_SOLID},
+    {"dash$ed", X11_DASHED},
+    {"linew$idth", X11_LINEWIDTH},
+    {"lw", X11_LINEWIDTH},
+    {"ctrl$q", X11_CTRLQ},
+    {"noctrl$q", X11_NOCTRLQ},
+    {"si$ze", X11_SIZE},
+    {"pos$ition", X11_POSITION},
+#ifdef EXTERNAL_X11_WINDOW
+    {"w$indow", X11_WINDOW},
+#endif
+    {NULL, X11_OTHER}
+};
+
+
+TERM_PUBLIC void
+X11_options()
+{
+
+#define NOT_PROCESS_IF_DUPLICATION 1
+
+    int c_title_token = 0;
+    int new_term_number = 0;
+    TBOOLEAN duplication = FALSE;
+    TBOOLEAN set_reset = FALSE, set_persist = FALSE, set_raise = FALSE, set_font = FALSE;
+    TBOOLEAN set_ctrlq = FALSE;
+    TBOOLEAN set_title = FALSE, set_number = FALSE, set_close = FALSE, set_solid = FALSE;
+#ifdef EXTERNAL_X11_WINDOW
+    unsigned long existing_X11_window_id = 0;
+    TBOOLEAN set_window = FALSE;
+#endif
+
+    do_raise = dashedlines = ctrlq = UNSET;
+    set_size = set_position = UNSET;
+    persist = persist_cl;	/* previously set from command line */
+
+    while (!END_OF_COMMAND) {
+	switch (lookup_table(&X11_opts[0], c_token)) {
+	case X11_RESET:
+	    c_token++;
+	    if (set_reset) duplication=TRUE;
+	    set_reset = TRUE;
+	    break;
+	case X11_CLOSE:
+	    c_token++;
+	    if (set_close) duplication=TRUE;
+	    set_close = TRUE;
+	    break;
+	case X11_PERSIST:
+	    persist = yes;
+	    c_token++;
+	    if (set_persist) duplication=TRUE;
+	    set_persist = TRUE;
+	    break;
+	case X11_NOPERSIST:
+	    persist = no;
+	    c_token++;
+	    if (set_persist) duplication=TRUE;
+	    set_persist = TRUE;
+	    break;
+	case X11_CTRLQ:
+	    ctrlq = yes;
+	    c_token++;
+	    if (set_ctrlq) duplication=TRUE;
+	    set_ctrlq = TRUE;
+	    break;
+	case X11_NOCTRLQ:
+	    ctrlq = no;
+	    c_token++;
+	    if (set_ctrlq) duplication=TRUE;
+	    set_ctrlq = TRUE;
+	    break;
+	case X11_SOLID:
+	    dashedlines = FALSE;
+	    c_token++;
+	    if (set_solid) duplication=TRUE;
+	    set_solid = TRUE;
+	    break;
+	case X11_DASHED:
+	    dashedlines = TRUE;
+	    c_token++;
+	    if (set_solid) duplication=TRUE;
+	    set_solid = TRUE;
+	    break;
+	case X11_LINEWIDTH:
+	    c_token++;
+	    X11_linewidth_multiplier = real_expression();
+	    if (X11_linewidth_multiplier <= 0)
+		X11_linewidth_multiplier = 1.0;
+	    break;
+	case X11_RAISE:
+	    do_raise = yes;
+	    c_token++;
+	    if (set_raise) duplication=TRUE;
+	    set_raise = TRUE;
+	    break;
+	case X11_NORAISE:
+	    do_raise = no;
+	    c_token++;
+	    if (set_raise) duplication=TRUE;
+	    set_raise = TRUE;
+	    break;
+	case X11_FONT:
+	    c_token++;
+	    if (END_OF_COMMAND)
+		int_error(c_token, "expecting font name");
+	    if (isstringvalue(c_token)) {
+		char *s = try_to_get_string();
+		strncpy(X11_default_font, s, sizeof(X11_default_font));
+		free(s);
+	    } else {
+		copy_str(X11_default_font, c_token, sizeof(X11_default_font));
+		c_token++;
+	    }
+	    if (strchr(X11_default_font,','))
+		sscanf(strchr(X11_default_font,',')+1, "%d",
+			&X11_default_fontsize);
+	    if (set_font) duplication=TRUE;
+	    set_font = TRUE;
+	    break;
+	case X11_TITLE:
+	    c_token++;
+	    if (END_OF_COMMAND)
+		int_error(c_token, "expecting title text");
+	    c_title_token = c_token;
+	    c_token++;
+	    if (set_title) duplication=TRUE;
+	    set_title = TRUE;
+	    break;
+	case X11_ENHANCED:
+	    term->put_text = ENHX11_put_text;
+	    term->flags |= TERM_ENHANCED_TEXT;
+	    c_token++;
+	    break;
+	case X11_NOENHANCED:
+	    term->put_text = X11_put_text;
+	    term->flags &= ~TERM_ENHANCED_TEXT;
+	    c_token++;
+	    break;
+	case X11_SIZE:
+	    c_token++;
+	    if (END_OF_COMMAND) {
+		int_error(c_token, "expecting X[,Y]");
+	    } else {
+		int x_in, y_in;
+		x_in = int_expression();
+		if (x_in > 0)
+		    X11_SIZE_X = x_in;
+		else
+		    int_error(c_token, "X size must be > 0");
+		if (equals(c_token, ",")) {
+		    c_token++;
+		    y_in = int_expression();
+		    if (y_in > 0)
+			X11_SIZE_Y = y_in;
+		    else
+			int_error(c_token, "Y size must be > 0");
+		}
+		set_size = yes;
+	    }
+	    break;
+	case X11_POSITION:
+	    c_token++;
+	    if (END_OF_COMMAND) {
+		int_error(c_token, "expecting X[,Y]");
+	    } else {
+		X11_POSITION_X = int_expression();
+		if (equals(c_token, ",")) {
+		    c_token++;
+		    X11_POSITION_Y = int_expression();
+		}
+		set_position = yes;
+	    }
+	    break;
+
+#ifdef EXTERNAL_X11_WINDOW
+	case X11_WINDOW:
+	{
+	    char *windowid;
+	    c_token++;
+	    if (!(windowid = try_to_get_string()))
+		int_error(c_token, "expecting X window ID as string in hex");
+	    sscanf(windowid,"%lx",&existing_X11_window_id);
+	    free(windowid);
+	    if (!existing_X11_window_id)
+		int_error(c_token, "expecting X window ID as string in hex");
+	    if (set_window) duplication=TRUE;
+	    set_window = TRUE;
+	    break;
+	}
+#endif
+	case X11_OTHER:
+	default:
+	    if (set_number) duplication=TRUE;
+	    /* let gnuplot_x11 check range */
+	    new_term_number = int_expression();
+	    if (new_term_number < 0)
+		int_error(c_token, "plot number must be non-negative");
+	    set_number = TRUE;
+	    break;
+	}
+
+	if (duplication) {
+	    int_error(c_token-1, "duplicated or contradicting arguments in X11 term options");
+	}
+
+    }
+
+
+    /* Call own init routine; this might be xlib rather than x11 */
+    term->init();
+
+    if (set_reset)
+	X11_atexit();	/* tell gnuplot_x11 to shut down */
+
+    /* Leave the current window unchanged when closing an old window */
+    if (X11_ipc) {
+	if (set_close) {
+	    fprintf(X11_ipc, (set_number ? "C%d\n" : "C\n"), new_term_number);
+	    fflush(X11_ipc);
+	} else if (set_number) {
+#ifdef EXTERNAL_X11_WINDOW
+	    if (set_window)
+		int_error(NO_CARET,"an existing X11 window cannot be asigned to a plot number");
+#endif
+	    fprintf(X11_ipc, "N%d\n", new_term_number);
+	    fflush(X11_ipc);
+#ifdef EXTERNAL_X11_WINDOW
+	} else if (set_window) {
+	    fprintf(X11_ipc, "%c%lx\n", X11_GR_SET_WINDOW_ID, existing_X11_window_id);
+	    fflush(X11_ipc);
+#endif
+	}
+    }
+
+#ifdef EXTERNAL_X11_WINDOW
+    if (set_window) {
+	sprintf(term_options, "XID 0x%lX", existing_X11_window_id);
+    } else
+#endif
+    if (set_number && new_term_number >= 0) {
+	sprintf(term_options, "%d", new_term_number);
+    }
+    if (UNSET != do_raise) {
+	strcat(term_options, (yes == do_raise ? " raise" : " noraise"));
+    }
+    if (UNSET != persist) {
+	strcat(term_options, (yes == persist ? " persist" : " nopersist"));
+    }
+    if (UNSET != ctrlq) {
+	strcat(term_options, (yes == ctrlq ? " ctrlq" : " noctrlq"));
+    }
+    if (UNSET != dashedlines) {
+	strcat(term_options, (yes == dashedlines ? " dashed" : " solid"));
+    }
+    if (term->put_text == ENHX11_put_text) {
+	strcat(term_options, " enhanced");
+    }
+    if (X11_linewidth_multiplier != 1.0) {
+	sprintf(term_options + strlen(term_options),
+		" linewidth %.2g", X11_linewidth_multiplier);
+    }
+    if (*X11_default_font) {
+	strcat(term_options, " font \"");
+	strcat(term_options, X11_default_font);
+	strcat(term_options, "\"");
+    }
+    if (set_title) {
+	char *title;
+	int save_token = c_token;
+	c_token = c_title_token;
+	strncat(term_options, " title \"", MAX_LINE_LEN-strlen(term_options));
+	title = term_options + strlen(term_options);
+	if (isstringvalue(c_title_token)) {
+	    char *s = try_to_get_string();
+	    strncat(term_options, s, MAX_LINE_LEN-strlen(term_options));
+	    free(s);
+	} else
+	    copy_str(term_options+strlen(term_options), c_title_token, MAX_LINE_LEN-strlen(term_options));
+	if (X11_ipc) {
+	    /* Send up to maximum buffer length minus three characters of
+	     * title string to account for required 'n', '\0', '\n'.
+	     */
+	    int i;
+	    fputc('n', X11_ipc);
+	    for (i=0; i < X11_COMMAND_BUFFER_LENGTH-3 && title[i] != '\0'; i++)
+		fputc(title[i], X11_ipc);
+	    fputc('\0', X11_ipc);
+	    fputc('\n', X11_ipc);
+	    fflush(X11_ipc);
+	}
+	strncat(term_options, "\"", MAX_LINE_LEN-strlen(term_options));
+	c_token = save_token;
+    }
+    if (set_size != UNSET)
+	sprintf(term_options + strlen(term_options),
+	      " size %d,%d ", X11_SIZE_X,X11_SIZE_Y);
+
+    if (set_position != UNSET)
+	sprintf(term_options + strlen(term_options),
+	      " position %d,%d ", X11_POSITION_X,X11_POSITION_Y);
+
+    X11_update_opts();
+}
+
+
+void
+x11_raise_terminal_window(int number)
+{
+    /* Send the raise character and a number. */
+    if (X11_ipc) {
+	fprintf(X11_ipc, "^%d\n", number);
+	fflush(X11_ipc);
+    }
+}
+
+void
+x11_raise_terminal_group(void)
+{
+    /* Send just the raise character. */
+    if (X11_ipc) {
+	fprintf(X11_ipc, "^\n");
+	fflush(X11_ipc);
+    }
+}
+
+void
+x11_lower_terminal_window(int number)
+{
+    /* Send the raise character and a number. */
+    if (X11_ipc) {
+	fprintf(X11_ipc, "v%d\n", number);
+	fflush(X11_ipc);
+    }
+}
+
+void
+x11_lower_terminal_group(void)
+{
+    /* Send just the raise character. */
+    if (X11_ipc) {
+	fprintf(X11_ipc, "v\n");
+	fflush(X11_ipc);
+    }
+}
+
+
+TERM_PUBLIC void
+X11_update_opts()
+{
+    if (!X11_ipc)
+	return;
+
+    if (UNSET != do_raise || UNSET != persist || UNSET != dashedlines || UNSET != ctrlq) {
+	fprintf(X11_ipc, "X %d %d %d %d\n", 
+		do_raise, persist, dashedlines, ctrlq);
+	fflush(X11_ipc);
+    }
+
+    /* pass size as a valid X11 geometry string WIDTHxHEIGHT[+XPOS+YPOS] */
+    if (set_size != UNSET || set_position != UNSET) {
+	if (set_size != UNSET && set_position == UNSET)
+	    fprintf(X11_ipc, "s %dx%d\n", X11_SIZE_X, X11_SIZE_Y);
+	else if (set_size == UNSET && set_position != UNSET)
+	    fprintf(X11_ipc, "s %+d%+d\n", X11_POSITION_X, X11_POSITION_Y);
+	else if (set_size != UNSET && set_position != UNSET)
+	    fprintf(X11_ipc, "s %dx%d%+d%+d\n", X11_SIZE_X, X11_SIZE_Y,
+		X11_POSITION_X, X11_POSITION_Y);
+	fflush(X11_ipc);
+    }
+}
+
+
+/*-----------------------------------------------------------------------------
+ *   Three different versions of the remainder of the X11 terminal driver
+ *   are provided to support three different types of IPC with the
+ *   gnuplot_x11 outboard terminal driver:
+ *
+ *   DEFAULT_X11:      popen() pipe for most un*x platforms
+ *
+ *   CRIPPLED_SELECT : file IPC for un*x platforms with incomplete or faulty
+ *                     implementation of BSD select()
+ *
+ *   VMS :             mailbox/spawn IPC
+ *---------------------------------------------------------------------------*/
+
+#define DEFAULT_X11
+#if defined(VMS) || defined(CRIPPLED_SELECT)
+# undef DEFAULT_X11
+#endif
+#if defined(VMS) && defined(CRIPPLED_SELECT)
+Error.Incompatible options.
+#endif
+/* we do not want to have to duplicate all the code, so we
+ * do most of it with macros.
+ * PRINT0(format), PRINT1(format, p1), PRINT2(format, p1, p2) etc
+ * also  FLUSH0(format), etc, which do an additional flush
+ */
+#ifdef DEFAULT_X11
+/*-----------------------------------------------------------------------------
+ *   DEFAULT_X11 popen() pipe IPC
+ *---------------------------------------------------------------------------*/
+static void
+X11_atexit()
+{
+    if (X11_ipc) {
+	fputs("R\n", X11_ipc);
+	fclose(X11_ipc);
+	/* dont wait(), since they might be -persist */
+	X11_ipc = NULL;
+#ifdef PIPE_IPC
+	close(ipc_back_fd);
+	ipc_back_fd = -1;
+#endif
+    }
+}
+
+#ifdef USE_MOUSE
+
+TERM_PUBLIC int
+X11_waitforinput()
+{
+#ifdef PIPE_IPC
+    fd_set fds;
+    static struct gp_event_t ge;
+    static int l = 0;
+    int n;
+    int fd = fileno(stdin);
+    int repeat_count = 0;
+
+AGAIN:
+    /* XXX:  if the input device it not a tty (e.g. /dev/null)
+     *       mouse events are not processed. This is necessary
+     *       as on some systems /dev/null is not selectable.
+     * TODO: should we close the ipc_back_fd in this case ? */
+    if (ipc_back_fd >= 0)
+	do {
+	    int ierr;
+	    FD_ZERO(&fds);
+	    FD_SET(fd, &fds);
+	    FD_SET(ipc_back_fd, &fds);
+	    ierr = select(ipc_back_fd + 1, SELECT_TYPE_ARG234 &fds, 0, 0, NULL);
+	    if (ierr < 0 && errno == EINTR) {
+		FD_ZERO(&fds);
+		continue;
+	    }
+	    if (FD_ISSET(ipc_back_fd, &fds)) {
+		n = read(ipc_back_fd, (void *) (l + (char *) &ge), sizeof(ge) - l);
+		if (n == 0) {
+		    close(ipc_back_fd);
+		    ipc_back_fd = -1;
+		    /* don't close X11_ipc, otherwise later writes
+		     * to it will cause a segfault */
+		    IPC_LOCK = FALSE;
+		    break;	/* outboard driver has stopped */
+		}
+		l += n;
+		if (l == sizeof(ge)) {
+		    /* note: do_event() may not return (if an
+		     * error occurs), so need to reset l first */
+		    l = 0;
+		    do_event(&ge);
+		    if (ge.type == GE_fontprops) {
+		    	if (repeat_count > 0) {
+		    	    FPRINTF((stderr,
+			        "X11_waitforinput: caught GE_fontprops after %d tries\n",
+				repeat_count));
+			}
+			return(GE_fontprops);
+		    }
+		    if (ge.type == GE_buttonrelease && (paused_for_mouse & PAUSE_CLICK)) {
+			int button = ge.par1;
+			if (button == 1 && (paused_for_mouse & PAUSE_BUTTON1))
+			    paused_for_mouse = 0;
+			if (button == 2 && (paused_for_mouse & PAUSE_BUTTON2))
+			    paused_for_mouse = 0;
+			if (button == 3 && (paused_for_mouse & PAUSE_BUTTON3))
+			    paused_for_mouse = 0;
+			if (paused_for_mouse == 0)
+			    return '\0';
+		    }
+		    if (ge.type == GE_keypress && (paused_for_mouse & PAUSE_KEYSTROKE)) {
+			/* Ignore NULL keycode */
+			if (ge.par1 > '\0') {
+			    paused_for_mouse = 0;
+			    return '\0';
+			}
+		    }
+		}
+	    }
+	} while (!FD_ISSET(fd, &fds));
+
+    /* If ipc_back_fd is not open, we will never see any mouse events! */
+    else if (paused_for_mouse) {
+	paused_for_mouse = 0;
+	int_error(NO_CARET,"Mousing not active");
+    }
+
+    /* IPC_LOCK indicates that we are specifically waiting for a reply on */
+    /* the mousing channel.  If stdin unblocks first, defer reading it,   */
+    /* wait a few microseconds, and try again.                            */
+    /* FIXME EAM - Give up after a few seconds. This will drop input chars*/
+    /* but at least it won't hang forever if the X11 connection goes bad. */
+    if (IPC_LOCK) {
+#ifdef HAVE_USLEEP
+	usleep(100);
+#endif
+        if (repeat_count++ < 10000)
+	    goto AGAIN;
+    }
+
+    /* Same sort of thing if we are specifically waiting for mouse input. */
+    if (paused_for_mouse) {
+#ifdef HAVE_USLEEP
+	usleep(10);
+#endif
+	goto AGAIN;
+    }
+
+#endif /* PIPE_IPC */
+
+# if 0
+/* HBB 20010620: switching back and forth between X11 and a non-GUI
+ * terminal, while stdin is redirected, causes gnuplot to terminate
+ * right after it re-enters the X11 terminal --- read() returns a '\0'
+ * character once, and then EOF. Switching to <stdio.h>'s getc() fixed
+ * that, for me. */
+    if (read(0, &c, 1) != 1)
+	return EOF;
+    else
+	return c;
+# else
+    return getc(stdin);
+# endif	/* 0/1 */
+}
+#endif /* USE_MOUSE */
+
+
+TERM_PUBLIC void
+X11_init()
+{
+    static int been_here = 0;
+
+    if (!X11_ipc) {
+	/* first time through or after a reset */
+#if defined(OSK)
+	/* OS-9 popen() does not block on close for child to end, so
+	 * we can safely use it here
+	 */
+	/* FIXME HBB 20020214: This doesn't understand X11_DRIVER_DIR
+	 * or $GNUPLOT_DRIVER_DIR yet. This may break execution of
+	 * freshly built gnuplot until 'make install' */
+
+	   X11_ipc = popen(X11_command, "w");
+#else
+#if defined(OS2)
+      /* FIXME amai 20020219: nice try...
+       * But popen() does return a non-NULL handle to almost command,
+       * it's just a new session which will stop if the command does
+       * not exist... We should stat() for the argument?! */
+      /* X11_ipc = popen(X11_full_command_path, "w");
+      if (X11_ipc==NULL) */
+      {
+	   X11_ipc = popen(X11_command, "w");
+      }
+#else /* !(OSK || OS/2) */
+	int fdes[2];
+# ifdef PIPE_IPC
+	int fdes_back[2];
+
+#define X11_ALLOW_EVENTS (mouse_setting.on)
+	if (X11_ALLOW_EVENTS) {
+	    if (pipe(fdes_back))
+		perror("pipe() failed:");
+	}
+# endif	/* PIPE_IPC */
+	if (pipe(fdes))
+	    perror("pipe() failed:");
+
+	if (fork() == 0) {
+	    /* child */
+# ifdef PIPE_IPC
+	    char noevents[] = "-noevents";
+	    if (X11_ALLOW_EVENTS) {
+		dup2(fdes_back[1], 1);	/* stdout to pipe */
+		close(fdes_back[0]);
+	    } else {
+		char **ptr;
+		for (ptr = optvec; ptr && *ptr; ptr++)
+		    ;		/* do nothing: skip over set arguments */
+		/* tell the driver not to supply any events by
+		 * appending "-noevents" to the optvec list. */
+		*ptr = noevents;
+		*++ptr = (char *) 0;	/* terminate */
+	    }
+# endif	/* PIPE_IPC */
+	    /* close the write side of the child's forward fd */
+	    close(fdes[1]);
+
+	    dup2(fdes[0], 0);	/* stdin from pipe */
+	    execvp(X11_full_command_path, optvec);
+	    /* if we get here, something went wrong */
+	    fprintf(stderr,"Expected X11 driver: %s\n",X11_full_command_path);
+	    perror("Exec failed");
+	    fprintf(stderr,"See 'help x11' for more details\n");
+	    exit(EXIT_FAILURE);
+	}
+	/* parent */
+# ifdef PIPE_IPC
+	/* X11_ipc_out = fdopen(fdes[0], "r"); */
+	if (ipc_back_fd > 0) {
+	    fprintf(stderr, "(X11_init) warning: unclosed ipc_back_fd.\n");
+	    fprintf(stderr, "           this is probably a program error.\n");
+	    close(ipc_back_fd);
+	}
+	if (X11_ALLOW_EVENTS) {
+	    ipc_back_fd = fdes_back[0];
+	    close(fdes_back[1]);	/* the parent doesn't need this */
+	} else {
+	    /* we do not open a bidirectional communication
+	     * for non-tty's by default. If this is desired,
+	     * the mouse must be turned on explicitely *before*
+	     * starting the x11 driver.
+	     * So: if we're here, we close the ipc-back-channel
+	     * which will cause a SIGPIPE in the driver. This
+	     * is *ugly* but it works. (joze) */
+	    /* close(fdes_back[0]); */
+	    /* mark ipc_back_fd as unusable */
+	    ipc_back_fd = IPC_BACK_UNUSABLE;
+	}
+# endif	/* PIPE_IPC */
+	/* close the read side of the parent's forward fd */
+	close(fdes[0]);
+	X11_ipc = fdopen(fdes[1], "w");
+#endif /* !OSK  */
+#endif /* !OS/2 */
+    }
+
+    if (!been_here) {
+	GP_ATEXIT(X11_atexit);
+	been_here++;
+    }
+    X11_send_endianess();
+#ifdef USE_MOUSE
+    default_font_size_known = FALSE;
+#endif
+    X11_update_opts();
+}
+
+TERM_PUBLIC void
+X11_reset()
+{
+    /* Leave the pipe alone, until exit or  set term x11 reset */
+    /* but make sure that all locks are cleared.               */
+#ifdef PIPE_IPC
+    IPC_LOCK = FALSE;
+#endif
+#ifdef USE_MOUSE
+    paused_for_mouse = 0;
+#endif
+}
+
+#define PRINT0(fmt)          fprintf(X11_ipc, fmt)
+#define PRINT1(fmt,p1)       fprintf(X11_ipc, fmt,p1)
+#define PRINT2(fmt,p1,p2)    fprintf(X11_ipc, fmt,p1,p2)
+#define PRINT3(fmt,p1,p2,p3) fprintf(X11_ipc, fmt,p1,p2,p3)
+#define PRINT4(fmt,p1,p2,p3,p4) fprintf(X11_ipc, fmt,p1,p2,p3,p4)
+#define PRINT5(fmt,p1,p2,p3,p4,p5) fprintf(X11_ipc, fmt,p1,p2,p3,p4,p5)
+
+#define FFLUSH()             fflush(X11_ipc)
+
+#define BEFORE_GRAPHICS		/* nowt */
+#define AFTER_TEXT		/* nowt */
+
+
+#elif defined(CRIPPLED_SELECT)
+/* PLEASE CAN SOMEONE CHECK THAT THIS STILL WORKS !!! */
+/*-----------------------------------------------------------------------------
+ *   CRIPPLED_SELECT file IPC
+ *---------------------------------------------------------------------------*/
+static char X11_tmp[32], X11_tmp0[32], X11_shutdown[32];
+static int X11_pid;
+
+TERM_PUBLIC void
+X11_init()
+{
+    if (!(X11_pid = fork())) {
+	execvp(X11_full_command_path, optvec);
+	_exit(1);
+    }
+    sprintf(X11_tmp, "/tmp/Gnuplot_%d", X11_pid);
+    sprintf(X11_tmp0, "%s-", X11_tmp);
+    sprintf(X11_shutdown, "echo R >%s", X11_tmp);
+}
+
+TERM_PUBLIC void
+X11_reset()
+{
+    system(X11_shutdown);
+}
+
+#define BEFORE_GRAPHICS \
+ if (!(X11_ipc = fopen(X11_tmp0, "w"))) { \
+   perror(X11_tmp0); system(X11_shutdown); exit(1); \
+ }
+
+#define AFTER_TEXT \
+ { fclose(X11_ipc); rename(X11_tmp0, X11_tmp); }
+
+#define PRINT0(fmt)          fprintf(X11_ipc, fmt)
+#define PRINT1(fmt,p1)       fprintf(X11_ipc, fmt,p1)
+#define PRINT2(fmt,p1,p2)    fprintf(X11_ipc, fmt,p1,p2)
+#define PRINT3(fmt,p1,p2,p3) fprintf(X11_ipc, fmt,p1,p2,p3)
+#define PRINT4(fmt,p1,p2,p3,p4) fprintf(X11_ipc, fmt,p1,p2,p3,p4)
+#define PRINT5(fmt,p1,p2,p3,p4,p5) fprintf(X11_ipc, fmt,p1,p2,p3,p4,p5)
+#define FFLUSH()             fflush(X11_ipc)
+
+static void
+X11_atexit()
+{
+    /* WHAT SHOULD I DO ? */
+}
+#elif defined(VMS)
+/*-----------------------------------------------------------------------------
+ *   VMS mailbox/spawn IPC - Yehavi Bourvine - YEHAVI@VMS.HUJI.AC.IL
+ *---------------------------------------------------------------------------*/
+#include <iodef.h>
+#include <descrip.h>
+#include <dvidef.h>
+#ifdef __DECC
+#include <lib$routines.h>
+#include <starlet.h>
+#endif
+#ifdef __GNUC__
+#include <errno.h>
+#else
+int vaxc$errno;
+#endif
+
+#define SS$_NORMAL 1		/* or include <ssdef.h> for all SS$_ def's */
+
+#define MBXMXMSG 128		/* DEFMBXMXMSG is set by SYSGEN */
+
+static short X11_channel;
+
+struct iosb {
+    unsigned short stat;
+    unsigned short count;
+    unsigned long info;
+};
+
+
+
+TERM_PUBLIC void
+X11_init()
+{
+
+    struct iosb iosb;
+
+    static char devnam_string[64];
+    static $DESCRIPTOR(devnam, devnam_string);
+
+    struct {
+	short int buf_len;
+	short int item;
+	char *buf_addr;
+	unsigned short int *ret_len;
+	int end;
+    } item_list = {
+    devnam.dsc$w_length, DVI$_DEVNAM, devnam.dsc$a_pointer, &devnam.dsc$w_length, 0};
+#define CMDLEN 1024
+    char cmdline[CMDLEN], *cmdp;
+    int optindex;
+
+    if (!X11_channel) {
+	int one = 1;
+
+	/* Create a descriptor for the command line that starts
+	   GNUPLOT_X11. $DESCRIP doesn't work in this context... */
+
+	/* FIXME!
+	 * This does not work anymore since X11 option passing has been
+	 * changed to use execvp() in the DEFAULT_X11 case
+	 */
+	struct dsc$descriptor_s pgmdsc = { 0, DSC$K_DTYPE_T,
+	    DSC$K_CLASS_S, 0
+	};
+	optindex = 0;
+	strcpy(cmdline, optvec[optindex]);
+	cmdp = cmdline + strlen(optvec[optindex]);
+	while (optvec[++optindex] != NULL) {
+	    *cmdp++ = ' ';
+	    *cmdp++ = '\"';
+	    strcpy(cmdp, optvec[optindex]);
+	    cmdp += strlen(optvec[optindex]);
+	    *cmdp++ = '\"';
+	}
+	pgmdsc.dsc$w_length = cmdp - cmdline;
+	pgmdsc.dsc$a_pointer = cmdline;
+
+	/* Create a mailbox which will be used as a pipe for commands to the
+	 * subprocess.  What we'll write to it will be read by the subprocess
+	 * as its STDIN.  Use an unnamed mailbox and refer to it by its device
+	 * number */
+
+	vaxc$errno = sys$crembx(0, &X11_channel, MBXMXMSG, MBXMXMSG, 0, 0, 0, 0);
+	if ((vaxc$errno & SS$_NORMAL) != SS$_NORMAL) {
+	    printf("SYS$CreMbx failed with status=%d\r\n", vaxc$errno);
+	    os_error(NO_CARET, "sys$crembx failed");
+	}
+	vaxc$errno = sys$getdviw(0, X11_channel, 0, &item_list, &iosb, 0, 0, 0);
+	if ((vaxc$errno & SS$_NORMAL) == SS$_NORMAL)
+	    vaxc$errno = iosb.stat;
+	if ((vaxc$errno & SS$_NORMAL) != SS$_NORMAL) {
+	    printf("SYS$Getdviw failed with status=%d\r\n", vaxc$errno);
+	    sys$dassgn(X11_channel);
+	    X11_channel = 0;
+	    os_error(NO_CARET, "sys$getdviw failed");
+	}
+	/* Create a subprocess whose input is this mailbox. */
+	vaxc$errno = lib$spawn(&pgmdsc, &devnam, 0, &one, 0, 0, 0, 0, 0, 0, 0, 0, 0);
+	if ((vaxc$errno & SS$_NORMAL) != SS$_NORMAL) {
+	    printf("LIB$SPAWN failed with status=%d\r\n", vaxc$errno);
+	    sys$dassgn(X11_channel);
+	    X11_channel = 0;
+	    os_error(NO_CARET, "lib$spawn failed");
+	}
+    }
+    {
+	static int been_here = 0;
+	if (!been_here) {
+	    GP_ATEXIT(X11_atexit);
+	    been_here = 1;
+	}
+    }
+}
+
+
+/*   We use $QIO in order to avoid buffering problems, although it might
+ *   work  as well with simple Fprintf calls.
+ */
+
+#define GO(x) \
+do { \
+   char buffer[512]; int status; struct iosb iosb;\
+   sprintf x; \
+   if (strlen(buffer) >= MBXMXMSG)  { \
+     printf("buffer contents (%d char) catenated to mailbox size (%d bytes)\n", \
+     strlen(buffer), MBXMXMSG); \
+     buffer[MBXMXMSG-1] = '\0';\
+     printf("%s\n", buffer); \
+   } \
+   status = sys$qiow(0, X11_channel, IO$_WRITEVBLK, &iosb, 0, 0, buffer, strlen(buffer), 0, 0, 0, 0); \
+   if ((status & SS$_NORMAL) == SS$_NORMAL) status = iosb.stat; \
+   if((status & SS$_NORMAL) != SS$_NORMAL) exit(status); \
+ } while (0)
+
+#define PRINT0(fmt)          GO((buffer, fmt))
+#define PRINT1(fmt,p1)       GO((buffer, fmt,p1))
+#define PRINT2(fmt,p1,p2)    GO((buffer, fmt,p1,p2))
+#define PRINT3(fmt,p1,p2,p3) GO((buffer, fmt,p1,p2,p3))
+#define PRINT4(fmt,p1,p2,p3,p4) GO((buffer, fmt,p1,p2,p3,p4))
+#define PRINT5(fmt,p1,p2,p3,p4,p5) GO((buffer, fmt,p1,p2,p3,p4,p5))
+
+#define FFLUSH()		/* nowt */
+#define BEFORE_GRAPHICS		/* nowt */
+#define AFTER_TEXT		/* nowt */
+
+static void
+X11_atexit()
+{
+    if (X11_channel) {
+	PRINT0("R\n");
+	sleep(2);		/* Wait for subprocess to finish */
+	sys$dassgn(X11_channel);
+	X11_channel = 0;
+    }
+}
+
+TERM_PUBLIC void
+X11_reset()
+{
+    /* do nothing until exit */
+}
+
+#else /* !VMS */
+    You lose.
+#endif /* !VMS */
+
+/* common stuff, using macros defined above */
+
+TERM_PUBLIC void
+X11_graphics()
+{
+#ifdef USE_MOUSE
+    static unsigned long windowid = 0;
+#endif
+    static enum set_encoding_id last_encoding = S_ENC_DEFAULT;
+
+    BEFORE_GRAPHICS;		/* kludge for crippled select */
+
+#ifndef USE_MOUSE
+    /* for VMS sake, keep as separate prints */
+    PRINT0("G\n");
+#else
+#ifdef PIPE_IPC
+    /* if we know the outboard driver has stopped, restart it */
+    if (ipc_back_fd == IPC_BACK_CLOSED) {
+	fclose(X11_ipc);
+	X11_ipc = NULL;
+	X11_init();
+    }
+#endif
+    /* send also XID of gnuplot window (<space> then raises it up) */
+    if (!windowid) {
+	char *window_env = getenv("WINDOWID");
+	if (window_env)
+	    sscanf(window_env, "%lu", &windowid);
+    }
+#ifndef OS2
+    PRINT1("G%lu\n", windowid);
+#else
+    PRINT2("G%lu %i\n", windowid, getpid());
+#endif
+#endif /* USE_MOUSE */
+
+#ifdef ULTRIX_KLUDGE
+    fflush(X11_ipc);
+#endif
+
+    if (encoding != last_encoding) {
+	PRINT1("QE%d\n",encoding);
+	last_encoding = encoding;
+    }
+
+#if defined(USE_MOUSE) && defined(PIPE_IPC)
+    /* EAM June 2003 - Flush the set font command through the pipe */
+    /* to gnuplot_x11, then wait for it to return the resulting    */
+    /* font size information (v_char and h_char). The feedback is  */
+    /* caught by do_event() as an event of type GE_fontprops.      */
+    if (ipc_back_fd >= 0 && X11_MOUSE_FEEDBACK) {
+	if (!default_font_size_known) {
+	    IPC_LOCK = TRUE;
+	    PRINT1("QG%s\n",X11_default_font);
+	    FFLUSH();
+	    X11_waitforinput();
+	    default_font_size_known = TRUE;
+	    IPC_LOCK = FALSE;
+	}
+    }
+#endif
+    /* Force default font at start of plot */
+    *X11_last_font_used = '\01';
+    X11_set_default_font();
+    X11_set_font("");
+}
+
+TERM_PUBLIC void
+X11_text()
+{
+     if (!X11_ipc)
+ 	return;
+
+#ifdef USE_MOUSE
+    /* EAM July 2003:  send over a snapshot of the final axis scaling
+     * so that subsequent mouse events can be transformed into plot
+     * coordinates even though the plot is no longer active.
+     */
+#ifdef PIPE_IPC
+    if (ipc_back_fd >= 0)
+#endif
+	{
+	/* Construct a mask showing which axes are active */
+	int axis_mask = 0;
+	int i;
+
+	for (i = FIRST_AXES; i < 2*SECOND_AXES; i++) {
+	    if (axis_array[i].ticmode != NO_TICS)
+		axis_mask |= (1 << i);
+	}
+	PRINT2("S %2d %d\n", -2, ALMOST2D);
+	PRINT2("S %2d %d\n", -1, axis_mask);
+	PRINT5("S %2d %14.3g %14d %14.3g %14.3g\n", FIRST_X_AXIS,
+		axis_array[FIRST_X_AXIS].min,
+		axis_array[FIRST_X_AXIS].term_lower,
+		axis_array[FIRST_X_AXIS].term_scale,
+		axis_array[FIRST_X_AXIS].log ? axis_array[FIRST_X_AXIS].log_base : 0);
+	PRINT5("S %2d %14.3g %14d %14.3g %14.3g\n", FIRST_Y_AXIS,
+		axis_array[FIRST_Y_AXIS].min,
+		axis_array[FIRST_Y_AXIS].term_lower,
+		axis_array[FIRST_Y_AXIS].term_scale,
+		axis_array[FIRST_Y_AXIS].log ? axis_array[FIRST_Y_AXIS].log_base : 0);
+	PRINT5("S %2d %14.3g %14d %14.3g %14.3g\n", SECOND_X_AXIS,
+		axis_array[SECOND_X_AXIS].min,
+		axis_array[SECOND_X_AXIS].term_lower,
+		axis_array[SECOND_X_AXIS].term_scale,
+		axis_array[SECOND_X_AXIS].log ? axis_array[SECOND_X_AXIS].log_base : 0);
+	PRINT5("S %2d %14.3g %14d %14.3g %14.3g\n", SECOND_Y_AXIS,
+		axis_array[SECOND_Y_AXIS].min,
+		axis_array[SECOND_Y_AXIS].term_lower,
+		axis_array[SECOND_Y_AXIS].term_scale,
+		axis_array[SECOND_Y_AXIS].log ? axis_array[SECOND_Y_AXIS].log_base : 0);
+    }
+#endif
+
+    PRINT0("E\n");
+    FFLUSH();
+#ifdef ULTRIX_KLUDGE
+    PRINT0("E\n");
+    FFLUSH();
+#endif
+
+    AFTER_TEXT;			/* kludge for crippled select */
+}
+
+TERM_PUBLIC void
+X11_move(unsigned int x, unsigned int y)
+{
+    PRINT2("M%04d%04d\n", x, y);
+}
+
+TERM_PUBLIC void
+X11_vector(unsigned int x, unsigned int y)
+{
+    PRINT2("V%04d%04d\n", x, y);
+}
+
+TERM_PUBLIC void
+X11_pointsize(double ps)
+{
+    if (ps < 0)
+	ps = 1;
+    PRINT2("P-2 %d %d\n",	/* size of point symbols */
+	   (int) (term->h_tic * ps * 0.5), (int) (term->v_tic * ps * 0.5));
+}
+
+TERM_PUBLIC void
+X11_linewidth(double lw)
+{
+    PRINT1("W%04d\n", (int) (lw * X11_linewidth_multiplier + 0.5));
+}
+
+TERM_PUBLIC void
+X11_linetype(int lt)
+{
+    PRINT1("L%04d\n", lt);
+}
+
+TERM_PUBLIC void
+X11_put_text(unsigned int x, unsigned int y, const char str[])
+{
+    /* Only send the font change request to X11 if it really is a change */
+    if (strcmp(X11_last_font_used,X11_next_font_used)) {
+	strcpy(X11_last_font_used,X11_next_font_used);
+	PRINT1("QF%s\n", X11_next_font_used);
+    }
+
+    /* badly outrange labels can overflow into text field */
+    if (x < 10000 && y < 10000) {
+	PRINT3("T%04d%04d%s\n", x, y, str);
+    }
+}
+
+TERM_PUBLIC int
+X11_text_angle(int ang)
+{
+    PRINT1("A%d\n", ang);
+    return TRUE;
+}
+
+TERM_PUBLIC int
+X11_justify_text(enum JUSTIFY mode)
+{
+    PRINT1("J%04d\n", mode);
+    X11_last_justification = mode;
+    return (TRUE);
+}
+
+TERM_PUBLIC void
+X11_point(unsigned int x, unsigned int y, int number)
+{
+    PRINT3("P%d %d %d\n", number, x, y);
+}
+
+TERM_PUBLIC int
+X11_set_font(const char *fontname)
+{
+    PRINT1("QF%s\n", fontname?fontname:"");
+    strncpy(X11_next_font_used,fontname?fontname:"",sizeof(X11_next_font_used)-1);
+    return(TRUE);
+}
+
+static void
+X11_set_default_font()
+{
+    PRINT1("QD%s\n",X11_default_font);
+}
+
+TERM_PUBLIC void
+X11_fillbox(int style, unsigned int x, unsigned int y, unsigned int w, unsigned int h)
+{
+    if (X11_ipc) {
+	PRINT5("F%04d%04u%04u%04u%04u\n", style, x, y, w, h);
+    }
+}
+
+#ifdef USE_MOUSE
+TERM_PUBLIC void
+X11_put_tmptext(int i, const char str[])
+{
+    if (X11_ipc) {
+	PRINT2("t%04d%s\n", i, str);
+	FFLUSH();
+    }
+}
+
+TERM_PUBLIC void
+X11_set_ruler(int x, int y)
+{
+    if (X11_ipc) {
+	PRINT2("r%04d%04d\n", x < 9999 ? x : 9999, y < 9999 ? y : 9999);
+	FFLUSH();
+    }
+}
+
+TERM_PUBLIC void
+X11_set_cursor(int c, int x, int y)
+{
+    if (X11_ipc) {
+	PRINT3("u%04d%04d%04d\n", c, x, y);
+	FFLUSH();
+    }
+}
+
+TERM_PUBLIC void
+X11_set_clipboard(const char s[])
+{
+    if (X11_ipc) {
+	PRINT1("z%s\n", s);
+	FFLUSH();
+    }
+}
+
+#endif /* USE_MOUSE */
+
+
+static void
+transmit_gradient(gradient_struct *gradient, int cnt)
+{
+    int i = 0;
+
+    fprintf(X11_ipc, "%d", cnt);
+    for(i=0; i<cnt; i++) {
+        /* this %50 *must* match the corresponding %50 in gplt_x11.c  */
+        if(i%50 == 0) {
+	    fputs("\n", X11_ipc);
+	    fflush(X11_ipc);
+	}
+	fprintf(X11_ipc, "%s", gradient_entry_to_str(&(gradient[i])));
+    }
+    fputs("\n", X11_ipc);
+}
+
+
+TERM_PUBLIC int
+X11_make_palette(t_sm_palette *palette)
+{
+    if(!palette) {
+        return 0;
+    }
+
+    if(!X11_ipc) {
+	    fprintf(stderr, "(X11_make_palette) 0 == X11_ipc\n");
+	    return -1;
+	}
+
+    fprintf(X11_ipc, "%c %c %c %c %d\n",
+	     X11_GR_MAKE_PALETTE, (char)(palette->colorMode),
+	     (char)(palette->positive), (char)(palette->cmodel),
+	     palette->use_maxcolors);
+
+    switch(palette->colorMode) {
+    case SMPAL_COLOR_MODE_GRAY:
+        fprintf(X11_ipc,"%g\n", palette->gamma);
+        break;
+    case SMPAL_COLOR_MODE_RGB:
+        fprintf(X11_ipc, "%d %d %d\n", palette->formulaR,
+		 palette->formulaG, palette->formulaB);
+	break;
+    case SMPAL_COLOR_MODE_GRADIENT:
+        transmit_gradient(palette->gradient, palette->gradient_num);
+	break;
+    case SMPAL_COLOR_MODE_FUNCTIONS: {
+        int cnt=0;
+	gradient_struct *gradient;
+	gradient = approximate_palette(palette, -1, -1, &cnt);
+	transmit_gradient(gradient, cnt);
+	free(gradient);
+	break;
+    }
+    default:
+        fprintf(stderr, "%s:%d ooops: Unknown colorMode '%c'.\n",
+		 __FILE__, __LINE__, (char)(palette->colorMode));
+    }
+    fflush(X11_ipc);
+    return 0;
+}
+
+
+#if 0
+/* The following are some handy little routines to keep around
+ * in case one wants to do statistics on the binary data being
+ * passed to a terminal function.
+ */
+
+int char_count[256];
+
+void histogram(unsigned char c) {
+    char_count[c] += 1;
+}
+
+void dump_histogram(void) {
+  int i, sum;
+  fprintf(stderr,"\n\n");
+  for (i=0,sum=0; i<256; i++) {
+    fprintf(stderr," %3.3d:%7.7d ", i, char_count[i]);
+    sum += char_count[i];
+  }
+  fprintf(stderr,"\n\ntotal: %d\n\n",sum);
+}
+#endif
+
+TERM_PUBLIC void
+X11_set_color(t_colorspec *colorspec)
+{
+    if (colorspec->type == TC_RGB) {
+	fputc(X11_GR_SET_RGBCOLOR, X11_ipc);
+	PRINT1("%6.6x\n", colorspec->lt);
+	FFLUSH();
+	return;
+    }
+
+    if (colorspec->type == TC_LT) {
+	fputc(X11_GR_SET_LINECOLOR, X11_ipc);
+	PRINT1("%4d\n", colorspec->lt);
+	FFLUSH();
+	return;
+    }
+
+    if (colorspec->type != TC_FRAC)
+	return;
+
+    {
+    char *c_ptr;
+    unsigned short byte_remaining;
+    float fgray = colorspec->value;
+
+    fputc(X11_GR_BINARY_COLOR, X11_ipc);
+    byte_remaining = sizeof(fgray);
+    c_ptr = (char *) &fgray;
+
+    while (byte_remaining) {
+
+	char c_tmp = *c_ptr++ - SET_COLOR_TRANSLATION_CHAR;
+
+	byte_remaining--;
+
+	if ( (c_tmp == '\n') || (c_tmp == SET_COLOR_CODE_CHAR) || (c_tmp == '\0') ) {
+	    fputc(SET_COLOR_CODE_CHAR, X11_ipc);
+	    c_tmp += 1;
+	}
+	fputc(c_tmp, X11_ipc);
+
+    }
+
+    fputc('\n', X11_ipc);
+    FFLUSH();
+    }
+
+}
+
+TERM_PUBLIC void
+X11_filled_polygon(int points, gpiPoint *corners)
+{
+    int int_cache[2];
+    int i_corner;
+    unsigned short i_buffer;
+    unsigned short byte_remaining;
+    unsigned int point_remaining;
+
+    /* Encode and transfer data to the pipe, one character at a time. */
+
+    if (!points) return;
+
+    fputc(X11_GR_BINARY_POLYGON, X11_ipc);
+    i_buffer = BINARY_MAX_CHAR_PER_TRANSFER;
+
+    /* First put number of points into the buffer.  Initialize the "cache"
+     * to the number of points and the number of bytes to transfer to the
+     * size of an int.  This will be the first transfer, so increase the
+     * number of points by one.
+     */
+    int_cache[0] = points;
+    int_cache[1] = corners->style;
+    byte_remaining = 2*sizeof(int_cache[0]);
+    point_remaining = points + 1;
+    i_corner = 0;
+
+    while (point_remaining) {
+
+	unsigned char *uc_ptr = (unsigned char *) int_cache;
+
+	while (byte_remaining) {
+
+	    int sent_val;
+
+	    unsigned char uc_tmp = *uc_ptr++ - FILLED_POLYGON_TRANSLATION_CHAR;
+	    byte_remaining--;
+
+	    if ( (uc_tmp == '\n') || (uc_tmp == FILLED_POLYGON_CODE_CHAR) || (uc_tmp == '\0') ) {
+		uc_tmp += 1;
+		sent_val = fputc(FILLED_POLYGON_CODE_CHAR, X11_ipc);
+		if (sent_val != (int)FILLED_POLYGON_CODE_CHAR)
+		    fprintf(stderr, "Bad character mapping %d -> %d\n", (int)FILLED_POLYGON_CODE_CHAR, sent_val);
+		i_buffer--;
+		if (!i_buffer) {
+		    fputc('\n', X11_ipc);  FFLUSH();               /* End of chunk. */
+		    i_buffer = BINARY_MAX_CHAR_PER_TRANSFER;
+		    fputc(X11_GR_BINARY_POLYGON, X11_ipc);         /* Will be another chunk. */
+		}
+	    }
+
+	    sent_val = fputc(uc_tmp, X11_ipc);
+	    if (sent_val != (int)uc_tmp)
+		fprintf(stderr, "Bad character mapping %d -> %d\n", (int)uc_tmp, sent_val);
+	    i_buffer--;
+	    if (!i_buffer) {
+		fputc('\n', X11_ipc);  FFLUSH();                   /* End of chunk. */
+		i_buffer = BINARY_MAX_CHAR_PER_TRANSFER;
+		if (point_remaining || byte_remaining)
+		    fputc(X11_GR_BINARY_POLYGON, X11_ipc);         /* Will be another chunk. */
+	    }
+
+	}
+
+	byte_remaining = 2*sizeof(int);
+	if (--point_remaining) {
+	    int_cache[0] = corners[i_corner].x;
+	    int_cache[1] = corners[i_corner].y;
+	    i_corner++;
+	}
+    }
+
+    /* Check if some characters were put in the buffer that need to be flushed. */
+    if (i_buffer != BINARY_MAX_CHAR_PER_TRANSFER) {
+	fputc('\n', X11_ipc);
+	FFLUSH();
+    }
+
+    return;
+}
+
+
+/*
+ * Ethan A Merritt November 2003
+ *	- Support for enhanced text mode
+ *
+ * PROBLEMS:
+ *	- The default font must be scalable
+ *	- Without more feedback from the outboard driver (gnuplot_x11) it is
+ *	  hard to set up proper text rotation. The current approximation is so-so.
+ *	- Right- and Center- justified text is problematic for the same reason.
+ *	- The default font size is not really known, and font scaling
+ *	  in general could be improved
+ */
+
+static TBOOLEAN ENHx11_opened_string;
+static TBOOLEAN ENHx11_sizeonly = FALSE;
+static TBOOLEAN ENHx11_show = TRUE;
+static int ENHx11_overprint = 0;
+static TBOOLEAN ENHx11_widthflag = TRUE;
+static double ENHx11_base;
+static double ENHx11_fontsize;
+static char  *ENHx11_font;
+
+TERM_PUBLIC void
+ENHX11_OPEN(
+    char *fontname,
+    double fontsize, double base,
+    TBOOLEAN widthflag, TBOOLEAN showflag,
+    int overprint)
+{
+    /* If the overprint code requests a save or request, that's all we do */
+    if (overprint == 3) {
+	PRINT2("Tp%04d%04d\n", 0, 0);
+	return;
+    } else if (overprint == 4) {
+	PRINT2("Tr%04d%04d\n", 0, 0);
+	return;
+    }
+
+    if (!ENHx11_opened_string) {
+	ENHx11_opened_string = TRUE;
+	enhanced_cur_text = &enhanced_text[0];
+	ENHx11_font = fontname;
+	ENHx11_fontsize = fontsize;
+	ENHx11_base = base * 10;	/* FIXME - should this be v_char? v_tic? */
+	ENHx11_show = showflag;
+	ENHx11_overprint = overprint;
+	ENHx11_widthflag = widthflag;
+    }
+}
+
+/*
+ * Write a string fragment and update current position.
+ * We leave the real work up to gnuplot_x11!
+ */
+TERM_PUBLIC void
+ENHX11_FLUSH()
+{
+    /* Send a command to print this string at current position */
+    if (ENHx11_opened_string) {
+
+	char tmpfont[128];	/* FIXME - there must be a better way! */
+	*enhanced_cur_text = '\0';
+	sprintf(tmpfont,"%s,%.1f", ENHx11_font, ENHx11_fontsize);
+	PRINT1("QF%s\n", tmpfont);
+	*X11_last_font_used = '\01';
+
+	if (!ENHx11_show || ENHx11_sizeonly)
+	    PRINT3("Ts%04d%04d%s\n", 0, (int)ENHx11_base, enhanced_text);
+	else if (ENHx11_overprint == 1)
+	    PRINT3("Tc%04d%04d%s\n", 0, (int)ENHx11_base, enhanced_text);
+	else if (!ENHx11_widthflag && ENHx11_overprint != 0)
+	    PRINT3("To%04d%04d%s\n", 0, (int)ENHx11_base, enhanced_text);
+	else
+	    PRINT3("Tu%04d%04d%s\n", 0, (int)ENHx11_base, enhanced_text);
+
+	ENHx11_opened_string = FALSE;
+    }
+}
+
+TERM_PUBLIC void
+ENHX11_put_text(unsigned int x, unsigned int y, const char *str)
+{
+    char *original_string = (char *)str;
+    static char *initial_font = NULL;
+    int pass = 1;
+
+    if (ignore_enhanced_text) {
+	X11_put_text(x,y,str);
+	return;
+    }
+
+    if (!strlen(str))
+	return;
+
+    /* if there are no magic characters, we should just be able
+     * punt the string to X11_put_text()
+     */
+    if (!strpbrk(str, "{}^_@&~")) {
+	X11_put_text(x,y,str);
+	return;
+    }
+
+    /* set up the global variables needed by enhanced_recursion() */
+    enhanced_fontscale = 1.25;
+    ENHx11_opened_string = FALSE;
+    strncpy(enhanced_escape_format,"%c",sizeof(enhanced_escape_format));
+
+
+    /* Tell gnuplot_x11 to set the current position to (x,y) */
+	PRINT2("Tl%04d%04d\n", x, y);
+
+    /* Text justification requires two passes. During the first pass we */
+    /* don't draw anything, we just measure the space it will take.     */
+    if (X11_last_justification != LEFT) {
+	PRINT1("J%04d\n", LEFT);
+	ENHx11_sizeonly = TRUE;
+    }
+PASS2:
+
+    /* Make sure that we start out using the intended font.  */
+	ENHx11_font = "DEFAULT";
+	ENHx11_fontsize = X11_default_fontsize;
+	if (*X11_next_font_used) {
+	    int sep = strcspn(X11_next_font_used,",");
+	    free(initial_font);
+	    initial_font = gp_strdup(X11_next_font_used);
+	    initial_font[sep] = '\0';
+	    sscanf(&(X11_next_font_used[sep+1]),"%lf",&ENHx11_fontsize);
+	    ENHx11_font = initial_font;
+	    FPRINTF((stderr,"setting font to %s,%g\n",ENHx11_font,ENHx11_fontsize));
+	}
+
+    /* Set the recursion going. We say to keep going until a
+     * closing brace, but we don't really expect to find one.
+     * If the return value is not the nul-terminator of the
+     * string, that can only mean that we did find an unmatched
+     * closing brace in the string. We increment past it (else
+     * we get stuck in an infinite loop) and try again.
+     */
+    while (*(str = enhanced_recursion((char *)str, TRUE,
+			ENHx11_font, ENHx11_fontsize,
+			0.0, TRUE, TRUE, 0))) {
+	(term->enhanced_flush)();
+
+	/* I think we can only get here if *str == '}' */
+	    enh_err_check(str);
+
+	if (!*++str)
+	    break; /* end of string */
+
+	/* else carry on and process the rest of the string */
+    }
+
+    /* Restore text justification flag after 2nd pass */
+    if (pass > 1) {
+	PRINT1("J%04d\n", X11_last_justification);
+	return;
+    }
+
+    /* In order to do text justification we need to do a second pass that */
+    /* uses information stored by gnuplot_x11 during the first pass.      */
+    if (X11_last_justification != LEFT) {
+	ENHx11_sizeonly = FALSE;
+
+	if (X11_last_justification == RIGHT) {
+		PRINT2("Tj%04d%04d\n", x, y);
+	} else if (X11_last_justification == CENTRE) {
+		PRINT2("Tk%04d%04d\n", x, y);
+	}
+	str = original_string;
+	pass = 2;
+	goto PASS2;
+
+    }
+
+}
+
+
+TERM_PUBLIC void
+X11_send_endianess(void)
+{
+    /* Place an integer 1 in the pipe and see if the byte order agrees
+     * with program on the other side.  Information used for routines
+     * having encoded binary data.
+     */
+    unsigned short tmp = (unsigned short) ENDIAN_VALUE;
+    fputc(X11_GR_CHECK_ENDIANESS, X11_ipc);
+    fputc(((char *)&tmp)[0], X11_ipc);
+    fputc(((char *)&tmp)[1], X11_ipc);
+    fputc('\n', X11_ipc);
+    fflush(X11_ipc);
+}
+
+
+TERM_PUBLIC void
+X11_image(unsigned int M, unsigned int N, coordval *image, gpiPoint *corner, t_imagecolor color_mode)
+{
+
+    /* Avoid using floats or formatted I/O.  That's too slow for image data.
+     *
+     * To avoid using floats, we assume that the maximum resolution of the
+     * color plane of the x11 device is 16 bits.  (Not an unreasonable
+     * assumption.)  So we convert coordval to unsigned short and then
+     * send those.  The driver then shifts these unsigned short values to
+     * the right to match the size of its palette.
+     *
+     * The driver uses the '\n' character to mean end of command.  When the
+     * core routine sees the '\n', it stops copying the remaining characters
+     * that are in the buffer.  Therefore, we need to hide the '\n' character
+     * from the data stream.  We also need to hide the '\0' because the core
+     * routine also does an 'strcpy'.  So the scheme is as follows:
+     *
+     *   On the driver side, if the char CODE_WORD is found it
+     *   should be ignored and replaced with the char that
+     *   follows it, but subtract one from that value.
+     *
+     * This means that there exists the chance of the data stream enlarging
+     * by a factor of two.  So the algorithm must make sure to keep the
+     * number of bytes transfered less than the buffer length.
+     *
+     * Also note that the '\0' character is often prevalent in 16 bit image
+     * data where the palette may be 8 bits or less.  For this reason, a
+     * translation is first done on the character to make the '\0' occur less
+     * often.  In this way, less amount of data is sent and fewer command
+     * lines are used to store an image.
+     */
+
+    unsigned short i_buffer;
+    unsigned int coord_remaining;
+    coordval *coord_ptr;
+
+    /* Use formatted I/O to transfer image information.  Hexadecimal uses less characters.
+     *
+     * Note that X11 has different frame of reference (top left origin) than does Gnuplot
+     * (bottom left origin)
+     */
+    fputc(X11_GR_IMAGE, X11_ipc);
+    fprintf(X11_ipc,"%x %x %x %x %x %x %x %x %x %x %x\n", M, N, corner[0].x, corner[0].y, corner[1].x,
+      corner[1].y, corner[2].x, corner[2].y, corner[3].x, corner[3].y, color_mode);
+    FFLUSH();
+
+    /* Encode and transfer data to the pipe, one character at a time. */
+
+    coord_remaining = M*N;
+    if (color_mode == IC_RGB)
+	coord_remaining *= 3;
+    else if (color_mode == IC_RGBA)
+	coord_remaining *= 4;
+
+    if (!coord_remaining) return;
+
+    fputc(X11_GR_IMAGE, X11_ipc);
+    i_buffer = BINARY_MAX_CHAR_PER_TRANSFER;
+    coord_ptr = image;
+
+    while (coord_remaining) {
+
+	unsigned short us_tmp;
+	unsigned short byte_remaining;
+	unsigned char *uc_ptr;
+
+	/* Convert coordinate value to an unsigned short.
+	 * Palette and RGB values are on scale [0:1] at this point,
+	 * but alpha values run from [0:255].  Why? I don't know.
+	 */
+	if (color_mode == IC_RGBA && !((coord_remaining+3) % 4))
+	    us_tmp = (*coord_ptr++);
+	else
+	    us_tmp = (unsigned short) ((*coord_ptr++)*IMAGE_PALETTE_VALUE_MAX + 0.5);
+	coord_remaining--;
+
+	byte_remaining = sizeof(us_tmp);
+	uc_ptr = (unsigned char *) &us_tmp;
+
+	while (byte_remaining) {
+
+	    int sent_val;
+
+	    unsigned char uc_tmp = *uc_ptr++ - IMAGE_TRANSLATION_CHAR;
+	    byte_remaining--;
+
+	    if ((uc_tmp == '\n') || (uc_tmp == IMAGE_CODE_CHAR) || (uc_tmp == '\0') ) {
+		uc_tmp += 1;
+		sent_val = fputc(IMAGE_CODE_CHAR, X11_ipc);
+		if (sent_val != (int)IMAGE_CODE_CHAR)
+		    fprintf(stderr, "Bad character mapping %d -> %d\n", (int)IMAGE_CODE_CHAR, sent_val);
+		i_buffer--;
+		if (!i_buffer) {
+		    fputc('\n', X11_ipc);  FFLUSH();               /* End of chunk. */
+		    i_buffer = BINARY_MAX_CHAR_PER_TRANSFER;
+		    fputc(X11_GR_IMAGE, X11_ipc);                  /* Will be another chunk. */
+		}
+	    }
+
+	    sent_val = fputc(uc_tmp, X11_ipc);
+	    if (sent_val != (int)uc_tmp)
+		fprintf(stderr, "Bad character mapping %d -> %d\n", (int)uc_tmp, sent_val);
+	    i_buffer--;
+	    if (!i_buffer) {
+		fputc('\n', X11_ipc);  FFLUSH();                   /* End of chunk. */
+		i_buffer = BINARY_MAX_CHAR_PER_TRANSFER;
+		if (coord_remaining || byte_remaining)
+		    fputc(X11_GR_IMAGE, X11_ipc);                  /* Will be another chunk. */
+	    }
+
+	}
+
+    }
+
+    /* Check if some characters were put in the buffer that need to be flushed. */
+    if (i_buffer != BINARY_MAX_CHAR_PER_TRANSFER) {fputc('\n', X11_ipc);  FFLUSH();}
+
+    return;
+}
+
+#endif /* TERM_BODY */
+
+#ifdef TERM_TABLE
+
+TERM_TABLE_START(x11_driver)
+    "x11", "X11 Window System",
+    X11_XMAX, X11_YMAX, X11_VCHAR, X11_HCHAR,
+    X11_VTIC, X11_HTIC, X11_options, X11_init, X11_reset,
+    X11_text, null_scale, X11_graphics, X11_move, X11_vector,
+    X11_linetype, X11_put_text, X11_text_angle,
+    X11_justify_text, X11_point, do_arrow, X11_set_font,
+    X11_pointsize, 
+    TERM_CAN_MULTIPLOT|TERM_INIT_ON_REPLOT|TERM_NO_OUTPUTFILE|TERM_CAN_DASH|TERM_ALPHA_CHANNEL|TERM_LINEWIDTH,
+    X11_text /* suspend can use same routine */ , 0 /* resume */ ,
+    X11_fillbox, X11_linewidth
+#ifdef USE_MOUSE
+    , X11_waitforinput, X11_put_tmptext, X11_set_ruler, X11_set_cursor, X11_set_clipboard
+#endif
+    , X11_make_palette, 0 /* X11_previous_palette */ ,
+    X11_set_color, X11_filled_polygon
+    , X11_image
+    , ENHX11_OPEN, ENHX11_FLUSH, do_enh_writec
+TERM_TABLE_END(x11_driver)
+
+#undef LAST_TERM
+#define LAST_TERM x11_driver
+
+#endif				/* TERM_TABLE */
+#endif				/* TERM_PROTO_ONLY */
+
+
+#ifdef TERM_HELP
+START_HELP(x11)
+"1 x11",
+"?commands set terminal x11",
+"?set terminal x11",
+"?set term x11",
+"?terminal x11",
+"?term x11",
+"?x11",
+"?X11",
+" `gnuplot` provides the `x11` terminal type for use with X servers.  This",
+" terminal type is set automatically at startup if the `DISPLAY` environment",
+" variable is set, if the `TERM` environment variable is set to `xterm`, or",
+" if the `-display` command line option is used.",
+"",
+" Syntax:",
+"    set terminal x11 {<n> | window \"<string>\"}",
+"                     {title \"<string>\"}",
+"                     {{no}enhanced} {font <fontspec>}",
+"                     {linewidth LW} {solid|dashed}",
+"                     {{no}persist} {{no}raise} {{no}ctrlq}",
+"                     {close}",
+"                     {size XX,YY} {position XX,YY}",
+"    set terminal x11 {reset}",
+"",
+" Multiple plot windows are supported: `set terminal x11 <n>` directs the",
+" output to plot window number n.  If n is not 0, the terminal number will be",
+" appended to the window title (unless a title has been supplied manually)",
+" and the icon will be labeled `Gnuplot <n>`.  The active window may be",
+" distinguished by a change in cursor (from default to crosshair).",
+"",
+" The `x11` terminal can connect to X windows previously created by an outside",
+" application via the option `window` followed by a string containing the",
+" X ID for the window in hexadecimal format.  Gnuplot uses that external X",
+" window as a container since X does not allow for multiple clients selecting",
+" the ButtonPress event.  In this way, gnuplot's mouse features work within",
+" the contained plot window.",
+"",
+"    set term x11 window \"220001e\"",
+"",
+" The x11 terminal supports enhanced text mode (see `enhanced`), subject",
+" to the available fonts. In order for font size commands embedded in text",
+" to have any effect, the default x11 font must be scalable. Thus the first",
+" example below will work as expected, but the second will not.",
+"",
+"    set term x11 enhanced font \"arial,15\" ",
+"    set title '{/=20 Big} Medium {/=5 Small}' ",
+"",
+"    set term x11 enhanced font \"terminal-14\" ",
+"    set title '{/=20 Big} Medium {/=5 Small}' ",
+"",
+" Plot windows remain open even when the `gnuplot` driver is changed to a",
+" different device.  A plot window can be closed by pressing the letter q",
+" while that window has input focus, or by choosing `close` from a window",
+" manager menu.  All plot windows can be closed by specifying `reset`, which",
+" actually terminates the subprocess which maintains the windows (unless",
+" `-persist` was specified).  The `close` command can be used to close",
+" individual plot windows by number.  However, after a `reset`, those plot",
+" windows left due to persist cannot be closed with the command `close`.",
+" A `close` without a number closes the current active plot window.",
+"",
+" The gnuplot outboard driver, gnuplot_x11, is searched in a default place",
+" chosen when the program is compiled.  You can override that by defining",
+" the environment variable GNUPLOT_DRIVER_DIR to point to a different",
+" location.",
+"",
+" Plot windows will automatically be closed at the end of the session",
+" unless the `-persist` option was given.",
+"",
+" The options `persist` and `raise` are unset by default, which means that",
+" the defaults (persist == no and raise == yes) or the command line options",
+" -persist / -raise or the Xresources are taken.  If [no]persist or",
+" [no]raise are specified, they will override command line options and",
+" Xresources.  Setting one of these options takes place immediately, so",
+" the behaviour of an already running driver can be modified.  If the window",
+" does not get raised, see discussion in `raise`.",
+"",
+" The option `title \"<title name>\"` will supply the title name of the window",
+" for the current plot window or plot window <n> if a number is given.",
+" Where (or if) this title is shown depends on your X window manager.",
+"",
+" The size option can be used to set the size of the plot window.  The",
+" size option will only apply to newly created windows.",
+"",
+" The position option can be used to set the position of the plot window.  The",
+" position option will only apply to newly created windows.",
+"",
+" The size or aspect ratio of a plot may be changed by resizing the `gnuplot`",
+" window.",
+"",
+" Linewidths and pointsizes may be changed from within `gnuplot` with",
+" `set linestyle`.",
+"",
+" For terminal type `x11`, `gnuplot` accepts (when initialized) the standard",
+" X Toolkit options and resources such as geometry, font, and name from the",
+" command line arguments or a configuration file.  See the X(1) man page",
+" (or its equivalent) for a description of such options.",
+"",
+"=X resources",
+" A number of other `gnuplot` options are available for the `x11` terminal.",
+" These may be specified either as command-line options when `gnuplot` is",
+" invoked or as resources in the configuration file \".Xdefaults\".  They are",
+" set upon initialization and cannot be altered during a `gnuplot` session.",
+" (except `persist` and `raise`)",
+"2 x11_fonts",
+"?commands set terminal x11 x11_fonts",
+"?set terminal x11 x11_fonts",
+"?set term x11 x11_fonts",
+"?x11 x11_fonts",
+"?x11_fonts",
+"=fonts",
+" Upon initial startup, the default font is taken from the X11 resources",
+" as set in the system or user .Xdefaults file or on the command line.",
+"",
+" Example:",
+"       gnuplot*font: lucidasans-bold-12",
+" A new default font may be specified to the x11 driver from inside",
+" gnuplot using",
+"      `set term x11 font \"<fontspec>\"`",
+" The driver first queries the X-server for a font of the exact name given.",
+" If this query fails, then it tries to interpret <fontspec> as",
+" \"<font>,<size>,<slant>,<weight>\" and to construct a full X11 font name",
+" of the form",
+"       -*-<font>-<weight>-<s>-*-*-<size>-*-*-*-*-*-<encoding>",
+"",
+"  <font> is the base name of the font (e.g. Times or Symbol)",
+"  <size> is the point size (defaults to 12 if not specified)",
+"  <s> is `i` if <slant>==\"italic\" `o` if <slant>==\"oblique\" `r` otherwise",
+"  <weight> is `medium` or `bold` if explicitly requested, otherwise `*`",
+"  <encoding> is set based on the current character set (see `set encoding`).",
+" So `set term x11 font \"arial,15,italic\"` will be translated to",
+" -*-arial-*-i-*-*-15-*-*-*-*-*-iso8859-1 (assuming default encoding).",
+" The <size>, <slant>, and <weight> specifications are all optional.",
+" If you do not specify <slant> or <weight> then you will get whatever font ",
+" variant the font server offers first.",
+" You may set a default enconding via the corresponding X11 resource. E.g.",
+"       gnuplot*encoding: iso8859-15",
+" The driver also recognizes some common PostScript font names and",
+" replaces them with possible X11 or TrueType equivalents.",
+" This same sequence is used to process font requests from `set label`.",
+"",
+" If your gnuplot was built with configuration option --enable-x11-mbfonts,",
+" you can specify multi-byte fonts by using the prefix \"mbfont:\" on the font",
+" name. An additional font may be given, separated by a semicolon.",
+" Since multi-byte font encodings are interpreted according to the locale",
+" setting, you must make sure that the environmental variable LC_CTYPE is set",
+" to some appropriate locale value such as ja_JP.eucJP, ko_KR.EUC, or zh_CN.EUC.",
+"",
+" Example:",
+"       set term x11 font 'mbfont:kana14;k14'",
+"             # 'kana14' and 'k14' are Japanese X11 font aliases, and ';'",
+"             # is the separator of font names.",
+"       set term x11 font 'mbfont:fixed,16,r,medium'",
+"             # <font>,<size>,<slant>,<weight> form is also usable.",
+"       set title '(mb strings)' font 'mbfont:*-fixed-medium-r-normal--14-*'",
+"",
+" The same syntax applies to the default font in Xresources settings,",
+" for example,", 
+"       gnuplot*font: \\",
+"           mbfont:-misc-fixed-medium-r-normal--14-*-*-*-c-*-jisx0208.1983-0",
+"",
+" If gnuplot is built with --enable-x11-mbfonts, you can use two special",
+" PostScript font names 'Ryumin-Light-*' and 'GothicBBB-Medium-*' (standard",
+" Japanese PS fonts) without the prefix \"mbfont:\".",
+"", 
+"2 command-line_options",
+"?commands set terminal x11 command-line-options",
+"?set terminal x11 command-line-options",
+"?set term x11 command-line-options",
+"?x11 command-line-options",
+"?command-line-options",
+" In addition to the X Toolkit options, the following options may be specified",
+" on the command line when starting `gnuplot` or as resources in your",
+" \".Xdefaults\" file (note that `raise` and `persist` can be overridden",
+" later by `set term x11 [no]raise [no]persist)`:",
+"@start table - first is interactive cleartext form",
+"  `-mono`     forces monochrome rendering on color displays.",
+"  `-gray`     requests grayscale rendering on grayscale or color displays.",
+"              (Grayscale displays receive monochrome rendering by default.)",
+"  `-clear`    requests that the window be cleared momentarily before a",
+"              new plot is displayed.",
+"  `-tvtwm`    requests that geometry specifications for position of the",
+"              window be made relative to the currently displayed portion",
+"              of the virtual root.",
+"  `-raise`    raises plot window after each plot",
+"  `-noraise`  does not raise plot window after each plot",
+#ifdef USE_MOUSE
+"  `-noevents` does not process mouse and key events",
+"  `-ctrlq   ` closes window on ctrl-q rather than q",
+#endif
+"  `-persist`  plot windows survive after main gnuplot program exits",
+"#\\begin{tabular}{|cl|} \\hline",
+"#`-mono`     & forces monochrome rendering on color displays.\\\\",
+"#`-gray`     & requests grayscale rendering on grayscale or color displays.\\\\",
+"#            & (Grayscale displays receive monochrome rendering by default.) \\\\",
+"#`-clear`    & requests that the window be cleared momentarily before a\\\\",
+"#            & new plot is displayed. \\\\",
+"#`-tvtwm`    & requests that geometry specifications for position of the\\\\",
+"#            & window be made relative to the currently displayed portion\\\\",
+"#            & of the virtual root. \\\\",
+"#`-raise`    & raises plot window after each plot. \\\\",
+"#`-noraise`  & does not raise plot window after each plot. \\\\",
+#ifdef USE_MOUSE
+"#`-noevents` & does not process mouse and key events. \\\\",
+#endif
+"#`-persist`  & plot windows survive after main gnuplot program exits. \\\\",
+"%c l .",
+"%`-mono`@forces monochrome rendering on color displays.",
+"%`-gray`@requests grayscale rendering on grayscale or color displays.",
+"%       @(Grayscale displays receive monochrome rendering by default.)",
+"%`-clear`@requests that the window be cleared momentarily before a",
+"%        @new plot is displayed.",
+"%`-tvtwm`@requests that geometry specifications for position of the",
+"%        @window be made relative to the currently displayed portion",
+"%        @of the virtual root.",
+"%`-raise`@raises plot window after each plot",
+"%`-noraise`@does not raise plot window after each plot",
+#ifdef USE_MOUSE
+"%`-novevents`@does not process mouse and key events",
+"%`-ctrlq`@closes window on ctrl-q rather than q",
+#endif
+"%`-persist`@plot windows survive after main gnuplot program exits",
+"@end table",
+"=X resources",
+" The options are shown above in their command-line syntax.  When entered as",
+" resources in \".Xdefaults\", they require a different syntax.",
+"",
+" Example:",
+"       gnuplot*gray:  on",
+"       gnuplot*ctrlq: on",
+"",
+" `gnuplot` also provides a command line option (`-pointsize <v>`) and a",
+" resource, `gnuplot*pointsize: <v>`, to control the size of points plotted",
+" with the `points` plotting style.  The value `v` is a real number (greater",
+" than 0 and less than or equal to ten) used as a scaling factor for point",
+" sizes.  For example, `-pointsize 2` uses points twice the default size, and",
+" `-pointsize 0.5` uses points half the normal size.",
+"",
+" The `-noevents` switch disables all mouse and key event processing (except",
+" for `q` and `<space>` for closing the window). This is useful for programs",
+" which use the x11 driver independent of the gnuplot main program.",
+"",
+" The `-ctrlq` switch changes the hot-key that closes a plot window from `q`",
+" to `<ctrl>q`. This is useful is you are using the keystroke-capture feature",
+" `pause mouse keystroke`, since it allows the character `q` to be captured",
+" just as all other alphanumeric characters. The `-ctrlq` switch similarly",
+" replaces the <space> hot-key with <ctrl><space> for the same reason.",
+"",
+"2 monochrome_options",
+"?commands set terminal x11 monochrome_options",
+"?set terminal x11 monochrome_options",
+"?set term x11 monochrome_options",
+"?x11 monochrome_options",
+"?monochrome_options",
+"=X resources",
+" For monochrome displays, `gnuplot` does not honor foreground or background",
+" colors.  The default is black-on-white.  `-rv` or `gnuplot*reverseVideo: on`",
+" requests white-on-black.",
+"",
+"2 color_resources",
+"?commands set terminal x11 color_resources",
+"?set terminal x11 color_resources",
+"?set term x11 color_resources",
+"?x11 color_resources",
+"?color_resources",
+"=X resources",
+" The X11 terminal honors the following resources (shown here with their",
+" default values) or the greyscale resources.  The values may be color names",
+" as listed in the X11 rgb.txt file on your system, hexadecimal RGB color",
+" specifications (see X11 documentation), or a color name followed by a comma",
+" and an `intensity` value from 0 to 1.  For example, `blue, 0.5` means a half",
+" intensity blue.",
+"@start table - first is interactive cleartext form",
+"  gnuplot*background:  white",
+"  gnuplot*textColor:   black",
+"  gnuplot*borderColor: black",
+"  gnuplot*axisColor:   black",
+"  gnuplot*line1Color:  red",
+"  gnuplot*line2Color:  green",
+"  gnuplot*line3Color:  blue",
+"  gnuplot*line4Color:  magenta",
+"  gnuplot*line5Color:  cyan",
+"  gnuplot*line6Color:  sienna",
+"  gnuplot*line7Color:  orange",
+"  gnuplot*line8Color:  coral",
+"#\\begin{tabular}{|cl|} \\hline",
+"#&gnuplot*background: white\\\\",
+"#&gnuplot*textColor: black\\\\",
+"#&gnuplot*borderColor: black\\\\",
+"#&gnuplot*axisColor: black\\\\",
+"#&gnuplot*line1Color: red\\\\",
+"#&gnuplot*line2Color: green\\\\",
+"#&gnuplot*line3Color: blue\\\\",
+"#&gnuplot*line4Color: magenta\\\\",
+"#&gnuplot*line5Color: cyan\\\\",
+"#&gnuplot*line6Color: sienna\\\\",
+"#&gnuplot*line7Color: orange\\\\",
+"#&gnuplot*line8Color: coral\\\\",
+"%c l .",
+"%@gnuplot*background: white",
+"%@gnuplot*textColor: black",
+"%@gnuplot*borderColor: black",
+"%@gnuplot*axisColor: black",
+"%@gnuplot*line1Color: red",
+"%@gnuplot*line2Color: green",
+"%@gnuplot*line3Color: blue",
+"%@gnuplot*line4Color: magenta",
+"%@gnuplot*line5Color: cyan",
+"%@gnuplot*line6Color: sienna",
+"%@gnuplot*line7Color: orange",
+"%@gnuplot*line8Color: coral",
+"@end table",
+"",
+" The command-line syntax for these is simple only for background,",
+" which maps directly to the usual X11 toolkit option \"-bg\".  All",
+" others can only be set on the command line by use of the generic",
+" \"-xrm\" resource override option",
+"",
+" Examples:",
+"",
+"       gnuplot -background coral",
+" to change the background color.",
+"",
+"       gnuplot -xrm 'gnuplot*line1Color:blue'",
+" to override the first linetype color.",
+"",
+"2 grayscale_resources",
+"?commands set terminal x11 grayscale_resources",
+"?set terminal x11 grayscale_resources",
+"?set term x11 grayscale_resources",
+"?x11 grayscale_resources",
+"?grayscale_resources",
+"=X resources",
+" When `-gray` is selected, `gnuplot` honors the following resources for",
+" grayscale or color displays (shown here with their default values).  Note",
+" that the default background is black.",
+"@start table - first is interactive cleartext form",
+"  gnuplot*background: black",
+"  gnuplot*textGray:   white",
+"  gnuplot*borderGray: gray50",
+"  gnuplot*axisGray:   gray50",
+"  gnuplot*line1Gray:  gray100",
+"  gnuplot*line2Gray:  gray60",
+"  gnuplot*line3Gray:  gray80",
+"  gnuplot*line4Gray:  gray40",
+"  gnuplot*line5Gray:  gray90",
+"  gnuplot*line6Gray:  gray50",
+"  gnuplot*line7Gray:  gray70",
+"  gnuplot*line8Gray:  gray30",
+"#\\begin{tabular}{|cl|} \\hline",
+"#&gnuplot*background: black\\\\",
+"#&gnuplot*textGray: white\\\\",
+"#&gnuplot*borderGray: gray50\\\\",
+"#&gnuplot*axisGray: gray50\\\\",
+"#&gnuplot*line1Gray: gray100\\\\",
+"#&gnuplot*line2Gray: gray60\\\\",
+"#&gnuplot*line3Gray: gray80\\\\",
+"#&gnuplot*line4Gray: gray40\\\\",
+"#&gnuplot*line5Gray: gray90\\\\",
+"#&gnuplot*line6Gray: gray50\\\\",
+"#&gnuplot*line7Gray: gray70\\\\",
+"#&gnuplot*line8Gray: gray30\\\\",
+"%c l .",
+"%@gnuplot*background: black",
+"%@gnuplot*textGray: white",
+"%@gnuplot*borderGray: gray50",
+"%@gnuplot*axisGray: gray50",
+"%@gnuplot*line1Gray: gray100",
+"%@gnuplot*line2Gray: gray60",
+"%@gnuplot*line3Gray: gray80",
+"%@gnuplot*line4Gray: gray40",
+"%@gnuplot*line5Gray: gray90",
+"%@gnuplot*line6Gray: gray50",
+"%@gnuplot*line7Gray: gray70",
+"%@gnuplot*line8Gray: gray30",
+"@end table",
+"",
+"2 line_resources",
+"?commands set terminal x11 line_resources",
+"?set terminal x11 line_resources",
+"?set term x11 line_resources",
+"?x11 line_resources",
+"?line_resources",
+"=X resources",
+" `gnuplot` honors the following resources for setting the width (in pixels) of",
+" plot lines (shown here with their default values.)  0 or 1 means a minimal",
+" width line of 1 pixel width.  A value of 2 or 3 may improve the appearance of",
+" some plots.",
+"@start table - first is interactive cleartext form",
+"  gnuplot*borderWidth: 2",
+"  gnuplot*axisWidth:   0",
+"  gnuplot*line1Width:  0",
+"  gnuplot*line2Width:  0",
+"  gnuplot*line3Width:  0",
+"  gnuplot*line4Width:  0",
+"  gnuplot*line5Width:  0",
+"  gnuplot*line6Width:  0",
+"  gnuplot*line7Width:  0",
+"  gnuplot*line8Width:  0",
+"#\\begin{tabular}{|cl|} \\hline",
+"#&gnuplot*borderWidth: 2\\\\",
+"#&gnuplot*axisWidth: 0\\\\",
+"#&gnuplot*line1Width: 0\\\\",
+"#&gnuplot*line2Width: 0\\\\",
+"#&gnuplot*line3Width: 0\\\\",
+"#&gnuplot*line4Width: 0\\\\",
+"#&gnuplot*line5Width: 0\\\\",
+"#&gnuplot*line6Width: 0\\\\",
+"#&gnuplot*line7Width: 0\\\\",
+"#&gnuplot*line8Width: 0\\\\",
+"%c l .",
+"%@gnuplot*borderWidth: 2",
+"%@gnuplot*axisWidth: 0",
+"%@gnuplot*line1Width: 0",
+"%@gnuplot*line2Width: 0",
+"%@gnuplot*line3Width: 0",
+"%@gnuplot*line4Width: 0",
+"%@gnuplot*line5Width: 0",
+"%@gnuplot*line6Width: 0",
+"%@gnuplot*line7Width: 0",
+"%@gnuplot*line8Width: 0",
+"@end table",
+"",
+" `gnuplot` honors the following resources for setting the dash style used for",
+" plotting lines.  0 means a solid line.  A two-digit number `jk` (`j` and `k`",
+" are >= 1 and <= 9) means a dashed line with a repeated pattern of `j` pixels",
+" on followed by `k` pixels off.  For example, '16' is a dotted line with one",
+" pixel on followed by six pixels off.  More elaborate on/off patterns can be",
+" specified with a four-digit value.  For example, '4441' is four on, four off,",
+" four on, one off.  The default values shown below are for monochrome displays",
+" or monochrome rendering on color or grayscale displays.",
+" Color displays default to dashed:off ",
+"@start table - first is interactive cleartext form",
+"  gnuplot*dashed:       off",
+"  gnuplot*borderDashes:   0",
+"  gnuplot*axisDashes:    16",
+"  gnuplot*line1Dashes:    0",
+"  gnuplot*line2Dashes:   42",
+"  gnuplot*line3Dashes:   13",
+"  gnuplot*line4Dashes:   44",
+"  gnuplot*line5Dashes:   15",
+"  gnuplot*line6Dashes: 4441",
+"  gnuplot*line7Dashes:   42",
+"  gnuplot*line8Dashes:   13",
+"#\\begin{tabular}{|cl|} \\hline",
+"#&gnuplot*dashed: off\\\\",
+"#&gnuplot*borderDashes: 0\\\\",
+"#&gnuplot*axisDashes: 16\\\\",
+"#&gnuplot*line1Dashes: 0\\\\",
+"#&gnuplot*line2Dashes: 42\\\\",
+"#&gnuplot*line3Dashes: 13\\\\",
+"#&gnuplot*line4Dashes: 44\\\\",
+"#&gnuplot*line5Dashes: 15\\\\",
+"#&gnuplot*line6Dashes: 4441\\\\",
+"#&gnuplot*line7Dashes: 42\\\\",
+"#&gnuplot*line8Dashes: 13\\\\",
+"%c l .",
+"%@gnuplot*dashed: off",
+"%@gnuplot*borderDashes: 0",
+"%@gnuplot*axisDashes: 16",
+"%@gnuplot*line1Dashes: 0",
+"%@gnuplot*line2Dashes: 42",
+"%@gnuplot*line3Dashes: 13",
+"%@gnuplot*line4Dashes: 44",
+"%@gnuplot*line5Dashes: 15",
+"%@gnuplot*line6Dashes: 4441",
+"%@gnuplot*line7Dashes: 42",
+"%@gnuplot*line8Dashes: 13",
+"@end table"
+, "",
+"2 x11 pm3d_resources",
+"?commands set terminal x11 pm3d_resources",
+"?set terminal x11 pm3d_resources",
+"?set term x11 pm3d_resources",
+"?x11 pm3d_resources",
+"?pm3d_resources",
+"?x11 pm3d",
+"=X resources",
+" Choosing the appropriate visual class and number of colors is a crucial",
+" point in X11 applications and a bit awkward, since X11 supports six visual",
+" types in different depths.",
+"",
+" By default `gnuplot` uses the default visual of the screen. The number of",
+" colors which can be allocated depends on the visual class chosen. On a",
+" visual class with a depth > 12bit, gnuplot starts with a maximal number",
+" of 0x200 colors.  On a visual class with a depth > 8bit (but <= 12 bit)",
+" the maximal number of colors is 0x100, on <= 8bit displays the maximum",
+" number of colors is 240 (16 are left for line colors).",
+"",
+" Gnuplot first starts to allocate the maximal number of colors as stated",
+" above.  If this fails, the number of colors is reduced by the factor 2",
+" until gnuplot gets all colors which are requested. If dividing `maxcolors`",
+" by 2 repeatedly results in a number which is smaller than `mincolors`",
+" `gnuplot` tries to install a private colormap. In this case the window",
+" manager is responsible for swapping colormaps when the pointer is moved",
+" in and out the x11 driver's window.",
+"",
+" The default for `mincolors` is maxcolors / (num_colormaps > 1 ? 2 : 8),",
+" where num_colormaps is the number of colormaps which are currently used",
+" by gnuplot (usually 1, if only one x11 window is open).",
+"",
+" Some systems support multiple (different) visual classes together on one",
+" screen. On these systems it might be necessary to force gnuplot to use a",
+" specific visual class, e.g. the default visual might be 8bit PseudoColor",
+" but the screen would also support 24bit TrueColor which would be the",
+" preferred choice.",
+"",
+" The information about an Xserver's capabilities can be obtained with the",
+" program `xdpyinfo`.  For the visual names below you can choose one of",
+" StaticGray, GrayScale, StaticColor, PseudoColor, TrueColor, DirectColor.",
+" If an Xserver supports a requested visual type at different depths,",
+" `gnuplot` chooses the visual class with the highest depth (deepest).",
+" If the requested visual class matches the default visual and multiple",
+" classes of this type are supported, the default visual is preferred.",
+"",
+" Example: on an 8bit PseudoColor visual you can force a private color map",
+" by specifying `gnuplot*maxcolors: 240` and `gnuplot*mincolors: 240`.",
+"",
+"@start table - first is interactive cleartext form",
+"  gnuplot*maxcolors:  <integer>",
+"  gnuplot*mincolors:  <integer>",
+"  gnuplot*visual:     <visual name>",
+"#\\begin{tabular}{|cl|} \\hline",
+"#&gnuplot*maxcolors:  integer\\\\",
+"#&gnuplot*mincolors:  integer\\\\",
+"#&gnuplot*visual:     visual name\\\\",
+"%c l .",
+"%@gnuplot*maxcolors:  <integer number>",
+"%@gnuplot*mincolors:  <integer number>",
+"%@gnuplot*visual:     <visual name>",
+"@end table"
+, "",
+"2 x11 other_resources",
+"?commands set terminal x11 other_resources",
+"?set terminal x11 other_resources",
+"?set term x11 other_resources",
+"?x11 other_resources",
+"=X resources",
+" By default the contents of the current plot window are exported to the X11",
+" clipboard in response to X events in the window. Setting the resource",
+" 'gnuplot*exportselection' to 'off' or 'false' will disable this.",
+"",
+" By default text rotation is done using a method that is fast, but can",
+" corrupt nearby colors depending on the background.  If this is a problem,",
+" you can set the resource 'gnuplot.fastrotate' to 'off'",
+"",
+"@start table - other x11 resources",
+"  gnuplot*exportselection:  off",
+"  gnuplot*fastrotate:  on",
+"  gnuplot*ctrlq:  off",
+"#\\begin{tabular}{|cl|} \\hline",
+"#&gnuplot*exportselection:  off\\\\",
+"#&gnuplot*fastrotate:  on\\\\",
+"#&gnuplot*ctrlq:  off\\\\",
+"%c l .",
+"%@gnuplot*exportselection:  off",
+"%@gnuplot*fastrotate:  on",
+"%@gnuplot*ctrlq:  off",
+"@end table"
+
+END_HELP(x11)
+#endif				/* TERM_HELP */
diff -rupN C:\gnuplot-4.4.0\term/.svn/text-base/xlib.trm.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/xlib.trm.svn-base
--- C:\gnuplot-4.4.0\term/.svn/text-base/xlib.trm.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/.svn/text-base/xlib.trm.svn-base	2012-01-03 17:07:48.500753900 -0800
@@ -0,0 +1,105 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: xlib.trm,v 1.23 2009/03/26 00:49:29 sfeam Exp $
+ */
+
+/* GNUPLOT - xlib.trm */
+
+/*
+ * xlib.trm - inboard terminal driver for X11 (dumps gnuplot_x11 commands)
+ *
+ * New implementation November 2003
+ * Xlib_init() sets up the output channels, but otherwise all work is done
+ * by the main x11.trm driver routines.
+ * Ethan A Merritt <merritt@u.washington.edu>
+ */
+
+#include "driver.h"
+
+#ifdef TERM_REGISTER
+register_term(xlib)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void Xlib_init __PROTO((void));
+TERM_PUBLIC void Xlib_text __PROTO((void));
+TERM_PUBLIC void Xlib_reset __PROTO((void));
+#define GOT_XLIB_PROTO
+#endif
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+TERM_PUBLIC void
+Xlib_init()
+{
+    /* x11.trm thinks it is writing to a private pipe, but here we */
+    /* set it to use the channel opened by 'set output <file>'     */
+    X11_ipc = gpoutfile;
+
+#ifdef PIPE_IPC
+    /* There is, of course, no mouse feedback */
+    ipc_back_fd = IPC_BACK_UNUSABLE;
+#endif
+}
+
+TERM_PUBLIC void
+Xlib_text()
+{
+    PRINT0("E\n");
+    FFLUSH();
+#ifdef PIPE_IPC
+    ipc_back_fd = IPC_BACK_UNUSABLE;
+#endif
+
+}
+
+TERM_PUBLIC void
+Xlib_reset()
+{
+    X11_ipc = NULL;
+}
+
+#endif
+
+#ifdef TERM_TABLE
+TERM_TABLE_START(xlib_driver)
+    "xlib", "X11 Window System (gnulib_x11 dump)",
+    X11_XMAX, X11_YMAX, X11_VCHAR, X11_HCHAR,
+    X11_VTIC, X11_HTIC, X11_options, Xlib_init, Xlib_reset,
+    Xlib_text, null_scale, X11_graphics, X11_move, X11_vector,
+    X11_linetype, X11_put_text, X11_text_angle,
+    X11_justify_text, X11_point, do_arrow, X11_set_font,
+    X11_pointsize, TERM_CAN_MULTIPLOT|TERM_INIT_ON_REPLOT|TERM_CAN_DASH,
+    X11_text /* suspend can use same routine */ , 0 /* resume */ ,
+    X11_fillbox, X11_linewidth
+#ifdef USE_MOUSE
+    , X11_waitforinput, X11_put_tmptext, X11_set_ruler, X11_set_cursor, X11_set_clipboard
+#endif
+    , X11_make_palette, 0 /* X11_previous_palette */ ,
+    X11_set_color, X11_filled_polygon
+    , X11_image
+    , ENHX11_OPEN, ENHX11_FLUSH, do_enh_writec
+TERM_TABLE_END(xlib_driver)
+
+#undef LAST_TERM
+#define LAST_TERM xlib_driver
+
+#endif /* TERM_TABLE */
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(xlib)
+"1 xlib",
+"?commands set terminal xlib",
+"?set terminal xlib",
+"?set term xlib",
+"?terminal xlib",
+"?term xlib",
+"?xlib",
+" The `xlib` terminal driver supports the X11 Windows System.  It generates",
+" gnuplot_x11 commands, but sends them to the output file specified by",
+" `set output '<filename>'`. `set term x11` is equivalent to",
+" `set output \"|gnuplot_x11 -noevents\"; set term xlib`.",
+" `xlib` takes the same set of options as `x11`."
+END_HELP(xlib)
+#endif
diff -rupN C:\gnuplot-4.4.0\term/Makefile C:\Users\champioc\workspace\AddiPlot\jni\term/Makefile
--- C:\gnuplot-4.4.0\term/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/Makefile	2012-01-03 15:32:39.263035900 -0800
@@ -0,0 +1,511 @@
+# Makefile.in generated by automake 1.11 from Makefile.am.
+# term/Makefile.  Generated from Makefile.in by configure.
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+
+
+
+pkgdatadir = $(datadir)/gnuplot
+pkgincludedir = $(includedir)/gnuplot
+pkglibdir = $(libdir)/gnuplot
+pkglibexecdir = $(libexecdir)/gnuplot
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+subdir = term
+DIST_COMMON = README $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/m4/alpha.m4 \
+	$(top_srcdir)/m4/apple.m4 $(top_srcdir)/m4/beos.m4 \
+	$(top_srcdir)/m4/msdos.m4 $(top_srcdir)/m4/next.m4 \
+	$(top_srcdir)/m4/pkg.m4 $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+SOURCES =
+DIST_SOURCES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
+am__install_max = 40
+am__nobase_strip_setup = \
+  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
+am__nobase_strip = \
+  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
+am__nobase_list = $(am__nobase_strip_setup); \
+  for p in $$list; do echo "$$p $$p"; done | \
+  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
+  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
+    if (++n[$$2] == $(am__install_max)) \
+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
+    END { for (dir in files) print dir, files[dir] }'
+am__base_list = \
+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
+  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+am__installdirs = "$(DESTDIR)$(jsdir)" "$(DESTDIR)$(luadir)" \
+	"$(DESTDIR)$(postscriptdir)"
+DATA = $(js_DATA) $(lua_DATA) $(postscript_DATA)
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = ${SHELL} /u/champioc/gnuplot-4.4.0/missing --run aclocal-1.11
+AMTAR = ${SHELL} /u/champioc/gnuplot-4.4.0/missing --run tar
+AUTOCONF = ${SHELL} /u/champioc/gnuplot-4.4.0/missing --run autoconf
+AUTOHEADER = ${SHELL} /u/champioc/gnuplot-4.4.0/missing --run autoheader
+AUTOMAKE = ${SHELL} /u/champioc/gnuplot-4.4.0/missing --run automake-1.11
+AWK = gawk
+CAIROPANGO_CFLAGS = -I/usr/include/cairo -I/usr/include/freetype2 -I/usr/include/libpng12 -I/usr/include/pango-1.0 -I/usr/include/glib-2.0 -I/usr/lib64/glib-2.0/include  
+CAIROPANGO_LIBS = -L/lib64 -lpangocairo-1.0 -lpango-1.0 -lcairo -lgobject-2.0 -lgmodule-2.0 -ldl -lglib-2.0  
+CAIROPDF_CFLAGS = -I/usr/include/cairo -I/usr/include/freetype2 -I/usr/include/libpng12 -I/usr/include/pango-1.0 -I/usr/include/glib-2.0 -I/usr/lib64/glib-2.0/include  
+CAIROPDF_LIBS = -L/lib64 -lz -lpangocairo-1.0 -lpango-1.0 -lcairo -lgobject-2.0 -lgmodule-2.0 -ldl -lglib-2.0  
+CC = gcc
+CCDEPMODE = depmode=gcc3
+CFLAGS = -g -O2
+CPP = gcc -E
+CPPFLAGS =   -I/usr/include -I/usr/include/cairo -I/usr/include/freetype2 -I/usr/include/libpng12 -I/usr/include/pango-1.0 -I/usr/include/glib-2.0 -I/usr/lib64/glib-2.0/include  
+CXX = g++
+CXXCPP = g++ -E
+CXXDEPMODE = depmode=gcc3
+CXXFLAGS = -g -O2
+CYGPATH_W = echo
+DEFS = -DHAVE_CONFIG_H
+DEPDIR = .deps
+DIST_CONTACT = 
+DVIPS = dvips
+ECHO_C = 
+ECHO_N = -n
+ECHO_T = 
+EGREP = /bin/grep -E
+EMACS = emacs
+EXEEXT = 
+GDLIB_CONFIG = /usr/bin/gdlib-config
+GIHDIR = ${datarootdir}/gnuplot/4.4
+GREP = /bin/grep
+GTK28_CFLAGS = 
+GTK28_LIBS = 
+GTK_CFLAGS = 
+GTK_LIBS = 
+INSTALL = /usr/bin/install -c
+INSTALL_DATA = ${INSTALL} -m 644
+INSTALL_PROGRAM = ${INSTALL}
+INSTALL_SCRIPT = ${INSTALL}
+INSTALL_STRIP_PROGRAM = $(install_sh) -c -s
+KPSEXPAND = kpsexpand
+LASERGNU = lasergnu-noinstall
+LATEX = latex
+LDFLAGS =  -L/usr/lib64
+LIBOBJS = 
+LIBRARIES_FOR_X =  -lX11 
+LIBS = -lm  -L/lib64 -lz -lpangocairo-1.0 -lpango-1.0 -lcairo -lgobject-2.0 -lgmodule-2.0 -ldl -lglib-2.0  
+LINUXSUID = 
+LISPDIR = lisp
+LN_S = ln -s
+LTLIBOBJS = 
+LUA_CFLAGS = 
+LUA_LIBS = 
+MAKEINFO = ${SHELL} /u/champioc/gnuplot-4.4.0/missing --run makeinfo
+MKDIR_P = /bin/mkdir -p
+OBJEXT = o
+PACKAGE = gnuplot
+PACKAGE_BUGREPORT = 
+PACKAGE_NAME = gnuplot
+PACKAGE_STRING = gnuplot 4.4.0
+PACKAGE_TARNAME = gnuplot
+PACKAGE_URL = 
+PACKAGE_VERSION = 4.4.0
+PANGO_1_10_2_CFLAGS = 
+PANGO_1_10_2_LIBS = 
+PATH_SEPARATOR = :
+PDFLATEX = pdflatex
+PDFLIB_CONFIG = 
+PKG_CONFIG = /usr/bin/pkg-config
+PLAINTEX = tex
+SET_MAKE = 
+SHELL = /bin/sh
+STRIP = 
+TERMLIBS =  -lreadline  -lncurses  -lz -lgd -lXpm -lX11 -ljpeg -lfontconfig -lfreetype -lpng12 -lz -lm -ljpeg -lfreetype -lpng
+TERMXLIBS = 
+TEXDIR = /usr/local/share/texmf/tex/latex/gnuplot
+TEXHASH = texhash
+TROFF = troff
+TUTORIAL = tutorial
+U = 
+VERSION = 4.4.0
+VERSION_MAJOR = 4.4
+WX_CONFIG = no
+WX_LIBS = 
+X11_APPDEFAULTS_DIR = /etc/X11/app-defaults/
+XMKMF = 
+X_CFLAGS = 
+X_EXTRA_LIBS = 
+X_LIBS = 
+X_PRE_LIBS =  -lSM -lICE
+abs_builddir = /u/champioc/gnuplot-4.4.0/term
+abs_srcdir = /u/champioc/gnuplot-4.4.0/term
+abs_top_builddir = /u/champioc/gnuplot-4.4.0
+abs_top_srcdir = /u/champioc/gnuplot-4.4.0
+ac_ct_CC = gcc
+ac_ct_CXX = g++
+am__include = include
+am__leading_dot = .
+am__quote = 
+am__tar = ${AMTAR} chof - "$$tardir"
+am__untar = ${AMTAR} xf -
+bindir = ${exec_prefix}/bin
+build_alias = 
+builddir = .
+datadir = ${datarootdir}
+datarootdir = ${prefix}/share
+docdir = ${datarootdir}/doc/${PACKAGE_TARNAME}
+dvidir = ${docdir}
+exec_prefix = ${prefix}
+host_alias = 
+htmldir = ${docdir}
+includedir = ${prefix}/include
+infodir = ${datarootdir}/info
+install_sh = ${SHELL} /u/champioc/gnuplot-4.4.0/install-sh
+libdir = ${exec_prefix}/lib
+libexecdir = ${exec_prefix}/libexec
+localedir = ${datarootdir}/locale
+localstatedir = ${prefix}/var
+mandir = ${datarootdir}/man
+mkdir_p = /bin/mkdir -p
+oldincludedir = /usr/include
+pdfdir = ${docdir}
+prefix = /usr/local
+program_transform_name = s,x,x,
+psdir = ${docdir}
+sbindir = ${exec_prefix}/sbin
+sharedstatedir = ${prefix}/com
+srcdir = .
+subdirs =  lisp
+sysconfdir = ${prefix}/etc
+target_alias = 
+top_build_prefix = ../
+top_builddir = ..
+top_srcdir = ..
+AUTOMAKE_OPTIONS = foreign 1.2h
+EXTRA_DIST = README Makefile.am.in driver.h impcodes.h \
+object.h post.h $(CORETERM) PostScript lua js
+
+postscriptdir = $(pkgdatadir)/$(VERSION_MAJOR)/PostScript
+luadir = $(pkgdatadir)/$(VERSION_MAJOR)/lua
+jsdir = $(pkgdatadir)/$(VERSION_MAJOR)/js
+
+# List of terminal drivers, and list of postscript installation files
+# must be created prior to running automake
+CORETERM = aed.trm ai.trm amiga.trm apollo.trm aquaterm.trm be.trm \
+cairo.trm canvas.trm cgi.trm cgm.trm corel.trm debug.trm djsvga.trm \
+dumb.trm dxf.trm dxy.trm eepic.trm emf.trm emxvga.trm epson.trm \
+estimate.trm excl.trm fg.trm fig.trm gd.trm ggi.trm gnugraph.trm \
+gpic.trm gpr.trm grass.trm hp2648.trm hp26.trm hp500c.trm hpgl.trm \
+hpljii.trm hppj.trm imagen.trm kyo.trm latex.trm linux.trm lua.trm \
+mac.trm metafont.trm metapost.trm mgr.trm mif.trm next.trm openstep.trm \
+pbm.trm pc.trm pdf.trm pm.trm post.trm pslatex.trm pstricks.trm qms.trm \
+regis.trm rgip.trm sun.trm svg.trm t410x.trm tek.trm texdraw.trm tgif.trm \
+tkcanvas.trm tpic.trm unixpc.trm unixplot.trm v384.trm vgagl.trm vws.trm \
+win.trm wxt.trm x11.trm xlib.trm 
+
+#
+postscript_DATA = PostScript/8859-15.ps PostScript/8859-1.ps \
+PostScript/8859-2.ps PostScript/8859-9.ps PostScript/cp1250.ps \
+PostScript/cp437.ps PostScript/cp850.ps PostScript/cp852.ps \
+PostScript/koi8r.ps PostScript/koi8u.ps PostScript/prologue.ps \
+PostScript/utf-8.ps PostScript/aglfn.txt 
+
+js_DATA = js/canvasmath.js js/canvastext.js js/gnuplot_common.js \
+js/gnuplot_mouse.js js/grid.png js/help.png js/nextzoom.png \
+js/previouszoom.png js/textzoom.png js/gnuplot_mouse.css js/README 
+
+lua_DATA = lua/gnuplot-tikz.lua 
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign term/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign term/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+install-jsDATA: $(js_DATA)
+	@$(NORMAL_INSTALL)
+	test -z "$(jsdir)" || $(MKDIR_P) "$(DESTDIR)$(jsdir)"
+	@list='$(js_DATA)'; test -n "$(jsdir)" || list=; \
+	for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  echo "$$d$$p"; \
+	done | $(am__base_list) | \
+	while read files; do \
+	  echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(jsdir)'"; \
+	  $(INSTALL_DATA) $$files "$(DESTDIR)$(jsdir)" || exit $$?; \
+	done
+
+uninstall-jsDATA:
+	@$(NORMAL_UNINSTALL)
+	@list='$(js_DATA)'; test -n "$(jsdir)" || list=; \
+	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
+	test -n "$$files" || exit 0; \
+	echo " ( cd '$(DESTDIR)$(jsdir)' && rm -f" $$files ")"; \
+	cd "$(DESTDIR)$(jsdir)" && rm -f $$files
+install-luaDATA: $(lua_DATA)
+	@$(NORMAL_INSTALL)
+	test -z "$(luadir)" || $(MKDIR_P) "$(DESTDIR)$(luadir)"
+	@list='$(lua_DATA)'; test -n "$(luadir)" || list=; \
+	for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  echo "$$d$$p"; \
+	done | $(am__base_list) | \
+	while read files; do \
+	  echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(luadir)'"; \
+	  $(INSTALL_DATA) $$files "$(DESTDIR)$(luadir)" || exit $$?; \
+	done
+
+uninstall-luaDATA:
+	@$(NORMAL_UNINSTALL)
+	@list='$(lua_DATA)'; test -n "$(luadir)" || list=; \
+	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
+	test -n "$$files" || exit 0; \
+	echo " ( cd '$(DESTDIR)$(luadir)' && rm -f" $$files ")"; \
+	cd "$(DESTDIR)$(luadir)" && rm -f $$files
+install-postscriptDATA: $(postscript_DATA)
+	@$(NORMAL_INSTALL)
+	test -z "$(postscriptdir)" || $(MKDIR_P) "$(DESTDIR)$(postscriptdir)"
+	@list='$(postscript_DATA)'; test -n "$(postscriptdir)" || list=; \
+	for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  echo "$$d$$p"; \
+	done | $(am__base_list) | \
+	while read files; do \
+	  echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(postscriptdir)'"; \
+	  $(INSTALL_DATA) $$files "$(DESTDIR)$(postscriptdir)" || exit $$?; \
+	done
+
+uninstall-postscriptDATA:
+	@$(NORMAL_UNINSTALL)
+	@list='$(postscript_DATA)'; test -n "$(postscriptdir)" || list=; \
+	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
+	test -n "$$files" || exit 0; \
+	echo " ( cd '$(DESTDIR)$(postscriptdir)' && rm -f" $$files ")"; \
+	cd "$(DESTDIR)$(postscriptdir)" && rm -f $$files
+tags: TAGS
+TAGS:
+
+ctags: CTAGS
+CTAGS:
+
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(DATA)
+installdirs:
+	for dir in "$(DESTDIR)$(jsdir)" "$(DESTDIR)$(luadir)" "$(DESTDIR)$(postscriptdir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am: install-jsDATA install-luaDATA install-postscriptDATA
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-jsDATA uninstall-luaDATA \
+	uninstall-postscriptDATA
+
+.MAKE: install-am install-strip
+
+.PHONY: all all-am check check-am clean clean-generic distclean \
+	distclean-generic distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-jsDATA \
+	install-luaDATA install-man install-pdf install-pdf-am \
+	install-postscriptDATA install-ps install-ps-am install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic pdf \
+	pdf-am ps ps-am uninstall uninstall-am uninstall-jsDATA \
+	uninstall-luaDATA uninstall-postscriptDATA
+
+
+Makefile.am: Makefile.am.in
+	rm -f $@ $@t
+	sed -n '1,/^##trm-files-begin/p' Makefile.am.in > $@t
+	echo CORETERM = *.trm | fmt | (tr '\012' @; echo) \
+	  |sed 's/@$$/%/;s/@/ \\@/g' | tr @% '\012 ' \
+	  >> $@t
+	echo '#' >> $@t
+	echo postscript_DATA = PostScript/*.ps PostScript/*.txt | fmt \
+	  | (tr '\012' @; echo) |sed 's/@$$/%/;s/@/ \\@/g' \
+	  | tr @% '\012 ' >> $@t
+	echo js_DATA = js/*.js js/*.png js/*.css js/README | fmt \
+	  | (tr '\012' @; echo) |sed 's/@$$/%/;s/@/ \\@/g' \
+	  | tr @% '\012 ' >> $@t
+	echo lua_DATA = lua/gnuplot-tikz.lua | fmt \
+	  | (tr '\012' @; echo) |sed 's/@$$/%/;s/@/ \\@/g' \
+	  | tr @% '\012 ' >> $@t
+	sed -n '/^##trm-files-end/,$$p' Makefile.am.in >> $@t
+	chmod a-w $@t
+	mv $@t $@
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -rupN C:\gnuplot-4.4.0\term/PostScript/.svn/all-wcprops C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/all-wcprops
--- C:\gnuplot-4.4.0\term/PostScript/.svn/all-wcprops	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/all-wcprops	2012-01-03 17:08:13.834450700 -0800
@@ -0,0 +1,119 @@
+K 25
+svn:wc:ra_dav:version-url
+V 42
+/svn/!svn/ver/39/trunk/jni/term/PostScript
+END
+8859-9.ps
+K 25
+svn:wc:ra_dav:version-url
+V 52
+/svn/!svn/ver/39/trunk/jni/term/PostScript/8859-9.ps
+END
+unicode_maps.README
+K 25
+svn:wc:ra_dav:version-url
+V 62
+/svn/!svn/ver/39/trunk/jni/term/PostScript/unicode_maps.README
+END
+8859-15.ps
+K 25
+svn:wc:ra_dav:version-url
+V 53
+/svn/!svn/ver/39/trunk/jni/term/PostScript/8859-15.ps
+END
+cp437.ps
+K 25
+svn:wc:ra_dav:version-url
+V 51
+/svn/!svn/ver/39/trunk/jni/term/PostScript/cp437.ps
+END
+prologues.h
+K 25
+svn:wc:ra_dav:version-url
+V 54
+/svn/!svn/ver/39/trunk/jni/term/PostScript/prologues.h
+END
+8859-2.ps
+K 25
+svn:wc:ra_dav:version-url
+V 52
+/svn/!svn/ver/39/trunk/jni/term/PostScript/8859-2.ps
+END
+cp1250.ps
+K 25
+svn:wc:ra_dav:version-url
+V 52
+/svn/!svn/ver/39/trunk/jni/term/PostScript/cp1250.ps
+END
+8859-1.ps
+K 25
+svn:wc:ra_dav:version-url
+V 52
+/svn/!svn/ver/39/trunk/jni/term/PostScript/8859-1.ps
+END
+cp852.ps
+K 25
+svn:wc:ra_dav:version-url
+V 51
+/svn/!svn/ver/39/trunk/jni/term/PostScript/cp852.ps
+END
+prologue.ps
+K 25
+svn:wc:ra_dav:version-url
+V 54
+/svn/!svn/ver/39/trunk/jni/term/PostScript/prologue.ps
+END
+cp850.ps
+K 25
+svn:wc:ra_dav:version-url
+V 51
+/svn/!svn/ver/39/trunk/jni/term/PostScript/cp850.ps
+END
+unicode_big.map
+K 25
+svn:wc:ra_dav:version-url
+V 58
+/svn/!svn/ver/39/trunk/jni/term/PostScript/unicode_big.map
+END
+README
+K 25
+svn:wc:ra_dav:version-url
+V 49
+/svn/!svn/ver/39/trunk/jni/term/PostScript/README
+END
+koi8u.ps
+K 25
+svn:wc:ra_dav:version-url
+V 51
+/svn/!svn/ver/39/trunk/jni/term/PostScript/koi8u.ps
+END
+aglfn.txt
+K 25
+svn:wc:ra_dav:version-url
+V 52
+/svn/!svn/ver/39/trunk/jni/term/PostScript/aglfn.txt
+END
+koi8r.ps
+K 25
+svn:wc:ra_dav:version-url
+V 51
+/svn/!svn/ver/39/trunk/jni/term/PostScript/koi8r.ps
+END
+unicode_small.map
+K 25
+svn:wc:ra_dav:version-url
+V 60
+/svn/!svn/ver/39/trunk/jni/term/PostScript/unicode_small.map
+END
+ps_header.sh
+K 25
+svn:wc:ra_dav:version-url
+V 55
+/svn/!svn/ver/39/trunk/jni/term/PostScript/ps_header.sh
+END
+utf-8.ps
+K 25
+svn:wc:ra_dav:version-url
+V 51
+/svn/!svn/ver/39/trunk/jni/term/PostScript/utf-8.ps
+END
diff -rupN C:\gnuplot-4.4.0\term/PostScript/.svn/entries C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/entries
--- C:\gnuplot-4.4.0\term/PostScript/.svn/entries	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/entries	2012-01-03 17:08:13.838461100 -0800
@@ -0,0 +1,681 @@
+10
+
+dir
+39
+https://addiplot.googlecode.com/svn/trunk/jni/term/PostScript
+https://addiplot.googlecode.com/svn
+
+
+
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+svn:special svn:externals svn:needs-lock
+
+
+
+
+
+
+
+
+
+
+
+776c9c97-d481-0677-478a-dd5044256a82
+
+
+
+
+
+
+0
+
+8859-1.ps
+file
+
+
+
+
+2012-01-03T23:32:38.476000Z
+18722c4465e1c6c0fc4bc565346ce940
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+2144
+
+8859-15.ps
+file
+
+
+
+
+2012-01-03T23:32:38.356000Z
+8f03ab19e7bc319d4a173dab407df3f1
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+2123
+
+8859-2.ps
+file
+
+
+
+
+2012-01-03T23:32:38.516000Z
+a20e49099fc059d408e79d18eb6297c6
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+2344
+
+8859-9.ps
+file
+
+
+
+
+2012-01-03T23:32:38.363000Z
+81d58290f91fbca8a1eaae951ee35b02
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+2238
+
+README
+file
+
+
+
+
+2012-01-03T23:32:38.459000Z
+b616fd26622efddbc624a27a7f5f41d6
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+394
+
+aglfn.txt
+file
+
+
+
+
+2012-01-03T23:32:38.527000Z
+a27effe53b21cc5eaecc27cd573ebe07
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+37634
+
+cp1250.ps
+file
+
+
+
+
+2012-01-03T23:32:38.425000Z
+d3e19a583925d9d38525741cb8b779bb
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+2187
+
+cp437.ps
+file
+
+
+
+
+2012-01-03T23:32:38.483000Z
+9b97e97caff1af6fb9f5546e87aecadd
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+2396
+
+cp850.ps
+file
+
+
+
+
+2012-01-03T23:32:38.411000Z
+2437c7ae8919ba6084949f77758e0d91
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+2335
+
+cp852.ps
+file
+
+
+
+
+2012-01-03T23:32:38.390000Z
+1f9bdf7c939e9a9afaa0ca2efe06e2da
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+2110
+
+koi8r.ps
+file
+
+
+
+
+2012-01-03T23:32:38.507000Z
+b695c96173a8466877a851eb4e0b1634
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+2461
+
+koi8u.ps
+file
+
+
+
+
+2012-01-03T23:32:38.491000Z
+46153af3fe063cec19a2f1786ca7c355
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+2281
+
+prologue.ps
+file
+
+
+
+
+2012-01-03T23:32:38.452000Z
+9fd1e5efc3886e49bb396bc1a540e246
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+13952
+
+prologues.h
+file
+
+
+
+
+2012-01-03T23:32:38.436000Z
+ad2ccf658a17649d0ad89ecce7459c9d
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+44582
+
+ps_header.sh
+file
+
+
+
+
+2012-01-03T23:32:38.468000Z
+237b39dd09475c322e27c1f0d23055c8
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+531
+
+unicode_big.map
+file
+
+
+
+
+2012-01-03T23:32:38.538000Z
+f206e19a3369e15107d83d1d36d23e7a
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+17590
+
+unicode_maps.README
+file
+
+
+
+
+2012-01-03T23:32:38.499000Z
+dfe9eba92fe3010f91b770360947eb38
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+2697
+
+unicode_small.map
+file
+
+
+
+
+2012-01-03T23:32:38.383000Z
+d3ef1ef56a73f4a5e63f08a44829c30b
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+8876
+
+utf-8.ps
+file
+
+
+
+
+2012-01-03T23:32:38.403000Z
+ae57789013d77c554f953b31b08b1053
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+2776
+
diff -rupN C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/8859-1.ps.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/8859-1.ps.svn-base
--- C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/8859-1.ps.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/8859-1.ps.svn-base	2012-01-03 17:07:19.613842700 -0800
@@ -0,0 +1,43 @@
+%
+% Encoding for ISO-8859-1 (also called Latin1)
+%
+/reencodeISO {
+dup dup findfont dup length dict begin
+{ 1 index /FID ne { def }{ pop pop } ifelse } forall
+currentdict /CharStrings known {
+	CharStrings /Idieresis known {
+		/Encoding ISOLatin1Encoding def } if
+} if
+currentdict end definefont
+} def
+/ISOLatin1Encoding [
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright
+/parenleft/parenright/asterisk/plus/comma/minus/period/slash
+/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon
+/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N
+/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright
+/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m
+/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/dotlessi/grave/acute/circumflex/tilde/macron/breve
+/dotaccent/dieresis/.notdef/ring/cedilla/.notdef/hungarumlaut
+/ogonek/caron/space/exclamdown/cent/sterling/currency/yen/brokenbar
+/section/dieresis/copyright/ordfeminine/guillemotleft/logicalnot
+/hyphen/registered/macron/degree/plusminus/twosuperior/threesuperior
+/acute/mu/paragraph/periodcentered/cedilla/onesuperior/ordmasculine
+/guillemotright/onequarter/onehalf/threequarters/questiondown
+/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/AE/Ccedilla
+/Egrave/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex
+/Idieresis/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis
+/multiply/Oslash/Ugrave/Uacute/Ucircumflex/Udieresis/Yacute
+/Thorn/germandbls/agrave/aacute/acircumflex/atilde/adieresis
+/aring/ae/ccedilla/egrave/eacute/ecircumflex/edieresis/igrave
+/iacute/icircumflex/idieresis/eth/ntilde/ograve/oacute/ocircumflex
+/otilde/odieresis/divide/oslash/ugrave/uacute/ucircumflex/udieresis
+/yacute/thorn/ydieresis
+] def
diff -rupN C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/8859-15.ps.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/8859-15.ps.svn-base
--- C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/8859-15.ps.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/8859-15.ps.svn-base	2012-01-03 17:07:19.876523900 -0800
@@ -0,0 +1,43 @@
+%
+% Encoding for ISO-8859-15 (also called Latin9)
+%
+/reencodeISO15 {
+dup dup findfont dup length dict begin
+{ 1 index /FID ne { def }{ pop pop } ifelse } forall
+currentdict /CharStrings known {
+	CharStrings /Idieresis known {
+		/Encoding ISOLatin15Encoding def } if
+} if
+currentdict end definefont
+} def
+/ISOLatin15Encoding [
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright
+/parenleft/parenright/asterisk/plus/comma/minus/period/slash
+/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon
+/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N
+/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright
+/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m
+/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/dotlessi/grave/acute/circumflex/tilde/macron/breve
+/dotaccent/dieresis/.notdef/ring/cedilla/.notdef/hungarumlaut
+/ogonek/caron/space/exclamdown/cent/sterling/Euro/yen/Scaron
+/section/scaron/copyright/ordfeminine/guillemotleft/logicalnot
+/hyphen/registered/macron/degree/plusminus/twosuperior/threesuperior
+/Zcaron/mu/paragraph/periodcentered/zcaron/onesuperior/ordmasculine
+/guillemotright/OE/oe/Ydieresis/questiondown
+/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/AE/Ccedilla
+/Egrave/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex
+/Idieresis/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis
+/multiply/Oslash/Ugrave/Uacute/Ucircumflex/Udieresis/Yacute
+/Thorn/germandbls/agrave/aacute/acircumflex/atilde/adieresis
+/aring/ae/ccedilla/egrave/eacute/ecircumflex/edieresis/igrave
+/iacute/icircumflex/idieresis/eth/ntilde/ograve/oacute/ocircumflex
+/otilde/odieresis/divide/oslash/ugrave/uacute/ucircumflex/udieresis
+/yacute/thorn/ydieresis
+] def
diff -rupN C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/8859-2.ps.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/8859-2.ps.svn-base
--- C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/8859-2.ps.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/8859-2.ps.svn-base	2012-01-03 17:07:20.124166100 -0800
@@ -0,0 +1,46 @@
+%
+% Encoding for ISO-8859-2 (also called Latin2), with
+% minor differences to "true" ISO-8859-2 (*commaaccent 
+% instead of *cedilla for sStT -> incorrect in ISO-8859-2,
+% the standard will probably be modified in this respect)
+%      Levente Novak <novak@jaguar.dote.hu>
+
+/reencodeISO2 {
+dup dup findfont dup length dict begin
+{ 1 index /FID ne { def }{ pop pop } ifelse } forall
+currentdict /CharStrings known {
+	CharStrings /Idieresis known {
+		/Encoding ISOLatin2Encoding def } if
+} if
+currentdict end definefont
+} def
+/ISOLatin2Encoding [
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright
+/parenleft/parenright/asterisk/plus/comma/hyphen/period/slash
+/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon
+/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M
+/N/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright
+/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m
+/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/nbspace/Aogonek/breve/Lslash/currency/Lcaron/Sacute/section
+/dieresis/Scaron/Scommaaccent/Tcaron/Zacute/hyphen/Zcaron/Zdotaccent
+/degree/aogonek/ogonek/lslash/acute/lcaron/sacute/caron/cedilla
+/scaron/scommaaccent/tcaron/zacute/hungarumlaut/zcaron/zdotaccent
+/Racute/Aacute/Acircumflex/Abreve/Adieresis/Lacute/Cacute/Ccedilla
+/Ccaron/Eacute/Eogonek/Edieresis/Ecaron/Iacute/Icircumflex/Dcaron
+/Dcroat/Nacute/Ncaron/Oacute/Ocircumflex/Ohungarumlaut/Odieresis
+/multiply/Rcaron/Uring/Uacute/Uhungarumlaut/Udieresis/Yacute
+/Tcommaaccent/germandbls/racute/aacute/acircumflex/abreve/adieresis
+/lacute/cacute/ccedilla/ccaron/eacute/eogonek/edieresis/ecaron
+/iacute/icircumflex/dcaron/dcroat/nacute/ncaron/oacute/ocircumflex
+/ohungarumlaut/odieresis/divide/rcaron/uring/uacute/uhungarumlaut
+/udieresis/yacute/tcommaaccent/dotaccent
+] def
diff -rupN C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/8859-9.ps.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/8859-9.ps.svn-base
--- C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/8859-9.ps.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/8859-9.ps.svn-base	2012-01-03 17:07:20.325688700 -0800
@@ -0,0 +1,44 @@
+%
+% Encoding for ISO_8859_9 (also called Latin5)
+% Plus code points 80-9F used in Codepage 1254
+%
+/reencodeISO9 {
+dup dup findfont dup length dict begin
+{ 1 index /FID ne { def }{ pop pop } ifelse } forall
+currentdict /CharStrings known {
+	CharStrings /Idieresis known {
+		/Encoding ISOLatin5Encoding def } if
+} if
+currentdict end definefont
+} def
+/ISOLatin5Encoding [
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright
+/parenleft/parenright/asterisk/plus/comma/minus/period/slash
+/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon
+/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N
+/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright
+/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m
+/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde
+/Euro/.notdef/quotesinglbase/florin/quotedblbase/ellipsis/dagger/daggerdbl
+/circumflex/perthousand/Scaron/guilsinglleft/OE/.notdef/.notdef/.notdef
+/.notdef/quoteleft/quoteright/quotedblleft/quotedblright/bullet/endash/emdash
+/tilde/trademark/scaron/guilsinglright/oe/.notdef/.notdef/Ydieresis
+/.notdef/space/exclamdown/cent/sterling/currency/yen/brokenbar
+/section/dieresis/copyright/ordfeminine/guillemotleft/logicalnot
+/hyphen/registered/macron/degree/plusminus/twosuperior/threesuperior
+/acute/mu/paragraph/bullet/cedilla/onesuperior/ordmasculine
+/guillemotright/onequarter/onehalf/threequarters/questiondown
+/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/AE/Ccedilla
+/Egrave/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex
+/Idieresis/Gbreve/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis
+/multiply/Oslash/Ugrave/Uacute/Ucircumflex/Udieresis/Idotaccent
+/Scedilla/germandbls/agrave/aacute/acircumflex/atilde/adieresis
+/aring/ae/ccedilla/egrave/eacute/ecircumflex/edieresis/igrave
+/iacute/icircumflex/idieresis/gbreve/ntilde/ograve/oacute/ocircumflex
+/otilde/odieresis/divide/oslash/ugrave/uacute/ucircumflex/udieresis
+/dotlessi/scedilla/ydieresis
+] def
diff -rupN C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/README.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/README.svn-base
--- C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/README.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/README.svn-base	2012-01-03 17:07:20.528213900 -0800
@@ -0,0 +1,7 @@
+On platforms where it is possible and easy to implement, the postscript
+prologues files are installed as separate files and located at run-time.
+
+On others (i.e. when the preprocessor variable GNUPLOT_PS_DIR is undefined),
+they are included at compile-time. To do that, the *.ps files are processed by
+the script ps_header.sh which creates char arrays suitable to inclusion in the
+source code.
diff -rupN C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/aglfn.txt.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/aglfn.txt.svn-base
--- C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/aglfn.txt.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/aglfn.txt.svn-base	2012-01-03 17:07:20.738759900 -0800
@@ -0,0 +1,933 @@
+# This document was obtained from http://www.adobe.com/devnet/opentype/archives/aglfn.txt
+# ###################################################################################
+# Copyright (c) 2003,2005,2006,2007 Adobe Systems Incorporated
+# 
+# Permission is hereby granted, free of charge, to any person obtaining a
+# copy of this documentation file to use, copy, publish, distribute,
+# sublicense, and/or sell copies of the documentation, and to permit
+# others to do the same, provided that:
+# - No modification, editing or other alteration of this document is
+# allowed; and
+# - The above copyright notice and this permission notice shall be
+# included in all copies of the documentation.
+# 
+# Permission is hereby granted, free of charge, to any person obtaining a
+# copy of this documentation file, to create their own derivative works
+# from the content of this document to use, copy, publish, distribute,
+# sublicense, and/or sell the derivative works, and to permit others to do
+# the same, provided that the derived work is not represented as being a
+# copy or version of this document.
+# 
+# Adobe shall not be liable to any party for any loss of revenue or profit
+# or for indirect, incidental, special, consequential, or other similar
+# damages, whether based on tort (including without limitation negligence
+# or strict liability), contract or other legal or equitable grounds even
+# if Adobe has been advised or had reason to know of the possibility of
+# such damages. The Adobe materials are provided on an "AS IS" basis.
+# Adobe specifically disclaims all express, statutory, or implied
+# warranties relating to the Adobe materials, including but not limited to
+# those concerning merchantability or fitness for a particular purpose or
+# non-infringement of any third party rights regarding the Adobe
+# materials.
+# ###################################################################################
+# Name:          Adobe Glyph List For New Fonts
+# Table version: 1.6
+# Date:          30 Januaury 2006
+#
+# Description:
+#
+#   The Adobe Glyph List For New Fonts (AGLFN) is meant to provide a list of 
+#   base glyph names which are compatible with the AGL specification at
+#   http://partners.adobe.com/asn/developer/type/unicodegn.html.
+#   and which can be used as described in section 6 of that document.
+#
+#   This list comprises the set of glyph names from the AGLv2,0 which map
+#   to via the AGL rules to the semanticly correct Unicode value. For
+#   example, Asmall is omitted as the AGL maps this to the Unicode
+#   Private Use Area value F761, rather than to the Unicode value for the
+#   character "A". "ffi" is also omitted, as the AGL maps this to the
+#   Alphabetic Presentation Forms Area value FB03, rather than
+#   decomposing it to the three-value Unicode sequence 0066,0066,0069.
+#    See section 7.1 of the Unicode Standard 4.0 on this issue.
+#   "arrowvertex" is omitted becuase this now has a real Unicode
+#   character value, and the AGL is now incorrect in mapping this to the 
+#   Private Use Area value  F8E6.
+#
+#  If you do not find an appropriate name for your glyph in this list,
+#  then please refer to section 6 of the document:
+#   http://partners.adobe.com/asn/developer/typeforum/unicodegn.html.
+#
+#	The Unicode values and names are given for convenience.
+#
+# Format: Semicolon-delimited fields:
+#
+#   (1) Standard UV or CUS UV. (4 uppercase hexadecimal digits)
+#
+#   (2) Glyph name. (upper- and lowercase letters, digits)
+#
+#   (3) Character names: Unicode character names for standard UVs, and
+#       descriptive names for CUS UVs. (uppercase letters, hyphen, space)
+#
+#   The entries are sorted by glyph name in increasing ASCII order; entries
+#   with the same glyph name are sorted in decreasing priority order.
+#
+#   Lines starting with "#" are comments; blank lines should be ignored.
+#
+#   1.6  [30 January 2006]
+#	- Completed work intended in 1.5
+#
+#   1.5  [23 November 2005]
+#      - removed duplicated block at end of file
+#      - changed mappings:
+#            2206;Delta;INCREMENT changed to 0394;Delta;GREEK CAPITAL LETTER DELTA
+#            2126;Omega;OHM SIGN changed to 03A9;Omega;GREEK CAPITAL LETTER OMEGA
+#            03BC;mu;MICRO SIGN changed to 03BC;mu;GREEK SMALL LETTER MU
+#      - corrected statement above about why ffi is omitted.
+
+#   1.4  [24 September 2003]  Changed version to 1.4, to avoid confusion 
+#		with the AGL 1.3
+#			fixed spelling errors in the header
+#			fully removed arrowvertex, as it is mapped only to a PUA Unicode value in some fonts.
+#
+#   1.1  [17 April 2003]  Renamed [Tt]cedilla back to [Tt]commaaccent:
+#
+#   1.0  [31 Jan 2003]  Original version. Derived from the AGLv1.2 by:
+#	-  removing the PUA area codes
+#	- removing duplicate Unicode mappings, and 
+#	- renaming tcommaaccent to tcedilla and Tcommaaccent to Tcedilla 
+#
+0041;A;LATIN CAPITAL LETTER A
+00C6;AE;LATIN CAPITAL LETTER AE
+01FC;AEacute;LATIN CAPITAL LETTER AE WITH ACUTE
+00C1;Aacute;LATIN CAPITAL LETTER A WITH ACUTE
+0102;Abreve;LATIN CAPITAL LETTER A WITH BREVE
+00C2;Acircumflex;LATIN CAPITAL LETTER A WITH CIRCUMFLEX
+00C4;Adieresis;LATIN CAPITAL LETTER A WITH DIAERESIS
+00C0;Agrave;LATIN CAPITAL LETTER A WITH GRAVE
+0391;Alpha;GREEK CAPITAL LETTER ALPHA
+0386;Alphatonos;GREEK CAPITAL LETTER ALPHA WITH TONOS
+0100;Amacron;LATIN CAPITAL LETTER A WITH MACRON
+0104;Aogonek;LATIN CAPITAL LETTER A WITH OGONEK
+00C5;Aring;LATIN CAPITAL LETTER A WITH RING ABOVE
+01FA;Aringacute;LATIN CAPITAL LETTER A WITH RING ABOVE AND ACUTE
+00C3;Atilde;LATIN CAPITAL LETTER A WITH TILDE
+0042;B;LATIN CAPITAL LETTER B
+0392;Beta;GREEK CAPITAL LETTER BETA
+0043;C;LATIN CAPITAL LETTER C
+0106;Cacute;LATIN CAPITAL LETTER C WITH ACUTE
+010C;Ccaron;LATIN CAPITAL LETTER C WITH CARON
+00C7;Ccedilla;LATIN CAPITAL LETTER C WITH CEDILLA
+0108;Ccircumflex;LATIN CAPITAL LETTER C WITH CIRCUMFLEX
+010A;Cdotaccent;LATIN CAPITAL LETTER C WITH DOT ABOVE
+03A7;Chi;GREEK CAPITAL LETTER CHI
+0044;D;LATIN CAPITAL LETTER D
+010E;Dcaron;LATIN CAPITAL LETTER D WITH CARON
+0110;Dcroat;LATIN CAPITAL LETTER D WITH STROKE
+0394;Delta;GREEK CAPITAL LETTER DELTA
+0045;E;LATIN CAPITAL LETTER E
+00C9;Eacute;LATIN CAPITAL LETTER E WITH ACUTE
+0114;Ebreve;LATIN CAPITAL LETTER E WITH BREVE
+011A;Ecaron;LATIN CAPITAL LETTER E WITH CARON
+00CA;Ecircumflex;LATIN CAPITAL LETTER E WITH CIRCUMFLEX
+00CB;Edieresis;LATIN CAPITAL LETTER E WITH DIAERESIS
+0116;Edotaccent;LATIN CAPITAL LETTER E WITH DOT ABOVE
+00C8;Egrave;LATIN CAPITAL LETTER E WITH GRAVE
+0112;Emacron;LATIN CAPITAL LETTER E WITH MACRON
+014A;Eng;LATIN CAPITAL LETTER ENG
+0118;Eogonek;LATIN CAPITAL LETTER E WITH OGONEK
+0395;Epsilon;GREEK CAPITAL LETTER EPSILON
+0388;Epsilontonos;GREEK CAPITAL LETTER EPSILON WITH TONOS
+0397;Eta;GREEK CAPITAL LETTER ETA
+0389;Etatonos;GREEK CAPITAL LETTER ETA WITH TONOS
+00D0;Eth;LATIN CAPITAL LETTER ETH
+20AC;Euro;EURO SIGN
+0046;F;LATIN CAPITAL LETTER F
+0047;G;LATIN CAPITAL LETTER G
+0393;Gamma;GREEK CAPITAL LETTER GAMMA
+011E;Gbreve;LATIN CAPITAL LETTER G WITH BREVE
+01E6;Gcaron;LATIN CAPITAL LETTER G WITH CARON
+011C;Gcircumflex;LATIN CAPITAL LETTER G WITH CIRCUMFLEX
+0122;Gcommaaccent;LATIN CAPITAL LETTER G WITH CEDILLA
+0120;Gdotaccent;LATIN CAPITAL LETTER G WITH DOT ABOVE
+0048;H;LATIN CAPITAL LETTER H
+25CF;H18533;BLACK CIRCLE
+25AA;H18543;BLACK SMALL SQUARE
+25AB;H18551;WHITE SMALL SQUARE
+25A1;H22073;WHITE SQUARE
+0126;Hbar;LATIN CAPITAL LETTER H WITH STROKE
+0124;Hcircumflex;LATIN CAPITAL LETTER H WITH CIRCUMFLEX
+0049;I;LATIN CAPITAL LETTER I
+0132;IJ;LATIN CAPITAL LIGATURE IJ
+00CD;Iacute;LATIN CAPITAL LETTER I WITH ACUTE
+012C;Ibreve;LATIN CAPITAL LETTER I WITH BREVE
+00CE;Icircumflex;LATIN CAPITAL LETTER I WITH CIRCUMFLEX
+00CF;Idieresis;LATIN CAPITAL LETTER I WITH DIAERESIS
+0130;Idotaccent;LATIN CAPITAL LETTER I WITH DOT ABOVE
+2111;Ifraktur;BLACK-LETTER CAPITAL I
+00CC;Igrave;LATIN CAPITAL LETTER I WITH GRAVE
+012A;Imacron;LATIN CAPITAL LETTER I WITH MACRON
+012E;Iogonek;LATIN CAPITAL LETTER I WITH OGONEK
+0399;Iota;GREEK CAPITAL LETTER IOTA
+03AA;Iotadieresis;GREEK CAPITAL LETTER IOTA WITH DIALYTIKA
+038A;Iotatonos;GREEK CAPITAL LETTER IOTA WITH TONOS
+0128;Itilde;LATIN CAPITAL LETTER I WITH TILDE
+004A;J;LATIN CAPITAL LETTER J
+0134;Jcircumflex;LATIN CAPITAL LETTER J WITH CIRCUMFLEX
+004B;K;LATIN CAPITAL LETTER K
+039A;Kappa;GREEK CAPITAL LETTER KAPPA
+0136;Kcommaaccent;LATIN CAPITAL LETTER K WITH CEDILLA
+004C;L;LATIN CAPITAL LETTER L
+0139;Lacute;LATIN CAPITAL LETTER L WITH ACUTE
+039B;Lambda;GREEK CAPITAL LETTER LAMDA
+013D;Lcaron;LATIN CAPITAL LETTER L WITH CARON
+013B;Lcommaaccent;LATIN CAPITAL LETTER L WITH CEDILLA
+013F;Ldot;LATIN CAPITAL LETTER L WITH MIDDLE DOT
+0141;Lslash;LATIN CAPITAL LETTER L WITH STROKE
+004D;M;LATIN CAPITAL LETTER M
+039C;Mu;GREEK CAPITAL LETTER MU
+004E;N;LATIN CAPITAL LETTER N
+0143;Nacute;LATIN CAPITAL LETTER N WITH ACUTE
+0147;Ncaron;LATIN CAPITAL LETTER N WITH CARON
+0145;Ncommaaccent;LATIN CAPITAL LETTER N WITH CEDILLA
+00D1;Ntilde;LATIN CAPITAL LETTER N WITH TILDE
+039D;Nu;GREEK CAPITAL LETTER NU
+004F;O;LATIN CAPITAL LETTER O
+0152;OE;LATIN CAPITAL LIGATURE OE
+00D3;Oacute;LATIN CAPITAL LETTER O WITH ACUTE
+014E;Obreve;LATIN CAPITAL LETTER O WITH BREVE
+00D4;Ocircumflex;LATIN CAPITAL LETTER O WITH CIRCUMFLEX
+00D6;Odieresis;LATIN CAPITAL LETTER O WITH DIAERESIS
+00D2;Ograve;LATIN CAPITAL LETTER O WITH GRAVE
+01A0;Ohorn;LATIN CAPITAL LETTER O WITH HORN
+0150;Ohungarumlaut;LATIN CAPITAL LETTER O WITH DOUBLE ACUTE
+014C;Omacron;LATIN CAPITAL LETTER O WITH MACRON
+03A9;Omega;GREEK CAPITAL LETTER OMEGA
+038F;Omegatonos;GREEK CAPITAL LETTER OMEGA WITH TONOS
+039F;Omicron;GREEK CAPITAL LETTER OMICRON
+038C;Omicrontonos;GREEK CAPITAL LETTER OMICRON WITH TONOS
+00D8;Oslash;LATIN CAPITAL LETTER O WITH STROKE
+01FE;Oslashacute;LATIN CAPITAL LETTER O WITH STROKE AND ACUTE
+00D5;Otilde;LATIN CAPITAL LETTER O WITH TILDE
+0050;P;LATIN CAPITAL LETTER P
+03A6;Phi;GREEK CAPITAL LETTER PHI
+03A0;Pi;GREEK CAPITAL LETTER PI
+03A8;Psi;GREEK CAPITAL LETTER PSI
+0051;Q;LATIN CAPITAL LETTER Q
+0052;R;LATIN CAPITAL LETTER R
+0154;Racute;LATIN CAPITAL LETTER R WITH ACUTE
+0158;Rcaron;LATIN CAPITAL LETTER R WITH CARON
+0156;Rcommaaccent;LATIN CAPITAL LETTER R WITH CEDILLA
+211C;Rfraktur;BLACK-LETTER CAPITAL R
+03A1;Rho;GREEK CAPITAL LETTER RHO
+0053;S;LATIN CAPITAL LETTER S
+250C;SF010000;BOX DRAWINGS LIGHT DOWN AND RIGHT
+2514;SF020000;BOX DRAWINGS LIGHT UP AND RIGHT
+2510;SF030000;BOX DRAWINGS LIGHT DOWN AND LEFT
+2518;SF040000;BOX DRAWINGS LIGHT UP AND LEFT
+253C;SF050000;BOX DRAWINGS LIGHT VERTICAL AND HORIZONTAL
+252C;SF060000;BOX DRAWINGS LIGHT DOWN AND HORIZONTAL
+2534;SF070000;BOX DRAWINGS LIGHT UP AND HORIZONTAL
+251C;SF080000;BOX DRAWINGS LIGHT VERTICAL AND RIGHT
+2524;SF090000;BOX DRAWINGS LIGHT VERTICAL AND LEFT
+2500;SF100000;BOX DRAWINGS LIGHT HORIZONTAL
+2502;SF110000;BOX DRAWINGS LIGHT VERTICAL
+2561;SF190000;BOX DRAWINGS VERTICAL SINGLE AND LEFT DOUBLE
+2562;SF200000;BOX DRAWINGS VERTICAL DOUBLE AND LEFT SINGLE
+2556;SF210000;BOX DRAWINGS DOWN DOUBLE AND LEFT SINGLE
+2555;SF220000;BOX DRAWINGS DOWN SINGLE AND LEFT DOUBLE
+2563;SF230000;BOX DRAWINGS DOUBLE VERTICAL AND LEFT
+2551;SF240000;BOX DRAWINGS DOUBLE VERTICAL
+2557;SF250000;BOX DRAWINGS DOUBLE DOWN AND LEFT
+255D;SF260000;BOX DRAWINGS DOUBLE UP AND LEFT
+255C;SF270000;BOX DRAWINGS UP DOUBLE AND LEFT SINGLE
+255B;SF280000;BOX DRAWINGS UP SINGLE AND LEFT DOUBLE
+255E;SF360000;BOX DRAWINGS VERTICAL SINGLE AND RIGHT DOUBLE
+255F;SF370000;BOX DRAWINGS VERTICAL DOUBLE AND RIGHT SINGLE
+255A;SF380000;BOX DRAWINGS DOUBLE UP AND RIGHT
+2554;SF390000;BOX DRAWINGS DOUBLE DOWN AND RIGHT
+2569;SF400000;BOX DRAWINGS DOUBLE UP AND HORIZONTAL
+2566;SF410000;BOX DRAWINGS DOUBLE DOWN AND HORIZONTAL
+2560;SF420000;BOX DRAWINGS DOUBLE VERTICAL AND RIGHT
+2550;SF430000;BOX DRAWINGS DOUBLE HORIZONTAL
+256C;SF440000;BOX DRAWINGS DOUBLE VERTICAL AND HORIZONTAL
+2567;SF450000;BOX DRAWINGS UP SINGLE AND HORIZONTAL DOUBLE
+2568;SF460000;BOX DRAWINGS UP DOUBLE AND HORIZONTAL SINGLE
+2564;SF470000;BOX DRAWINGS DOWN SINGLE AND HORIZONTAL DOUBLE
+2565;SF480000;BOX DRAWINGS DOWN DOUBLE AND HORIZONTAL SINGLE
+2559;SF490000;BOX DRAWINGS UP DOUBLE AND RIGHT SINGLE
+2558;SF500000;BOX DRAWINGS UP SINGLE AND RIGHT DOUBLE
+2552;SF510000;BOX DRAWINGS DOWN SINGLE AND RIGHT DOUBLE
+2553;SF520000;BOX DRAWINGS DOWN DOUBLE AND RIGHT SINGLE
+256B;SF530000;BOX DRAWINGS VERTICAL DOUBLE AND HORIZONTAL SINGLE
+256A;SF540000;BOX DRAWINGS VERTICAL SINGLE AND HORIZONTAL DOUBLE
+015A;Sacute;LATIN CAPITAL LETTER S WITH ACUTE
+0160;Scaron;LATIN CAPITAL LETTER S WITH CARON
+015E;Scedilla;LATIN CAPITAL LETTER S WITH CEDILLA
+015C;Scircumflex;LATIN CAPITAL LETTER S WITH CIRCUMFLEX
+0218;Scommaaccent;LATIN CAPITAL LETTER S WITH COMMA BELOW
+03A3;Sigma;GREEK CAPITAL LETTER SIGMA
+0054;T;LATIN CAPITAL LETTER T
+03A4;Tau;GREEK CAPITAL LETTER TAU
+0166;Tbar;LATIN CAPITAL LETTER T WITH STROKE
+0164;Tcaron;LATIN CAPITAL LETTER T WITH CARON
+0162;Tcommaaccent;LATIN CAPITAL LETTER T WITH CEDILLA
+0398;Theta;GREEK CAPITAL LETTER THETA
+00DE;Thorn;LATIN CAPITAL LETTER THORN
+0055;U;LATIN CAPITAL LETTER U
+00DA;Uacute;LATIN CAPITAL LETTER U WITH ACUTE
+016C;Ubreve;LATIN CAPITAL LETTER U WITH BREVE
+00DB;Ucircumflex;LATIN CAPITAL LETTER U WITH CIRCUMFLEX
+00DC;Udieresis;LATIN CAPITAL LETTER U WITH DIAERESIS
+00D9;Ugrave;LATIN CAPITAL LETTER U WITH GRAVE
+01AF;Uhorn;LATIN CAPITAL LETTER U WITH HORN
+0170;Uhungarumlaut;LATIN CAPITAL LETTER U WITH DOUBLE ACUTE
+016A;Umacron;LATIN CAPITAL LETTER U WITH MACRON
+0172;Uogonek;LATIN CAPITAL LETTER U WITH OGONEK
+03A5;Upsilon;GREEK CAPITAL LETTER UPSILON
+03D2;Upsilon1;GREEK UPSILON WITH HOOK SYMBOL
+03AB;Upsilondieresis;GREEK CAPITAL LETTER UPSILON WITH DIALYTIKA
+038E;Upsilontonos;GREEK CAPITAL LETTER UPSILON WITH TONOS
+016E;Uring;LATIN CAPITAL LETTER U WITH RING ABOVE
+0168;Utilde;LATIN CAPITAL LETTER U WITH TILDE
+0056;V;LATIN CAPITAL LETTER V
+0057;W;LATIN CAPITAL LETTER W
+1E82;Wacute;LATIN CAPITAL LETTER W WITH ACUTE
+0174;Wcircumflex;LATIN CAPITAL LETTER W WITH CIRCUMFLEX
+1E84;Wdieresis;LATIN CAPITAL LETTER W WITH DIAERESIS
+1E80;Wgrave;LATIN CAPITAL LETTER W WITH GRAVE
+0058;X;LATIN CAPITAL LETTER X
+039E;Xi;GREEK CAPITAL LETTER XI
+0059;Y;LATIN CAPITAL LETTER Y
+00DD;Yacute;LATIN CAPITAL LETTER Y WITH ACUTE
+0176;Ycircumflex;LATIN CAPITAL LETTER Y WITH CIRCUMFLEX
+0178;Ydieresis;LATIN CAPITAL LETTER Y WITH DIAERESIS
+1EF2;Ygrave;LATIN CAPITAL LETTER Y WITH GRAVE
+005A;Z;LATIN CAPITAL LETTER Z
+0179;Zacute;LATIN CAPITAL LETTER Z WITH ACUTE
+017D;Zcaron;LATIN CAPITAL LETTER Z WITH CARON
+017B;Zdotaccent;LATIN CAPITAL LETTER Z WITH DOT ABOVE
+0396;Zeta;GREEK CAPITAL LETTER ZETA
+0061;a;LATIN SMALL LETTER A
+00E1;aacute;LATIN SMALL LETTER A WITH ACUTE
+0103;abreve;LATIN SMALL LETTER A WITH BREVE
+00E2;acircumflex;LATIN SMALL LETTER A WITH CIRCUMFLEX
+00B4;acute;ACUTE ACCENT
+0301;acutecomb;COMBINING ACUTE ACCENT
+00E4;adieresis;LATIN SMALL LETTER A WITH DIAERESIS
+00E6;ae;LATIN SMALL LETTER AE
+01FD;aeacute;LATIN SMALL LETTER AE WITH ACUTE
+2015;afii00208;HORIZONTAL BAR
+0410;afii10017;CYRILLIC CAPITAL LETTER A
+0411;afii10018;CYRILLIC CAPITAL LETTER BE
+0412;afii10019;CYRILLIC CAPITAL LETTER VE
+0413;afii10020;CYRILLIC CAPITAL LETTER GHE
+0414;afii10021;CYRILLIC CAPITAL LETTER DE
+0415;afii10022;CYRILLIC CAPITAL LETTER IE
+0401;afii10023;CYRILLIC CAPITAL LETTER IO
+0416;afii10024;CYRILLIC CAPITAL LETTER ZHE
+0417;afii10025;CYRILLIC CAPITAL LETTER ZE
+0418;afii10026;CYRILLIC CAPITAL LETTER I
+0419;afii10027;CYRILLIC CAPITAL LETTER SHORT I
+041A;afii10028;CYRILLIC CAPITAL LETTER KA
+041B;afii10029;CYRILLIC CAPITAL LETTER EL
+041C;afii10030;CYRILLIC CAPITAL LETTER EM
+041D;afii10031;CYRILLIC CAPITAL LETTER EN
+041E;afii10032;CYRILLIC CAPITAL LETTER O
+041F;afii10033;CYRILLIC CAPITAL LETTER PE
+0420;afii10034;CYRILLIC CAPITAL LETTER ER
+0421;afii10035;CYRILLIC CAPITAL LETTER ES
+0422;afii10036;CYRILLIC CAPITAL LETTER TE
+0423;afii10037;CYRILLIC CAPITAL LETTER U
+0424;afii10038;CYRILLIC CAPITAL LETTER EF
+0425;afii10039;CYRILLIC CAPITAL LETTER HA
+0426;afii10040;CYRILLIC CAPITAL LETTER TSE
+0427;afii10041;CYRILLIC CAPITAL LETTER CHE
+0428;afii10042;CYRILLIC CAPITAL LETTER SHA
+0429;afii10043;CYRILLIC CAPITAL LETTER SHCHA
+042A;afii10044;CYRILLIC CAPITAL LETTER HARD SIGN
+042B;afii10045;CYRILLIC CAPITAL LETTER YERU
+042C;afii10046;CYRILLIC CAPITAL LETTER SOFT SIGN
+042D;afii10047;CYRILLIC CAPITAL LETTER E
+042E;afii10048;CYRILLIC CAPITAL LETTER YU
+042F;afii10049;CYRILLIC CAPITAL LETTER YA
+0490;afii10050;CYRILLIC CAPITAL LETTER GHE WITH UPTURN
+0402;afii10051;CYRILLIC CAPITAL LETTER DJE
+0403;afii10052;CYRILLIC CAPITAL LETTER GJE
+0404;afii10053;CYRILLIC CAPITAL LETTER UKRAINIAN IE
+0405;afii10054;CYRILLIC CAPITAL LETTER DZE
+0406;afii10055;CYRILLIC CAPITAL LETTER BYELORUSSIAN-UKRAINIAN I
+0407;afii10056;CYRILLIC CAPITAL LETTER YI
+0408;afii10057;CYRILLIC CAPITAL LETTER JE
+0409;afii10058;CYRILLIC CAPITAL LETTER LJE
+040A;afii10059;CYRILLIC CAPITAL LETTER NJE
+040B;afii10060;CYRILLIC CAPITAL LETTER TSHE
+040C;afii10061;CYRILLIC CAPITAL LETTER KJE
+040E;afii10062;CYRILLIC CAPITAL LETTER SHORT U
+0430;afii10065;CYRILLIC SMALL LETTER A
+0431;afii10066;CYRILLIC SMALL LETTER BE
+0432;afii10067;CYRILLIC SMALL LETTER VE
+0433;afii10068;CYRILLIC SMALL LETTER GHE
+0434;afii10069;CYRILLIC SMALL LETTER DE
+0435;afii10070;CYRILLIC SMALL LETTER IE
+0451;afii10071;CYRILLIC SMALL LETTER IO
+0436;afii10072;CYRILLIC SMALL LETTER ZHE
+0437;afii10073;CYRILLIC SMALL LETTER ZE
+0438;afii10074;CYRILLIC SMALL LETTER I
+0439;afii10075;CYRILLIC SMALL LETTER SHORT I
+043A;afii10076;CYRILLIC SMALL LETTER KA
+043B;afii10077;CYRILLIC SMALL LETTER EL
+043C;afii10078;CYRILLIC SMALL LETTER EM
+043D;afii10079;CYRILLIC SMALL LETTER EN
+043E;afii10080;CYRILLIC SMALL LETTER O
+043F;afii10081;CYRILLIC SMALL LETTER PE
+0440;afii10082;CYRILLIC SMALL LETTER ER
+0441;afii10083;CYRILLIC SMALL LETTER ES
+0442;afii10084;CYRILLIC SMALL LETTER TE
+0443;afii10085;CYRILLIC SMALL LETTER U
+0444;afii10086;CYRILLIC SMALL LETTER EF
+0445;afii10087;CYRILLIC SMALL LETTER HA
+0446;afii10088;CYRILLIC SMALL LETTER TSE
+0447;afii10089;CYRILLIC SMALL LETTER CHE
+0448;afii10090;CYRILLIC SMALL LETTER SHA
+0449;afii10091;CYRILLIC SMALL LETTER SHCHA
+044A;afii10092;CYRILLIC SMALL LETTER HARD SIGN
+044B;afii10093;CYRILLIC SMALL LETTER YERU
+044C;afii10094;CYRILLIC SMALL LETTER SOFT SIGN
+044D;afii10095;CYRILLIC SMALL LETTER E
+044E;afii10096;CYRILLIC SMALL LETTER YU
+044F;afii10097;CYRILLIC SMALL LETTER YA
+0491;afii10098;CYRILLIC SMALL LETTER GHE WITH UPTURN
+0452;afii10099;CYRILLIC SMALL LETTER DJE
+0453;afii10100;CYRILLIC SMALL LETTER GJE
+0454;afii10101;CYRILLIC SMALL LETTER UKRAINIAN IE
+0455;afii10102;CYRILLIC SMALL LETTER DZE
+0456;afii10103;CYRILLIC SMALL LETTER BYELORUSSIAN-UKRAINIAN I
+0457;afii10104;CYRILLIC SMALL LETTER YI
+0458;afii10105;CYRILLIC SMALL LETTER JE
+0459;afii10106;CYRILLIC SMALL LETTER LJE
+045A;afii10107;CYRILLIC SMALL LETTER NJE
+045B;afii10108;CYRILLIC SMALL LETTER TSHE
+045C;afii10109;CYRILLIC SMALL LETTER KJE
+045E;afii10110;CYRILLIC SMALL LETTER SHORT U
+040F;afii10145;CYRILLIC CAPITAL LETTER DZHE
+0462;afii10146;CYRILLIC CAPITAL LETTER YAT
+0472;afii10147;CYRILLIC CAPITAL LETTER FITA
+0474;afii10148;CYRILLIC CAPITAL LETTER IZHITSA
+045F;afii10193;CYRILLIC SMALL LETTER DZHE
+0463;afii10194;CYRILLIC SMALL LETTER YAT
+0473;afii10195;CYRILLIC SMALL LETTER FITA
+0475;afii10196;CYRILLIC SMALL LETTER IZHITSA
+04D9;afii10846;CYRILLIC SMALL LETTER SCHWA
+200E;afii299;LEFT-TO-RIGHT MARK
+200F;afii300;RIGHT-TO-LEFT MARK
+200D;afii301;ZERO WIDTH JOINER
+066A;afii57381;ARABIC PERCENT SIGN
+060C;afii57388;ARABIC COMMA
+0660;afii57392;ARABIC-INDIC DIGIT ZERO
+0661;afii57393;ARABIC-INDIC DIGIT ONE
+0662;afii57394;ARABIC-INDIC DIGIT TWO
+0663;afii57395;ARABIC-INDIC DIGIT THREE
+0664;afii57396;ARABIC-INDIC DIGIT FOUR
+0665;afii57397;ARABIC-INDIC DIGIT FIVE
+0666;afii57398;ARABIC-INDIC DIGIT SIX
+0667;afii57399;ARABIC-INDIC DIGIT SEVEN
+0668;afii57400;ARABIC-INDIC DIGIT EIGHT
+0669;afii57401;ARABIC-INDIC DIGIT NINE
+061B;afii57403;ARABIC SEMICOLON
+061F;afii57407;ARABIC QUESTION MARK
+0621;afii57409;ARABIC LETTER HAMZA
+0622;afii57410;ARABIC LETTER ALEF WITH MADDA ABOVE
+0623;afii57411;ARABIC LETTER ALEF WITH HAMZA ABOVE
+0624;afii57412;ARABIC LETTER WAW WITH HAMZA ABOVE
+0625;afii57413;ARABIC LETTER ALEF WITH HAMZA BELOW
+0626;afii57414;ARABIC LETTER YEH WITH HAMZA ABOVE
+0627;afii57415;ARABIC LETTER ALEF
+0628;afii57416;ARABIC LETTER BEH
+0629;afii57417;ARABIC LETTER TEH MARBUTA
+062A;afii57418;ARABIC LETTER TEH
+062B;afii57419;ARABIC LETTER THEH
+062C;afii57420;ARABIC LETTER JEEM
+062D;afii57421;ARABIC LETTER HAH
+062E;afii57422;ARABIC LETTER KHAH
+062F;afii57423;ARABIC LETTER DAL
+0630;afii57424;ARABIC LETTER THAL
+0631;afii57425;ARABIC LETTER REH
+0632;afii57426;ARABIC LETTER ZAIN
+0633;afii57427;ARABIC LETTER SEEN
+0634;afii57428;ARABIC LETTER SHEEN
+0635;afii57429;ARABIC LETTER SAD
+0636;afii57430;ARABIC LETTER DAD
+0637;afii57431;ARABIC LETTER TAH
+0638;afii57432;ARABIC LETTER ZAH
+0639;afii57433;ARABIC LETTER AIN
+063A;afii57434;ARABIC LETTER GHAIN
+0640;afii57440;ARABIC TATWEEL
+0641;afii57441;ARABIC LETTER FEH
+0642;afii57442;ARABIC LETTER QAF
+0643;afii57443;ARABIC LETTER KAF
+0644;afii57444;ARABIC LETTER LAM
+0645;afii57445;ARABIC LETTER MEEM
+0646;afii57446;ARABIC LETTER NOON
+0648;afii57448;ARABIC LETTER WAW
+0649;afii57449;ARABIC LETTER ALEF MAKSURA
+064A;afii57450;ARABIC LETTER YEH
+064B;afii57451;ARABIC FATHATAN
+064C;afii57452;ARABIC DAMMATAN
+064D;afii57453;ARABIC KASRATAN
+064E;afii57454;ARABIC FATHA
+064F;afii57455;ARABIC DAMMA
+0650;afii57456;ARABIC KASRA
+0651;afii57457;ARABIC SHADDA
+0652;afii57458;ARABIC SUKUN
+0647;afii57470;ARABIC LETTER HEH
+06A4;afii57505;ARABIC LETTER VEH
+067E;afii57506;ARABIC LETTER PEH
+0686;afii57507;ARABIC LETTER TCHEH
+0698;afii57508;ARABIC LETTER JEH
+06AF;afii57509;ARABIC LETTER GAF
+0679;afii57511;ARABIC LETTER TTEH
+0688;afii57512;ARABIC LETTER DDAL
+0691;afii57513;ARABIC LETTER RREH
+06BA;afii57514;ARABIC LETTER NOON GHUNNA
+06D2;afii57519;ARABIC LETTER YEH BARREE
+06D5;afii57534;ARABIC LETTER AE
+20AA;afii57636;NEW SHEQEL SIGN
+05BE;afii57645;HEBREW PUNCTUATION MAQAF
+05C3;afii57658;HEBREW PUNCTUATION SOF PASUQ
+05D0;afii57664;HEBREW LETTER ALEF
+05D1;afii57665;HEBREW LETTER BET
+05D2;afii57666;HEBREW LETTER GIMEL
+05D3;afii57667;HEBREW LETTER DALET
+05D4;afii57668;HEBREW LETTER HE
+05D5;afii57669;HEBREW LETTER VAV
+05D6;afii57670;HEBREW LETTER ZAYIN
+05D7;afii57671;HEBREW LETTER HET
+05D8;afii57672;HEBREW LETTER TET
+05D9;afii57673;HEBREW LETTER YOD
+05DA;afii57674;HEBREW LETTER FINAL KAF
+05DB;afii57675;HEBREW LETTER KAF
+05DC;afii57676;HEBREW LETTER LAMED
+05DD;afii57677;HEBREW LETTER FINAL MEM
+05DE;afii57678;HEBREW LETTER MEM
+05DF;afii57679;HEBREW LETTER FINAL NUN
+05E0;afii57680;HEBREW LETTER NUN
+05E1;afii57681;HEBREW LETTER SAMEKH
+05E2;afii57682;HEBREW LETTER AYIN
+05E3;afii57683;HEBREW LETTER FINAL PE
+05E4;afii57684;HEBREW LETTER PE
+05E5;afii57685;HEBREW LETTER FINAL TSADI
+05E6;afii57686;HEBREW LETTER TSADI
+05E7;afii57687;HEBREW LETTER QOF
+05E8;afii57688;HEBREW LETTER RESH
+05E9;afii57689;HEBREW LETTER SHIN
+05EA;afii57690;HEBREW LETTER TAV
+05F0;afii57716;HEBREW LIGATURE YIDDISH DOUBLE VAV
+05F1;afii57717;HEBREW LIGATURE YIDDISH VAV YOD
+05F2;afii57718;HEBREW LIGATURE YIDDISH DOUBLE YOD
+05B4;afii57793;HEBREW POINT HIRIQ
+05B5;afii57794;HEBREW POINT TSERE
+05B6;afii57795;HEBREW POINT SEGOL
+05BB;afii57796;HEBREW POINT QUBUTS
+05B8;afii57797;HEBREW POINT QAMATS
+05B7;afii57798;HEBREW POINT PATAH
+05B0;afii57799;HEBREW POINT SHEVA
+05B2;afii57800;HEBREW POINT HATAF PATAH
+05B1;afii57801;HEBREW POINT HATAF SEGOL
+05B3;afii57802;HEBREW POINT HATAF QAMATS
+05C2;afii57803;HEBREW POINT SIN DOT
+05C1;afii57804;HEBREW POINT SHIN DOT
+05B9;afii57806;HEBREW POINT HOLAM
+05BC;afii57807;HEBREW POINT DAGESH OR MAPIQ
+05BD;afii57839;HEBREW POINT METEG
+05BF;afii57841;HEBREW POINT RAFE
+05C0;afii57842;HEBREW PUNCTUATION PASEQ
+02BC;afii57929;MODIFIER LETTER APOSTROPHE
+2105;afii61248;CARE OF
+2113;afii61289;SCRIPT SMALL L
+2116;afii61352;NUMERO SIGN
+202C;afii61573;POP DIRECTIONAL FORMATTING
+202D;afii61574;LEFT-TO-RIGHT OVERRIDE
+202E;afii61575;RIGHT-TO-LEFT OVERRIDE
+200C;afii61664;ZERO WIDTH NON-JOINER
+066D;afii63167;ARABIC FIVE POINTED STAR
+02BD;afii64937;MODIFIER LETTER REVERSED COMMA
+00E0;agrave;LATIN SMALL LETTER A WITH GRAVE
+2135;aleph;ALEF SYMBOL
+03B1;alpha;GREEK SMALL LETTER ALPHA
+03AC;alphatonos;GREEK SMALL LETTER ALPHA WITH TONOS
+0101;amacron;LATIN SMALL LETTER A WITH MACRON
+0026;ampersand;AMPERSAND
+2220;angle;ANGLE
+2329;angleleft;LEFT-POINTING ANGLE BRACKET
+232A;angleright;RIGHT-POINTING ANGLE BRACKET
+0387;anoteleia;GREEK ANO TELEIA
+0105;aogonek;LATIN SMALL LETTER A WITH OGONEK
+2248;approxequal;ALMOST EQUAL TO
+00E5;aring;LATIN SMALL LETTER A WITH RING ABOVE
+01FB;aringacute;LATIN SMALL LETTER A WITH RING ABOVE AND ACUTE
+2194;arrowboth;LEFT RIGHT ARROW
+21D4;arrowdblboth;LEFT RIGHT DOUBLE ARROW
+21D3;arrowdbldown;DOWNWARDS DOUBLE ARROW
+21D0;arrowdblleft;LEFTWARDS DOUBLE ARROW
+21D2;arrowdblright;RIGHTWARDS DOUBLE ARROW
+21D1;arrowdblup;UPWARDS DOUBLE ARROW
+2193;arrowdown;DOWNWARDS ARROW
+2190;arrowleft;LEFTWARDS ARROW
+2192;arrowright;RIGHTWARDS ARROW
+2191;arrowup;UPWARDS ARROW
+2195;arrowupdn;UP DOWN ARROW
+21A8;arrowupdnbse;UP DOWN ARROW WITH BASE
+005E;asciicircum;CIRCUMFLEX ACCENT
+007E;asciitilde;TILDE
+002A;asterisk;ASTERISK
+2217;asteriskmath;ASTERISK OPERATOR
+0040;at;COMMERCIAL AT
+00E3;atilde;LATIN SMALL LETTER A WITH TILDE
+0062;b;LATIN SMALL LETTER B
+005C;backslash;REVERSE SOLIDUS
+007C;bar;VERTICAL LINE
+03B2;beta;GREEK SMALL LETTER BETA
+2588;block;FULL BLOCK
+007B;braceleft;LEFT CURLY BRACKET
+007D;braceright;RIGHT CURLY BRACKET
+005B;bracketleft;LEFT SQUARE BRACKET
+005D;bracketright;RIGHT SQUARE BRACKET
+02D8;breve;BREVE
+00A6;brokenbar;BROKEN BAR
+2022;bullet;BULLET
+0063;c;LATIN SMALL LETTER C
+0107;cacute;LATIN SMALL LETTER C WITH ACUTE
+02C7;caron;CARON
+21B5;carriagereturn;DOWNWARDS ARROW WITH CORNER LEFTWARDS
+010D;ccaron;LATIN SMALL LETTER C WITH CARON
+00E7;ccedilla;LATIN SMALL LETTER C WITH CEDILLA
+0109;ccircumflex;LATIN SMALL LETTER C WITH CIRCUMFLEX
+010B;cdotaccent;LATIN SMALL LETTER C WITH DOT ABOVE
+00B8;cedilla;CEDILLA
+00A2;cent;CENT SIGN
+03C7;chi;GREEK SMALL LETTER CHI
+25CB;circle;WHITE CIRCLE
+2297;circlemultiply;CIRCLED TIMES
+2295;circleplus;CIRCLED PLUS
+02C6;circumflex;MODIFIER LETTER CIRCUMFLEX ACCENT
+2663;club;BLACK CLUB SUIT
+003A;colon;COLON
+20A1;colonmonetary;COLON SIGN
+002C;comma;COMMA
+2245;congruent;APPROXIMATELY EQUAL TO
+00A9;copyright;COPYRIGHT SIGN
+00A4;currency;CURRENCY SIGN
+0064;d;LATIN SMALL LETTER D
+2020;dagger;DAGGER
+2021;daggerdbl;DOUBLE DAGGER
+010F;dcaron;LATIN SMALL LETTER D WITH CARON
+0111;dcroat;LATIN SMALL LETTER D WITH STROKE
+00B0;degree;DEGREE SIGN
+03B4;delta;GREEK SMALL LETTER DELTA
+2666;diamond;BLACK DIAMOND SUIT
+00A8;dieresis;DIAERESIS
+0385;dieresistonos;GREEK DIALYTIKA TONOS
+00F7;divide;DIVISION SIGN
+2593;dkshade;DARK SHADE
+2584;dnblock;LOWER HALF BLOCK
+0024;dollar;DOLLAR SIGN
+20AB;dong;DONG SIGN
+02D9;dotaccent;DOT ABOVE
+0323;dotbelowcomb;COMBINING DOT BELOW
+0131;dotlessi;LATIN SMALL LETTER DOTLESS I
+22C5;dotmath;DOT OPERATOR
+0065;e;LATIN SMALL LETTER E
+00E9;eacute;LATIN SMALL LETTER E WITH ACUTE
+0115;ebreve;LATIN SMALL LETTER E WITH BREVE
+011B;ecaron;LATIN SMALL LETTER E WITH CARON
+00EA;ecircumflex;LATIN SMALL LETTER E WITH CIRCUMFLEX
+00EB;edieresis;LATIN SMALL LETTER E WITH DIAERESIS
+0117;edotaccent;LATIN SMALL LETTER E WITH DOT ABOVE
+00E8;egrave;LATIN SMALL LETTER E WITH GRAVE
+0038;eight;DIGIT EIGHT
+2208;element;ELEMENT OF
+2026;ellipsis;HORIZONTAL ELLIPSIS
+0113;emacron;LATIN SMALL LETTER E WITH MACRON
+2014;emdash;EM DASH
+2205;emptyset;EMPTY SET
+2013;endash;EN DASH
+014B;eng;LATIN SMALL LETTER ENG
+0119;eogonek;LATIN SMALL LETTER E WITH OGONEK
+03B5;epsilon;GREEK SMALL LETTER EPSILON
+03AD;epsilontonos;GREEK SMALL LETTER EPSILON WITH TONOS
+003D;equal;EQUALS SIGN
+2261;equivalence;IDENTICAL TO
+212E;estimated;ESTIMATED SYMBOL
+03B7;eta;GREEK SMALL LETTER ETA
+03AE;etatonos;GREEK SMALL LETTER ETA WITH TONOS
+00F0;eth;LATIN SMALL LETTER ETH
+0021;exclam;EXCLAMATION MARK
+203C;exclamdbl;DOUBLE EXCLAMATION MARK
+00A1;exclamdown;INVERTED EXCLAMATION MARK
+2203;existential;THERE EXISTS
+0066;f;LATIN SMALL LETTER F
+2640;female;FEMALE SIGN
+2012;figuredash;FIGURE DASH
+25A0;filledbox;BLACK SQUARE
+25AC;filledrect;BLACK RECTANGLE
+0035;five;DIGIT FIVE
+215D;fiveeighths;VULGAR FRACTION FIVE EIGHTHS
+0192;florin;LATIN SMALL LETTER F WITH HOOK
+0034;four;DIGIT FOUR
+2044;fraction;FRACTION SLASH
+20A3;franc;FRENCH FRANC SIGN
+0067;g;LATIN SMALL LETTER G
+03B3;gamma;GREEK SMALL LETTER GAMMA
+011F;gbreve;LATIN SMALL LETTER G WITH BREVE
+01E7;gcaron;LATIN SMALL LETTER G WITH CARON
+011D;gcircumflex;LATIN SMALL LETTER G WITH CIRCUMFLEX
+0123;gcommaaccent;LATIN SMALL LETTER G WITH CEDILLA
+0121;gdotaccent;LATIN SMALL LETTER G WITH DOT ABOVE
+00DF;germandbls;LATIN SMALL LETTER SHARP S
+2207;gradient;NABLA
+0060;grave;GRAVE ACCENT
+0300;gravecomb;COMBINING GRAVE ACCENT
+003E;greater;GREATER-THAN SIGN
+2265;greaterequal;GREATER-THAN OR EQUAL TO
+00AB;guillemotleft;LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
+00BB;guillemotright;RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
+2039;guilsinglleft;SINGLE LEFT-POINTING ANGLE QUOTATION MARK
+203A;guilsinglright;SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
+0068;h;LATIN SMALL LETTER H
+0127;hbar;LATIN SMALL LETTER H WITH STROKE
+0125;hcircumflex;LATIN SMALL LETTER H WITH CIRCUMFLEX
+2665;heart;BLACK HEART SUIT
+0309;hookabovecomb;COMBINING HOOK ABOVE
+2302;house;HOUSE
+02DD;hungarumlaut;DOUBLE ACUTE ACCENT
+002D;hyphen;HYPHEN-MINUS
+0069;i;LATIN SMALL LETTER I
+00ED;iacute;LATIN SMALL LETTER I WITH ACUTE
+012D;ibreve;LATIN SMALL LETTER I WITH BREVE
+00EE;icircumflex;LATIN SMALL LETTER I WITH CIRCUMFLEX
+00EF;idieresis;LATIN SMALL LETTER I WITH DIAERESIS
+00EC;igrave;LATIN SMALL LETTER I WITH GRAVE
+0133;ij;LATIN SMALL LIGATURE IJ
+012B;imacron;LATIN SMALL LETTER I WITH MACRON
+221E;infinity;INFINITY
+222B;integral;INTEGRAL
+2321;integralbt;BOTTOM HALF INTEGRAL
+2320;integraltp;TOP HALF INTEGRAL
+2229;intersection;INTERSECTION
+25D8;invbullet;INVERSE BULLET
+25D9;invcircle;INVERSE WHITE CIRCLE
+263B;invsmileface;BLACK SMILING FACE
+012F;iogonek;LATIN SMALL LETTER I WITH OGONEK
+03B9;iota;GREEK SMALL LETTER IOTA
+03CA;iotadieresis;GREEK SMALL LETTER IOTA WITH DIALYTIKA
+0390;iotadieresistonos;GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS
+03AF;iotatonos;GREEK SMALL LETTER IOTA WITH TONOS
+0129;itilde;LATIN SMALL LETTER I WITH TILDE
+006A;j;LATIN SMALL LETTER J
+0135;jcircumflex;LATIN SMALL LETTER J WITH CIRCUMFLEX
+006B;k;LATIN SMALL LETTER K
+03BA;kappa;GREEK SMALL LETTER KAPPA
+0137;kcommaaccent;LATIN SMALL LETTER K WITH CEDILLA
+0138;kgreenlandic;LATIN SMALL LETTER KRA
+006C;l;LATIN SMALL LETTER L
+013A;lacute;LATIN SMALL LETTER L WITH ACUTE
+03BB;lambda;GREEK SMALL LETTER LAMDA
+013E;lcaron;LATIN SMALL LETTER L WITH CARON
+013C;lcommaaccent;LATIN SMALL LETTER L WITH CEDILLA
+0140;ldot;LATIN SMALL LETTER L WITH MIDDLE DOT
+003C;less;LESS-THAN SIGN
+2264;lessequal;LESS-THAN OR EQUAL TO
+258C;lfblock;LEFT HALF BLOCK
+20A4;lira;LIRA SIGN
+2227;logicaland;LOGICAL AND
+00AC;logicalnot;NOT SIGN
+2228;logicalor;LOGICAL OR
+017F;longs;LATIN SMALL LETTER LONG S
+25CA;lozenge;LOZENGE
+0142;lslash;LATIN SMALL LETTER L WITH STROKE
+2591;ltshade;LIGHT SHADE
+006D;m;LATIN SMALL LETTER M
+00AF;macron;MACRON
+2642;male;MALE SIGN
+2212;minus;MINUS SIGN
+2032;minute;PRIME
+03BC;mu;GREEK SMALL LETTER MU
+00D7;multiply;MULTIPLICATION SIGN
+266A;musicalnote;EIGHTH NOTE
+266B;musicalnotedbl;BEAMED EIGHTH NOTES
+006E;n;LATIN SMALL LETTER N
+0144;nacute;LATIN SMALL LETTER N WITH ACUTE
+0149;napostrophe;LATIN SMALL LETTER N PRECEDED BY APOSTROPHE
+0148;ncaron;LATIN SMALL LETTER N WITH CARON
+0146;ncommaaccent;LATIN SMALL LETTER N WITH CEDILLA
+0039;nine;DIGIT NINE
+2209;notelement;NOT AN ELEMENT OF
+2260;notequal;NOT EQUAL TO
+2284;notsubset;NOT A SUBSET OF
+00F1;ntilde;LATIN SMALL LETTER N WITH TILDE
+03BD;nu;GREEK SMALL LETTER NU
+0023;numbersign;NUMBER SIGN
+006F;o;LATIN SMALL LETTER O
+00F3;oacute;LATIN SMALL LETTER O WITH ACUTE
+014F;obreve;LATIN SMALL LETTER O WITH BREVE
+00F4;ocircumflex;LATIN SMALL LETTER O WITH CIRCUMFLEX
+00F6;odieresis;LATIN SMALL LETTER O WITH DIAERESIS
+0153;oe;LATIN SMALL LIGATURE OE
+02DB;ogonek;OGONEK
+00F2;ograve;LATIN SMALL LETTER O WITH GRAVE
+01A1;ohorn;LATIN SMALL LETTER O WITH HORN
+0151;ohungarumlaut;LATIN SMALL LETTER O WITH DOUBLE ACUTE
+014D;omacron;LATIN SMALL LETTER O WITH MACRON
+03C9;omega;GREEK SMALL LETTER OMEGA
+03D6;omega1;GREEK PI SYMBOL
+03CE;omegatonos;GREEK SMALL LETTER OMEGA WITH TONOS
+03BF;omicron;GREEK SMALL LETTER OMICRON
+03CC;omicrontonos;GREEK SMALL LETTER OMICRON WITH TONOS
+0031;one;DIGIT ONE
+2024;onedotenleader;ONE DOT LEADER
+215B;oneeighth;VULGAR FRACTION ONE EIGHTH
+00BD;onehalf;VULGAR FRACTION ONE HALF
+00BC;onequarter;VULGAR FRACTION ONE QUARTER
+2153;onethird;VULGAR FRACTION ONE THIRD
+25E6;openbullet;WHITE BULLET
+00AA;ordfeminine;FEMININE ORDINAL INDICATOR
+00BA;ordmasculine;MASCULINE ORDINAL INDICATOR
+221F;orthogonal;RIGHT ANGLE
+00F8;oslash;LATIN SMALL LETTER O WITH STROKE
+01FF;oslashacute;LATIN SMALL LETTER O WITH STROKE AND ACUTE
+00F5;otilde;LATIN SMALL LETTER O WITH TILDE
+0070;p;LATIN SMALL LETTER P
+00B6;paragraph;PILCROW SIGN
+0028;parenleft;LEFT PARENTHESIS
+0029;parenright;RIGHT PARENTHESIS
+2202;partialdiff;PARTIAL DIFFERENTIAL
+0025;percent;PERCENT SIGN
+002E;period;FULL STOP
+00B7;periodcentered;MIDDLE DOT
+22A5;perpendicular;UP TACK
+2030;perthousand;PER MILLE SIGN
+20A7;peseta;PESETA SIGN
+03C6;phi;GREEK SMALL LETTER PHI
+03D5;phi1;GREEK PHI SYMBOL
+03C0;pi;GREEK SMALL LETTER PI
+002B;plus;PLUS SIGN
+00B1;plusminus;PLUS-MINUS SIGN
+211E;prescription;PRESCRIPTION TAKE
+220F;product;N-ARY PRODUCT
+2282;propersubset;SUBSET OF
+2283;propersuperset;SUPERSET OF
+221D;proportional;PROPORTIONAL TO
+03C8;psi;GREEK SMALL LETTER PSI
+0071;q;LATIN SMALL LETTER Q
+003F;question;QUESTION MARK
+00BF;questiondown;INVERTED QUESTION MARK
+0022;quotedbl;QUOTATION MARK
+201E;quotedblbase;DOUBLE LOW-9 QUOTATION MARK
+201C;quotedblleft;LEFT DOUBLE QUOTATION MARK
+201D;quotedblright;RIGHT DOUBLE QUOTATION MARK
+2018;quoteleft;LEFT SINGLE QUOTATION MARK
+201B;quotereversed;SINGLE HIGH-REVERSED-9 QUOTATION MARK
+2019;quoteright;RIGHT SINGLE QUOTATION MARK
+201A;quotesinglbase;SINGLE LOW-9 QUOTATION MARK
+0027;quotesingle;APOSTROPHE
+0072;r;LATIN SMALL LETTER R
+0155;racute;LATIN SMALL LETTER R WITH ACUTE
+221A;radical;SQUARE ROOT
+0159;rcaron;LATIN SMALL LETTER R WITH CARON
+0157;rcommaaccent;LATIN SMALL LETTER R WITH CEDILLA
+2286;reflexsubset;SUBSET OF OR EQUAL TO
+2287;reflexsuperset;SUPERSET OF OR EQUAL TO
+00AE;registered;REGISTERED SIGN
+2310;revlogicalnot;REVERSED NOT SIGN
+03C1;rho;GREEK SMALL LETTER RHO
+02DA;ring;RING ABOVE
+2590;rtblock;RIGHT HALF BLOCK
+0073;s;LATIN SMALL LETTER S
+015B;sacute;LATIN SMALL LETTER S WITH ACUTE
+0161;scaron;LATIN SMALL LETTER S WITH CARON
+015F;scedilla;LATIN SMALL LETTER S WITH CEDILLA
+015D;scircumflex;LATIN SMALL LETTER S WITH CIRCUMFLEX
+0219;scommaaccent;LATIN SMALL LETTER S WITH COMMA BELOW
+2033;second;DOUBLE PRIME
+00A7;section;SECTION SIGN
+003B;semicolon;SEMICOLON
+0037;seven;DIGIT SEVEN
+215E;seveneighths;VULGAR FRACTION SEVEN EIGHTHS
+2592;shade;MEDIUM SHADE
+03C3;sigma;GREEK SMALL LETTER SIGMA
+03C2;sigma1;GREEK SMALL LETTER FINAL SIGMA
+223C;similar;TILDE OPERATOR
+0036;six;DIGIT SIX
+002F;slash;SOLIDUS
+263A;smileface;WHITE SMILING FACE
+0020;space;SPACE
+2660;spade;BLACK SPADE SUIT
+00A3;sterling;POUND SIGN
+220B;suchthat;CONTAINS AS MEMBER
+2211;summation;N-ARY SUMMATION
+263C;sun;WHITE SUN WITH RAYS
+0074;t;LATIN SMALL LETTER T
+03C4;tau;GREEK SMALL LETTER TAU
+0167;tbar;LATIN SMALL LETTER T WITH STROKE
+0165;tcaron;LATIN SMALL LETTER T WITH CARON
+0163;tcommaaccent;LATIN SMALL LETTER T WITH CEDILLA
+2234;therefore;THEREFORE
+03B8;theta;GREEK SMALL LETTER THETA
+03D1;theta1;GREEK THETA SYMBOL
+00FE;thorn;LATIN SMALL LETTER THORN
+0033;three;DIGIT THREE
+215C;threeeighths;VULGAR FRACTION THREE EIGHTHS
+00BE;threequarters;VULGAR FRACTION THREE QUARTERS
+02DC;tilde;SMALL TILDE
+0303;tildecomb;COMBINING TILDE
+0384;tonos;GREEK TONOS
+2122;trademark;TRADE MARK SIGN
+25BC;triagdn;BLACK DOWN-POINTING TRIANGLE
+25C4;triaglf;BLACK LEFT-POINTING POINTER
+25BA;triagrt;BLACK RIGHT-POINTING POINTER
+25B2;triagup;BLACK UP-POINTING TRIANGLE
+0032;two;DIGIT TWO
+2025;twodotenleader;TWO DOT LEADER
+2154;twothirds;VULGAR FRACTION TWO THIRDS
+0075;u;LATIN SMALL LETTER U
+00FA;uacute;LATIN SMALL LETTER U WITH ACUTE
+016D;ubreve;LATIN SMALL LETTER U WITH BREVE
+00FB;ucircumflex;LATIN SMALL LETTER U WITH CIRCUMFLEX
+00FC;udieresis;LATIN SMALL LETTER U WITH DIAERESIS
+00F9;ugrave;LATIN SMALL LETTER U WITH GRAVE
+01B0;uhorn;LATIN SMALL LETTER U WITH HORN
+0171;uhungarumlaut;LATIN SMALL LETTER U WITH DOUBLE ACUTE
+016B;umacron;LATIN SMALL LETTER U WITH MACRON
+005F;underscore;LOW LINE
+2017;underscoredbl;DOUBLE LOW LINE
+222A;union;UNION
+2200;universal;FOR ALL
+0173;uogonek;LATIN SMALL LETTER U WITH OGONEK
+2580;upblock;UPPER HALF BLOCK
+03C5;upsilon;GREEK SMALL LETTER UPSILON
+03CB;upsilondieresis;GREEK SMALL LETTER UPSILON WITH DIALYTIKA
+03B0;upsilondieresistonos;GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS
+03CD;upsilontonos;GREEK SMALL LETTER UPSILON WITH TONOS
+016F;uring;LATIN SMALL LETTER U WITH RING ABOVE
+0169;utilde;LATIN SMALL LETTER U WITH TILDE
+0076;v;LATIN SMALL LETTER V
+0077;w;LATIN SMALL LETTER W
+1E83;wacute;LATIN SMALL LETTER W WITH ACUTE
+0175;wcircumflex;LATIN SMALL LETTER W WITH CIRCUMFLEX
+1E85;wdieresis;LATIN SMALL LETTER W WITH DIAERESIS
+2118;weierstrass;SCRIPT CAPITAL P
+1E81;wgrave;LATIN SMALL LETTER W WITH GRAVE
+0078;x;LATIN SMALL LETTER X
+03BE;xi;GREEK SMALL LETTER XI
+0079;y;LATIN SMALL LETTER Y
+00FD;yacute;LATIN SMALL LETTER Y WITH ACUTE
+0177;ycircumflex;LATIN SMALL LETTER Y WITH CIRCUMFLEX
+00FF;ydieresis;LATIN SMALL LETTER Y WITH DIAERESIS
+00A5;yen;YEN SIGN
+1EF3;ygrave;LATIN SMALL LETTER Y WITH GRAVE
+007A;z;LATIN SMALL LETTER Z
+017A;zacute;LATIN SMALL LETTER Z WITH ACUTE
+017E;zcaron;LATIN SMALL LETTER Z WITH CARON
+017C;zdotaccent;LATIN SMALL LETTER Z WITH DOT ABOVE
+0030;zero;DIGIT ZERO
+03B6;zeta;GREEK SMALL LETTER ZETA
diff -rupN C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/cp1250.ps.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/cp1250.ps.svn-base
--- C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/cp1250.ps.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/cp1250.ps.svn-base	2012-01-03 17:07:20.977378700 -0800
@@ -0,0 +1,41 @@
+%
+% Encoding for code page 1250 (Microsoft Windows Central and Eastern European)
+%
+/reencodeCP1250 {
+dup dup findfont dup length dict begin
+{ 1 index /FID ne { def }{ pop pop } ifelse } forall
+currentdict /CharStrings known {
+	CharStrings /Idieresis known {
+		/Encoding CP1250Encoding def } if
+} if
+currentdict end definefont
+} def
+/CP1250Encoding [
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright
+/parenleft/parenright/asterisk/plus/comma/minus/period/slash/zero/one
+/two/three/four/five/six/seven/eight/nine/colon/semicolon/less/equal/greater
+/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N/O/P/Q/R/S/T/U/V/W/X/Y/Z
+/bracketleft/backslash/bracketright/asciicircum/underscore/quoteleft
+/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar
+/braceright/tilde/.notdef/.notdef/.notdef/quotesinglbase/.notdef/quotedblbase
+/ellipsis/dagger/daggerdbl/.notdef/perthousand/Scaron/guilsinglleft/Sacute
+/Tcaron/Zcaron/Zacute/.notdef/quoteleft/quoteright/quotedblleft
+/quotedblright/bullet/endash/emdash/.notdef/trademark/scaron
+/guilsinglright/sacute/tcaron/zcaron/zacute/space/caron/breve/Lslash
+/currency/Aogonek/brokenbar/section/dieresis/copyright/Scedilla
+/guillemotleft/logicalnot/hyphen/registered/Zdotaccent
+/degree/plusminus/ogonek/lslash/acute/mu/paragraph/bullet
+/cedilla/aogonek/scedilla/guillemotright/Lcaron/hungarumlaut/lcaron
+/zdotaccent/Racute/Aacute/Acircumflex/Abreve/Adieresis/Lacute/Cacute
+/Ccedilla/Ccaron/Eacute/Eogonek/Edieresis/Ecaron/Iacute/Icircumflex
+/Dcaron/Eth/Nacute/Ncaron/Oacute/Ocircumflex/Ohungarumlaut/Odieresis
+/multiply/Rcaron/Uring/Uacute/Uhungarumlaut/Udieresis/Yacute/Tcedilla
+/germandbls/racute/aacute/acircumflex/abreve/adieresis/lacute/cacute
+/ccedilla/ccaron/eacute/eogonek/edieresis/ecaron/iacute/icircumflex
+/dcaron/dbar/nacute/ncaron/oacute/ocircumflex/ohungarumlaut/odieresis
+/divide/rcaron/uring/uacute/uhungarumlaut/udieresis/yacute/tcedilla/dotaccent
+] def
diff -rupN C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/cp437.ps.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/cp437.ps.svn-base
--- C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/cp437.ps.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/cp437.ps.svn-base	2012-01-03 17:07:21.221010500 -0800
@@ -0,0 +1,49 @@
+%
+% encoding for code page 437 (original MSDOS)
+% version 1.0:	- Mainly letters are mapped. The following positions
+% (JFi)		  are left blank (undefined):
+%		-- first 32 positions,
+%		-- frame characters,
+%		-- greek characters,
+%		-- some more special characters.
+%
+% version 1.1:  - added some more special characters
+
+/reencodeCP437 {
+dup dup findfont dup length dict begin
+{ 1 index /FID ne { def }{ pop pop } ifelse } forall
+currentdict /CharStrings known {
+	CharStrings /Idieresis known {
+		/Encoding CP437Encoding def } if
+} if
+currentdict end definefont
+} def
+/CP437Encoding [
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright
+/parenleft/parenright/asterisk/plus/comma/minus/period/slash
+/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon
+/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N
+/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright
+/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m
+/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde/.notdef
+/Ccedilla/udieresis/eacute/acircumflex/adieresis/agrave/aring/ccedilla
+/ecircumflex/edieresis/egrave/idieresis/icircumflex/igrave/Adieresis/Aring
+/Eacute/ae/AE/ocircumflex/odieresis/ograve/ucircumflex/ugrave
+/ydieresis/Odieresis/Udieresis/cent/sterling/yen/.notdef/florin
+/aacute/iacute/oacute/uacute/ntilde/Ntilde/ordfeminine/ordmasculine
+/questiondown/.notdef/logicalnot/onehalf/onequarter/exclamdown/guillemotleft/guillemotright
+/space/space/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/germandbls/.notdef/.notdef/.notdef/.notdef/mu/.notdef
+/.notdef/.notdef/.notdef/.notdef/infinity/.notdef/.notdef/.notdef
+/.notdef/plusminus/greaterequal/lessequal/.notdef/.notdef/divide/.notdef
+/degree/bullet/periodcentered/.notdef/nsuperior/twosuperior/.notdef/.notdef
+] def
diff -rupN C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/cp850.ps.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/cp850.ps.svn-base
--- C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/cp850.ps.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/cp850.ps.svn-base	2012-01-03 17:07:21.431556500 -0800
@@ -0,0 +1,46 @@
+%
+% encoding for code page 850 (obsolete MSDOS Western Europe)
+% version 1.0:  - Mainly letters are mapped. The following positions
+% (JFi)		  are left blank (undefined):
+%		-- first 32 positions,
+%		-- frame characters,
+%		-- a few special characters.
+
+/reencodeCP850 {
+dup dup findfont dup length dict begin
+{ 1 index /FID ne { def }{ pop pop } ifelse } forall
+currentdict /CharStrings known {
+	CharStrings /Idieresis known {
+		/Encoding CP850Encoding def } if
+} if
+currentdict end definefont
+} def
+/CP850Encoding [
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright
+/parenleft/parenright/asterisk/plus/comma/minus/period/slash
+/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon
+/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N
+/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright
+/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m
+/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde/.notdef
+/Ccedilla/udieresis/eacute/acircumflex/adieresis/agrave/aring/ccedilla
+/ecircumflex/edieresis/egrave/idieresis/icircumflex/igrave/Adieresis/Aring
+/Eacute/ae/AE/ocircumflex/odieresis/ograve/ucircumflex/ugrave
+/ydieresis/Odieresis/Udieresis/oslash/sterling/Oslash/multiply/florin
+/aacute/iacute/oacute/uacute/ntilde/Ntilde/ordfeminine/ordmasculine
+/questiondown/registered/logicalnot/onehalf/onequarter/exclamdown/guillemotleft/guillemotright
+/space/space/.notdef/.notdef/.notdef/Aacute/Acircumflex/Agrave
+/.notdef/.notdef/.notdef/.notdef/.notdef/cent/yen/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/atilde/Atilde
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/currency
+/eth/Eth/Ecircumflex/Edieresis/Egrave/dotlessi/Iacute/Icircumflex
+/Idieresis/.notdef/.notdef/.notdef/.notdef/brokenbar/Igrave/.notdef
+/Oacute/germandbls/Ocircumflex/Ograve/otilde/Otilde/mu/thorn
+/Thorn/Uacute/Ucircumflex/Ugrave/yacute/Yacute/macron/acute
+/hyphen/plusminus/equal/threequarters/paragraph/section/divide/.notdef
+/degree/.notdef/periodcentered/onesuperior/threesuperior/twosuperior/.notdef/.notdef
+] def
diff -rupN C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/cp852.ps.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/cp852.ps.svn-base
--- C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/cp852.ps.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/cp852.ps.svn-base	2012-01-03 17:07:21.640097300 -0800
@@ -0,0 +1,41 @@
+%
+% encoding for code page 852 (MSDOS Central European)
+/reencodeCP852 {
+dup dup findfont dup length dict begin
+{ 1 index /FID ne { def }{ pop pop } ifelse } forall
+currentdict /CharStrings known {
+	CharStrings /Idieresis known {
+		/Encoding CP852Encoding def } if
+} if
+currentdict end definefont
+} def
+/CP852Encoding [
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/paragraph/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quotesingle
+/parenleft/parenright/asterisk/plus/comma/hyphen/period/slash
+/zero/one/two/three/four/five/six/seven/eight/nine
+/colon/semicolon/less/equal/greater/question
+/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N/O/P/Q/R/S/T/U/V/W/X/Y/Z
+/bracketleft/backslash/bracketright/asciicircum/underscore
+/grave/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q/r/s/t/u/v/w
+/x/y/z/braceleft/bar/braceright/asciitilde/.notdef
+/Ccedilla/udieresis/eacute/acircumflex/adieresis/uring/cacute/ccedilla
+/lslash/edieresis/Ohungarumlaut/ohungarumlaut/icircumflex/Zacute/Adieresis
+/Cacute/Eacute/Lacute/lacute/ocircumflex/odieresis/Lcaron/lcaron/Sacute
+/sacute/Odieresis/Udieresis/Tcaron/tcaron/Lslash/multiply/ccaron
+/aacute/iacute/oacute/uacute/Aogonek/aogonek/Zcaron/zcaron
+/Eogonek/eogonek/.notdef/zacute/Ccaron/scedilla/guillemotleft/guillemotright
+/.notdef/.notdef/.notdef/.notdef/.notdef/Aacute/Acircumflex/Ecaron
+/Scedilla/.notdef/.notdef/.notdef/.notdef/Zdotaccent/zdotaccent/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/Abreve/abreve
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/currency
+/eth/Eth/Dcaron/Edieresis/dcaron/Ncaron/Iacute/Icircumflex
+/ecaron/.notdef/.notdef/.notdef/.notdef/Tcedilla/Uring/.notdef
+/Oacute/germandbls/Ocircumflex/Nacute/nacute/ncaron/Scaron/scaron
+/Racute/Uacute/racute/Uhungarumlaut/yacute/Yacute/tcedilla/acute
+/hyphen/hungarumlaut/ogonek/caron/breve/section/divide/cedilla
+/degree/dieresis/dotaccent/uhungarumlaut/Rcaron/rcaron/.notdef/.notdef
+] def
diff -rupN C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/koi8r.ps.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/koi8r.ps.svn-base
--- C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/koi8r.ps.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/koi8r.ps.svn-base	2012-01-03 17:07:21.857661500 -0800
@@ -0,0 +1,46 @@
+%
+% encoding for code page koi8r (8-bit Russian)
+% version 1.0:	- Mainly letters are mapped. The following positions
+% (JFi)		  are left blank (undefined):
+%		-- first 32 positions,
+%		-- frame characters,
+%		-- a few special characters.
+
+/reencodeKOI8R {
+dup dup findfont dup length dict begin
+{ 1 index /FID ne { def }{ pop pop } ifelse } forall
+currentdict /CharStrings known {
+	CharStrings /Idieresis known {
+		/Encoding KOI8REncoding def } if
+} if
+currentdict end definefont
+} def
+/KOI8REncoding [
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright
+/parenleft/parenright/asterisk/plus/comma/minus/period/slash
+/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon
+/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N
+/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright
+/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m
+/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde/.notdef
+/SF100000/SF110000/SF010000/SF030000/SF020000/SF040000/SF080000/SF090000
+/SF060000/SF070000/SF050000/SF600000/SF570000/SF610000/SF580000/SF590000
+/SF140000/SF150000/SF160000/SS260000/filledbox/bullet/radical/approxequal
+/lessequal/greaterequal/space/SS270000/degree/twosuperior/periodcentered/divide
+/SF430000/SF240000/SF510000/afii10071/SF520000/SF390000/SF220000/SF210000
+/SF250000/SF500000/SF490000/SF380000/SF280000/SF270000/SF260000/SF360000
+/SF370000/SF420000/SF190000/afii10023/SF200000/SF230000/SF470000/SF480000
+/SF410000/SF450000/SF460000/SF400000/SF540000/SF530000/SF440000/copyright
+/afii10096/afii10065/afii10066/afii10088/afii10069/afii10070/afii10086/afii10068
+/afii10087/afii10074/afii10075/afii10076/afii10077/afii10078/afii10079/afii10080
+/afii10081/afii10097/afii10082/afii10083/afii10084/afii10085/afii10072/afii10067
+/afii10094/afii10093/afii10073/afii10090/afii10095/afii10091/afii10089/afii10092
+/afii10048/afii10017/afii10018/afii10040/afii10021/afii10022/afii10038/afii10020
+/afii10039/afii10026/afii10027/afii10028/afii10029/afii10030/afii10031/afii10032
+/afii10033/afii10049/afii10034/afii10035/afii10036/afii10037/afii10024/afii10019
+/afii10046/afii10045/afii10025/afii10042/afii10047/afii10043/afii10041/afii10044
+] def
diff -rupN C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/koi8u.ps.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/koi8u.ps.svn-base
--- C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/koi8u.ps.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/koi8u.ps.svn-base	2012-01-03 17:07:22.059184100 -0800
@@ -0,0 +1,40 @@
+%
+% encoding for code page koi8r (8-bit Ukrainian)
+/reencodeKOI8U {
+dup dup findfont dup length dict begin
+{ 1 index /FID ne { def }{ pop pop } ifelse } forall
+currentdict /CharStrings known {
+	CharStrings /Idieresis known {
+		/Encoding KOI8UEncoding def } if
+} if
+currentdict end definefont
+} def
+/KOI8UEncoding [
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright
+/parenleft/parenright/asterisk/plus/comma/minus/period/slash
+/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon
+/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N
+/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright
+/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m
+/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde/.notdef
+/SF100000/SF110000/SF010000/SF030000/SF020000/SF040000/SF080000/SF090000
+/SF060000/SF070000/SF050000/SF600000/SF570000/SF610000/SF580000/SF590000
+/SF140000/SF150000/SF160000/SS260000/filledbox/bullet/radical/approxequal
+/lessequal/greaterequal/space/SS270000/degree/twosuperior/periodcentered/divide
+/SF430000/SF240000/SF510000/afii10071/afii10101/SF390000/afii10103/afii10104
+/SF250000/SF500000/SF490000/SF380000/SF280000/afii10098/SF260000/SF360000
+/SF370000/SF420000/SF190000/afii10023/afii10053/SF230000/afii10055/afii10056
+/SF410000/SF450000/SF460000/SF400000/SF540000/afii10050/SF440000/copyright
+/afii10096/afii10065/afii10066/afii10088/afii10069/afii10070/afii10086/afii10068
+/afii10087/afii10074/afii10075/afii10076/afii10077/afii10078/afii10079/afii10080
+/afii10081/afii10097/afii10082/afii10083/afii10084/afii10085/afii10072/afii10067
+/afii10094/afii10093/afii10073/afii10090/afii10095/afii10091/afii10089/afii10092
+/afii10048/afii10017/afii10018/afii10040/afii10021/afii10022/afii10038/afii10020
+/afii10039/afii10026/afii10027/afii10028/afii10029/afii10030/afii10031/afii10032
+/afii10033/afii10049/afii10034/afii10035/afii10036/afii10037/afii10024/afii10019
+/afii10046/afii10045/afii10025/afii10042/afii10047/afii10043/afii10041/afii10044
+] def
diff -rupN C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/prologue.ps.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/prologue.ps.svn-base
--- C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/prologue.ps.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/prologue.ps.svn-base	2012-01-03 17:07:22.258701500 -0800
@@ -0,0 +1,371 @@
+%
+% Gnuplot Prolog Version 4.4 (January 2010)
+%
+%/SuppressPDFMark true def
+%
+/M {moveto} bind def
+/L {lineto} bind def
+/R {rmoveto} bind def
+/V {rlineto} bind def
+/N {newpath moveto} bind def
+/Z {closepath} bind def
+/C {setrgbcolor} bind def
+/f {rlineto fill} bind def
+/Gshow {show} def   % May be redefined later in the file to support UTF-8
+/vpt2 vpt 2 mul def
+/hpt2 hpt 2 mul def
+/Lshow {currentpoint stroke M 0 vshift R 
+	Blacktext {gsave 0 setgray show grestore} {show} ifelse} def
+/Rshow {currentpoint stroke M dup stringwidth pop neg vshift R
+	Blacktext {gsave 0 setgray show grestore} {show} ifelse} def
+/Cshow {currentpoint stroke M dup stringwidth pop -2 div vshift R 
+	Blacktext {gsave 0 setgray show grestore} {show} ifelse} def
+/UP {dup vpt_ mul /vpt exch def hpt_ mul /hpt exch def
+  /hpt2 hpt 2 mul def /vpt2 vpt 2 mul def} def
+/DL {Color {setrgbcolor Solid {pop []} if 0 setdash}
+ {pop pop pop 0 setgray Solid {pop []} if 0 setdash} ifelse} def
+/BL {stroke userlinewidth 2 mul setlinewidth
+	Rounded {1 setlinejoin 1 setlinecap} if} def
+/AL {stroke userlinewidth 2 div setlinewidth
+	Rounded {1 setlinejoin 1 setlinecap} if} def
+/UL {dup gnulinewidth mul /userlinewidth exch def
+	dup 1 lt {pop 1} if 10 mul /udl exch def} def
+/PL {stroke userlinewidth setlinewidth
+	Rounded {1 setlinejoin 1 setlinecap} if} def
+% Default Line colors
+/LCw {1 1 1} def
+/LCb {0 0 0} def
+/LCa {0 0 0} def
+/LC0 {1 0 0} def
+/LC1 {0 1 0} def
+/LC2 {0 0 1} def
+/LC3 {1 0 1} def
+/LC4 {0 1 1} def
+/LC5 {1 1 0} def
+/LC6 {0 0 0} def
+/LC7 {1 0.3 0} def
+/LC8 {0.5 0.5 0.5} def
+% Default Line Types
+/LTw {PL [] 1 setgray} def
+/LTb {BL [] LCb DL} def
+/LTa {AL [1 udl mul 2 udl mul] 0 setdash LCa setrgbcolor} def
+/LT0 {PL [] LC0 DL} def
+/LT1 {PL [4 dl1 2 dl2] LC1 DL} def
+/LT2 {PL [2 dl1 3 dl2] LC2 DL} def
+/LT3 {PL [1 dl1 1.5 dl2] LC3 DL} def
+/LT4 {PL [6 dl1 2 dl2 1 dl1 2 dl2] LC4 DL} def
+/LT5 {PL [3 dl1 3 dl2 1 dl1 3 dl2] LC5 DL} def
+/LT6 {PL [2 dl1 2 dl2 2 dl1 6 dl2] LC6 DL} def
+/LT7 {PL [1 dl1 2 dl2 6 dl1 2 dl2 1 dl1 2 dl2] LC7 DL} def
+/LT8 {PL [2 dl1 2 dl2 2 dl1 2 dl2 2 dl1 2 dl2 2 dl1 4 dl2] LC8 DL} def
+/Pnt {stroke [] 0 setdash gsave 1 setlinecap M 0 0 V stroke grestore} def
+/Dia {stroke [] 0 setdash 2 copy vpt add M
+  hpt neg vpt neg V hpt vpt neg V
+  hpt vpt V hpt neg vpt V closepath stroke
+  Pnt} def
+/Pls {stroke [] 0 setdash vpt sub M 0 vpt2 V
+  currentpoint stroke M
+  hpt neg vpt neg R hpt2 0 V stroke
+ } def
+/Box {stroke [] 0 setdash 2 copy exch hpt sub exch vpt add M
+  0 vpt2 neg V hpt2 0 V 0 vpt2 V
+  hpt2 neg 0 V closepath stroke
+  Pnt} def
+/Crs {stroke [] 0 setdash exch hpt sub exch vpt add M
+  hpt2 vpt2 neg V currentpoint stroke M
+  hpt2 neg 0 R hpt2 vpt2 V stroke} def
+/TriU {stroke [] 0 setdash 2 copy vpt 1.12 mul add M
+  hpt neg vpt -1.62 mul V
+  hpt 2 mul 0 V
+  hpt neg vpt 1.62 mul V closepath stroke
+  Pnt} def
+/Star {2 copy Pls Crs} def
+/BoxF {stroke [] 0 setdash exch hpt sub exch vpt add M
+  0 vpt2 neg V hpt2 0 V 0 vpt2 V
+  hpt2 neg 0 V closepath fill} def
+/TriUF {stroke [] 0 setdash vpt 1.12 mul add M
+  hpt neg vpt -1.62 mul V
+  hpt 2 mul 0 V
+  hpt neg vpt 1.62 mul V closepath fill} def
+/TriD {stroke [] 0 setdash 2 copy vpt 1.12 mul sub M
+  hpt neg vpt 1.62 mul V
+  hpt 2 mul 0 V
+  hpt neg vpt -1.62 mul V closepath stroke
+  Pnt} def
+/TriDF {stroke [] 0 setdash vpt 1.12 mul sub M
+  hpt neg vpt 1.62 mul V
+  hpt 2 mul 0 V
+  hpt neg vpt -1.62 mul V closepath fill} def
+/DiaF {stroke [] 0 setdash vpt add M
+  hpt neg vpt neg V hpt vpt neg V
+  hpt vpt V hpt neg vpt V closepath fill} def
+/Pent {stroke [] 0 setdash 2 copy gsave
+  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
+  closepath stroke grestore Pnt} def
+/PentF {stroke [] 0 setdash gsave
+  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
+  closepath fill grestore} def
+/Circle {stroke [] 0 setdash 2 copy
+  hpt 0 360 arc stroke Pnt} def
+/CircleF {stroke [] 0 setdash hpt 0 360 arc fill} def
+/C0 {BL [] 0 setdash 2 copy moveto vpt 90 450 arc} bind def
+/C1 {BL [] 0 setdash 2 copy moveto
+	2 copy vpt 0 90 arc closepath fill
+	vpt 0 360 arc closepath} bind def
+/C2 {BL [] 0 setdash 2 copy moveto
+	2 copy vpt 90 180 arc closepath fill
+	vpt 0 360 arc closepath} bind def
+/C3 {BL [] 0 setdash 2 copy moveto
+	2 copy vpt 0 180 arc closepath fill
+	vpt 0 360 arc closepath} bind def
+/C4 {BL [] 0 setdash 2 copy moveto
+	2 copy vpt 180 270 arc closepath fill
+	vpt 0 360 arc closepath} bind def
+/C5 {BL [] 0 setdash 2 copy moveto
+	2 copy vpt 0 90 arc
+	2 copy moveto
+	2 copy vpt 180 270 arc closepath fill
+	vpt 0 360 arc} bind def
+/C6 {BL [] 0 setdash 2 copy moveto
+	2 copy vpt 90 270 arc closepath fill
+	vpt 0 360 arc closepath} bind def
+/C7 {BL [] 0 setdash 2 copy moveto
+	2 copy vpt 0 270 arc closepath fill
+	vpt 0 360 arc closepath} bind def
+/C8 {BL [] 0 setdash 2 copy moveto
+	2 copy vpt 270 360 arc closepath fill
+	vpt 0 360 arc closepath} bind def
+/C9 {BL [] 0 setdash 2 copy moveto
+	2 copy vpt 270 450 arc closepath fill
+	vpt 0 360 arc closepath} bind def
+/C10 {BL [] 0 setdash 2 copy 2 copy moveto vpt 270 360 arc closepath fill
+	2 copy moveto
+	2 copy vpt 90 180 arc closepath fill
+	vpt 0 360 arc closepath} bind def
+/C11 {BL [] 0 setdash 2 copy moveto
+	2 copy vpt 0 180 arc closepath fill
+	2 copy moveto
+	2 copy vpt 270 360 arc closepath fill
+	vpt 0 360 arc closepath} bind def
+/C12 {BL [] 0 setdash 2 copy moveto
+	2 copy vpt 180 360 arc closepath fill
+	vpt 0 360 arc closepath} bind def
+/C13 {BL [] 0 setdash 2 copy moveto
+	2 copy vpt 0 90 arc closepath fill
+	2 copy moveto
+	2 copy vpt 180 360 arc closepath fill
+	vpt 0 360 arc closepath} bind def
+/C14 {BL [] 0 setdash 2 copy moveto
+	2 copy vpt 90 360 arc closepath fill
+	vpt 0 360 arc} bind def
+/C15 {BL [] 0 setdash 2 copy vpt 0 360 arc closepath fill
+	vpt 0 360 arc closepath} bind def
+/Rec {newpath 4 2 roll moveto 1 index 0 rlineto 0 exch rlineto
+	neg 0 rlineto closepath} bind def
+/Square {dup Rec} bind def
+/Bsquare {vpt sub exch vpt sub exch vpt2 Square} bind def
+/S0 {BL [] 0 setdash 2 copy moveto 0 vpt rlineto BL Bsquare} bind def
+/S1 {BL [] 0 setdash 2 copy vpt Square fill Bsquare} bind def
+/S2 {BL [] 0 setdash 2 copy exch vpt sub exch vpt Square fill Bsquare} bind def
+/S3 {BL [] 0 setdash 2 copy exch vpt sub exch vpt2 vpt Rec fill Bsquare} bind def
+/S4 {BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt Square fill Bsquare} bind def
+/S5 {BL [] 0 setdash 2 copy 2 copy vpt Square fill
+	exch vpt sub exch vpt sub vpt Square fill Bsquare} bind def
+/S6 {BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill Bsquare} bind def
+/S7 {BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill
+	2 copy vpt Square fill Bsquare} bind def
+/S8 {BL [] 0 setdash 2 copy vpt sub vpt Square fill Bsquare} bind def
+/S9 {BL [] 0 setdash 2 copy vpt sub vpt vpt2 Rec fill Bsquare} bind def
+/S10 {BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt Square fill
+	Bsquare} bind def
+/S11 {BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt2 vpt Rec fill
+	Bsquare} bind def
+/S12 {BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill Bsquare} bind def
+/S13 {BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill
+	2 copy vpt Square fill Bsquare} bind def
+/S14 {BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill
+	2 copy exch vpt sub exch vpt Square fill Bsquare} bind def
+/S15 {BL [] 0 setdash 2 copy Bsquare fill Bsquare} bind def
+/D0 {gsave translate 45 rotate 0 0 S0 stroke grestore} bind def
+/D1 {gsave translate 45 rotate 0 0 S1 stroke grestore} bind def
+/D2 {gsave translate 45 rotate 0 0 S2 stroke grestore} bind def
+/D3 {gsave translate 45 rotate 0 0 S3 stroke grestore} bind def
+/D4 {gsave translate 45 rotate 0 0 S4 stroke grestore} bind def
+/D5 {gsave translate 45 rotate 0 0 S5 stroke grestore} bind def
+/D6 {gsave translate 45 rotate 0 0 S6 stroke grestore} bind def
+/D7 {gsave translate 45 rotate 0 0 S7 stroke grestore} bind def
+/D8 {gsave translate 45 rotate 0 0 S8 stroke grestore} bind def
+/D9 {gsave translate 45 rotate 0 0 S9 stroke grestore} bind def
+/D10 {gsave translate 45 rotate 0 0 S10 stroke grestore} bind def
+/D11 {gsave translate 45 rotate 0 0 S11 stroke grestore} bind def
+/D12 {gsave translate 45 rotate 0 0 S12 stroke grestore} bind def
+/D13 {gsave translate 45 rotate 0 0 S13 stroke grestore} bind def
+/D14 {gsave translate 45 rotate 0 0 S14 stroke grestore} bind def
+/D15 {gsave translate 45 rotate 0 0 S15 stroke grestore} bind def
+/DiaE {stroke [] 0 setdash vpt add M
+  hpt neg vpt neg V hpt vpt neg V
+  hpt vpt V hpt neg vpt V closepath stroke} def
+/BoxE {stroke [] 0 setdash exch hpt sub exch vpt add M
+  0 vpt2 neg V hpt2 0 V 0 vpt2 V
+  hpt2 neg 0 V closepath stroke} def
+/TriUE {stroke [] 0 setdash vpt 1.12 mul add M
+  hpt neg vpt -1.62 mul V
+  hpt 2 mul 0 V
+  hpt neg vpt 1.62 mul V closepath stroke} def
+/TriDE {stroke [] 0 setdash vpt 1.12 mul sub M
+  hpt neg vpt 1.62 mul V
+  hpt 2 mul 0 V
+  hpt neg vpt -1.62 mul V closepath stroke} def
+/PentE {stroke [] 0 setdash gsave
+  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
+  closepath stroke grestore} def
+/CircE {stroke [] 0 setdash 
+  hpt 0 360 arc stroke} def
+/Opaque {gsave closepath 1 setgray fill grestore 0 setgray closepath} def
+/DiaW {stroke [] 0 setdash vpt add M
+  hpt neg vpt neg V hpt vpt neg V
+  hpt vpt V hpt neg vpt V Opaque stroke} def
+/BoxW {stroke [] 0 setdash exch hpt sub exch vpt add M
+  0 vpt2 neg V hpt2 0 V 0 vpt2 V
+  hpt2 neg 0 V Opaque stroke} def
+/TriUW {stroke [] 0 setdash vpt 1.12 mul add M
+  hpt neg vpt -1.62 mul V
+  hpt 2 mul 0 V
+  hpt neg vpt 1.62 mul V Opaque stroke} def
+/TriDW {stroke [] 0 setdash vpt 1.12 mul sub M
+  hpt neg vpt 1.62 mul V
+  hpt 2 mul 0 V
+  hpt neg vpt -1.62 mul V Opaque stroke} def
+/PentW {stroke [] 0 setdash gsave
+  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
+  Opaque stroke grestore} def
+/CircW {stroke [] 0 setdash 
+  hpt 0 360 arc Opaque stroke} def
+/BoxFill {gsave Rec 1 setgray fill grestore} def
+/Density {
+  /Fillden exch def
+  currentrgbcolor
+  /ColB exch def /ColG exch def /ColR exch def
+  /ColR ColR Fillden mul Fillden sub 1 add def
+  /ColG ColG Fillden mul Fillden sub 1 add def
+  /ColB ColB Fillden mul Fillden sub 1 add def
+  ColR ColG ColB setrgbcolor} def
+/BoxColFill {gsave Rec PolyFill} def
+/PolyFill {gsave Density fill grestore grestore} def
+/h {rlineto rlineto rlineto gsave closepath fill grestore} bind def
+%
+% PostScript Level 1 Pattern Fill routine for rectangles
+% Usage: x y w h s a XX PatternFill
+%	x,y = lower left corner of box to be filled
+%	w,h = width and height of box
+%	  a = angle in degrees between lines and x-axis
+%	 XX = 0/1 for no/yes cross-hatch
+%
+/PatternFill {gsave /PFa [ 9 2 roll ] def
+  PFa 0 get PFa 2 get 2 div add PFa 1 get PFa 3 get 2 div add translate
+  PFa 2 get -2 div PFa 3 get -2 div PFa 2 get PFa 3 get Rec
+  gsave 1 setgray fill grestore clip
+  currentlinewidth 0.5 mul setlinewidth
+  /PFs PFa 2 get dup mul PFa 3 get dup mul add sqrt def
+  0 0 M PFa 5 get rotate PFs -2 div dup translate
+  0 1 PFs PFa 4 get div 1 add floor cvi
+	{PFa 4 get mul 0 M 0 PFs V} for
+  0 PFa 6 get ne {
+	0 1 PFs PFa 4 get div 1 add floor cvi
+	{PFa 4 get mul 0 2 1 roll M PFs 0 V} for
+ } if
+  stroke grestore} def
+%
+/languagelevel where
+ {pop languagelevel} {1} ifelse
+ 2 lt
+	{/InterpretLevel1 true def}
+	{/InterpretLevel1 Level1 def}
+ ifelse
+%
+% PostScript level 2 pattern fill definitions
+%
+/Level2PatternFill {
+/Tile8x8 {/PaintType 2 /PatternType 1 /TilingType 1 /BBox [0 0 8 8] /XStep 8 /YStep 8}
+	bind def
+/KeepColor {currentrgbcolor [/Pattern /DeviceRGB] setcolorspace} bind def
+<< Tile8x8
+ /PaintProc {0.5 setlinewidth pop 0 0 M 8 8 L 0 8 M 8 0 L stroke} 
+>> matrix makepattern
+/Pat1 exch def
+<< Tile8x8
+ /PaintProc {0.5 setlinewidth pop 0 0 M 8 8 L 0 8 M 8 0 L stroke
+	0 4 M 4 8 L 8 4 L 4 0 L 0 4 L stroke}
+>> matrix makepattern
+/Pat2 exch def
+<< Tile8x8
+ /PaintProc {0.5 setlinewidth pop 0 0 M 0 8 L
+	8 8 L 8 0 L 0 0 L fill}
+>> matrix makepattern
+/Pat3 exch def
+<< Tile8x8
+ /PaintProc {0.5 setlinewidth pop -4 8 M 8 -4 L
+	0 12 M 12 0 L stroke}
+>> matrix makepattern
+/Pat4 exch def
+<< Tile8x8
+ /PaintProc {0.5 setlinewidth pop -4 0 M 8 12 L
+	0 -4 M 12 8 L stroke}
+>> matrix makepattern
+/Pat5 exch def
+<< Tile8x8
+ /PaintProc {0.5 setlinewidth pop -2 8 M 4 -4 L
+	0 12 M 8 -4 L 4 12 M 10 0 L stroke}
+>> matrix makepattern
+/Pat6 exch def
+<< Tile8x8
+ /PaintProc {0.5 setlinewidth pop -2 0 M 4 12 L
+	0 -4 M 8 12 L 4 -4 M 10 8 L stroke}
+>> matrix makepattern
+/Pat7 exch def
+<< Tile8x8
+ /PaintProc {0.5 setlinewidth pop 8 -2 M -4 4 L
+	12 0 M -4 8 L 12 4 M 0 10 L stroke}
+>> matrix makepattern
+/Pat8 exch def
+<< Tile8x8
+ /PaintProc {0.5 setlinewidth pop 0 -2 M 12 4 L
+	-4 0 M 12 8 L -4 4 M 8 10 L stroke}
+>> matrix makepattern
+/Pat9 exch def
+/Pattern1 {PatternBgnd KeepColor Pat1 setpattern} bind def
+/Pattern2 {PatternBgnd KeepColor Pat2 setpattern} bind def
+/Pattern3 {PatternBgnd KeepColor Pat3 setpattern} bind def
+/Pattern4 {PatternBgnd KeepColor Landscape {Pat5} {Pat4} ifelse setpattern} bind def
+/Pattern5 {PatternBgnd KeepColor Landscape {Pat4} {Pat5} ifelse setpattern} bind def
+/Pattern6 {PatternBgnd KeepColor Landscape {Pat9} {Pat6} ifelse setpattern} bind def
+/Pattern7 {PatternBgnd KeepColor Landscape {Pat8} {Pat7} ifelse setpattern} bind def
+} def
+%
+%
+%End of PostScript Level 2 code
+%
+/PatternBgnd {
+  TransparentPatterns {} {gsave 1 setgray fill grestore} ifelse
+} def
+%
+% Substitute for Level 2 pattern fill codes with
+% grayscale if Level 2 support is not selected.
+%
+/Level1PatternFill {
+/Pattern1 {0.250 Density} bind def
+/Pattern2 {0.500 Density} bind def
+/Pattern3 {0.750 Density} bind def
+/Pattern4 {0.125 Density} bind def
+/Pattern5 {0.375 Density} bind def
+/Pattern6 {0.625 Density} bind def
+/Pattern7 {0.875 Density} bind def
+} def
+%
+% Now test for support of Level 2 code
+%
+Level1 {Level1PatternFill} {Level2PatternFill} ifelse
+%
+/Symbol-Oblique /Symbol findfont [1 0 .167 1 0 0] makefont
+dup length dict begin {1 index /FID eq {pop pop} {def} ifelse} forall
+currentdict end definefont pop
diff -rupN C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/prologues.h.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/prologues.h.svn-base
--- C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/prologues.h.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/prologues.h.svn-base	2012-01-03 17:07:22.520380100 -0800
@@ -0,0 +1,919 @@
+/* This script-generated file contains the PostScript prologues
+ * in a form suitable to inclusion in a C source code */
+
+static const char *prologue_8859_1_ps[] = {
+"%\n",
+"% Encoding for ISO-8859-1 (also called Latin1)\n",
+"%\n",
+"/reencodeISO {\n",
+"dup dup findfont dup length dict begin\n",
+"{ 1 index /FID ne { def }{ pop pop } ifelse } forall\n",
+"currentdict /CharStrings known {\n",
+"\tCharStrings /Idieresis known {\n",
+"\t\t/Encoding ISOLatin1Encoding def } if\n",
+"} if\n",
+"currentdict end definefont\n",
+"} def\n",
+"/ISOLatin1Encoding [\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright\n",
+"/parenleft/parenright/asterisk/plus/comma/minus/period/slash\n",
+"/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon\n",
+"/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N\n",
+"/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright\n",
+"/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m\n",
+"/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/dotlessi/grave/acute/circumflex/tilde/macron/breve\n",
+"/dotaccent/dieresis/.notdef/ring/cedilla/.notdef/hungarumlaut\n",
+"/ogonek/caron/space/exclamdown/cent/sterling/currency/yen/brokenbar\n",
+"/section/dieresis/copyright/ordfeminine/guillemotleft/logicalnot\n",
+"/hyphen/registered/macron/degree/plusminus/twosuperior/threesuperior\n",
+"/acute/mu/paragraph/periodcentered/cedilla/onesuperior/ordmasculine\n",
+"/guillemotright/onequarter/onehalf/threequarters/questiondown\n",
+"/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/AE/Ccedilla\n",
+"/Egrave/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex\n",
+"/Idieresis/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis\n",
+"/multiply/Oslash/Ugrave/Uacute/Ucircumflex/Udieresis/Yacute\n",
+"/Thorn/germandbls/agrave/aacute/acircumflex/atilde/adieresis\n",
+"/aring/ae/ccedilla/egrave/eacute/ecircumflex/edieresis/igrave\n",
+"/iacute/icircumflex/idieresis/eth/ntilde/ograve/oacute/ocircumflex\n",
+"/otilde/odieresis/divide/oslash/ugrave/uacute/ucircumflex/udieresis\n",
+"/yacute/thorn/ydieresis\n",
+"] def\n",
+NULL
+};
+
+static const char *prologue_8859_15_ps[] = {
+"%\n",
+"% Encoding for ISO-8859-15 (also called Latin9)\n",
+"%\n",
+"/reencodeISO15 {\n",
+"dup dup findfont dup length dict begin\n",
+"{ 1 index /FID ne { def }{ pop pop } ifelse } forall\n",
+"currentdict /CharStrings known {\n",
+"\tCharStrings /Idieresis known {\n",
+"\t\t/Encoding ISOLatin15Encoding def } if\n",
+"} if\n",
+"currentdict end definefont\n",
+"} def\n",
+"/ISOLatin15Encoding [\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright\n",
+"/parenleft/parenright/asterisk/plus/comma/minus/period/slash\n",
+"/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon\n",
+"/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N\n",
+"/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright\n",
+"/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m\n",
+"/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/dotlessi/grave/acute/circumflex/tilde/macron/breve\n",
+"/dotaccent/dieresis/.notdef/ring/cedilla/.notdef/hungarumlaut\n",
+"/ogonek/caron/space/exclamdown/cent/sterling/Euro/yen/Scaron\n",
+"/section/scaron/copyright/ordfeminine/guillemotleft/logicalnot\n",
+"/hyphen/registered/macron/degree/plusminus/twosuperior/threesuperior\n",
+"/Zcaron/mu/paragraph/periodcentered/zcaron/onesuperior/ordmasculine\n",
+"/guillemotright/OE/oe/Ydieresis/questiondown\n",
+"/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/AE/Ccedilla\n",
+"/Egrave/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex\n",
+"/Idieresis/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis\n",
+"/multiply/Oslash/Ugrave/Uacute/Ucircumflex/Udieresis/Yacute\n",
+"/Thorn/germandbls/agrave/aacute/acircumflex/atilde/adieresis\n",
+"/aring/ae/ccedilla/egrave/eacute/ecircumflex/edieresis/igrave\n",
+"/iacute/icircumflex/idieresis/eth/ntilde/ograve/oacute/ocircumflex\n",
+"/otilde/odieresis/divide/oslash/ugrave/uacute/ucircumflex/udieresis\n",
+"/yacute/thorn/ydieresis\n",
+"] def\n",
+NULL
+};
+
+static const char *prologue_8859_2_ps[] = {
+"%\n",
+"% Encoding for ISO-8859-2 (also called Latin2), with\n",
+"% minor differences to \"true\" ISO-8859-2 (*commaaccent \n",
+"% instead of *cedilla for sStT -> incorrect in ISO-8859-2,\n",
+"% the standard will probably be modified in this respect)\n",
+"%      Levente Novak <novak@jaguar.dote.hu>\n",
+"\n",
+"/reencodeISO2 {\n",
+"dup dup findfont dup length dict begin\n",
+"{ 1 index /FID ne { def }{ pop pop } ifelse } forall\n",
+"currentdict /CharStrings known {\n",
+"\tCharStrings /Idieresis known {\n",
+"\t\t/Encoding ISOLatin2Encoding def } if\n",
+"} if\n",
+"currentdict end definefont\n",
+"} def\n",
+"/ISOLatin2Encoding [\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright\n",
+"/parenleft/parenright/asterisk/plus/comma/hyphen/period/slash\n",
+"/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon\n",
+"/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M\n",
+"/N/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright\n",
+"/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m\n",
+"/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/nbspace/Aogonek/breve/Lslash/currency/Lcaron/Sacute/section\n",
+"/dieresis/Scaron/Scommaaccent/Tcaron/Zacute/hyphen/Zcaron/Zdotaccent\n",
+"/degree/aogonek/ogonek/lslash/acute/lcaron/sacute/caron/cedilla\n",
+"/scaron/scommaaccent/tcaron/zacute/hungarumlaut/zcaron/zdotaccent\n",
+"/Racute/Aacute/Acircumflex/Abreve/Adieresis/Lacute/Cacute/Ccedilla\n",
+"/Ccaron/Eacute/Eogonek/Edieresis/Ecaron/Iacute/Icircumflex/Dcaron\n",
+"/Dcroat/Nacute/Ncaron/Oacute/Ocircumflex/Ohungarumlaut/Odieresis\n",
+"/multiply/Rcaron/Uring/Uacute/Uhungarumlaut/Udieresis/Yacute\n",
+"/Tcommaaccent/germandbls/racute/aacute/acircumflex/abreve/adieresis\n",
+"/lacute/cacute/ccedilla/ccaron/eacute/eogonek/edieresis/ecaron\n",
+"/iacute/icircumflex/dcaron/dcroat/nacute/ncaron/oacute/ocircumflex\n",
+"/ohungarumlaut/odieresis/divide/rcaron/uring/uacute/uhungarumlaut\n",
+"/udieresis/yacute/tcommaaccent/dotaccent\n",
+"] def\n",
+NULL
+};
+
+static const char *prologue_8859_9_ps[] = {
+"%\n",
+"% Encoding for ISO_8859_9 (also called Latin5)\n",
+"% Plus code points 80-9F used in Codepage 1254\n",
+"%\n",
+"/reencodeISO9 {\n",
+"dup dup findfont dup length dict begin\n",
+"{ 1 index /FID ne { def }{ pop pop } ifelse } forall\n",
+"currentdict /CharStrings known {\n",
+"\tCharStrings /Idieresis known {\n",
+"\t\t/Encoding ISOLatin5Encoding def } if\n",
+"} if\n",
+"currentdict end definefont\n",
+"} def\n",
+"/ISOLatin5Encoding [\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright\n",
+"/parenleft/parenright/asterisk/plus/comma/minus/period/slash\n",
+"/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon\n",
+"/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N\n",
+"/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright\n",
+"/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m\n",
+"/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde\n",
+"/Euro/.notdef/quotesinglbase/florin/quotedblbase/ellipsis/dagger/daggerdbl\n",
+"/circumflex/perthousand/Scaron/guilsinglleft/OE/.notdef/.notdef/.notdef\n",
+"/.notdef/quoteleft/quoteright/quotedblleft/quotedblright/bullet/endash/emdash\n",
+"/tilde/trademark/scaron/guilsinglright/oe/.notdef/.notdef/Ydieresis\n",
+"/.notdef/space/exclamdown/cent/sterling/currency/yen/brokenbar\n",
+"/section/dieresis/copyright/ordfeminine/guillemotleft/logicalnot\n",
+"/hyphen/registered/macron/degree/plusminus/twosuperior/threesuperior\n",
+"/acute/mu/paragraph/bullet/cedilla/onesuperior/ordmasculine\n",
+"/guillemotright/onequarter/onehalf/threequarters/questiondown\n",
+"/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/AE/Ccedilla\n",
+"/Egrave/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex\n",
+"/Idieresis/Gbreve/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis\n",
+"/multiply/Oslash/Ugrave/Uacute/Ucircumflex/Udieresis/Idotaccent\n",
+"/Scedilla/germandbls/agrave/aacute/acircumflex/atilde/adieresis\n",
+"/aring/ae/ccedilla/egrave/eacute/ecircumflex/edieresis/igrave\n",
+"/iacute/icircumflex/idieresis/gbreve/ntilde/ograve/oacute/ocircumflex\n",
+"/otilde/odieresis/divide/oslash/ugrave/uacute/ucircumflex/udieresis\n",
+"/dotlessi/scedilla/ydieresis\n",
+"] def\n",
+NULL
+};
+
+static const char *prologue_cp1250_ps[] = {
+"%\n",
+"% Encoding for code page 1250 (Microsoft Windows Central and Eastern European)\n",
+"%\n",
+"/reencodeCP1250 {\n",
+"dup dup findfont dup length dict begin\n",
+"{ 1 index /FID ne { def }{ pop pop } ifelse } forall\n",
+"currentdict /CharStrings known {\n",
+"\tCharStrings /Idieresis known {\n",
+"\t\t/Encoding CP1250Encoding def } if\n",
+"} if\n",
+"currentdict end definefont\n",
+"} def\n",
+"/CP1250Encoding [\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright\n",
+"/parenleft/parenright/asterisk/plus/comma/minus/period/slash/zero/one\n",
+"/two/three/four/five/six/seven/eight/nine/colon/semicolon/less/equal/greater\n",
+"/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N/O/P/Q/R/S/T/U/V/W/X/Y/Z\n",
+"/bracketleft/backslash/bracketright/asciicircum/underscore/quoteleft\n",
+"/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar\n",
+"/braceright/tilde/.notdef/.notdef/.notdef/quotesinglbase/.notdef/quotedblbase\n",
+"/ellipsis/dagger/daggerdbl/.notdef/perthousand/Scaron/guilsinglleft/Sacute\n",
+"/Tcaron/Zcaron/Zacute/.notdef/quoteleft/quoteright/quotedblleft\n",
+"/quotedblright/bullet/endash/emdash/.notdef/trademark/scaron\n",
+"/guilsinglright/sacute/tcaron/zcaron/zacute/space/caron/breve/Lslash\n",
+"/currency/Aogonek/brokenbar/section/dieresis/copyright/Scedilla\n",
+"/guillemotleft/logicalnot/hyphen/registered/Zdotaccent\n",
+"/degree/plusminus/ogonek/lslash/acute/mu/paragraph/bullet\n",
+"/cedilla/aogonek/scedilla/guillemotright/Ydieresis/hungarumlaut/Lcaron\n",
+"/zdotaccent/Racute/Aacute/Acircumflex/Abreve/Adieresis/Lacute/Cacute\n",
+"/Ccedilla/Ccaron/Eacute/Eogonek/Edieresis/Ecaron/Iacute/Icircumflex\n",
+"/Dcaron/Eth/Nacute/Ncaron/Oacute/Ocircumflex/Ohungarumlaut/Odieresis\n",
+"/multiply/Rcaron/Uring/Uacute/Uhungarumlaut/Udieresis/Yacute/Tcedilla\n",
+"/germandbls/racute/aacute/acircumflex/abreve/adieresis/lacute/cacute\n",
+"/ccedilla/ccaron/eacute/eogonek/edieresis/ecaron/iacute/icircumflex\n",
+"/dcaron/dbar/nacute/ncaron/oacute/ocircumflex/ohungarumlaut/odieresis\n",
+"/divide/rcaron/uring/uacute/uhungarumlaut/udieresis/yacute/tcedilla/dotaccent\n",
+"] def\n",
+NULL
+};
+
+static const char *prologue_cp437_ps[] = {
+"%\n",
+"% encoding for code page 437 (original MSDOS)\n",
+"% version 1.0:\t- Mainly letters are mapped. The following positions\n",
+"% (JFi)\t\t  are left blank (undefined):\n",
+"%\t\t-- first 32 positions,\n",
+"%\t\t-- frame characters,\n",
+"%\t\t-- greek characters,\n",
+"%\t\t-- some more special characters.\n",
+"%\n",
+"% version 1.1:  - added some more special characters\n",
+"\n",
+"/reencodeCP437 {\n",
+"dup dup findfont dup length dict begin\n",
+"{ 1 index /FID ne { def }{ pop pop } ifelse } forall\n",
+"currentdict /CharStrings known {\n",
+"\tCharStrings /Idieresis known {\n",
+"\t\t/Encoding CP437Encoding def } if\n",
+"} if\n",
+"currentdict end definefont\n",
+"} def\n",
+"/CP437Encoding [\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright\n",
+"/parenleft/parenright/asterisk/plus/comma/minus/period/slash\n",
+"/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon\n",
+"/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N\n",
+"/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright\n",
+"/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m\n",
+"/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde/.notdef\n",
+"/Ccedilla/udieresis/eacute/acircumflex/adieresis/agrave/aring/ccedilla\n",
+"/ecircumflex/edieresis/egrave/idieresis/icircumflex/igrave/Adieresis/Aring\n",
+"/Eacute/ae/AE/ocircumflex/odieresis/ograve/ucircumflex/ugrave\n",
+"/ydieresis/Odieresis/Udieresis/cent/sterling/yen/.notdef/florin\n",
+"/aacute/iacute/oacute/uacute/ntilde/Ntilde/ordfeminine/ordmasculine\n",
+"/questiondown/.notdef/logicalnot/onehalf/onequarter/exclamdown/guillemotleft/guillemotright\n",
+"/space/space/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/germandbls/.notdef/.notdef/.notdef/.notdef/mu/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/infinity/.notdef/.notdef/.notdef\n",
+"/.notdef/plusminus/greaterequal/lessequal/.notdef/.notdef/divide/.notdef\n",
+"/degree/bullet/periodcentered/.notdef/nsuperior/twosuperior/.notdef/.notdef\n",
+"] def\n",
+NULL
+};
+
+static const char *prologue_cp850_ps[] = {
+"%\n",
+"% encoding for code page 850 (obsolete MSDOS Western Europe)\n",
+"% version 1.0:  - Mainly letters are mapped. The following positions\n",
+"% (JFi)\t\t  are left blank (undefined):\n",
+"%\t\t-- first 32 positions,\n",
+"%\t\t-- frame characters,\n",
+"%\t\t-- a few special characters.\n",
+"\n",
+"/reencodeCP850 {\n",
+"dup dup findfont dup length dict begin\n",
+"{ 1 index /FID ne { def }{ pop pop } ifelse } forall\n",
+"currentdict /CharStrings known {\n",
+"\tCharStrings /Idieresis known {\n",
+"\t\t/Encoding CP850Encoding def } if\n",
+"} if\n",
+"currentdict end definefont\n",
+"} def\n",
+"/CP850Encoding [\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright\n",
+"/parenleft/parenright/asterisk/plus/comma/minus/period/slash\n",
+"/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon\n",
+"/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N\n",
+"/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright\n",
+"/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m\n",
+"/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde/.notdef\n",
+"/Ccedilla/udieresis/eacute/acircumflex/adieresis/agrave/aring/ccedilla\n",
+"/ecircumflex/edieresis/egrave/idieresis/icircumflex/igrave/Adieresis/Aring\n",
+"/Eacute/ae/AE/ocircumflex/odieresis/ograve/ucircumflex/ugrave\n",
+"/ydieresis/Odieresis/Udieresis/oslash/sterling/Oslash/multiply/florin\n",
+"/aacute/iacute/oacute/uacute/ntilde/Ntilde/ordfeminine/ordmasculine\n",
+"/questiondown/registered/logicalnot/onehalf/onequarter/exclamdown/guillemotleft/guillemotright\n",
+"/space/space/.notdef/.notdef/.notdef/Aacute/Acircumflex/Agrave\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/cent/yen/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/atilde/Atilde\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/currency\n",
+"/eth/Eth/Ecircumflex/Edieresis/Egrave/dotlessi/Iacute/Icircumflex\n",
+"/Idieresis/.notdef/.notdef/.notdef/.notdef/brokenbar/Igrave/.notdef\n",
+"/Oacute/germandbls/Ocircumflex/Ograve/otilde/Otilde/mu/thorn\n",
+"/Thorn/Uacute/Ucircumflex/Ugrave/yacute/Yacute/macron/acute\n",
+"/hyphen/plusminus/equal/threequarters/paragraph/section/divide/.notdef\n",
+"/degree/.notdef/periodcentered/onesuperior/threesuperior/twosuperior/.notdef/.notdef\n",
+"] def\n",
+NULL
+};
+
+static const char *prologue_cp852_ps[] = {
+"%\n",
+"% encoding for code page 852 (MSDOS Central European)\n",
+"/reencodeCP852 {\n",
+"dup dup findfont dup length dict begin\n",
+"{ 1 index /FID ne { def }{ pop pop } ifelse } forall\n",
+"currentdict /CharStrings known {\n",
+"\tCharStrings /Idieresis known {\n",
+"\t\t/Encoding CP852Encoding def } if\n",
+"} if\n",
+"currentdict end definefont\n",
+"} def\n",
+"/CP852Encoding [\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/paragraph/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quotesingle\n",
+"/parenleft/parenright/asterisk/plus/comma/hyphen/period/slash\n",
+"/zero/one/two/three/four/five/six/seven/eight/nine\n",
+"/colon/semicolon/less/equal/greater/question\n",
+"/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N/O/P/Q/R/S/T/U/V/W/X/Y/Z\n",
+"/bracketleft/backslash/bracketright/asciicircum/underscore\n",
+"/grave/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q/r/s/t/u/v/w\n",
+"/x/y/z/braceleft/bar/braceright/asciitilde/.notdef\n",
+"/Ccedilla/udieresis/eacute/acircumflex/adieresis/uring/cacute/ccedilla\n",
+"/lslash/edieresis/Ohungarumlaut/ohungarumlaut/icircumflex/Zacute/Adieresis\n",
+"/Cacute/Eacute/Lacute/lacute/ocircumflex/odieresis/Lcaron/lcaron/Sacute\n",
+"/sacute/Odieresis/Udieresis/Tcaron/tcaron/Lslash/multiply/ccaron\n",
+"/aacute/iacute/oacute/uacute/Aogonek/aogonek/Zcaron/zcaron\n",
+"/Eogonek/eogonek/.notdef/zacute/Ccaron/scedilla/guillemotleft/guillemotright\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/Aacute/Acircumflex/Ecaron\n",
+"/Scedilla/.notdef/.notdef/.notdef/.notdef/Zdotaccent/zdotaccent/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/Abreve/abreve\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/currency\n",
+"/eth/Eth/Dcaron/Edieresis/dcaron/Ncaron/Iacute/Icircumflex\n",
+"/ecaron/.notdef/.notdef/.notdef/.notdef/Tcedilla/Uring/.notdef\n",
+"/Oacute/germandbls/Ocircumflex/Nacute/nacute/ncaron/Scaron/scaron\n",
+"/Racute/Uacute/racute/Uhungarumlaut/yacute/Yacute/tcedilla/acute\n",
+"/hyphen/hungarumlaut/ogonek/caron/breve/section/divide/cedilla\n",
+"/degree/dieresis/dotaccent/uhungarumlaut/Rcaron/rcaron/.notdef/.notdef\n",
+"] def\n",
+NULL
+};
+
+static const char *prologue_koi8r_ps[] = {
+"%\n",
+"% encoding for code page koi8r (8-bit Russian)\n",
+"% version 1.0:\t- Mainly letters are mapped. The following positions\n",
+"% (JFi)\t\t  are left blank (undefined):\n",
+"%\t\t-- first 32 positions,\n",
+"%\t\t-- frame characters,\n",
+"%\t\t-- a few special characters.\n",
+"\n",
+"/reencodeKOI8R {\n",
+"dup dup findfont dup length dict begin\n",
+"{ 1 index /FID ne { def }{ pop pop } ifelse } forall\n",
+"currentdict /CharStrings known {\n",
+"\tCharStrings /Idieresis known {\n",
+"\t\t/Encoding KOI8REncoding def } if\n",
+"} if\n",
+"currentdict end definefont\n",
+"} def\n",
+"/KOI8REncoding [\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright\n",
+"/parenleft/parenright/asterisk/plus/comma/minus/period/slash\n",
+"/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon\n",
+"/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N\n",
+"/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright\n",
+"/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m\n",
+"/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde/.notdef\n",
+"/SF100000/SF110000/SF010000/SF030000/SF020000/SF040000/SF080000/SF090000\n",
+"/SF060000/SF070000/SF050000/SF600000/SF570000/SF610000/SF580000/SF590000\n",
+"/SF140000/SF150000/SF160000/SS260000/filledbox/bullet/radical/approxequal\n",
+"/lessequal/greaterequal/space/SS270000/degree/twosuperior/periodcentered/divide\n",
+"/SF430000/SF240000/SF510000/afii10071/SF520000/SF390000/SF220000/SF210000\n",
+"/SF250000/SF500000/SF490000/SF380000/SF280000/SF270000/SF260000/SF360000\n",
+"/SF370000/SF420000/SF190000/afii10023/SF200000/SF230000/SF470000/SF480000\n",
+"/SF410000/SF450000/SF460000/SF400000/SF540000/SF530000/SF440000/copyright\n",
+"/afii10096/afii10065/afii10066/afii10088/afii10069/afii10070/afii10086/afii10068\n",
+"/afii10087/afii10074/afii10075/afii10076/afii10077/afii10078/afii10079/afii10080\n",
+"/afii10081/afii10097/afii10082/afii10083/afii10084/afii10085/afii10072/afii10067\n",
+"/afii10094/afii10093/afii10073/afii10090/afii10095/afii10091/afii10089/afii10092\n",
+"/afii10048/afii10017/afii10018/afii10040/afii10021/afii10022/afii10038/afii10020\n",
+"/afii10039/afii10026/afii10027/afii10028/afii10029/afii10030/afii10031/afii10032\n",
+"/afii10033/afii10049/afii10034/afii10035/afii10036/afii10037/afii10024/afii10019\n",
+"/afii10046/afii10045/afii10025/afii10042/afii10047/afii10043/afii10041/afii10044\n",
+"] def\n",
+NULL
+};
+
+static const char *prologue_koi8u_ps[] = {
+"%\n",
+"% encoding for code page koi8r (8-bit Ukrainian)\n",
+"/reencodeKOI8U {\n",
+"dup dup findfont dup length dict begin\n",
+"{ 1 index /FID ne { def }{ pop pop } ifelse } forall\n",
+"currentdict /CharStrings known {\n",
+"\tCharStrings /Idieresis known {\n",
+"\t\t/Encoding KOI8UEncoding def } if\n",
+"} if\n",
+"currentdict end definefont\n",
+"} def\n",
+"/KOI8UEncoding [\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright\n",
+"/parenleft/parenright/asterisk/plus/comma/minus/period/slash\n",
+"/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon\n",
+"/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N\n",
+"/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright\n",
+"/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m\n",
+"/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde/.notdef\n",
+"/SF100000/SF110000/SF010000/SF030000/SF020000/SF040000/SF080000/SF090000\n",
+"/SF060000/SF070000/SF050000/SF600000/SF570000/SF610000/SF580000/SF590000\n",
+"/SF140000/SF150000/SF160000/SS260000/filledbox/bullet/radical/approxequal\n",
+"/lessequal/greaterequal/space/SS270000/degree/twosuperior/periodcentered/divide\n",
+"/SF430000/SF240000/SF510000/afii10071/afii10101/SF390000/afii10103/afii10104\n",
+"/SF250000/SF500000/SF490000/SF380000/SF280000/afii10098/SF260000/SF360000\n",
+"/SF370000/SF420000/SF190000/afii10023/afii10053/SF230000/afii10055/afii10056\n",
+"/SF410000/SF450000/SF460000/SF400000/SF540000/afii10050/SF440000/copyright\n",
+"/afii10096/afii10065/afii10066/afii10088/afii10069/afii10070/afii10086/afii10068\n",
+"/afii10087/afii10074/afii10075/afii10076/afii10077/afii10078/afii10079/afii10080\n",
+"/afii10081/afii10097/afii10082/afii10083/afii10084/afii10085/afii10072/afii10067\n",
+"/afii10094/afii10093/afii10073/afii10090/afii10095/afii10091/afii10089/afii10092\n",
+"/afii10048/afii10017/afii10018/afii10040/afii10021/afii10022/afii10038/afii10020\n",
+"/afii10039/afii10026/afii10027/afii10028/afii10029/afii10030/afii10031/afii10032\n",
+"/afii10033/afii10049/afii10034/afii10035/afii10036/afii10037/afii10024/afii10019\n",
+"/afii10046/afii10045/afii10025/afii10042/afii10047/afii10043/afii10041/afii10044\n",
+"] def\n",
+NULL
+};
+
+static const char *prologue_prologue_ps[] = {
+"%\n",
+"% Gnuplot Prolog Version 4.4 (January 2010)\n",
+"%\n",
+"%/SuppressPDFMark true def\n",
+"%\n",
+"/M {moveto} bind def\n",
+"/L {lineto} bind def\n",
+"/R {rmoveto} bind def\n",
+"/V {rlineto} bind def\n",
+"/N {newpath moveto} bind def\n",
+"/Z {closepath} bind def\n",
+"/C {setrgbcolor} bind def\n",
+"/f {rlineto fill} bind def\n",
+"/Gshow {show} def   % May be redefined later in the file to support UTF-8\n",
+"/vpt2 vpt 2 mul def\n",
+"/hpt2 hpt 2 mul def\n",
+"/Lshow {currentpoint stroke M 0 vshift R \n",
+"\tBlacktext {gsave 0 setgray show grestore} {show} ifelse} def\n",
+"/Rshow {currentpoint stroke M dup stringwidth pop neg vshift R\n",
+"\tBlacktext {gsave 0 setgray show grestore} {show} ifelse} def\n",
+"/Cshow {currentpoint stroke M dup stringwidth pop -2 div vshift R \n",
+"\tBlacktext {gsave 0 setgray show grestore} {show} ifelse} def\n",
+"/UP {dup vpt_ mul /vpt exch def hpt_ mul /hpt exch def\n",
+"  /hpt2 hpt 2 mul def /vpt2 vpt 2 mul def} def\n",
+"/DL {Color {setrgbcolor Solid {pop []} if 0 setdash}\n",
+" {pop pop pop 0 setgray Solid {pop []} if 0 setdash} ifelse} def\n",
+"/BL {stroke userlinewidth 2 mul setlinewidth\n",
+"\tRounded {1 setlinejoin 1 setlinecap} if} def\n",
+"/AL {stroke userlinewidth 2 div setlinewidth\n",
+"\tRounded {1 setlinejoin 1 setlinecap} if} def\n",
+"/UL {dup gnulinewidth mul /userlinewidth exch def\n",
+"\tdup 1 lt {pop 1} if 10 mul /udl exch def} def\n",
+"/PL {stroke userlinewidth setlinewidth\n",
+"\tRounded {1 setlinejoin 1 setlinecap} if} def\n",
+"% Default Line colors\n",
+"/LCw {1 1 1} def\n",
+"/LCb {0 0 0} def\n",
+"/LCa {0 0 0} def\n",
+"/LC0 {1 0 0} def\n",
+"/LC1 {0 1 0} def\n",
+"/LC2 {0 0 1} def\n",
+"/LC3 {1 0 1} def\n",
+"/LC4 {0 1 1} def\n",
+"/LC5 {1 1 0} def\n",
+"/LC6 {0 0 0} def\n",
+"/LC7 {1 0.3 0} def\n",
+"/LC8 {0.5 0.5 0.5} def\n",
+"% Default Line Types\n",
+"/LTw {PL [] 1 setgray} def\n",
+"/LTb {BL [] LCb DL} def\n",
+"/LTa {AL [1 udl mul 2 udl mul] 0 setdash LCa setrgbcolor} def\n",
+"/LT0 {PL [] LC0 DL} def\n",
+"/LT1 {PL [4 dl1 2 dl2] LC1 DL} def\n",
+"/LT2 {PL [2 dl1 3 dl2] LC2 DL} def\n",
+"/LT3 {PL [1 dl1 1.5 dl2] LC3 DL} def\n",
+"/LT4 {PL [6 dl1 2 dl2 1 dl1 2 dl2] LC4 DL} def\n",
+"/LT5 {PL [3 dl1 3 dl2 1 dl1 3 dl2] LC5 DL} def\n",
+"/LT6 {PL [2 dl1 2 dl2 2 dl1 6 dl2] LC6 DL} def\n",
+"/LT7 {PL [1 dl1 2 dl2 6 dl1 2 dl2 1 dl1 2 dl2] LC7 DL} def\n",
+"/LT8 {PL [2 dl1 2 dl2 2 dl1 2 dl2 2 dl1 2 dl2 2 dl1 4 dl2] LC8 DL} def\n",
+"/Pnt {stroke [] 0 setdash gsave 1 setlinecap M 0 0 V stroke grestore} def\n",
+"/Dia {stroke [] 0 setdash 2 copy vpt add M\n",
+"  hpt neg vpt neg V hpt vpt neg V\n",
+"  hpt vpt V hpt neg vpt V closepath stroke\n",
+"  Pnt} def\n",
+"/Pls {stroke [] 0 setdash vpt sub M 0 vpt2 V\n",
+"  currentpoint stroke M\n",
+"  hpt neg vpt neg R hpt2 0 V stroke\n",
+" } def\n",
+"/Box {stroke [] 0 setdash 2 copy exch hpt sub exch vpt add M\n",
+"  0 vpt2 neg V hpt2 0 V 0 vpt2 V\n",
+"  hpt2 neg 0 V closepath stroke\n",
+"  Pnt} def\n",
+"/Crs {stroke [] 0 setdash exch hpt sub exch vpt add M\n",
+"  hpt2 vpt2 neg V currentpoint stroke M\n",
+"  hpt2 neg 0 R hpt2 vpt2 V stroke} def\n",
+"/TriU {stroke [] 0 setdash 2 copy vpt 1.12 mul add M\n",
+"  hpt neg vpt -1.62 mul V\n",
+"  hpt 2 mul 0 V\n",
+"  hpt neg vpt 1.62 mul V closepath stroke\n",
+"  Pnt} def\n",
+"/Star {2 copy Pls Crs} def\n",
+"/BoxF {stroke [] 0 setdash exch hpt sub exch vpt add M\n",
+"  0 vpt2 neg V hpt2 0 V 0 vpt2 V\n",
+"  hpt2 neg 0 V closepath fill} def\n",
+"/TriUF {stroke [] 0 setdash vpt 1.12 mul add M\n",
+"  hpt neg vpt -1.62 mul V\n",
+"  hpt 2 mul 0 V\n",
+"  hpt neg vpt 1.62 mul V closepath fill} def\n",
+"/TriD {stroke [] 0 setdash 2 copy vpt 1.12 mul sub M\n",
+"  hpt neg vpt 1.62 mul V\n",
+"  hpt 2 mul 0 V\n",
+"  hpt neg vpt -1.62 mul V closepath stroke\n",
+"  Pnt} def\n",
+"/TriDF {stroke [] 0 setdash vpt 1.12 mul sub M\n",
+"  hpt neg vpt 1.62 mul V\n",
+"  hpt 2 mul 0 V\n",
+"  hpt neg vpt -1.62 mul V closepath fill} def\n",
+"/DiaF {stroke [] 0 setdash vpt add M\n",
+"  hpt neg vpt neg V hpt vpt neg V\n",
+"  hpt vpt V hpt neg vpt V closepath fill} def\n",
+"/Pent {stroke [] 0 setdash 2 copy gsave\n",
+"  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat\n",
+"  closepath stroke grestore Pnt} def\n",
+"/PentF {stroke [] 0 setdash gsave\n",
+"  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat\n",
+"  closepath fill grestore} def\n",
+"/Circle {stroke [] 0 setdash 2 copy\n",
+"  hpt 0 360 arc stroke Pnt} def\n",
+"/CircleF {stroke [] 0 setdash hpt 0 360 arc fill} def\n",
+"/C0 {BL [] 0 setdash 2 copy moveto vpt 90 450 arc} bind def\n",
+"/C1 {BL [] 0 setdash 2 copy moveto\n",
+"\t2 copy vpt 0 90 arc closepath fill\n",
+"\tvpt 0 360 arc closepath} bind def\n",
+"/C2 {BL [] 0 setdash 2 copy moveto\n",
+"\t2 copy vpt 90 180 arc closepath fill\n",
+"\tvpt 0 360 arc closepath} bind def\n",
+"/C3 {BL [] 0 setdash 2 copy moveto\n",
+"\t2 copy vpt 0 180 arc closepath fill\n",
+"\tvpt 0 360 arc closepath} bind def\n",
+"/C4 {BL [] 0 setdash 2 copy moveto\n",
+"\t2 copy vpt 180 270 arc closepath fill\n",
+"\tvpt 0 360 arc closepath} bind def\n",
+"/C5 {BL [] 0 setdash 2 copy moveto\n",
+"\t2 copy vpt 0 90 arc\n",
+"\t2 copy moveto\n",
+"\t2 copy vpt 180 270 arc closepath fill\n",
+"\tvpt 0 360 arc} bind def\n",
+"/C6 {BL [] 0 setdash 2 copy moveto\n",
+"\t2 copy vpt 90 270 arc closepath fill\n",
+"\tvpt 0 360 arc closepath} bind def\n",
+"/C7 {BL [] 0 setdash 2 copy moveto\n",
+"\t2 copy vpt 0 270 arc closepath fill\n",
+"\tvpt 0 360 arc closepath} bind def\n",
+"/C8 {BL [] 0 setdash 2 copy moveto\n",
+"\t2 copy vpt 270 360 arc closepath fill\n",
+"\tvpt 0 360 arc closepath} bind def\n",
+"/C9 {BL [] 0 setdash 2 copy moveto\n",
+"\t2 copy vpt 270 450 arc closepath fill\n",
+"\tvpt 0 360 arc closepath} bind def\n",
+"/C10 {BL [] 0 setdash 2 copy 2 copy moveto vpt 270 360 arc closepath fill\n",
+"\t2 copy moveto\n",
+"\t2 copy vpt 90 180 arc closepath fill\n",
+"\tvpt 0 360 arc closepath} bind def\n",
+"/C11 {BL [] 0 setdash 2 copy moveto\n",
+"\t2 copy vpt 0 180 arc closepath fill\n",
+"\t2 copy moveto\n",
+"\t2 copy vpt 270 360 arc closepath fill\n",
+"\tvpt 0 360 arc closepath} bind def\n",
+"/C12 {BL [] 0 setdash 2 copy moveto\n",
+"\t2 copy vpt 180 360 arc closepath fill\n",
+"\tvpt 0 360 arc closepath} bind def\n",
+"/C13 {BL [] 0 setdash 2 copy moveto\n",
+"\t2 copy vpt 0 90 arc closepath fill\n",
+"\t2 copy moveto\n",
+"\t2 copy vpt 180 360 arc closepath fill\n",
+"\tvpt 0 360 arc closepath} bind def\n",
+"/C14 {BL [] 0 setdash 2 copy moveto\n",
+"\t2 copy vpt 90 360 arc closepath fill\n",
+"\tvpt 0 360 arc} bind def\n",
+"/C15 {BL [] 0 setdash 2 copy vpt 0 360 arc closepath fill\n",
+"\tvpt 0 360 arc closepath} bind def\n",
+"/Rec {newpath 4 2 roll moveto 1 index 0 rlineto 0 exch rlineto\n",
+"\tneg 0 rlineto closepath} bind def\n",
+"/Square {dup Rec} bind def\n",
+"/Bsquare {vpt sub exch vpt sub exch vpt2 Square} bind def\n",
+"/S0 {BL [] 0 setdash 2 copy moveto 0 vpt rlineto BL Bsquare} bind def\n",
+"/S1 {BL [] 0 setdash 2 copy vpt Square fill Bsquare} bind def\n",
+"/S2 {BL [] 0 setdash 2 copy exch vpt sub exch vpt Square fill Bsquare} bind def\n",
+"/S3 {BL [] 0 setdash 2 copy exch vpt sub exch vpt2 vpt Rec fill Bsquare} bind def\n",
+"/S4 {BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt Square fill Bsquare} bind def\n",
+"/S5 {BL [] 0 setdash 2 copy 2 copy vpt Square fill\n",
+"\texch vpt sub exch vpt sub vpt Square fill Bsquare} bind def\n",
+"/S6 {BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill Bsquare} bind def\n",
+"/S7 {BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill\n",
+"\t2 copy vpt Square fill Bsquare} bind def\n",
+"/S8 {BL [] 0 setdash 2 copy vpt sub vpt Square fill Bsquare} bind def\n",
+"/S9 {BL [] 0 setdash 2 copy vpt sub vpt vpt2 Rec fill Bsquare} bind def\n",
+"/S10 {BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt Square fill\n",
+"\tBsquare} bind def\n",
+"/S11 {BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt2 vpt Rec fill\n",
+"\tBsquare} bind def\n",
+"/S12 {BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill Bsquare} bind def\n",
+"/S13 {BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill\n",
+"\t2 copy vpt Square fill Bsquare} bind def\n",
+"/S14 {BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill\n",
+"\t2 copy exch vpt sub exch vpt Square fill Bsquare} bind def\n",
+"/S15 {BL [] 0 setdash 2 copy Bsquare fill Bsquare} bind def\n",
+"/D0 {gsave translate 45 rotate 0 0 S0 stroke grestore} bind def\n",
+"/D1 {gsave translate 45 rotate 0 0 S1 stroke grestore} bind def\n",
+"/D2 {gsave translate 45 rotate 0 0 S2 stroke grestore} bind def\n",
+"/D3 {gsave translate 45 rotate 0 0 S3 stroke grestore} bind def\n",
+"/D4 {gsave translate 45 rotate 0 0 S4 stroke grestore} bind def\n",
+"/D5 {gsave translate 45 rotate 0 0 S5 stroke grestore} bind def\n",
+"/D6 {gsave translate 45 rotate 0 0 S6 stroke grestore} bind def\n",
+"/D7 {gsave translate 45 rotate 0 0 S7 stroke grestore} bind def\n",
+"/D8 {gsave translate 45 rotate 0 0 S8 stroke grestore} bind def\n",
+"/D9 {gsave translate 45 rotate 0 0 S9 stroke grestore} bind def\n",
+"/D10 {gsave translate 45 rotate 0 0 S10 stroke grestore} bind def\n",
+"/D11 {gsave translate 45 rotate 0 0 S11 stroke grestore} bind def\n",
+"/D12 {gsave translate 45 rotate 0 0 S12 stroke grestore} bind def\n",
+"/D13 {gsave translate 45 rotate 0 0 S13 stroke grestore} bind def\n",
+"/D14 {gsave translate 45 rotate 0 0 S14 stroke grestore} bind def\n",
+"/D15 {gsave translate 45 rotate 0 0 S15 stroke grestore} bind def\n",
+"/DiaE {stroke [] 0 setdash vpt add M\n",
+"  hpt neg vpt neg V hpt vpt neg V\n",
+"  hpt vpt V hpt neg vpt V closepath stroke} def\n",
+"/BoxE {stroke [] 0 setdash exch hpt sub exch vpt add M\n",
+"  0 vpt2 neg V hpt2 0 V 0 vpt2 V\n",
+"  hpt2 neg 0 V closepath stroke} def\n",
+"/TriUE {stroke [] 0 setdash vpt 1.12 mul add M\n",
+"  hpt neg vpt -1.62 mul V\n",
+"  hpt 2 mul 0 V\n",
+"  hpt neg vpt 1.62 mul V closepath stroke} def\n",
+"/TriDE {stroke [] 0 setdash vpt 1.12 mul sub M\n",
+"  hpt neg vpt 1.62 mul V\n",
+"  hpt 2 mul 0 V\n",
+"  hpt neg vpt -1.62 mul V closepath stroke} def\n",
+"/PentE {stroke [] 0 setdash gsave\n",
+"  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat\n",
+"  closepath stroke grestore} def\n",
+"/CircE {stroke [] 0 setdash \n",
+"  hpt 0 360 arc stroke} def\n",
+"/Opaque {gsave closepath 1 setgray fill grestore 0 setgray closepath} def\n",
+"/DiaW {stroke [] 0 setdash vpt add M\n",
+"  hpt neg vpt neg V hpt vpt neg V\n",
+"  hpt vpt V hpt neg vpt V Opaque stroke} def\n",
+"/BoxW {stroke [] 0 setdash exch hpt sub exch vpt add M\n",
+"  0 vpt2 neg V hpt2 0 V 0 vpt2 V\n",
+"  hpt2 neg 0 V Opaque stroke} def\n",
+"/TriUW {stroke [] 0 setdash vpt 1.12 mul add M\n",
+"  hpt neg vpt -1.62 mul V\n",
+"  hpt 2 mul 0 V\n",
+"  hpt neg vpt 1.62 mul V Opaque stroke} def\n",
+"/TriDW {stroke [] 0 setdash vpt 1.12 mul sub M\n",
+"  hpt neg vpt 1.62 mul V\n",
+"  hpt 2 mul 0 V\n",
+"  hpt neg vpt -1.62 mul V Opaque stroke} def\n",
+"/PentW {stroke [] 0 setdash gsave\n",
+"  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat\n",
+"  Opaque stroke grestore} def\n",
+"/CircW {stroke [] 0 setdash \n",
+"  hpt 0 360 arc Opaque stroke} def\n",
+"/BoxFill {gsave Rec 1 setgray fill grestore} def\n",
+"/Density {\n",
+"  /Fillden exch def\n",
+"  currentrgbcolor\n",
+"  /ColB exch def /ColG exch def /ColR exch def\n",
+"  /ColR ColR Fillden mul Fillden sub 1 add def\n",
+"  /ColG ColG Fillden mul Fillden sub 1 add def\n",
+"  /ColB ColB Fillden mul Fillden sub 1 add def\n",
+"  ColR ColG ColB setrgbcolor} def\n",
+"/BoxColFill {gsave Rec PolyFill} def\n",
+"/PolyFill {gsave Density fill grestore grestore} def\n",
+"/h {rlineto rlineto rlineto gsave closepath fill grestore} bind def\n",
+"%\n",
+"% PostScript Level 1 Pattern Fill routine for rectangles\n",
+"% Usage: x y w h s a XX PatternFill\n",
+"%\tx,y = lower left corner of box to be filled\n",
+"%\tw,h = width and height of box\n",
+"%\t  a = angle in degrees between lines and x-axis\n",
+"%\t XX = 0/1 for no/yes cross-hatch\n",
+"%\n",
+"/PatternFill {gsave /PFa [ 9 2 roll ] def\n",
+"  PFa 0 get PFa 2 get 2 div add PFa 1 get PFa 3 get 2 div add translate\n",
+"  PFa 2 get -2 div PFa 3 get -2 div PFa 2 get PFa 3 get Rec\n",
+"  gsave 1 setgray fill grestore clip\n",
+"  currentlinewidth 0.5 mul setlinewidth\n",
+"  /PFs PFa 2 get dup mul PFa 3 get dup mul add sqrt def\n",
+"  0 0 M PFa 5 get rotate PFs -2 div dup translate\n",
+"  0 1 PFs PFa 4 get div 1 add floor cvi\n",
+"\t{PFa 4 get mul 0 M 0 PFs V} for\n",
+"  0 PFa 6 get ne {\n",
+"\t0 1 PFs PFa 4 get div 1 add floor cvi\n",
+"\t{PFa 4 get mul 0 2 1 roll M PFs 0 V} for\n",
+" } if\n",
+"  stroke grestore} def\n",
+"%\n",
+"/languagelevel where\n",
+" {pop languagelevel} {1} ifelse\n",
+" 2 lt\n",
+"\t{/InterpretLevel1 true def}\n",
+"\t{/InterpretLevel1 Level1 def}\n",
+" ifelse\n",
+"%\n",
+"% PostScript level 2 pattern fill definitions\n",
+"%\n",
+"/Level2PatternFill {\n",
+"/Tile8x8 {/PaintType 2 /PatternType 1 /TilingType 1 /BBox [0 0 8 8] /XStep 8 /YStep 8}\n",
+"\tbind def\n",
+"/KeepColor {currentrgbcolor [/Pattern /DeviceRGB] setcolorspace} bind def\n",
+"<< Tile8x8\n",
+" /PaintProc {0.5 setlinewidth pop 0 0 M 8 8 L 0 8 M 8 0 L stroke} \n",
+">> matrix makepattern\n",
+"/Pat1 exch def\n",
+"<< Tile8x8\n",
+" /PaintProc {0.5 setlinewidth pop 0 0 M 8 8 L 0 8 M 8 0 L stroke\n",
+"\t0 4 M 4 8 L 8 4 L 4 0 L 0 4 L stroke}\n",
+">> matrix makepattern\n",
+"/Pat2 exch def\n",
+"<< Tile8x8\n",
+" /PaintProc {0.5 setlinewidth pop 0 0 M 0 8 L\n",
+"\t8 8 L 8 0 L 0 0 L fill}\n",
+">> matrix makepattern\n",
+"/Pat3 exch def\n",
+"<< Tile8x8\n",
+" /PaintProc {0.5 setlinewidth pop -4 8 M 8 -4 L\n",
+"\t0 12 M 12 0 L stroke}\n",
+">> matrix makepattern\n",
+"/Pat4 exch def\n",
+"<< Tile8x8\n",
+" /PaintProc {0.5 setlinewidth pop -4 0 M 8 12 L\n",
+"\t0 -4 M 12 8 L stroke}\n",
+">> matrix makepattern\n",
+"/Pat5 exch def\n",
+"<< Tile8x8\n",
+" /PaintProc {0.5 setlinewidth pop -2 8 M 4 -4 L\n",
+"\t0 12 M 8 -4 L 4 12 M 10 0 L stroke}\n",
+">> matrix makepattern\n",
+"/Pat6 exch def\n",
+"<< Tile8x8\n",
+" /PaintProc {0.5 setlinewidth pop -2 0 M 4 12 L\n",
+"\t0 -4 M 8 12 L 4 -4 M 10 8 L stroke}\n",
+">> matrix makepattern\n",
+"/Pat7 exch def\n",
+"<< Tile8x8\n",
+" /PaintProc {0.5 setlinewidth pop 8 -2 M -4 4 L\n",
+"\t12 0 M -4 8 L 12 4 M 0 10 L stroke}\n",
+">> matrix makepattern\n",
+"/Pat8 exch def\n",
+"<< Tile8x8\n",
+" /PaintProc {0.5 setlinewidth pop 0 -2 M 12 4 L\n",
+"\t-4 0 M 12 8 L -4 4 M 8 10 L stroke}\n",
+">> matrix makepattern\n",
+"/Pat9 exch def\n",
+"/Pattern1 {PatternBgnd KeepColor Pat1 setpattern} bind def\n",
+"/Pattern2 {PatternBgnd KeepColor Pat2 setpattern} bind def\n",
+"/Pattern3 {PatternBgnd KeepColor Pat3 setpattern} bind def\n",
+"/Pattern4 {PatternBgnd KeepColor Landscape {Pat5} {Pat4} ifelse setpattern} bind def\n",
+"/Pattern5 {PatternBgnd KeepColor Landscape {Pat4} {Pat5} ifelse setpattern} bind def\n",
+"/Pattern6 {PatternBgnd KeepColor Landscape {Pat9} {Pat6} ifelse setpattern} bind def\n",
+"/Pattern7 {PatternBgnd KeepColor Landscape {Pat8} {Pat7} ifelse setpattern} bind def\n",
+"} def\n",
+"%\n",
+"%\n",
+"%End of PostScript Level 2 code\n",
+"%\n",
+"/PatternBgnd {\n",
+"  TransparentPatterns {} {gsave 1 setgray fill grestore} ifelse\n",
+"} def\n",
+"%\n",
+"% Substitute for Level 2 pattern fill codes with\n",
+"% grayscale if Level 2 support is not selected.\n",
+"%\n",
+"/Level1PatternFill {\n",
+"/Pattern1 {0.250 Density} bind def\n",
+"/Pattern2 {0.500 Density} bind def\n",
+"/Pattern3 {0.750 Density} bind def\n",
+"/Pattern4 {0.125 Density} bind def\n",
+"/Pattern5 {0.375 Density} bind def\n",
+"/Pattern6 {0.625 Density} bind def\n",
+"/Pattern7 {0.875 Density} bind def\n",
+"} def\n",
+"%\n",
+"% Now test for support of Level 2 code\n",
+"%\n",
+"Level1 {Level1PatternFill} {Level2PatternFill} ifelse\n",
+"%\n",
+"/Symbol-Oblique /Symbol findfont [1 0 .167 1 0 0] makefont\n",
+"dup length dict begin {1 index /FID eq {pop pop} {def} ifelse} forall\n",
+"currentdict end definefont pop\n",
+NULL
+};
+
+static const char *prologue_utf_8_ps[] = {
+"%\n",
+"% Base ISO8859-1 character encoding plus support macros for UTF-8 encoding\n",
+"% via the glyphshow operator\n",
+"%\n",
+"/reencodeISO {\n",
+"dup dup findfont dup length dict begin\n",
+"{ 1 index /FID ne { def }{ pop pop } ifelse } forall\n",
+"currentdict /CharStrings known {\n",
+"\tCharStrings /Idieresis known {\n",
+"\t\t/Encoding ISOLatin1Encoding def } if\n",
+"} if\n",
+"currentdict end definefont\n",
+"} def\n",
+"/ISOLatin1Encoding [\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright\n",
+"/parenleft/parenright/asterisk/plus/comma/minus/period/slash\n",
+"/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon\n",
+"/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N\n",
+"/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright\n",
+"/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m\n",
+"/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
+"/.notdef/dotlessi/grave/acute/circumflex/tilde/macron/breve\n",
+"/dotaccent/dieresis/.notdef/ring/cedilla/.notdef/hungarumlaut\n",
+"/ogonek/caron/space/exclamdown/cent/sterling/currency/yen/brokenbar\n",
+"/section/dieresis/copyright/ordfeminine/guillemotleft/logicalnot\n",
+"/hyphen/registered/macron/degree/plusminus/twosuperior/threesuperior\n",
+"/acute/mu/paragraph/periodcentered/cedilla/onesuperior/ordmasculine\n",
+"/guillemotright/onequarter/onehalf/threequarters/questiondown\n",
+"/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/AE/Ccedilla\n",
+"/Egrave/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex\n",
+"/Idieresis/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis\n",
+"/multiply/Oslash/Ugrave/Uacute/Ucircumflex/Udieresis/Yacute\n",
+"/Thorn/germandbls/agrave/aacute/acircumflex/atilde/adieresis\n",
+"/aring/ae/ccedilla/egrave/eacute/ecircumflex/edieresis/igrave\n",
+"/iacute/icircumflex/idieresis/eth/ntilde/ograve/oacute/ocircumflex\n",
+"/otilde/odieresis/divide/oslash/ugrave/uacute/ucircumflex/udieresis\n",
+"/yacute/thorn/ydieresis\n",
+"] def\n",
+"\n",
+"/Gshow { dup type /stringtype eq { show } { glyphshow } ifelse } def\n",
+"\n",
+"/Gsall { {Gshow} forall } def\n",
+"/Gwidth {\n",
+"\tdup currentpoint pop exch\n",
+"\tgsave 6 array currentmatrix nulldevice setmatrix Gsall currentpoint pop grestore sub\n",
+"\t} def\n",
+"/GLshow {currentpoint stroke M 0 vshift R \n",
+"\tBlacktext {gsave 0 setgray Gsall grestore} {Gsall} ifelse} def\n",
+"/GRshow {currentpoint stroke M dup Gwidth vshift R\n",
+"\tBlacktext {gsave 0 setgray Gsall grestore} {Gsall} ifelse} def\n",
+"/GCshow {currentpoint stroke M dup Gwidth 2 div vshift R \n",
+"\tBlacktext {gsave 0 setgray Gsall grestore} {Gsall} ifelse} def\n",
+NULL
+};
+
diff -rupN C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/ps_header.sh.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/ps_header.sh.svn-base
--- C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/ps_header.sh.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/ps_header.sh.svn-base	2012-01-03 17:07:22.766017100 -0800
@@ -0,0 +1,21 @@
+#! /bin/sh
+
+echo "/* This script-generated file contains the PostScript prologues" > output
+echo " * in a form suitable to inclusion in a C source code */" >> output
+echo "" >> output
+
+for i in `ls -1 *.ps | LC_ALL=C sort`; do
+	echo $i > temp
+	name=`sed -e 's/\.ps/_ps/g' -e 's/-/_/g' temp`
+	rm temp
+	echo "static const char *prologue_$name[] = {" >> output
+	sed -e 's/"/\\"/g' -e 's/^/\"/g' -e 's/\t/\\t/g' -e 's/$/\\n\",/g' $i >> output
+	echo "NULL" >> output
+	echo "};" >> output
+	echo "" >> output
+done
+
+cat output
+
+rm output
+
diff -rupN C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/unicode_big.map.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/unicode_big.map.svn-base
--- C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/unicode_big.map.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/unicode_big.map.svn-base	2012-01-03 17:07:23.014661900 -0800
@@ -0,0 +1,863 @@
+=00 U+0000
+=01 U+0001
+=02 U+0002
+=03 U+0003
+=04 U+0004
+=05 U+0005
+=06 U+0006
+=07 U+0007
+=08 U+0008
+=09 U+0009
+=0A U+000A
+=0B U+000B
+=0C U+000C
+=0D U+000D
+=0E U+000E
+=0F U+000F
+=10 U+0010
+=11 U+0011
+=12 U+0012
+=13 U+0013
+=14 U+0014
+=15 U+0015
+=16 U+0016
+=17 U+0017
+=18 U+0018
+=19 U+0019
+=1A U+001A
+=1B U+001B
+=1C U+001C
+=1D U+001D
+=1E U+001E
+=1F U+001F
+!20 U+0020 space
+!21 U+0021 exclam
+!22 U+0022 quotedbl
+!23 U+0023 numbersign
+!24 U+0024 dollar
+!25 U+0025 percent
+!26 U+0026 ampersand
+!27 U+0027 quotesingle
+!28 U+0028 parenleft
+!29 U+0029 parenright
+!2A U+002A asterisk
+!2B U+002B plus
+!2C U+002C comma
+!2D U+002D hyphen
+!2E U+002E period
+!2F U+002F slash
+!30 U+0030 zero
+!31 U+0031 one
+!32 U+0032 two
+!33 U+0033 three
+!34 U+0034 four
+!35 U+0035 five
+!36 U+0036 six
+!37 U+0037 seven
+!38 U+0038 eight
+!39 U+0039 nine
+!3A U+003A colon
+!3B U+003B semicolon
+!3C U+003C less
+!3D U+003D equal
+!3E U+003E greater
+!3F U+003F question
+!40 U+0040 at
+!41 U+0041 A
+!42 U+0042 B
+!43 U+0043 C
+!44 U+0044 D
+!45 U+0045 E
+!46 U+0046 F
+!47 U+0047 G
+!48 U+0048 H
+!49 U+0049 I
+!4A U+004A J
+!4B U+004B K
+!4C U+004C L
+!4D U+004D M
+!4E U+004E N
+!4F U+004F O
+!50 U+0050 P
+!51 U+0051 Q
+!52 U+0052 R
+!53 U+0053 S
+!54 U+0054 T
+!55 U+0055 U
+!56 U+0056 V
+!57 U+0057 W
+!58 U+0058 X
+!59 U+0059 Y
+!5A U+005A Z
+!5B U+005B bracketleft
+!5C U+005C backslash
+!5D U+005D bracketright
+!5E U+005E asciicircum
+!5F U+005F underscore
+!60 U+0060 grave
+!61 U+0061 a
+!62 U+0062 b
+!63 U+0063 c
+!64 U+0064 d
+!65 U+0065 e
+!66 U+0066 f
+!67 U+0067 g
+!68 U+0068 h
+!69 U+0069 i
+!6A U+006A j
+!6B U+006B k
+!6C U+006C l
+!6D U+006D m
+!6E U+006E n
+!6F U+006F o
+!70 U+0070 p
+!71 U+0071 q
+!72 U+0072 r
+!73 U+0073 s
+!74 U+0074 t
+!75 U+0075 u
+!76 U+0076 v
+!77 U+0077 w
+!78 U+0078 x
+!79 U+0079 y
+!7A U+007A z
+!7B U+007B braceleft
+!7C U+007C bar
+!7D U+007D braceright
+!7E U+007E asciitilde
+=A0 U+00A0
+!A1 U+00A1 exclamdown
+!A2 U+00A2 cent
+!A3 U+00A3 sterling
+!A4 U+00A4 currency
+!A5 U+00A5 yen
+!A6 U+00A6 brokenbar
+!A7 U+00A7 section
+!A8 U+00A8 dieresis
+!A9 U+00A9 copyright
+!AA U+00AA ordfeminine
+!AB U+00AB guillemotleft
+!AC U+00AC logicalnot
+=AD U+00AD
+!AE U+00AE registered
+!AF U+00AF macron
+!B0 U+00B0 degree
+!B1 U+00B1 plusminus
+=B2 U+00B2
+=B3 U+00B3
+!B4 U+00B4 acute
+=B5 U+00B5
+!B6 U+00B6 paragraph
+!B7 U+00B7 periodcentered
+!B8 U+00B8 cedilla
+=B9 U+00B9
+!BA U+00BA ordmasculine
+!BB U+00BB guillemotright
+!BC U+00BC onequarter
+!BD U+00BD onehalf
+!BE U+00BE threequarters
+!BF U+00BF questiondown
+!C0 U+00C0 Agrave
+!C1 U+00C1 Aacute
+!C2 U+00C2 Acircumflex
+!C3 U+00C3 Atilde
+!C4 U+00C4 Adieresis
+!C5 U+00C5 Aring
+!C6 U+00C6 AE
+!C7 U+00C7 Ccedilla
+!C8 U+00C8 Egrave
+!C9 U+00C9 Eacute
+!CA U+00CA Ecircumflex
+!CB U+00CB Edieresis
+!CC U+00CC Igrave
+!CD U+00CD Iacute
+!CE U+00CE Icircumflex
+!CF U+00CF Idieresis
+!D0 U+00D0 Eth
+!D1 U+00D1 Ntilde
+!D2 U+00D2 Ograve
+!D3 U+00D3 Oacute
+!D4 U+00D4 Ocircumflex
+!D5 U+00D5 Otilde
+!D6 U+00D6 Odieresis
+!D7 U+00D7 multiply
+!D8 U+00D8 Oslash
+!D9 U+00D9 Ugrave
+!DA U+00DA Uacute
+!DB U+00DB Ucircumflex
+!DC U+00DC Udieresis
+!DD U+00DD Yacute
+!DE U+00DE Thorn
+!DF U+00DF germandbls
+!E0 U+00E0 agrave
+!E1 U+00E1 aacute
+!E2 U+00E2 acircumflex
+!E3 U+00E3 atilde
+!E4 U+00E4 adieresis
+!E5 U+00E5 aring
+!E6 U+00E6 ae
+!E7 U+00E7 ccedilla
+!E8 U+00E8 egrave
+!E9 U+00E9 eacute
+!EA U+00EA ecircumflex
+!EB U+00EB edieresis
+!EC U+00EC igrave
+!ED U+00ED iacute
+!EE U+00EE icircumflex
+!EF U+00EF idieresis
+!F0 U+00F0 eth
+!F1 U+00F1 ntilde
+!F2 U+00F2 ograve
+!F3 U+00F3 oacute
+!F4 U+00F4 ocircumflex
+!F5 U+00F5 otilde
+!F6 U+00F6 odieresis
+!F7 U+00F7 divide
+!F8 U+00F8 oslash
+!F9 U+00F9 ugrave
+!FA U+00FA uacute
+!FB U+00FB ucircumflex
+!FC U+00FC udieresis
+!FD U+00FD yacute
+!FE U+00FE thorn
+!FF U+00FF ydieresis
+!100 U+0100 Amacron
+!101 U+0101 amacron
+!102 U+0102 Abreve
+!103 U+0103 abreve
+!104 U+0104 Aogonek
+!105 U+0105 aogonek
+!106 U+0106 Cacute
+!107 U+0107 cacute
+!108 U+0108 Ccircumflex
+!109 U+0109 ccircumflex
+!10a U+010A Cdotaccent
+!10b U+010B cdotaccent
+!10c U+010C Ccaron
+!10d U+010D ccaron
+!10e U+010E Dcaron
+!10f U+010F dcaron
+!110 U+0110 Dcroat
+!111 U+0111 dcroat
+!112 U+0112 Emacron
+!113 U+0113 emacron
+!114 U+0114 Ebreve
+!115 U+0115 ebreve
+!116 U+0116 Edotaccent
+!117 U+0117 edotaccent
+!118 U+0118 Eogonek
+!119 U+0119 eogonek
+!11a U+011A Ecaron
+!11b U+011B ecaron
+!11c U+011C Gcircumflex
+!11d U+011D gcircumflex
+!11e U+011E Gbreve
+!11f U+011F gbreve
+!120 U+0120 Gdotaccent
+!121 U+0121 gdotaccent
+!122 U+0122 Gcommaaccent
+!123 U+0123 gcommaaccent
+!124 U+0124 Hcircumflex
+!125 U+0125 hcircumflex
+!126 U+0126 Hbar
+!127 U+0127 hbar
+!128 U+0128 Itilde
+!129 U+0129 itilde
+!12a U+012A Imacron
+!12b U+012B imacron
+!12c U+012C Ibreve
+!12d U+012D ibreve
+!12e U+012E Iogonek
+!12f U+012F iogonek
+!130 U+0130 Idotaccent
+!131 U+0131 dotlessi
+!132 U+0132 IJ
+!133 U+0133 ij
+!134 U+0134 Jcircumflex
+!135 U+0135 jcircumflex
+!136 U+0136 Kcommaaccent
+!137 U+0137 kcommaaccent
+!138 U+0138 kgreenlandic
+!139 U+0139 Lacute
+!13a U+013A lacute
+!13b U+013B Lcommaaccent
+!13c U+013C lcommaaccent
+!13d U+013D Lcaron
+!13e U+013E lcaron
+!13f U+013F Ldot
+!140 U+0140 ldot
+!141 U+0141 Lslash
+!142 U+0142 lslash
+!143 U+0143 Nacute
+!144 U+0144 nacute
+!145 U+0145 Ncommaaccent
+!146 U+0146 ncommaaccent
+!147 U+0147 Ncaron
+!148 U+0148 ncaron
+!149 U+0149 napostrophe
+!14a U+014A Eng
+!14b U+014B eng
+!14c U+014C Omacron
+!14d U+014D omacron
+!14e U+014E Obreve
+!14f U+014F obreve
+!150 U+0150 Ohungarumlaut
+!151 U+0151 ohungarumlaut
+!152 U+0152 OE
+!153 U+0153 oe
+!154 U+0154 Racute
+!155 U+0155 racute
+!156 U+0156 Rcommaaccent
+!157 U+0157 rcommaaccent
+!158 U+0158 Rcaron
+!159 U+0159 rcaron
+!15a U+015A Sacute
+!15b U+015B sacute
+!15c U+015C Scircumflex
+!15d U+015D scircumflex
+!15e U+015E Scedilla
+!15f U+015F scedilla
+!160 U+0160 Scaron
+!161 U+0161 scaron
+!162 U+0162 Tcommaaccent
+!163 U+0163 tcommaaccent
+!164 U+0164 Tcaron
+!165 U+0165 tcaron
+!166 U+0166 Tbar
+!167 U+0167 tbar
+!168 U+0168 Utilde
+!169 U+0169 utilde
+!16a U+016A Umacron
+!16b U+016B umacron
+!16c U+016C Ubreve
+!16d U+016D ubreve
+!16e U+016E Uring
+!16f U+016F uring
+!170 U+0170 Uhungarumlaut
+!171 U+0171 uhungarumlaut
+!172 U+0172 Uogonek
+!173 U+0173 uogonek
+!174 U+0174 Wcircumflex
+!175 U+0175 wcircumflex
+!176 U+0176 Ycircumflex
+!177 U+0177 ycircumflex
+!178 U+0178 Ydieresis
+!179 U+0179 Zacute
+!17a U+017A zacute
+!17b U+017B Zdotaccent
+!17c U+017C zdotaccent
+!17d U+017D Zcaron
+!17e U+017E zcaron
+!17f U+017F longs
+!180 U+0192 florin
+!181 U+01A0 Ohorn
+!182 U+01A1 ohorn
+!183 U+01AF Uhorn
+!184 U+01B0 uhorn
+!185 U+01E6 Gcaron
+!186 U+01E7 gcaron
+!187 U+01FA Aringacute
+!188 U+01FB aringacute
+!189 U+01FC AEacute
+!18a U+01FD aeacute
+!18b U+01FE Oslashacute
+!18c U+01FF oslashacute
+!18d  U+0218 uni0218 
+!18e  U+0219 uni0219 
+!18f  U+02BC uni02BC 
+!190  U+02BD uni02BD 
+!191  U+02C6 uni02C6 
+!192  U+02C7 uni02C7 
+!193  U+02D8 uni02D8 
+!194  U+02D9 uni02D9 
+!195  U+02DA uni02DA 
+!196  U+02DB uni02DB 
+!197  U+02DC uni02DC 
+!198  U+02DD uni02DD 
+!199  U+0300 uni0300 
+!19a  U+0301 uni0301 
+!19b  U+0303 uni0303 
+!19c  U+0309 uni0309 
+!19d  U+0323 uni0323 
+!19e  U+0391 uni0391 
+!19f  U+0392 uni0392 
+!1a0  U+0393 uni0393 
+!1a1  U+0394 uni0394 
+!1a2  U+0395 uni0395 
+!1a3  U+0396 uni0396 
+!1a4  U+0397 uni0397 
+!1a5  U+0398 uni0398 
+!1a6  U+0399 uni0399 
+!1a7  U+039A uni039A 
+!1a8  U+039B uni039B 
+!1a9  U+039C uni039C 
+!1aa  U+039D uni039D 
+!1ab  U+039E uni039E 
+!1ac  U+039F uni039F 
+!1ad  U+03A0 uni03A0 
+!1ae  U+03A1 uni03A1 
+!1af  U+03A3 uni03A3 
+!1b0  U+03A4 uni03A4 
+!1b1  U+03A5 uni03A5 
+!1b2  U+03A6 uni03A6 
+!1b3  U+03A7 uni03A7 
+!1b4  U+03A8 uni03A8 
+!1b5  U+03A9 uni03A9 
+!1b6  U+03B1 uni03B1 
+!1b7  U+03B2 uni03B2 
+!1b8  U+03B3 uni03B3 
+!1b9  U+03B4 uni03B4 
+!1ba  U+03B5 uni03B5 
+!1bb  U+03B6 uni03B6 
+!1bc  U+03B7 uni03B7 
+!1bd  U+03B8 uni03B8 
+!1be  U+03B9 uni03B9 
+!1bf  U+03BA uni03BA 
+!1c0  U+03BB uni03BB 
+!1c1  U+03BC uni03BC 
+!1c2  U+03BD uni03BD 
+!1c3  U+03BE uni03BE 
+!1c4  U+03BF uni03BF 
+!1c5  U+03C0 uni03C0 
+!1c6  U+03C1 uni03C1 
+!1c7  U+03C2 uni03C2 
+!1c8  U+03C3 uni03C3 
+!1c9  U+03C4 uni03C4 
+!1ca  U+03C5 uni03C5 
+!1cb  U+03C6 uni03C6 
+!1cc  U+03C7 uni03C7 
+!1cd  U+03C8 uni03C8 
+!1ce  U+03C9 uni03C9 
+!1cf  U+03D0 uni03D0 
+!1d0  U+03D1 uni03D1 
+!1d1  U+03D5 uni03D5 
+!1d2  U+03D6 uni03D6 
+!1d3  U+0401 uni0401 
+!1d4  U+0402 uni0402 
+!1d5  U+0403 uni0403 
+!1d6  U+0404 uni0404 
+!1d7  U+0405 uni0405 
+!1d8  U+0406 uni0406 
+!1d9  U+0407 uni0407 
+!1da  U+0408 uni0408 
+!1db  U+0409 uni0409 
+!1dc  U+040A uni040A 
+!1dd  U+040B uni040B 
+!1de  U+040C uni040C 
+!1df  U+040E uni040E 
+!1e0  U+040F uni040F 
+!1e1  U+0410 uni0410 
+!1e2  U+0411 uni0411 
+!1e3  U+0412 uni0412 
+!1e4  U+0413 uni0413 
+!1e5  U+0414 uni0414 
+!1e6  U+0415 uni0415 
+!1e7  U+0416 uni0416 
+!1e8  U+0417 uni0417 
+!1e9  U+0418 uni0418 
+!1ea  U+0419 uni0419 
+!1eb  U+041A uni041A 
+!1ec  U+041B uni041B 
+!1ed  U+041C uni041C 
+!1ee  U+041D uni041D 
+!1ef  U+041E uni041E 
+!1f0  U+041F uni041F 
+!1f1  U+0420 uni0420 
+!1f2  U+0421 uni0421 
+!1f3  U+0422 uni0422 
+!1f4  U+0423 uni0423 
+!1f5  U+0424 uni0424 
+!1f6  U+0425 uni0425 
+!1f7  U+0426 uni0426 
+!1f8  U+0427 uni0427 
+!1f9  U+0428 uni0428 
+!1fa  U+0429 uni0429 
+!1fb  U+042A uni042A 
+!1fc  U+042B uni042B 
+!1fd  U+042C uni042C 
+!1fe  U+042D uni042D 
+!1ff  U+042E uni042E 
+!200  U+042F uni042F 
+!201  U+0430 uni0430 
+!202  U+0431 uni0431 
+!203  U+0432 uni0432 
+!204  U+0433 uni0433 
+!205  U+0434 uni0434 
+!206  U+0435 uni0435 
+!207  U+0436 uni0436 
+!208  U+0437 uni0437 
+!209  U+0438 uni0438 
+!20a  U+0439 uni0439 
+!20b  U+043A uni043A 
+!20c  U+043B uni043B 
+!20d  U+043C uni043C 
+!20e  U+043D uni043D 
+!20f  U+043E uni043E 
+!210  U+043F uni043F 
+!211  U+0440 uni0440 
+!212  U+0441 uni0441 
+!213  U+0442 uni0442 
+!214  U+0443 uni0443 
+!215  U+0444 uni0444 
+!216  U+0445 uni0445 
+!217  U+0446 uni0446 
+!218  U+0447 uni0447 
+!219  U+0448 uni0448 
+!21a  U+0449 uni0449 
+!21b  U+044A uni044A 
+!21c  U+044B uni044B 
+!21d  U+044C uni044C 
+!21e  U+044D uni044D 
+!21f  U+044E uni044E 
+!220  U+044F uni044F 
+!221  U+0451 uni0451 
+!222  U+0452 uni0452 
+!223  U+0453 uni0453 
+!224  U+0454 uni0454 
+!225  U+0455 uni0455 
+!226  U+0456 uni0456 
+!227  U+0457 uni0457 
+!228  U+0458 uni0458 
+!229  U+0459 uni0459 
+!22a  U+045A uni045A 
+!22b  U+045B uni045B 
+!22c  U+045C uni045C 
+!22d  U+045E uni045E 
+!22e  U+045F uni045F 
+!22f  U+0490 uni0490 
+!230  U+0491 uni0491
+!231  U+05D0 uni05D0 
+!232  U+05D1 uni05D1 
+!233  U+05D2 uni05D2 
+!234  U+05D3 uni05D3 
+!235  U+05D4 uni05D4 
+!236  U+05D5 uni05D5 
+!237  U+05D6 uni05D6 
+!238  U+05D7 uni05D7 
+!239  U+05D8 uni05D8 
+!23a  U+05D9 uni05D9 
+!23b  U+05DA uni05DA 
+!23c  U+05DB uni05DB 
+!23d  U+05DC uni05DC 
+!23e  U+05DD uni05DD 
+!23f  U+05DE uni05DE 
+!240  U+05DF uni05DF 
+!241  U+05E0 uni05E0 
+!242  U+05E1 uni05E1 
+!243  U+05E2 uni05E2 
+!244  U+05E3 uni05E3 
+!245  U+05E4 uni05E4 
+!246  U+05E5 uni05E5 
+!247  U+05E6 uni05E6 
+!248  U+05E7 uni05E7 
+!249  U+05E8 uni05E8 
+!24a  U+05E9 uni05E9 
+!24b  U+05EA uni05EA 
+!24c  U+1E80 uni1E80 	Extended latin
+!24d  U+1E81 uni1E81 	Extended latin
+!24e  U+1E82 uni1E82 	Extended latin
+!24f  U+1E83 uni1E83 	Extended latin
+!250  U+1E84 uni1E84 	Extended latin
+!251  U+1E85 uni1E85 	Extended latin
+!252  U+1EF2 uni1EF2 	Extended latin
+!253  U+1EF3 uni1EF3 	Extended latin
+!254  U+200C uni200C 
+!255  U+200D uni200D 
+!256  U+200E uni200E 
+!257  U+200F uni200F 
+!258  U+2012 uni2012 
+!259  U+2013 uni2013 
+!25a  U+2014 uni2014 
+!25b  U+2015 uni2015 
+!25c  U+2017 uni2017 
+!25d  U+2018 uni2018 
+!25e  U+2019 uni2019 
+!25f  U+201A uni201A 
+!260  U+201B uni201B 
+!261  U+201C uni201C 
+!262  U+201D uni201D 
+!263  U+201E uni201E 
+!264  U+2020 uni2020 
+!265  U+2021 uni2021 
+!266  U+2022 uni2022 
+!267  U+2024 uni2024 
+!268  U+2025 uni2025 
+!269  U+2026 uni2026 
+!26a  U+202C uni202C 
+!26b  U+202D uni202D 
+!26c  U+202E uni202E 
+!26d  U+2032 uni2032 
+!26e  U+2033 uni2033
+!26f  U+2034 uni2034
+!270  U+2035 uni2035
+!271  U+2036 uni2036
+!272  U+2037 uni2037
+!273  U+2039 uni2039 
+!274  U+203A uni203A 
+!275  U+203C uni203C 
+!276  U+2044 uni2044 
+!277  U+20AC uni20AC
+!278  U+2107 uni2107
+!279  U+210B uni210B 
+!27a  U+210E uni210E
+!27b  U+210F uni210F
+!27c  U+2111 uni2111 
+!27d  U+2112 uni2112 
+!27e  U+2113 uni2113 
+!27f  U+2115 uni2115 
+!280  U+2116 uni2116 
+!281  U+2118 uni2118 
+!282  U+2119 uni2119 
+!283  U+211A uni211A 
+!284  U+211B uni211B 
+!285  U+211C uni211C 
+!286  U+211D uni211D 
+!287  U+2122 uni2122
+!288  U+2124 uni2124
+!289  U+2126 uni2126
+!28a  U+2127 uni2127
+!28b  U+2128 uni2128 
+!28c  U+2129 uni2129 
+!28d  U+212B uni212B 
+!28e  U+212C uni212C 
+!28f  U+212E uni212E 
+!290  U+212F uni212F 
+!291  U+2130 uni2130 
+!292  U+2131 uni2131 
+!293  U+2133 uni2133 
+!294  U+2134 uni2134 
+!295  U+2135 uni2135 
+!296  U+2136 uni2136
+!297  U+2137 uni2137
+!298  U+2138 uni2138
+!299  U+2190 uni2190 
+!29a  U+2191 uni2191 
+!29b  U+2192 uni2192 
+!29c  U+2193 uni2193 
+!29d  U+2194 uni2194 
+!29e  U+2195 uni2195 
+!2a1  U+21D0 uni21D0 
+!2a2  U+21D1 uni21D1 
+!2a3  U+21D2 uni21D2 
+!2a4  U+21D3 uni21D3 
+!2a5  U+21D4 uni21D4
+!2a6  U+2200 uni2200 
+!2a7  U+2202 uni2202 
+!2a8  U+2203 uni2203 
+!2a9  U+2204 uni2204 
+!2aa  U+2205 uni2205 
+!2ab  U+2206 uni2206 
+!2ac  U+2207 uni2207 
+!2ad  U+2208 uni2208 
+!2ae  U+2209 uni2209 
+!2af  U+220A uni220A 
+!2b0  U+220B uni220B 
+!2b1  U+220C uni220C 
+!2b2  U+220D uni220D 
+!2b3  U+220E uni220E 
+!2b4  U+220F uni220F 
+!2b5  U+2210 uni2210 
+!2b6  U+2211 uni2211 
+!2b7  U+2212 uni2212 
+!2b8  U+2213 uni2213 
+!2b9  U+2214 uni2214 
+!2ba  U+2215 uni2215 
+!2bb  U+2216 uni2216 
+!2bc  U+2217 uni2217 
+!2bd  U+2218 uni2218 
+!2be  U+2219 uni2219 
+!2bf  U+221A uni221A 
+!2c0  U+221B uni221B 
+!2c1  U+221C uni221C 
+!2c2  U+221D uni221D 
+!2c3  U+221E uni221E 
+!2c4  U+221F uni221F 
+!2c5  U+2220 uni2220 
+!2c6  U+2221 uni2221 
+!2c7  U+2222 uni2222 
+!2c8  U+2223 uni2223 
+!2c9  U+2224 uni2224 
+!2ca  U+2225 uni2225 
+!2cb  U+2226 uni2226 
+!2cc  U+2227 uni2227 
+!2cd  U+2228 uni2228 
+!2ce  U+2229 uni2229 
+!2cf  U+222A uni222A 
+!2d0  U+222B uni222B 
+!2d1  U+222C uni222C 
+!2d2  U+222D uni222D 
+!2d3  U+222E uni222E 
+!2d4  U+222F uni222F 
+!2d5  U+2230 uni2230 
+!2d6  U+2231 uni2231 
+!2d7  U+2232 uni2232 
+!2d8  U+2233 uni2233 
+!2d9  U+2234 uni2234 
+!2da  U+2235 uni2235 
+!2db  U+2236 uni2236 
+!2dc  U+2237 uni2237 
+!2dd  U+2238 uni2238 
+!2de  U+2239 uni2239 
+!2df  U+223A uni223A 
+!2e0  U+223B uni223B 
+!2e1  U+223C uni223C 
+!2e2  U+223D uni223D 
+!2e3  U+223E uni223E 
+!2e4  U+223F uni223F 
+!2e5  U+2240 uni2240 
+!2e6  U+2241 uni2241 
+!2e7  U+2242 uni2242 
+!2e8  U+2243 uni2243 
+!2e9  U+2244 uni2244 
+!2ea  U+2245 uni2245 
+!2eb  U+2246 uni2246 
+!2ec  U+2247 uni2247 
+!2ed  U+2248 uni2248 
+!2ee  U+2249 uni2249 
+!2ef  U+224A uni224A 
+!2f0  U+224B uni224B 
+!2f1  U+224C uni224C 
+!2f2  U+224D uni224D 
+!2f3  U+224E uni224E 
+!2f4  U+224F uni224F 
+!2f5  U+225F uni225F 
+!2f6  U+2260 uni2260 
+!2f7  U+2261 uni2261 
+!2f8  U+2262 uni2262 
+!2f9  U+2263 uni2263 
+!2fa  U+2264 uni2264 
+!2fb  U+2265 uni2265 
+!2fc  U+2266 uni2266 
+!2fd  U+2267 uni2267 
+!2fe  U+2268 uni2268 
+!2ff  U+2269 uni2269 
+!300  U+226A uni226A 
+!301  U+226B uni226B 
+!302  U+226C uni226C 
+!303  U+226D uni226D 
+!304  U+226E uni226E 
+!305  U+226F uni226F 
+!306  U+2270 uni2270 
+!307  U+2271 uni2271 
+!308  U+2272 uni2272 
+!309  U+2273 uni2273 
+!30a  U+2274 uni2274 
+!30b  U+2275 uni2275 
+!30c  U+2276 uni2276 
+!30d  U+2277 uni2277 
+!30e  U+2278 uni2278 
+!30f  U+2279 uni2279 
+!310  U+227A uni227A 
+!311  U+227B uni227B 
+!312  U+227C uni227C 
+!313  U+227D uni227D 
+!314  U+227E uni227E 
+!315  U+227F uni227F 
+!316  U+2280 uni2280 
+!317  U+2281 uni2281 
+!318  U+2282 uni2282 
+!319  U+2283 uni2283 
+!31a  U+2284 uni2284 
+!31b  U+2285 uni2285 
+!31c  U+2286 uni2286 
+!31d  U+2287 uni2287 
+!31e  U+2288 uni2288 
+!31f  U+2289 uni2289 
+!320  U+22C0 uni22C0 
+!321  U+22C1 uni22C1 
+!322  U+22C2 uni22C2 
+!323  U+22C3 uni22C3 
+!324  U+22C4 uni22C4 
+!325  U+22C5 uni22C5 
+!326  U+2302 uni2302 
+!327  U+2310 uni2310 
+!328  U+2320 uni2320 
+!329  U+2321 uni2321 
+!32a  U+2322 uni2322 
+!32b  U+2323 uni2323 
+!32c  U+2329 uni2329 
+!32d  U+232A uni232A
+!32e  U+239B uni239B
+!32f  U+239C uni239C
+!330  U+239D uni239D
+!331  U+239E uni239E
+!332  U+239F uni239F
+!333  U+23A0 uni23A0
+!334  U+23A1 uni23A1
+!335  U+23A2 uni2392
+!336  U+23A3 uni23A3
+!337  U+23A4 uni23A4
+!338  U+23A5 uni23A5
+!339  U+23A6 uni23A6
+!33a  U+23A7 uni23A7
+!33b  U+23A8 uni23A8
+!33c  U+23A9 uni23A9
+!33d  U+23AA uni23AA
+!33e  U+23AB uni23AB
+!33f  U+23AC uni23AC
+!340  U+23AD uni23AD
+!341  U+23AE uni23AE
+!342  U+23AF uni23AF
+!343  U+23B0 uni23B0
+!344  U+23B1 uni23B1
+!345  U+23B2 uni23B2
+!346  U+23B3 uni23B3
+!347  U+23B4 uni23B4
+!348  U+23B5 uni23B5
+!349  U+23B6 uni23B6
+!34a  U+23B7 uni23B7
+!34b  U+23B8 uni23B8
+!34c  U+23B9 uni23B9
+!34d  U+23BA uni23BA
+!34e  U+23BB uni23BB
+!34f  U+23BC uni23BC
+!350  U+23BD uni23BD
+!351  U+23BE uni23BE
+!352  U+23BF uni23BF
+!353  U+23DE uni23DE
+!354  U+23DF uni23DF
+!355  U+23E1 uni23E1
+!356  U+25A0 uni25A0 
+!357  U+25A1 uni25A1 
+!358  U+25AA uni25AA 
+!359  U+25AB uni25AB 
+!35b  U+25B2 uni25B2 
+!35c  U+25B3 uni25B3 
+!35d  U+25BC uni25BC 
+!35e  U+25BD uni25BD 
+!35a  U+25C6 uni25C6 
+!35f  U+25CA uni25CA 
+!360  U+25CB uni25CB 
+!361  U+25CF uni25CF 
+!364  U+25E6 uni25E6
+!362  U+25FB uni25FB 
+!363  U+25FC uni25FC 
+!365  U+2609 uni2609 
+!366  U+2639 uni2639 
+!367  U+263C uni263C 
+!368  U+263D uni263D 
+!369  U+263E uni263E 
+!36a  U+263F uni263F 
+!36b  U+2640 uni2640 
+!36c  U+2641 uni2641 
+!36d  U+2642 uni2642 
+!36e  U+2643 uni2643 
+!36f  U+2644 uni2644 
+!370  U+2645 uni2645
+!371  U+2646 uni2646
+!372  U+2647 uni2647
+!373  U+2648 uni2648
+!374  U+2649 uni2649
+!375  U+264A uni264A
+!376  U+264B uni264B
+!377  U+264C uni264C
+!378  U+264D uni264D
+!379  U+264E uni264E
+!37a  U+264F uni264F
+!37b  U+2650 uni2650
+!37c  U+2651 uni2651
+!37d  U+2652 uni2652
+!37e  U+2653 uni2653
+!37f  U+25C7 uni25C7
+!380  U+2297 uni2297
+!381  U+2299 uni2299
diff -rupN C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/unicode_maps.README.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/unicode_maps.README.svn-base
--- C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/unicode_maps.README.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/unicode_maps.README.svn-base	2012-01-03 17:07:23.224205300 -0800
@@ -0,0 +1,75 @@
+		unicode maps README
+		===================
+
+Each unicode_XXX.map file contains a list of unicode code points that might
+plausibly be used from inside gnuplot.  These are only relevant to the
+PostScript terminal drivers, and only if you want to use UTF-8 encoding.
+
+If you have a TTF unicode font containing the relevant characters, you can
+use the unicode map file to instruct the external program ttf2pt1 to prepare
+an Adobe Type 1 font.
+
+For example:
+
+  ttf2pt1 -p ft -e -L unicode_big.map arialuni.ttf
+
+This will extract character glyphs for these particular code points
+from arialuni.ttf and create a new file arialuni.ps.  You can use this new
+*.pfa font file from gnuplot by saying
+
+  set encoding utf8
+  set term post fontfile 'arialuni.ps' font 'ArialUnicodeMS'
+
+Note that gnuplot can run ttf2pt1 for you on the fly if you
+first define the appropriate command in the environmental variable
+GNUPLOT_TTFTOPFA.   For example:
+
+  setenv GNUPLOT_TTFTOPFA "ttf2pt1 -e -p ft -L unimap.map %s -"
+
+In this case you could say
+
+  set encoding utf8
+  set term post fontfile 'arialuni.ttf' font 'ArialUnicodeMS'
+
+In either case, the converted glyphs will be embedded in your
+gnuplot output file.  There are several caveats:
+
+1) This can make the file quite large.
+
+2) If a glyph isn't in the starting *.ttf font to begin with, nothing
+   you do here will fix that.
+
+3) If gnuplot runs the conversion for you, it will be triggered each
+   time you plot.
+
+Several unicode map files are provided.  They differ in how many
+characters they request, and hence in the size of the resulting font file.
+
+  unicode_small.map  (462 characters)
+  ===================================
+
+- the Latin1 character set
+- the basic Greek alphabet
+- basic math and physical symbols
+- 133 less obscure math symbols from Unicode pages 34 and 35
+
+
+  unicode_big.map  (863 characters)
+  =================================
+
+- the Latin1 character set 
+- extended Latin character sets needed to support other European languages
+- the Cyrillic alphabet, with extensions for various slavic languages
+  (may not be complete - please report omissions)
+- the basic Greek and Hebrew alphabets
+- basic math symbols
+- 176 mathematical symbols, some obscure, from Unicode pages 34 and 35
+- physical and astronomical symbols
+
+The unicode_big map makes a total of about 860 glyphs available to use
+from gnuplot, but only if they exist in the original TTF font file.
+The maximum number that ttf2pt1 can process is 1024.
+This is only a tiny fraction of the total characters indexed by Unicode.
+But if you need more, probably you would do better to use a different
+gnuplot terminal that supports direct use of UTF-8 TTF fonts (pdf, png, svg).
+
diff -rupN C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/unicode_small.map.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/unicode_small.map.svn-base
--- C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/unicode_small.map.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/unicode_small.map.svn-base	2012-01-03 17:07:23.407681100 -0800
@@ -0,0 +1,462 @@
+=00 U+0000
+=01 U+0001
+=02 U+0002
+=03 U+0003
+=04 U+0004
+=05 U+0005
+=06 U+0006
+=07 U+0007
+=08 U+0008
+=09 U+0009
+=0A U+000A
+=0B U+000B
+=0C U+000C
+=0D U+000D
+=0E U+000E
+=0F U+000F
+=10 U+0010
+=11 U+0011
+=12 U+0012
+=13 U+0013
+=14 U+0014
+=15 U+0015
+=16 U+0016
+=17 U+0017
+=18 U+0018
+=19 U+0019
+=1A U+001A
+=1B U+001B
+=1C U+001C
+=1D U+001D
+=1E U+001E
+=1F U+001F
+!20 U+0020 space
+!21 U+0021 exclam
+!22 U+0022 quotedbl
+!23 U+0023 numbersign
+!24 U+0024 dollar
+!25 U+0025 percent
+!26 U+0026 ampersand
+!27 U+0027 quotesingle
+!28 U+0028 parenleft
+!29 U+0029 parenright
+!2A U+002A asterisk
+!2B U+002B plus
+!2C U+002C comma
+!2D U+002D hyphen
+!2E U+002E period
+!2F U+002F slash
+!30 U+0030 zero
+!31 U+0031 one
+!32 U+0032 two
+!33 U+0033 three
+!34 U+0034 four
+!35 U+0035 five
+!36 U+0036 six
+!37 U+0037 seven
+!38 U+0038 eight
+!39 U+0039 nine
+!3A U+003A colon
+!3B U+003B semicolon
+!3C U+003C less
+!3D U+003D equal
+!3E U+003E greater
+!3F U+003F question
+!40 U+0040 at
+!41 U+0041 A
+!42 U+0042 B
+!43 U+0043 C
+!44 U+0044 D
+!45 U+0045 E
+!46 U+0046 F
+!47 U+0047 G
+!48 U+0048 H
+!49 U+0049 I
+!4A U+004A J
+!4B U+004B K
+!4C U+004C L
+!4D U+004D M
+!4E U+004E N
+!4F U+004F O
+!50 U+0050 P
+!51 U+0051 Q
+!52 U+0052 R
+!53 U+0053 S
+!54 U+0054 T
+!55 U+0055 U
+!56 U+0056 V
+!57 U+0057 W
+!58 U+0058 X
+!59 U+0059 Y
+!5A U+005A Z
+!5B U+005B bracketleft
+!5C U+005C backslash
+!5D U+005D bracketright
+!5E U+005E asciicircum
+!5F U+005F underscore
+!60 U+0060 grave
+!61 U+0061 a
+!62 U+0062 b
+!63 U+0063 c
+!64 U+0064 d
+!65 U+0065 e
+!66 U+0066 f
+!67 U+0067 g
+!68 U+0068 h
+!69 U+0069 i
+!6A U+006A j
+!6B U+006B k
+!6C U+006C l
+!6D U+006D m
+!6E U+006E n
+!6F U+006F o
+!70 U+0070 p
+!71 U+0071 q
+!72 U+0072 r
+!73 U+0073 s
+!74 U+0074 t
+!75 U+0075 u
+!76 U+0076 v
+!77 U+0077 w
+!78 U+0078 x
+!79 U+0079 y
+!7A U+007A z
+!7B U+007B braceleft
+!7C U+007C bar
+!7D U+007D braceright
+!7E U+007E asciitilde
+=A0 U+00A0
+!A1 U+00A1 exclamdown
+!A2 U+00A2 cent
+!A3 U+00A3 sterling
+!A4 U+00A4 currency
+!A5 U+00A5 yen
+!A6 U+00A6 brokenbar
+!A7 U+00A7 section
+!A8 U+00A8 dieresis
+!A9 U+00A9 copyright
+!AA U+00AA ordfeminine
+!AB U+00AB guillemotleft
+!AC U+00AC logicalnot
+=AD U+00AD
+!AE U+00AE registered
+!AF U+00AF macron
+!B0 U+00B0 degree
+!B1 U+00B1 plusminus
+=B2 U+00B2
+=B3 U+00B3
+!B4 U+00B4 acute
+=B5 U+00B5
+!B6 U+00B6 paragraph
+!B7 U+00B7 periodcentered
+!B8 U+00B8 cedilla
+=B9 U+00B9
+!BA U+00BA ordmasculine
+!BB U+00BB guillemotright
+!BC U+00BC onequarter
+!BD U+00BD onehalf
+!BE U+00BE threequarters
+!BF U+00BF questiondown
+!C0 U+00C0 Agrave
+!C1 U+00C1 Aacute
+!C2 U+00C2 Acircumflex
+!C3 U+00C3 Atilde
+!C4 U+00C4 Adieresis
+!C5 U+00C5 Aring
+!C6 U+00C6 AE
+!C7 U+00C7 Ccedilla
+!C8 U+00C8 Egrave
+!C9 U+00C9 Eacute
+!CA U+00CA Ecircumflex
+!CB U+00CB Edieresis
+!CC U+00CC Igrave
+!CD U+00CD Iacute
+!CE U+00CE Icircumflex
+!CF U+00CF Idieresis
+!D0 U+00D0 Eth
+!D1 U+00D1 Ntilde
+!D2 U+00D2 Ograve
+!D3 U+00D3 Oacute
+!D4 U+00D4 Ocircumflex
+!D5 U+00D5 Otilde
+!D6 U+00D6 Odieresis
+!D7 U+00D7 multiply
+!D8 U+00D8 Oslash
+!D9 U+00D9 Ugrave
+!DA U+00DA Uacute
+!DB U+00DB Ucircumflex
+!DC U+00DC Udieresis
+!DD U+00DD Yacute
+!DE U+00DE Thorn
+!DF U+00DF germandbls
+!E0 U+00E0 agrave
+!E1 U+00E1 aacute
+!E2 U+00E2 acircumflex
+!E3 U+00E3 atilde
+!E4 U+00E4 adieresis
+!E5 U+00E5 aring
+!E6 U+00E6 ae
+!E7 U+00E7 ccedilla
+!E8 U+00E8 egrave
+!E9 U+00E9 eacute
+!EA U+00EA ecircumflex
+!EB U+00EB edieresis
+!EC U+00EC igrave
+!ED U+00ED iacute
+!EE U+00EE icircumflex
+!EF U+00EF idieresis
+!F0 U+00F0 eth
+!F1 U+00F1 ntilde
+!F2 U+00F2 ograve
+!F3 U+00F3 oacute
+!F4 U+00F4 ocircumflex
+!F5 U+00F5 otilde
+!F6 U+00F6 odieresis
+!F7 U+00F7 divide
+!F8 U+00F8 oslash
+!F9 U+00F9 ugrave
+!FA U+00FA uacute
+!FB U+00FB ucircumflex
+!FC U+00FC udieresis
+!FD U+00FD yacute
+!FE U+00FE thorn
+!FF U+00FF ydieresis
+!19e  U+0391 uni0391 
+!19f  U+0392 uni0392 
+!1a0  U+0393 uni0393 
+!1a1  U+0394 uni0394 
+!1a2  U+0395 uni0395 
+!1a3  U+0396 uni0396 
+!1a4  U+0397 uni0397 
+!1a5  U+0398 uni0398 
+!1a6  U+0399 uni0399 
+!1a7  U+039A uni039A 
+!1a8  U+039B uni039B 
+!1a9  U+039C uni039C 
+!1aa  U+039D uni039D 
+!1ab  U+039E uni039E 
+!1ac  U+039F uni039F 
+!1ad  U+03A0 uni03A0 
+!1ae  U+03A1 uni03A1 
+!1af  U+03A3 uni03A3 
+!1b0  U+03A4 uni03A4 
+!1b1  U+03A5 uni03A5 
+!1b2  U+03A6 uni03A6 
+!1b3  U+03A7 uni03A7 
+!1b4  U+03A8 uni03A8 
+!1b5  U+03A9 uni03A9 
+!1b6  U+03B1 uni03B1 
+!1b7  U+03B2 uni03B2 
+!1b8  U+03B3 uni03B3 
+!1b9  U+03B4 uni03B4 
+!1ba  U+03B5 uni03B5 
+!1bb  U+03B6 uni03B6 
+!1bc  U+03B7 uni03B7 
+!1bd  U+03B8 uni03B8 
+!1be  U+03B9 uni03B9 
+!1bf  U+03BA uni03BA 
+!1c0  U+03BB uni03BB 
+!1c1  U+03BC uni03BC 
+!1c2  U+03BD uni03BD 
+!1c3  U+03BE uni03BE 
+!1c4  U+03BF uni03BF 
+!1c5  U+03C0 uni03C0 
+!1c6  U+03C1 uni03C1 
+!1c7  U+03C2 uni03C2 
+!1c8  U+03C3 uni03C3 
+!1c9  U+03C4 uni03C4 
+!1ca  U+03C5 uni03C5 
+!1cb  U+03C6 uni03C6 
+!1cc  U+03C7 uni03C7 
+!1cd  U+03C8 uni03C8 
+!1ce  U+03C9 uni03C9 
+!1cf  U+03D0 uni03D0 
+!1d0  U+03D1 uni03D1 
+!1d1  U+03D5 uni03D5 
+!1d2  U+03D6 uni03D6 
+!25b  U+2016 uni2016 
+!26d  U+2032 uni2032 
+!26e  U+2033 uni2033
+!26f  U+2034 uni2034
+!270  U+2035 uni2035
+!271  U+2036 uni2036
+!272  U+2037 uni2037
+!273  U+2039 uni2039 
+!274  U+203A uni203A 
+!275  U+203C uni203C 
+!276  U+2044 uni2044 
+!277  U+20AC uni20AC
+!278  U+2107 uni2107
+!279  U+210B uni210B 
+!27a  U+210E uni210E
+!27b  U+210F uni210F
+!27e  U+2113 uni2113 
+!284  U+211B uni211B 
+!289  U+2126 uni2126
+!28a  U+2127 uni2127
+!28d  U+212B uni212B 
+!295  U+2135 uni2135 
+!296  U+2136 uni2136
+!297  U+2137 uni2137
+!298  U+2138 uni2138
+!299  U+2190 uni2190 
+!29a  U+2191 uni2191 
+!29b  U+2192 uni2192 
+!29c  U+2193 uni2193 
+!29d  U+2194 uni2194 
+!29e  U+2195 uni2195 
+!2a1  U+21D0 uni21D0 
+!2a2  U+21D1 uni21D1 
+!2a3  U+21D2 uni21D2 
+!2a4  U+21D3 uni21D3 
+!2a5  U+21D4 uni21D4
+!2a6  U+2200 uni2200 
+!2a7  U+2202 uni2202 
+!2a8  U+2203 uni2203 
+!2aa  U+2205 uni2205 
+!2ab  U+2206 uni2206 
+!2ac  U+2207 uni2207 
+!2ad  U+2208 uni2208 
+!2ae  U+2209 uni2209 
+!2af  U+220A uni220A 
+!2b0  U+220B uni220B 
+!2b1  U+220C uni220C 
+!2b2  U+220D uni220D 
+!2b4  U+220F uni220F 
+!2b6  U+2211 uni2211 
+!2b7  U+2212 uni2212 
+!2b8  U+2213 uni2213 
+!2ba  U+2215 uni2215 
+!2bb  U+2216 uni2216 
+!2bc  U+2217 uni2217 
+!2bd  U+2218 uni2218 
+!2be  U+2219 uni2219 
+!2bf  U+221A uni221A 
+!2c0  U+221B uni221B 
+!2c1  U+221C uni221C 
+!2c2  U+221D uni221D 
+!2c3  U+221E uni221E 
+!2c4  U+221F uni221F 
+!2c8  U+2223 uni2223 
+!2ca  U+2225 uni2225 
+!2cc  U+2227 uni2227 
+!2cd  U+2228 uni2228 
+!2ce  U+2229 uni2229 
+!2cf  U+222A uni222A 
+!2d0  U+222B uni222B 
+!2d1  U+222C uni222C 
+!2d2  U+222D uni222D 
+!2d3  U+222E uni222E 
+!2d9  U+2234 uni2234 
+!2da  U+2235 uni2235 
+!2db  U+2236 uni2236 
+!2dc  U+2237 uni2237 
+!2e1  U+223C uni223C 
+!2e2  U+223D uni223D 
+!2e3  U+223E uni223E 
+!2e4  U+223F uni223F 
+!2e6  U+2241 uni2241 
+!2e7  U+2242 uni2242 
+!2e8  U+2243 uni2243 
+!2e9  U+2244 uni2244 
+!2ea  U+2245 uni2245 
+!2eb  U+2246 uni2246 
+!2ec  U+2247 uni2247 
+!2ed  U+2248 uni2248 
+!2ee  U+2249 uni2249 
+!2f4  U+224F uni224F 
+!2f5  U+225F uni225F 
+!2f6  U+2260 uni2260 
+!2f7  U+2261 uni2261 
+!2fa  U+2264 uni2264 
+!2fb  U+2265 uni2265 
+!2fc  U+2266 uni2266 
+!2fd  U+2267 uni2267 
+!300  U+226A uni226A 
+!301  U+226B uni226B 
+!302  U+226C uni226C 
+!303  U+226D uni226D 
+!304  U+226E uni226E 
+!305  U+226F uni226F 
+!306  U+2270 uni2270 
+!307  U+2271 uni2271 
+!308  U+2272 uni2272 
+!309  U+2273 uni2273 
+!30a  U+2274 uni2274 
+!30b  U+2275 uni2275 
+!310  U+227A uni227A 
+!311  U+227B uni227B 
+!312  U+227C uni227C 
+!313  U+227D uni227D 
+!314  U+227E uni227E 
+!315  U+227F uni227F 
+!316  U+2280 uni2280 
+!317  U+2281 uni2281 
+!318  U+2282 uni2282 
+!319  U+2283 uni2283 
+!31a  U+2284 uni2284 
+!31b  U+2285 uni2285 
+!31c  U+2286 uni2286 
+!31d  U+2287 uni2287 
+!31e  U+2288 uni2288 
+!31f  U+2289 uni2289 
+!389  U+2297 uni2297
+!38b  U+2299 uni2299
+!320  U+22C0 uni22C0 
+!321  U+22C1 uni22C1 
+!322  U+22C2 uni22C2 
+!323  U+22C3 uni22C3 
+!327  U+2310 uni2310 
+!328  U+2320 uni2320 
+!329  U+2321 uni2321 
+!32a  U+2322 uni2322 
+!32b  U+2323 uni2323 
+!32c  U+2329 uni2329 
+!32d  U+232A uni232A
+!32e  U+239B uni239B
+!32f  U+239C uni239C
+!330  U+239D uni239D
+!331  U+239E uni239E
+!332  U+239F uni239F
+!333  U+23A0 uni23A0
+!334  U+23A1 uni23A1
+!335  U+23A2 uni2392
+!336  U+23A3 uni23A3
+!337  U+23A4 uni23A4
+!338  U+23A5 uni23A5
+!339  U+23A6 uni23A6
+!33a  U+23A7 uni23A7
+!33b  U+23A8 uni23A8
+!33c  U+23A9 uni23A9
+!33d  U+23AA uni23AA
+!33e  U+23AB uni23AB
+!33f  U+23AC uni23AC
+!340  U+23AD uni23AD
+!341  U+23AE uni23AE
+!342  U+23AF uni23AF
+!343  U+23B0 uni23B0
+!344  U+23B1 uni23B1
+!345  U+23B2 uni23B2
+!346  U+23B3 uni23B3
+!347  U+23B4 uni23B4
+!348  U+23B5 uni23B5
+!349  U+23B6 uni23B6
+!34a  U+23B7 uni23B7
+!34b  U+23B8 uni23B8
+!34c  U+23B9 uni23B9
+!356  U+25A0 uni25A0 
+!357  U+25A1 uni25A1 
+!358  U+25AA uni25AA 
+!359  U+25AB uni25AB 
+!35b  U+25B2 uni25B2 
+!35c  U+25B3 uni25B3 
+!35d  U+25BC uni25BC 
+!35e  U+25BD uni25BD 
+!35a  U+25C6 uni25C6 
+!35f  U+25CA uni25CA 
+!360  U+25CB uni25CB 
+!361  U+25CF uni25CF 
+!364  U+25E6 uni25E6
+!362  U+25FB uni25FB 
+!363  U+25FC uni25FC 
+!365  U+2609 uni2609 
diff -rupN C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/utf-8.ps.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/utf-8.ps.svn-base
--- C:\gnuplot-4.4.0\term/PostScript/.svn/text-base/utf-8.ps.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/PostScript/.svn/text-base/utf-8.ps.svn-base	2012-01-03 17:07:23.585141300 -0800
@@ -0,0 +1,58 @@
+%
+% Base ISO8859-1 character encoding plus support macros for UTF-8 encoding
+% via the glyphshow operator
+%
+/reencodeISO {
+dup dup findfont dup length dict begin
+{ 1 index /FID ne { def }{ pop pop } ifelse } forall
+currentdict /CharStrings known {
+	CharStrings /Idieresis known {
+		/Encoding ISOLatin1Encoding def } if
+} if
+currentdict end definefont
+} def
+/ISOLatin1Encoding [
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright
+/parenleft/parenright/asterisk/plus/comma/minus/period/slash
+/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon
+/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N
+/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright
+/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m
+/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
+/.notdef/dotlessi/grave/acute/circumflex/tilde/macron/breve
+/dotaccent/dieresis/.notdef/ring/cedilla/.notdef/hungarumlaut
+/ogonek/caron/space/exclamdown/cent/sterling/currency/yen/brokenbar
+/section/dieresis/copyright/ordfeminine/guillemotleft/logicalnot
+/hyphen/registered/macron/degree/plusminus/twosuperior/threesuperior
+/acute/mu/paragraph/periodcentered/cedilla/onesuperior/ordmasculine
+/guillemotright/onequarter/onehalf/threequarters/questiondown
+/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/AE/Ccedilla
+/Egrave/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex
+/Idieresis/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis
+/multiply/Oslash/Ugrave/Uacute/Ucircumflex/Udieresis/Yacute
+/Thorn/germandbls/agrave/aacute/acircumflex/atilde/adieresis
+/aring/ae/ccedilla/egrave/eacute/ecircumflex/edieresis/igrave
+/iacute/icircumflex/idieresis/eth/ntilde/ograve/oacute/ocircumflex
+/otilde/odieresis/divide/oslash/ugrave/uacute/ucircumflex/udieresis
+/yacute/thorn/ydieresis
+] def
+
+/Gshow { dup type /stringtype eq { show } { glyphshow } ifelse } def
+
+/Gsall { {Gshow} forall } def
+/Gwidth {
+	dup currentpoint pop exch
+	gsave 6 array currentmatrix nulldevice setmatrix Gsall currentpoint pop grestore sub
+	} def
+/GLshow {currentpoint stroke M 0 vshift R 
+	Blacktext {gsave 0 setgray Gsall grestore} {Gsall} ifelse} def
+/GRshow {currentpoint stroke M dup Gwidth vshift R
+	Blacktext {gsave 0 setgray Gsall grestore} {Gsall} ifelse} def
+/GCshow {currentpoint stroke M dup Gwidth 2 div vshift R 
+	Blacktext {gsave 0 setgray Gsall grestore} {Gsall} ifelse} def
diff -rupN C:\gnuplot-4.4.0\term/android.trm C:\Users\champioc\workspace\AddiPlot\jni\term/android.trm
--- C:\gnuplot-4.4.0\term/android.trm	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/android.trm	2012-05-23 09:00:27.951331400 -0700
@@ -0,0 +1,261 @@
+/* Hello, Emacs, this is -*-C-*-
+ * $Id: android.trm,v 1.15 2006/07/21 02:35:48 sfeam Exp $
+ *
+ */
+
+/* GNUPLOT - android.trm */
+
+/*[
+ * Copyright 1990 - 1993, 1998, 2004
+ *
+ * Permission to use, copy, and distribute this software and its
+ * documentation for any purpose with or without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.
+ *
+ * Permission to modify the software is granted, but not the right to
+ * distribute the complete modified source code.  Modifications are to
+ * be distributed as patches to the released version.  Permission to
+ * distribute binaries produced by compiling modified sources is granted,
+ * provided you
+ *   1. distribute the corresponding source modifications from the
+ *    released version in the form of a patch file along with the binaries,
+ *   2. add special version identification to distinguish your version
+ *    in addition to the base release version number,
+ *   3. provide your name and address as the primary contact for the
+ *    support of your modified version, and
+ *   4. retain our contact information in regard to use of the base
+ *    software.
+ * Permission to distribute the released version of the source code along
+ * with corresponding source modifications in the form of a patch file is
+ * granted with same provisions 2 through 4 for binary distributions.
+ *
+ * This software is provided "as is" without express or implied warranty
+ * to the extent permitted by applicable law.
+]*/
+
+/*
+ * This file is included by ../term.c.
+ *
+ * This terminal driver supports:
+ *  ANDROID devices
+ *
+ * AUTHORS
+ *  Corbin Champion
+ *
+ * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
+ *
+ */
+
+#include "driver.h"
+
+#ifdef TERM_ANDROID
+android_term(android)
+#endif
+
+#ifdef TERM_PROTO
+TERM_PUBLIC void ANDROID_options __PROTO((void));
+TERM_PUBLIC void ANDROID_init __PROTO((void));
+TERM_PUBLIC void ANDROID_reset __PROTO((void));
+TERM_PUBLIC void ANDROID_text __PROTO((void));
+TERM_PUBLIC void ANDROID_graphics __PROTO((void));
+TERM_PUBLIC void ANDROID_move __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void ANDROID_vector __PROTO((unsigned int x, unsigned int y));
+TERM_PUBLIC void ANDROID_linetype __PROTO((int linetype));
+TERM_PUBLIC void ANDROID_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
+TERM_PUBLIC int ANDROID_text_angle __PROTO((int ang));
+
+#define ANDROIDDEFAULTXMAX	480
+#define ANDROIDDEFAULTYMAX	480
+
+#define ANDROIDDEFAULTVCHAR	18
+#define ANDROIDDEFAULTHCHAR	11
+#define ANDROIDDEFAULTVTIC	18
+#define ANDROIDDEFAULTHTIC	18
+
+/* is defined in plot.h
+#define TRUE 1
+#define FALSE 0
+*/
+#endif
+
+#ifndef TERM_PROTO_ONLY
+#ifdef TERM_BODY
+
+enum ANDROID_id {
+    ANDROID_SIZE,
+    ANDROID_CHARSIZE,
+    ANDROID_TICSIZE,
+    ANDROID_OTHER
+};
+
+static struct gen_table PNG_opts[] =
+{
+    { "size", ANDROID_SIZE },
+    { "charsize", ANDROID_CHARSIZE },
+    { "ticsize", ANDROID_TICSIZE },
+    { NULL, ANDROID_OTHER }
+};
+
+TERM_PUBLIC void
+ANDROID_init()
+{
+   printf("ANDROIDTERM,init\n");
+}
+
+TERM_PUBLIC void
+ANDROID_graphics()
+{
+   printf("ANDROIDTERM,graphics\n");
+}
+
+TERM_PUBLIC void
+ANDROID_text()
+{
+   printf("ANDROIDTERM,text\n");
+}
+
+TERM_PUBLIC void
+ANDROID_linewidth(int linetype)
+{
+   printf("ANDROIDTERM,linetype,%d\n",linetype);
+}
+
+TERM_PUBLIC void
+ANDROID_linetype(int linetype)
+{
+   printf("ANDROIDTERM,linetype,%d\n",linetype);
+}
+
+TERM_PUBLIC void
+ANDROID_move(unsigned int x, unsigned int y)
+{
+   printf("ANDROIDTERM,move,%d,%d\n", x, y);
+}
+
+TERM_PUBLIC void
+ANDROID_vector(unsigned int x, unsigned int y)
+{
+   printf("ANDROIDTERM,vector,%d,%d\n", x, y);
+}
+
+TERM_PUBLIC void
+ANDROID_put_text(unsigned int x, unsigned int y, const char *str)
+{
+   printf("ANDROIDTERM,put_text,%d,%d,%s\n",x,y,str);
+}
+
+TERM_PUBLIC int 
+ANDROID_text_angle(int ang)
+{
+   printf("ANDROIDTERM,text_angle,%d\n",ang);
+}
+
+TERM_PUBLIC int
+ANDROID_justify_text(enum JUSTIFY mode)
+{
+    switch (mode) {
+    case LEFT:
+	printf("ANDROIDTERM,justify_text,%s\n","LEFT");
+	break;
+    case CENTRE:
+	printf("ANDROIDTERM,justify_text,%s\n","CENTRE");
+	break;
+    case RIGHT:
+	printf("ANDROIDTERM,justify_text,%s\n","RIGHT");
+	break;
+	/* shouldn't happen */
+    default:
+	printf("ANDROIDTERM,justify_text,%s\n","LEFT");
+	return (FALSE);
+	break;
+    }
+    return (TRUE);
+}
+
+TERM_PUBLIC void
+ANDROID_reset()
+{
+   printf("ANDROIDTERM,reset\n");
+}
+
+static struct gen_table ANDROID_opts[] =
+{
+    { "size", ANDROID_SIZE },
+    { "charsize", ANDROID_CHARSIZE },
+    { "ticsize", ANDROID_TICSIZE },
+    { NULL, ANDROID_OTHER }
+};
+
+TERM_PUBLIC void
+ANDROID_options()
+{
+   while (!END_OF_COMMAND) {
+      switch(lookup_table(&ANDROID_opts[0],c_token)) {
+         case ANDROID_SIZE:
+            c_token++;
+            if (!END_OF_COMMAND) {
+               term->xmax = real_expression();
+               if (equals(c_token, ",")) {
+		       c_token++;
+		       term->ymax = real_expression();
+               }
+            }
+            break;
+         case ANDROID_CHARSIZE:
+            c_token++;
+            if (!END_OF_COMMAND) {
+               term->h_char = real_expression();
+               if (equals(c_token, ",")) {
+		       c_token++;
+		       term->v_char = real_expression();
+               }
+            }
+            break;
+         case ANDROID_TICSIZE:
+            c_token++;
+            if (!END_OF_COMMAND) {
+               term->h_tic = real_expression();
+               if (equals(c_token, ",")) {
+		       c_token++;
+		       term->v_tic = real_expression();
+               }
+            }
+            break;
+      }
+   }
+}
+
+#endif
+
+#ifdef TERM_TABLE
+TERM_TABLE_START(android_driver)
+    "android", "ANDROID canvas",
+    ANDROIDDEFAULTXMAX, ANDROIDDEFAULTYMAX, ANDROIDDEFAULTVCHAR, ANDROIDDEFAULTHCHAR,
+    ANDROIDDEFAULTVTIC, ANDROIDDEFAULTHTIC, ANDROID_options, ANDROID_init, ANDROID_reset,
+    ANDROID_text, null_scale, ANDROID_graphics, ANDROID_move, ANDROID_vector,
+    ANDROID_linetype, ANDROID_put_text, null_text_angle,
+    ANDROID_justify_text, line_and_point, do_arrow, set_font_null
+TERM_TABLE_END(android_driver)
+
+#undef LAST_TERM
+#define LAST_TERM android_driver
+#endif
+#endif /* TERM_PROTO_ONLY */
+
+#ifdef TERM_HELP
+START_HELP(android)
+"1 android",
+"?commands set terminal android",
+"?set terminal android",
+"?set term android",
+"?terminal android",
+"?term android",
+"?android",
+" The `android` terminal device generates output into an Android canvas through some JNI.",
+"",
+" Syntax:",
+"       set terminal android"
+END_HELP(android)
+#endif
diff -rupN C:\gnuplot-4.4.0\term/js/.svn/all-wcprops C:\Users\champioc\workspace\AddiPlot\jni\term/js/.svn/all-wcprops
--- C:\gnuplot-4.4.0\term/js/.svn/all-wcprops	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/js/.svn/all-wcprops	2012-01-03 17:08:15.151867100 -0800
@@ -0,0 +1,71 @@
+K 25
+svn:wc:ra_dav:version-url
+V 34
+/svn/!svn/ver/39/trunk/jni/term/js
+END
+grid.png
+K 25
+svn:wc:ra_dav:version-url
+V 43
+/svn/!svn/ver/39/trunk/jni/term/js/grid.png
+END
+nextzoom.png
+K 25
+svn:wc:ra_dav:version-url
+V 47
+/svn/!svn/ver/39/trunk/jni/term/js/nextzoom.png
+END
+canvastext.js
+K 25
+svn:wc:ra_dav:version-url
+V 48
+/svn/!svn/ver/39/trunk/jni/term/js/canvastext.js
+END
+gnuplot_mouse.js
+K 25
+svn:wc:ra_dav:version-url
+V 51
+/svn/!svn/ver/39/trunk/jni/term/js/gnuplot_mouse.js
+END
+previouszoom.png
+K 25
+svn:wc:ra_dav:version-url
+V 51
+/svn/!svn/ver/39/trunk/jni/term/js/previouszoom.png
+END
+canvasmath.js
+K 25
+svn:wc:ra_dav:version-url
+V 48
+/svn/!svn/ver/39/trunk/jni/term/js/canvasmath.js
+END
+gnuplot_mouse.css
+K 25
+svn:wc:ra_dav:version-url
+V 52
+/svn/!svn/ver/39/trunk/jni/term/js/gnuplot_mouse.css
+END
+textzoom.png
+K 25
+svn:wc:ra_dav:version-url
+V 47
+/svn/!svn/ver/39/trunk/jni/term/js/textzoom.png
+END
+gnuplot_common.js
+K 25
+svn:wc:ra_dav:version-url
+V 52
+/svn/!svn/ver/39/trunk/jni/term/js/gnuplot_common.js
+END
+help.png
+K 25
+svn:wc:ra_dav:version-url
+V 43
+/svn/!svn/ver/39/trunk/jni/term/js/help.png
+END
+README
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/39/trunk/jni/term/js/README
+END
diff -rupN C:\gnuplot-4.4.0\term/js/.svn/entries C:\Users\champioc\workspace\AddiPlot\jni\term/js/.svn/entries
--- C:\gnuplot-4.4.0\term/js/.svn/entries	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/js/.svn/entries	2012-01-03 17:08:15.153872300 -0800
@@ -0,0 +1,409 @@
+10
+
+dir
+39
+https://addiplot.googlecode.com/svn/trunk/jni/term/js
+https://addiplot.googlecode.com/svn
+
+
+
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+svn:special svn:externals svn:needs-lock
+
+
+
+
+
+
+
+
+
+
+
+776c9c97-d481-0677-478a-dd5044256a82
+
+
+
+
+
+
+0
+
+README
+file
+
+
+
+
+2012-01-03T23:32:38.131000Z
+235f619bfe955596ae2c6bacf28c25d5
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+4927
+
+canvasmath.js
+file
+
+
+
+
+2012-01-03T23:32:38.123000Z
+fd008ef849059ef4a96e243879510482
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+32746
+
+canvastext.js
+file
+
+
+
+
+2012-01-03T23:32:38.075000Z
+d4ff58b879f0aa6fefc608eeb6a60d42
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+15018
+
+gnuplot_common.js
+file
+
+
+
+
+2012-01-03T23:32:38.145000Z
+f12ffa7b5a6f81db8608e3e7949e373e
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+3437
+
+gnuplot_mouse.css
+file
+
+
+
+
+2012-01-03T23:32:38.154000Z
+cc5d4047e0ed802e52268b801551f858
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+901
+
+gnuplot_mouse.js
+file
+
+
+
+
+2012-01-03T23:32:38.055000Z
+959844710695d48e8cb4f5de0ba74e27
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+11656
+
+grid.png
+file
+
+
+
+
+2012-01-03T23:32:38.161000Z
+fc588c539ec5eaf9aab9049c5f4218d9
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+has-props
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+180
+
+help.png
+file
+
+
+
+
+2012-01-03T23:32:38.062000Z
+d7de7980c2128c705b66f01f62b9d223
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+has-props
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+588
+
+nextzoom.png
+file
+
+
+
+
+2012-01-03T23:32:38.096000Z
+12107d8bfb82558d9912f329749450ce
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+has-props
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+766
+
+previouszoom.png
+file
+
+
+
+
+2012-01-03T23:32:38.081000Z
+647f090e83d3f37a2b59492f169e7399
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+has-props
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+792
+
+textzoom.png
+file
+
+
+
+
+2012-01-03T23:32:38.089000Z
+009fea65a8e17eb22cd6b83e27ca523d
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+has-props
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+556
+
diff -rupN C:\gnuplot-4.4.0\term/js/.svn/prop-base/grid.png.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/js/.svn/prop-base/grid.png.svn-base
--- C:\gnuplot-4.4.0\term/js/.svn/prop-base/grid.png.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/js/.svn/prop-base/grid.png.svn-base	2012-01-03 17:05:57.105000000 -0800
@@ -0,0 +1,5 @@
+K 13
+svn:mime-type
+V 24
+application/octet-stream
+END
diff -rupN C:\gnuplot-4.4.0\term/js/.svn/prop-base/help.png.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/js/.svn/prop-base/help.png.svn-base
--- C:\gnuplot-4.4.0\term/js/.svn/prop-base/help.png.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/js/.svn/prop-base/help.png.svn-base	2012-01-03 17:05:57.107000000 -0800
@@ -0,0 +1,5 @@
+K 13
+svn:mime-type
+V 24
+application/octet-stream
+END
diff -rupN C:\gnuplot-4.4.0\term/js/.svn/prop-base/nextzoom.png.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/js/.svn/prop-base/nextzoom.png.svn-base
--- C:\gnuplot-4.4.0\term/js/.svn/prop-base/nextzoom.png.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/js/.svn/prop-base/nextzoom.png.svn-base	2012-01-03 17:05:57.109000000 -0800
@@ -0,0 +1,5 @@
+K 13
+svn:mime-type
+V 24
+application/octet-stream
+END
diff -rupN C:\gnuplot-4.4.0\term/js/.svn/prop-base/previouszoom.png.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/js/.svn/prop-base/previouszoom.png.svn-base
--- C:\gnuplot-4.4.0\term/js/.svn/prop-base/previouszoom.png.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/js/.svn/prop-base/previouszoom.png.svn-base	2012-01-03 17:05:57.112000000 -0800
@@ -0,0 +1,5 @@
+K 13
+svn:mime-type
+V 24
+application/octet-stream
+END
diff -rupN C:\gnuplot-4.4.0\term/js/.svn/prop-base/textzoom.png.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/js/.svn/prop-base/textzoom.png.svn-base
--- C:\gnuplot-4.4.0\term/js/.svn/prop-base/textzoom.png.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/js/.svn/prop-base/textzoom.png.svn-base	2012-01-03 17:05:57.114000000 -0800
@@ -0,0 +1,5 @@
+K 13
+svn:mime-type
+V 24
+application/octet-stream
+END
diff -rupN C:\gnuplot-4.4.0\term/js/.svn/text-base/README.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/js/.svn/text-base/README.svn-base
--- C:\gnuplot-4.4.0\term/js/.svn/text-base/README.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/js/.svn/text-base/README.svn-base	2012-01-03 17:07:32.975492900 -0800
@@ -0,0 +1,108 @@
+     Notes on using the gnuplot canvas terminal driver to create web pages
+     =====================================================================
+
+
+1) Using UTF-8 characters in your plots
+
+I expect that eventually web browsers will learn to draw text onto the HTML
+canvas element using their native font-handling code.  But until then we
+have to refer to an external character drawing library. 
+
+The gnuplot package includes two versions of a script to draw characters on
+the canvas.  The first one, canvastext.js, was written by Jim Studt. It only
+knows about the 7-bit ascii characters.  The second one, canvasmath.js, is
+an expanded version of Jim Studt's script that I wrote to handle UTF8.
+It contains glyphs for the first two unicode code pages (latin-1), the greek
+alphabet, and select math and physics symbols. You can use this to replace
+canvastext.js if you like, or refer to it explicitly in plots that need
+non-ascii characters.
+
+
+2) Browser dependencies
+
+As of this time (May 2009) the HTML canvas element is supported by the
+latest versions of Opera, Safari, Firefox, and Konqueror.  However, each
+of these has quirks.
+
+For instance, only Firefox makes it easy to click and drag with the middle
+or right mouse buttons;  the other browsers try to pop up various menus instead.
+We try to override this, but it doesn't always work.
+
+Conversely, Opera and Safari make it easy to use hot keys ('e' for refresh,
+'r' to toggle the ruler, etc), but I have not managed to get this to work
+in Firefox.
+
+If you run into problems, please try several browsers before concluding that it
+is a gnuplot problem.  If you figure out a work-around for one of these browser
+quirks, please tell me so that we can try to incorporate into gnuplot output.
+
+
+3) Creating a basic web page with a single mouseable plot
+
+The canvas terminal driver itself will create a basic html document containing
+a mousable plot.  The command options to do this are
+	set term canvas standalone mousing jsdir "http://myserver"
+	set output 'myplot.html'
+This document contains
+	- a reference to style sheet gnuplot_mouse.css
+	- a reference to support script gnuplot_mouse.js
+	- a javascript function named 'gnuplot_canvas'
+	- a canvas element named 'gnuplot_canvas' that will be drawn in by the
+	  javascript function of the same name
+	- an html table containing the readout for mouse coordinates, as well
+	  as clickable icons for additional mousing operations
+The *.css and *.js references point back to whatever source URL you specified
+in the jsdir option to the 'set term' command.  For example:
+<link text="text/css" href="http://myserver/gnuplot_mouse.css" rel="stylesheet">
+In order for viewers to use your plot document, they must be able to access the
+*.css and *.js files via the URL embedded in the document.
+
+
+4) Creating a web page with multiple mouseable plots
+
+In order to embed multiple plots in a single document, you must
+provide your own html framework.  You can use the one created by the canvas
+driver in standalone mode as a starting point, including the references to
+gnuplot_mouse.css and gnuplot_mouse.js.  However, instead of a single
+javascript routine named gnuplot_canvas() that always draws the same plot,
+you must provide a wrapper routine with the same name that connects the
+mousing code to whichever plot is currently active.  Here is an example:
+- create the individual plots as separate javascript files
+	set term canvas name 'plot1'
+	set output 'plot1.js'
+	plot something
+	set term canvas name 'plot2'
+	set output 'plot2.js'
+	plot something_else
+- create your html wrapper, including a script block such as the one below.
+  You must use these specific variable names, as they are referenced by the
+  javascript code produced by the canvas terminal.
+	<script type="text/javascript">
+	var canvas, ctx;
+	var grid_lines = true;
+	var zoomed = false;
+	var active_plot_name = "gnuplot_canvas";
+	var active_plot = dummyplot;
+	function dummyplot() {};
+	function gnuplot_canvas( plot ) { active_plot(); };
+	</script>
+- add one or more mousing output tables.  As a model, you can use either the one
+  in a standalone plot or the file .../demo/html/mousebox.template.
+  The table id and text span ids in the "mousebox" table must match the ones
+  by your individual plots in order for mousing readout to work.
+- each of the individual plots in the document should be explicitly called when
+  the document is loaded.  For example, for each plot there could be a block
+  of html similar to the following:
+	<canvas id="plot1" width="600" height="400" tabindex="0"></canvas>
+	<script src="plot1.js"></script>
+	<script>
+	    if (window.attachEvent) {window.attachEvent('onload', plot1);}
+	    else if (window.addEventListener) {window.addEventListener('load', plot1, false);}
+	</script>
+  Alternatively, the onload attributes could be set in the html <BODY> element
+
+
+
+	- Ethan A Merritt (sfeam@users.sourceforge.net)
+	  May 2009
+	
diff -rupN C:\gnuplot-4.4.0\term/js/.svn/text-base/canvasmath.js.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/js/.svn/text-base/canvasmath.js.svn-base
--- C:\gnuplot-4.4.0\term/js/.svn/text-base/canvasmath.js.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/js/.svn/text-base/canvasmath.js.svn-base	2012-01-03 17:07:33.447717500 -0800
@@ -0,0 +1,384 @@
+/*
+ * $Id: canvasmath.js,v 1.6 2009/03/24 19:03:38 sfeam Exp $
+ */
+// The canvastext.js code was released to the public domain by Jim Studt, 2007.
+// He may keep some sort of up to date copy at http://www.federated.com/~jim/canvastext/
+// Mar 2009 Ethan A Merritt (EAM) Modify code to work in non-ascii environments.
+//	    Add Latin-1, Hershey simplex Greek, and math symbols with unicode indexing.
+//
+var CanvasTextFunctions = { };
+
+CanvasTextFunctions.letters = {
+    ' ': { width: 16, points: [] },
+    '!': { width: 10, points: [[5,21],[5,7],[-1,-1],[5,2],[4,1],[5,0],[6,1],[5,2]] },
+    '"': { width: 16, points: [[4,21],[4,14],[-1,-1],[12,21],[12,14]] },
+    '#': { width: 21, points: [[11,25],[4,-7],[-1,-1],[17,25],[10,-7],[-1,-1],[4,12],[18,12],[-1,-1],[3,6],[17,6]] },
+    '$': { width: 20, points: [[8,25],[8,-4],[-1,-1],[12,25],[12,-4],[-1,-1],[17,18],[15,20],[12,21],[8,21],[5,20],[3,18],[3,16],[4,14],[5,13],[7,12],[13,10],[15,9],[16,8],[17,6],[17,3],[15,1],[12,0],[8,0],[5,1],[3,3]] },
+    '%': { width: 24, points: [[21,21],[3,0],[-1,-1],[8,21],[10,19],[10,17],[9,15],[7,14],[5,14],[3,16],[3,18],[4,20],[6,21],[8,21],[10,20],[13,19],[16,19],[19,20],[21,21],[-1,-1],[17,7],[15,6],[14,4],[14,2],[16,0],[18,0],[20,1],[21,3],[21,5],[19,7],[17,7]] },
+    '&': { width: 26, points: [[23,12],[23,13],[22,14],[21,14],[20,13],[19,11],[17,6],[15,3],[13,1],[11,0],[7,0],[5,1],[4,2],[3,4],[3,6],[4,8],[5,9],[12,13],[13,14],[14,16],[14,18],[13,20],[11,21],[9,20],[8,18],[8,16],[9,13],[11,10],[16,3],[18,1],[20,0],[22,0],[23,1],[23,2]] },
+    '\'': { width: 10, points: [[5,19],[4,20],[5,21],[6,20],[6,18],[5,16],[4,15]] },
+    '(': { width: 14, points: [[11,25],[9,23],[7,20],[5,16],[4,11],[4,7],[5,2],[7,-2],[9,-5],[11,-7]] },
+    ')': { width: 14, points: [[3,25],[5,23],[7,20],[9,16],[10,11],[10,7],[9,2],[7,-2],[5,-5],[3,-7]] },
+    '*': { width: 16, points: [[8,21],[8,9],[-1,-1],[3,18],[13,12],[-1,-1],[13,18],[3,12]] },
+    '+': { width: 20, points: [[10,15],[10,3],[-1,-1],[4,9],[16,9]] },
+    ',': { width: 10, points: [[6,1],[5,0],[4,1],[5,2],[6,1],[6,-1],[5,-3],[4,-4]] },
+    '-': { width: 20, points: [[4,9],[16,9]] },
+    '.': { width: 10, points: [[5,2],[4,1],[5,0],[6,1],[5,2]] },
+    '/': { width: 20, points: [[19,25],[1,-7]] },
+    '0': { width: 20, points: [[9,21],[6,20],[4,17],[3,12],[3,9],[4,4],[6,1],[9,0],[11,0],[14,1],[16,4],[17,9],[17,12],[16,17],[14,20],[11,21],[9,21]] },
+    '1': { width: 20, points: [[6,17],[8,18],[11,21],[11,0]] },
+    '2': { width: 20, points: [[4,16],[4,17],[5,19],[6,20],[8,21],[12,21],[14,20],[15,19],[16,17],[16,15],[15,13],[13,10],[3,0],[17,0]] },
+    '3': { width: 20, points: [[5,21],[16,21],[10,13],[13,13],[15,12],[16,11],[17,8],[17,6],[16,3],[14,1],[11,0],[8,0],[5,1],[4,2],[3,4]] },
+    '4': { width: 20, points: [[13,21],[3,7],[18,7],[-1,-1],[13,21],[13,0]] },
+    '5': { width: 20, points: [[15,21],[5,21],[4,12],[5,13],[8,14],[11,14],[14,13],[16,11],[17,8],[17,6],[16,3],[14,1],[11,0],[8,0],[5,1],[4,2],[3,4]] },
+    '6': { width: 20, points: [[16,18],[15,20],[12,21],[10,21],[7,20],[5,17],[4,12],[4,7],[5,3],[7,1],[10,0],[11,0],[14,1],[16,3],[17,6],[17,7],[16,10],[14,12],[11,13],[10,13],[7,12],[5,10],[4,7]] },
+    '7': { width: 20, points: [[17,21],[7,0],[-1,-1],[3,21],[17,21]] },
+    '8': { width: 20, points: [[8,21],[5,20],[4,18],[4,16],[5,14],[7,13],[11,12],[14,11],[16,9],[17,7],[17,4],[16,2],[15,1],[12,0],[8,0],[5,1],[4,2],[3,4],[3,7],[4,9],[6,11],[9,12],[13,13],[15,14],[16,16],[16,18],[15,20],[12,21],[8,21]] },
+    '9': { width: 20, points: [[16,14],[15,11],[13,9],[10,8],[9,8],[6,9],[4,11],[3,14],[3,15],[4,18],[6,20],[9,21],[10,21],[13,20],[15,18],[16,14],[16,9],[15,4],[13,1],[10,0],[8,0],[5,1],[4,3]] },
+    ':': { width: 10, points: [[5,14],[4,13],[5,12],[6,13],[5,14],[-1,-1],[5,2],[4,1],[5,0],[6,1],[5,2]] },
+    ';': { width: 10, points: [[5,14],[4,13],[5,12],[6,13],[5,14],[-1,-1],[6,1],[5,0],[4,1],[5,2],[6,1],[6,-1],[5,-3],[4,-4]] },
+    '<': { width: 24, points: [[20,18],[4,9],[20,0]] },
+    '=': { width: 24, points: [[3,12],[20,12],[-1,-1],[3,6],[20,6]] },
+    '>': { width: 24, points: [[4,18],[20,9],[4,0]] },
+    '?': { width: 18, points: [[3,16],[3,17],[4,19],[5,20],[7,21],[11,21],[13,20],[14,19],[15,17],[15,15],[14,13],[13,12],[9,10],[9,7],[-1,-1],[9,2],[8,1],[9,0],[10,1],[9,2]] },
+    '@': { width: 27, points: [[18,13],[17,15],[15,16],[12,16],[10,15],[9,14],[8,11],[8,8],[9,6],[11,5],[14,5],[16,6],[17,8],[-1,-1],[12,16],[10,14],[9,11],[9,8],[10,6],[11,5],[-1,-1],[18,16],[17,8],[17,6],[19,5],[21,5],[23,7],[24,10],[24,12],[23,15],[22,17],[20,19],[18,20],[15,21],[12,21],[9,20],[7,19],[5,17],[4,15],[3,12],[3,9],[4,6],[5,4],[7,2],[9,1],[12,0],[15,0],[18,1],[20,2],[21,3],[-1,-1],[19,16],[18,8],[18,6],[19,5]] },
+    'A': { width: 18, points: [[9,21],[1,0],[-1,-1],[9,21],[17,0],[-1,-1],[4,7],[14,7]] },
+    'B': { width: 21, points: [[4,21],[4,0],[-1,-1],[4,21],[13,21],[16,20],[17,19],[18,17],[18,15],[17,13],[16,12],[13,11],[-1,-1],[4,11],[13,11],[16,10],[17,9],[18,7],[18,4],[17,2],[16,1],[13,0],[4,0]] },
+    'C': { width: 21, points: [[18,16],[17,18],[15,20],[13,21],[9,21],[7,20],[5,18],[4,16],[3,13],[3,8],[4,5],[5,3],[7,1],[9,0],[13,0],[15,1],[17,3],[18,5]] },
+    'D': { width: 21, points: [[4,21],[4,0],[-1,-1],[4,21],[11,21],[14,20],[16,18],[17,16],[18,13],[18,8],[17,5],[16,3],[14,1],[11,0],[4,0]] },
+    'E': { width: 19, points: [[4,21],[4,0],[-1,-1],[4,21],[17,21],[-1,-1],[4,11],[12,11],[-1,-1],[4,0],[17,0]] },
+    'F': { width: 18, points: [[4,21],[4,0],[-1,-1],[4,21],[17,21],[-1,-1],[4,11],[12,11]] },
+    'G': { width: 21, points: [[18,16],[17,18],[15,20],[13,21],[9,21],[7,20],[5,18],[4,16],[3,13],[3,8],[4,5],[5,3],[7,1],[9,0],[13,0],[15,1],[17,3],[18,5],[18,8],[-1,-1],[13,8],[18,8]] },
+    'H': { width: 22, points: [[4,21],[4,0],[-1,-1],[18,21],[18,0],[-1,-1],[4,11],[18,11]] },
+    'I': { width: 8, points: [[4,21],[4,0]] },
+    'J': { width: 16, points: [[12,21],[12,5],[11,2],[10,1],[8,0],[6,0],[4,1],[3,2],[2,5],[2,7]] },
+    'K': { width: 21, points: [[4,21],[4,0],[-1,-1],[18,21],[4,7],[-1,-1],[9,12],[18,0]] },
+    'L': { width: 17, points: [[4,21],[4,0],[-1,-1],[4,0],[16,0]] },
+    'M': { width: 24, points: [[4,21],[4,0],[-1,-1],[4,21],[12,0],[-1,-1],[20,21],[12,0],[-1,-1],[20,21],[20,0]] },
+    'N': { width: 22, points: [[4,21],[4,0],[-1,-1],[4,21],[18,0],[-1,-1],[18,21],[18,0]] },
+    'O': { width: 22, points: [[9,21],[7,20],[5,18],[4,16],[3,13],[3,8],[4,5],[5,3],[7,1],[9,0],[13,0],[15,1],[17,3],[18,5],[19,8],[19,13],[18,16],[17,18],[15,20],[13,21],[9,21]] },
+    'P': { width: 21, points: [[4,21],[4,0],[-1,-1],[4,21],[13,21],[16,20],[17,19],[18,17],[18,14],[17,12],[16,11],[13,10],[4,10]] },
+    'Q': { width: 22, points: [[9,21],[7,20],[5,18],[4,16],[3,13],[3,8],[4,5],[5,3],[7,1],[9,0],[13,0],[15,1],[17,3],[18,5],[19,8],[19,13],[18,16],[17,18],[15,20],[13,21],[9,21],[-1,-1],[12,4],[18,-2]] },
+    'R': { width: 21, points: [[4,21],[4,0],[-1,-1],[4,21],[13,21],[16,20],[17,19],[18,17],[18,15],[17,13],[16,12],[13,11],[4,11],[-1,-1],[11,11],[18,0]] },
+    'S': { width: 20, points: [[17,18],[15,20],[12,21],[8,21],[5,20],[3,18],[3,16],[4,14],[5,13],[7,12],[13,10],[15,9],[16,8],[17,6],[17,3],[15,1],[12,0],[8,0],[5,1],[3,3]] },
+    'T': { width: 16, points: [[8,21],[8,0],[-1,-1],[1,21],[15,21]] },
+    'U': { width: 22, points: [[4,21],[4,6],[5,3],[7,1],[10,0],[12,0],[15,1],[17,3],[18,6],[18,21]] },
+    'V': { width: 18, points: [[1,21],[9,0],[-1,-1],[17,21],[9,0]] },
+    'W': { width: 24, points: [[2,21],[7,0],[-1,-1],[12,21],[7,0],[-1,-1],[12,21],[17,0],[-1,-1],[22,21],[17,0]] },
+    'X': { width: 20, points: [[3,21],[17,0],[-1,-1],[17,21],[3,0]] },
+    'Y': { width: 18, points: [[1,21],[9,11],[9,0],[-1,-1],[17,21],[9,11]] },
+    'Z': { width: 20, points: [[17,21],[3,0],[-1,-1],[3,21],[17,21],[-1,-1],[3,0],[17,0]] },
+    '[': { width: 14, points: [[4,25],[4,-7],[-1,-1],[5,25],[5,-7],[-1,-1],[4,25],[11,25],[-1,-1],[4,-7],[11,-7]] },
+    '\\': { width: 14, points: [[0,21],[14,-3]] },
+    ']': { width: 14, points: [[9,25],[9,-7],[-1,-1],[10,25],[10,-7],[-1,-1],[3,25],[10,25],[-1,-1],[3,-7],[10,-7]] },
+    '^': { width: 16, points: [[5,15],[8,19],[11,15],[-1,-1],[2,12],[8,18],[14,12]] },
+    '_': { width: 16, points: [[0,-2],[16,-2]] },
+    '`': { width: 10, points: [[6,21],[5,20],[4,18],[4,16],[5,15],[6,16],[5,17]] },
+    'a': { width: 19, points: [[15,14],[15,0],[-1,-1],[15,11],[13,13],[11,14],[8,14],[6,13],[4,11],[3,8],[3,6],[4,3],[6,1],[8,0],[11,0],[13,1],[15,3]] },
+    'b': { width: 19, points: [[4,21],[4,0],[-1,-1],[4,11],[6,13],[8,14],[11,14],[13,13],[15,11],[16,8],[16,6],[15,3],[13,1],[11,0],[8,0],[6,1],[4,3]] },
+    'c': { width: 18, points: [[15,11],[13,13],[11,14],[8,14],[6,13],[4,11],[3,8],[3,6],[4,3],[6,1],[8,0],[11,0],[13,1],[15,3]] },
+    'd': { width: 19, points: [[15,21],[15,0],[-1,-1],[15,11],[13,13],[11,14],[8,14],[6,13],[4,11],[3,8],[3,6],[4,3],[6,1],[8,0],[11,0],[13,1],[15,3]] },
+    'e': { width: 18, points: [[3,8],[15,8],[15,10],[14,12],[13,13],[11,14],[8,14],[6,13],[4,11],[3,8],[3,6],[4,3],[6,1],[8,0],[11,0],[13,1],[15,3]] },
+    'f': { width: 12, points: [[10,21],[8,21],[6,20],[5,17],[5,0],[-1,-1],[2,14],[9,14]] },
+    'g': { width: 19, points: [[15,14],[15,-2],[14,-5],[13,-6],[11,-7],[8,-7],[6,-6],[-1,-1],[15,11],[13,13],[11,14],[8,14],[6,13],[4,11],[3,8],[3,6],[4,3],[6,1],[8,0],[11,0],[13,1],[15,3]] },
+    'h': { width: 19, points: [[4,21],[4,0],[-1,-1],[4,10],[7,13],[9,14],[12,14],[14,13],[15,10],[15,0]] },
+    'i': { width: 8, points: [[3,21],[4,20],[5,21],[4,22],[3,21],[-1,-1],[4,14],[4,0]] },
+    'j': { width: 10, points: [[5,21],[6,20],[7,21],[6,22],[5,21],[-1,-1],[6,14],[6,-3],[5,-6],[3,-7],[1,-7]] },
+    'k': { width: 17, points: [[4,21],[4,0],[-1,-1],[14,14],[4,4],[-1,-1],[8,8],[15,0]] },
+    'l': { width: 8, points: [[4,21],[4,0]] },
+    'm': { width: 30, points: [[4,14],[4,0],[-1,-1],[4,10],[7,13],[9,14],[12,14],[14,13],[15,10],[15,0],[-1,-1],[15,10],[18,13],[20,14],[23,14],[25,13],[26,10],[26,0]] },
+    'n': { width: 19, points: [[4,14],[4,0],[-1,-1],[4,10],[7,13],[9,14],[12,14],[14,13],[15,10],[15,0]] },
+    'o': { width: 19, points: [[8,14],[6,13],[4,11],[3,8],[3,6],[4,3],[6,1],[8,0],[11,0],[13,1],[15,3],[16,6],[16,8],[15,11],[13,13],[11,14],[8,14]] },
+    'p': { width: 19, points: [[4,14],[4,-7],[-1,-1],[4,11],[6,13],[8,14],[11,14],[13,13],[15,11],[16,8],[16,6],[15,3],[13,1],[11,0],[8,0],[6,1],[4,3]] },
+    'q': { width: 19, points: [[15,14],[15,-7],[-1,-1],[15,11],[13,13],[11,14],[8,14],[6,13],[4,11],[3,8],[3,6],[4,3],[6,1],[8,0],[11,0],[13,1],[15,3]] },
+    'r': { width: 13, points: [[4,14],[4,0],[-1,-1],[4,8],[5,11],[7,13],[9,14],[12,14]] },
+    's': { width: 17, points: [[14,11],[13,13],[10,14],[7,14],[4,13],[3,11],[4,9],[6,8],[11,7],[13,6],[14,4],[14,3],[13,1],[10,0],[7,0],[4,1],[3,3]] },
+    't': { width: 12, points: [[5,21],[5,4],[6,1],[8,0],[10,0],[-1,-1],[2,14],[9,14]] },
+    'u': { width: 19, points: [[4,14],[4,4],[5,1],[7,0],[10,0],[12,1],[15,4],[-1,-1],[15,14],[15,0]] },
+    'v': { width: 16, points: [[2,14],[8,0],[-1,-1],[14,14],[8,0]] },
+    'w': { width: 22, points: [[3,14],[7,0],[-1,-1],[11,14],[7,0],[-1,-1],[11,14],[15,0],[-1,-1],[19,14],[15,0]] },
+    'x': { width: 17, points: [[3,14],[14,0],[-1,-1],[14,14],[3,0]] },
+    'y': { width: 16, points: [[2,14],[8,0],[-1,-1],[14,14],[8,0],[6,-4],[4,-6],[2,-7],[1,-7]] },
+    'z': { width: 17, points: [[14,14],[3,0],[-1,-1],[3,14],[14,14],[-1,-1],[3,0],[14,0]] },
+    '{': { width: 14, points: [[9,25],[7,24],[6,23],[5,21],[5,19],[6,17],[7,16],[8,14],[8,12],[6,10],[-1,-1],[7,24],[6,22],[6,20],[7,18],[8,17],[9,15],[9,13],[8,11],[4,9],[8,7],[9,5],[9,3],[8,1],[7,0],[6,-2],[6,-4],[7,-6],[-1,-1],[6,8],[8,6],[8,4],[7,2],[6,1],[5,-1],[5,-3],[6,-5],[7,-6],[9,-7]] },
+    '|': { width: 8, points: [[4,25],[4,-7]] },
+    '}': { width: 14, points: [[5,25],[7,24],[8,23],[9,21],[9,19],[8,17],[7,16],[6,14],[6,12],[8,10],[-1,-1],[7,24],[8,22],[8,20],[7,18],[6,17],[5,15],[5,13],[6,11],[10,9],[6,7],[5,5],[5,3],[6,1],[7,0],[8,-2],[8,-4],[7,-6],[-1,-1],[8,8],[6,6],[6,4],[7,2],[8,1],[9,-1],[9,-3],[8,-5],[7,-6],[5,-7]] },
+    '~': { width: 24, points: [[3,6],[3,8],[4,11],[6,12],[8,12],[10,11],[14,8],[16,7],[18,7],[20,8],[21,10],[-1,-1],[3,8],[4,10],[6,11],[8,11],[10,10],[14,7],[16,6],[18,6],[20,7],[21,10],[21,12]] },
+
+// latin-1 as diacritical + base character
+
+192: { width: 0, points: [[4,28],[10,24],[-99,'A']] },
+193: { width: 0, points: [[8,24],[14,28],[-99,'A']] },
+194: { width: 0, points: [[5,24],[9,27],[13,24],[-99,'A']] },
+195: { width: 0, points: [[4,24],[5,26],[6,27],[8,27], [10,24],[12,24],[13,25],[14,27],[-99,'A']] },
+196: { width: 0, points: [[6,25],[6,26],[7,26],[7,25],[-1,-1],[12,25],[12,26],[13,26],[13,25],[-99,'A']] },
+197: { width: 0, points: [[8,27],[6,25],[6,23],[8,21],[10,21],[12,23],[12,25],[10,27],[8,27],[-99,'A']]},
+198: { width: 11, points: [[3,0],[14,21],[-1,-1],[7,8],[14,8],[-99,'E']] },
+199: { width: 0, points: [[10,0],[10,-3],[11,-3],[12,-4],[12,-6],[11,-7],[8,-7],[-99,'C']] },
+200: { width: 0, points: [[8,28],[14,24],[-99,'E']] },
+201: { width: 0, points: [[6,24],[12,28],[-99,'E']] },
+202: { width: 0, points: [[5,24],[9,27],[13,24],[-99,'E']] },
+203: { width: 0, points: [[6,25],[6,26],[7,26],[7,25],[-1,-1],[12,25],[12,26],[13,26],[13,25],[-99,'E']] },
+204: { width: 0, points: [[-99,'I']] },
+205: { width: 0, points: [[-99,'I']] },
+206: { width: 0, points: [[-99,'I']] },
+207: { width: 0, points: [[-99,'I']] },
+209: { width: 0, points: [[6,24],[7,26],[8,27],[10,27], [12,24],[14,24],[15,25],[16,27],[-99,'N']] },
+210: { width: 0, points: [[8,28],[14,24],[-99,'O']] },
+211: { width: 0, points: [[6,24],[12,28],[-99,'O']] },
+212: { width: 0, points: [[7,24],[11,27],[15,24],[-99,'O']] },
+213: { width: 0, points: [[6,24],[7,26],[8,27],[10,27], [12,24],[14,24],[15,25],[16,27],[-99,'O']] },
+214: { width: 0, points: [[8,25],[8,26],[9,26],[9,25],[-1,-1],[14,25],[14,26],[15,26],[15,25],[-99,'O']] },
+216: { width: 0, points: [[3,0],[19,21],[-99,'O']] },
+217: { width: 0, points: [[8,28],[14,24],[-99,'U']] },
+218: { width: 0, points: [[6,24],[12,28],[-99,'U']] },
+219: { width: 0, points: [[7,24],[11,27],[15,24],[-99,'U']] },
+220: { width: 0, points: [[8,25],[8,26],[9,26],[9,25],[-1,-1],[14,25],[14,26],[15,26],[15,25],[-99,'U']] },
+224: { width: 0, points: [[8,21],[14,17],[-99,'a']] },
+225: { width: 0, points: [[6,17],[12,21],[-99,'a']] },
+226: { width: 0, points: [[5,17],[9,20],[13,17],[-99,'a']] },
+227: { width: 0, points: [[4,17],[5,19],[6,20],[8,20], [10,17],[12,17],[13,18],[14,20],[-99,'a']] },
+228: { width: 0, points: [[6,18],[6,19],[7,19],[7,18],[-1,-1],[12,18],[12,19],[13,19],[13,18],[-99,'a']] },
+229: { width: 0, points: [[9,21],[7,19],[7,18],[9,16],[10,16],[12,18],[12,19],[10,21],[8,21],[-99,'a']] },
+231: { width: 0, points: [[10,0],[10,-3],[11,-3],[12,-4],[12,-6],[11,-7],[8,-7],[-99,'c']] },
+232: { width: 0, points: [[8,21],[14,17],[-99,'e']] },
+233: { width: 0, points: [[6,17],[12,21],[-99,'e']] },
+234: { width: 0, points: [[5,17],[9,20],[13,17],[-99,'e']] },
+235: { width: 0, points: [[6,18],[6,19],[7,19],[7,18],[-1,-1],[12,18],[12,19],[13,19],[13,18],[-99,'e']] },
+236: { width: 8, points: [[4,14],[4,0],[-1,-1],[1,21],[4,18]] },
+237: { width: 8, points: [[4,14],[4,0],[-1,-1],[7,21],[4,18]] },
+238: { width: 8, points: [[4,14],[4,0],[-1,-1],[1,17],[4,20],[7,17]] },
+239: { width: 10, points: [[5,14],[5,0],[-1,-1],[2,18],[2,19],[3,19],[3,18],[-1,-1],[7,18],[7,19],[8,19],[8,18]] },
+241: { width: 0, points: [[5,17],[6,19],[7,20],[9,20], [11,17],[13,17],[14,18],[15,20],[-99,'n']] },
+242: { width: 0, points: [[8,21],[14,17],[-99,'o']] },
+243: { width: 0, points: [[6,17],[12,21],[-99,'o']] },
+244: { width: 0, points: [[5,17],[9,20],[13,17],[-99,'o']] },
+245: { width: 0, points: [[4,17],[5,19],[6,20],[8,20], [10,17],[12,17],[13,18],[14,20],[-99,'o']] },
+246: { width: 0, points: [[6,18],[6,19],[7,19],[7,18],[-1,-1],[12,18],[12,19],[13,19],[13,18],[-99,'o']] },
+247: { width: 20, points: [[4,9],[16,9],[-1,-1],[10,14],[10,13],[11,13],[11,14],[-1,-1],[10,4],[10,5],[11,5],[11,4]] },
+248: { width: 0, points: [[3,0],[17,14],[-99,'o']] },
+249: { width: 0, points: [[8,21],[14,17],[-99,'u']] },
+250: { width: 0, points: [[6,17],[12,21],[-99,'u']] },
+251: { width: 0, points: [[5,17],[9,20],[13,17],[-99,'u']] },
+252: { width: 0, points: [[6,18],[6,19],[7,19],[7,18],[-1,-1],[12,18],[12,19],[13,19],[13,18],[-99,'u']] },
+253: { width: 0, points: [[12,21],[6,17],[-99,'y']] },
+255: { width: 0, points: [[6,18],[6,19],[7,19],[7,18],[-1,-1],[12,18],[12,19],[13,19],[13,18],[-99,'y']] },
+
+// Hershey simplex greek font
+
+913: { width: 18, points: [[9,22],[1,1],[-1,-1],[9,22],[17,1],[-1,-1],[4,8],[14,8]] },
+914: { width: 21, points: [[4,22],[4,1],[-1,-1],[4,22],[13,22],[16,21],[17,20],[18,18],[18,16],[17,14],[16,13],[13,12],[-1,-1],[4,12],[13,12],[16,11],[17,10],[18,8],[18,5],[17,3],[16,2],[13,1],[4,1]] },
+915: { width: 17, points: [[4,22],[4,1],[-1,-1],[4,22],[16,22]] },
+916: { width: 18, points: [[9,22],[1,1],[-1,-1],[9,22],[17,1],[-1,-1],[1,1],[17,1]] },
+917: { width: 19, points: [[4,22],[4,1],[-1,-1],[4,22],[17,22],[-1,-1],[4,12],[12,12],[-1,-1],[4,1],[17,1]] },
+918: { width: 20, points: [[17,22],[3,1],[-1,-1],[3,22],[17,22],[-1,-1],[3,1],[17,1]] },
+919: { width: 22, points: [[4,22],[4,1],[-1,-1],[18,22],[18,1],[-1,-1],[4,12],[18,12]] },
+920: { width: 22, points: [[9,22],[7,21],[5,19],[4,17],[3,14],[3,9],[4,6],[5,4],[7,2],[9,1],[13,1],[15,2],[17,4],[18,6],[19,9],[19,14],[18,17],[17,19],[15,21],[13,22],[9,22],[-1,-1],[8,12],[14,12]] },
+921: { width:  8, points: [[4,22],[4,1]] },
+922: { width: 21, points: [[4,22],[4,1],[-1,-1],[18,22],[4,8],[-1,-1],[9,13],[18,1]] },
+923: { width: 18, points: [[9,22],[1,1],[-1,-1],[9,22],[17,1]] },
+924: { width: 24, points: [[4,22],[4,1],[-1,-1],[4,22],[12,1],[-1,-1],[20,22],[12,1],[-1,-1],[20,22],[20,1]] },
+925: { width: 22, points: [[4,22],[4,1],[-1,-1],[4,22],[18,1],[-1,-1],[18,22],[18,1]] },
+926: { width: 18, points: [[2,22],[16,22],[-1,-1],[6,12],[12,12],[-1,-1],[2,1],[16,1]] },
+927: { width: 22, points: [[9,22],[7,21],[5,19],[4,17],[3,14],[3,9],[4,6],[5,4],[7,2],[9,1],[13,1],[15,2],[17,4],[18,6],[19,9],[19,14],[18,17],[17,19],[15,21],[13,22],[9,22]] },
+928: { width: 22, points: [[4,22],[4,1],[-1,-1],[18,22],[18,1],[-1,-1],[4,22],[18,22]] },
+929: { width: 21, points: [[4,22],[4,1],[-1,-1],[4,22],[13,22],[16,21],[17,20],[18,18],[18,15],[17,13],[16,12],[13,11],[4,11]] },
+931: { width: 18, points: [[2,22],[9,12],[2,1],[-1,-1],[2,22],[16,22],[-1,-1],[2,1],[16,1]] },
+932: { width: 16, points: [[8,22],[8,1],[-1,-1],[1,22],[15,22]] },
+933: { width: 18, points: [[2,17],[2,19],[3,21],[4,22],[6,22],[7,21],[8,19],[9,15],[9,1],[-1,-1],[16,17],[16,19],[15,21],[14,22],[12,22],[11,21],[10,19],[9,15]] },
+934: { width: 20, points: [[10,22],[10,1],[-1,-1],[8,17],[5,16],[4,15],[3,13],[3,10],[4,8],[5,7],[8,6],[12,6],[15,7],[16,8],[17,10],[17,13],[16,15],[15,16],[12,17],[8,17]] },
+935: { width: 20, points: [[3,22],[17,1],[-1,-1],[3,1],[17,22]] },
+936: { width: 22, points: [[11,22],[11,1],[-1,-1],[2,16],[3,16],[4,15],[5,11],[6,9],[7,8],[10,7],[12,7],[15,8],[16,9],[17,11],[18,15],[19,16],[20,16]] },
+937: { width: 20, points: [[3,1],[7,1],[4,8],[3,12],[3,16],[4,19],[6,21],[9,22],[11,22],[14,21],[16,19],[17,16],[17,12],[16,8],[13,1],[17,1]] },
+945: { width: 21, points: [[9,15],[7,14],[5,12],[4,10],[3,7],[3,4],[4,2],[6,1],[8,1],[10,2],[13,5],[15,8],[17,12],[18,15],[-1,-1],[9,15],[11,15],[12,14],[13,12],[15,4],[16,2],[17,1],[18,1]] },
+946: { width: 19, points: [[12,22],[10,21],[8,19],[6,15],[5,12],[4,8],[3,2],[2,-6],[-1,-1],[12,22],[14,22],[16,20],[16,17],[15,15],[14,14],[12,13],[9,13],[-1,-1],[9,13],[11,12],[13,10],[14,8],[14,5],[13,3],[12,2],[10,1],[8,1],[6,2],[5,3],[4,6]] },
+947: { width: 19, points: [[1,12],[3,14],[5,15],[6,15],[8,14],[9,13],[10,10],[10,6],[9,1],[-1,-1],[17,15],[16,12],[15,10],[9,1],[7,-3],[6,-6]] },
+948: { width: 18, points: [[11,15],[8,15],[6,14],[4,12],[3,9],[3,6],[4,3],[5,2],[7,1],[9,1],[11,2],[13,4],[14,7],[14,10],[13,13],[11,15],[9,17],[8,19],[8,21],[9,22],[11,22],[13,21],[15,19]] },
+949: { width: 16, points: [[13,13],[12,14],[10,15],[7,15],[5,14],[5,12],[6,10],[9,9],[-1,-1],[9,9],[5,8],[3,6],[3,4],[4,2],[6,1],[9,1],[11,2],[13,4]] },
+950: { width: 15, points: [[10,22],[8,21],[7,20],[7,19],[8,18],[11,17],[14,17],[-1,-1],[14,17],[10,15],[7,13],[4,10],[3,7],[3,5],[4,3],[6,1],[9,-1],[10,-3],[10,-5],[9,-6],[7,-6],[6,-4]] },
+951: { width: 20, points: [[1,11],[2,13],[4,15],[6,15],[7,14],[7,12],[6,8],[4,1],[-1,-1],[6,8],[8,12],[10,14],[12,15],[14,15],[16,13],[16,10],[15,5],[12,-6]] },
+952: { width: 17, points: [[10,22],[8,21],[6,18],[5,16],[4,13],[3,8],[3,4],[4,2],[5,1],[7,1],[9,2],[11,5],[12,7],[13,10],[14,15],[14,19],[13,21],[12,22],[10,22],[-1,-1],[4,12],[13,12]] },
+953: { width: 11, points: [[6,15],[4,8],[3,4],[3,2],[4,1],[6,1],[8,3],[9,5]] },
+954: { width: 18, points: [[6,15],[2,1],[-1,-1],[16,14],[15,15],[14,15],[12,14],[8,10],[6,9],[5,9],[-1,-1],[5,9],[7,8],[8,7],[10,2],[11,1],[12,1],[13,2]] },
+955: { width: 16, points: [[1,22],[3,22],[5,21],[6,20],[14,1],[-1,-1],[8,15],[2,1]] },
+956: { width: 21, points: [[7,15],[1,-6],[-1,-1],[6,11],[5,6],[5,3],[7,1],[9,1],[11,2],[13,4],[15,8],[-1,-1],[17,15],[15,8],[14,4],[14,2],[15,1],[17,1],[19,3],[20,5]] },
+957: { width: 18, points: [[3,15],[6,15],[5,9],[4,4],[3,1],[-1,-1],[16,15],[15,12],[14,10],[12,7],[9,4],[6,2],[3,1]] },
+958: { width: 16, points: [[10,22],[8,21],[7,20],[7,19],[8,18],[11,17],[14,17],[-1,-1],[11,17],[8,16],[6,15],[5,13],[5,11],[7,9],[10,8],[12,8],[-1,-1],[10,8],[6,7],[4,6],[3,4],[3,2],[5,0],[9,-2],[10,-3],[10,-5],[8,-6],[6,-6]] },
+959: { width: 17, points: [[8,15],[6,14],[4,12],[3,9],[3,6],[4,3],[5,2],[7,1],[9,1],[11,2],[13,4],[14,7],[14,10],[13,13],[12,14],[10,15],[8,15]] },
+960: { width: 18, points: [[6,15],[2,1],[-1,-1],[16,14],[15,15],[14,15],[12,14],[8,10],[6,9],[5,9],[-1,-1],[5,9],[7,8],[8,7],[10,2],[11,1],[12,1],[13,2]] },
+960: { width: 22, points: [[9,15],[5,1],[-1,-1],[14,15],[15,9],[16,4],[17,1],[-1,-1],[2,12],[4,14],[7,15],[20,15]] },
+961: { width: 18, points: [[4,9],[4,6],[5,3],[6,2],[8,1],[10,1],[12,2],[14,4],[15,7],[15,10],[14,13],[13,14],[11,15],[9,15],[7,14],[5,12],[4,9],[0,-6]] },
+962: { width: 18, points: [[15,13],[14,14],[11,15],[8,15],[5,14],[4,13],[3,11],[3,9],[4,7],[6,5],[10,2],[11,0],[11,-2],[10,-3],[8,-3]] },
+963: { width: 18, points: [[3,15],[6,15],[5,9],[4,4],[3,1],[-1,-1],[16,15],[15,12],[14,10],[12,7],[9,4],[6,2],[3,1]] },
+963: { width: 20, points: [[18,15],[8,15],[6,14],[4,12],[3,9],[3,6],[4,3],[5,2],[7,1],[9,1],[11,2],[13,4],[14,7],[14,10],[13,13],[12,14],[10,15]] },
+964: { width: 20, points: [[11,15],[8,1],[-1,-1],[2,12],[4,14],[7,15],[18,15]] },
+965: { width: 20, points: [[1,11],[2,13],[4,15],[6,15],[7,14],[7,12],[5,6],[5,3],[7,1],[9,1],[12,2],[14,4],[16,8],[17,12],[17,15]] },
+966: { width: 22, points: [[8,14],[6,13],[4,11],[3,8],[3,5],[4,3],[5,2],[7,1],[10,1],[13,2],[16,4],[18,7],[19,10],[19,13],[17,15],[15,15],[13,13],[11,9],[9,4],[6,-6]] },
+967: { width: 18, points: [[2,15],[4,15],[6,13],[12,-4],[14,-6],[16,-6],[-1,-1],[17,15],[16,13],[14,10],[4,-1],[2,-4],[1,-6]] },
+968: { width: 23, points: [[16,22],[8,-6],[-1,-1],[1,11],[2,13],[4,15],[6,15],[7,14],[7,12],[6,7],[6,4],[7,2],[9,1],[11,1],[14,2],[16,4],[18,7],[20,12],[21,15]] },
+969: { width: 23, points: [[8,15],[6,14],[4,11],[3,8],[3,5],[4,2],[5,1],[7,1],[9,2],[11,5],[-1,-1],[12,9],[11,5],[12,2],[13,1],[15,1],[17,2],[19,5],[20,8],[20,11],[19,14],[18,15]] },
+977: { width: 21, points: [[1,11],[2,13],[4,15],[6,15],[7,14],[7,12],[6,7],[6,4],[7,2],[8,1],[10,1],[12,2],[14,5],[15,7],[16,10],[17,15],[17,18],[16,21],[14,22],[12,22],[11,20],[11,18],[12,15],[14,12],[16,10],[19,8]] },
+981: { width: 20, points: [[14,22],[6,-6],[-1,-1],[9,15],[6,14],[4,12],[3,9],[3,6],[4,4],[6,2],[9,1],[11,1],[14,2],[16,4],[17,7],[17,10],[16,12],[14,14],[11,15],[9,15]] },
+982: { width: 23, points: [[9,14],[6,13],[4,11],[3,8],[3,5],[4,2],[5,1],[7,1],[9,2],[11,5],[-1,-1],[12,9],[11,5],[12,2],[13,1],[15,1],[17,2],[19,5],[20,8],[20,11],[19,14],[18,15],[-1,-1],[2,14],[4,15],[20,15]] },
+986: { width: 18, points: [[15,13],[14,14],[11,15],[8,15],[5,14],[4,13],[3,11],[3,9],[4,7],[6,5],[10,2],[11,0],[11,-2],[10,-3],[8,-3]] },
+
+// Hershey math symbols
+
+8501: { width: 20, points: [[3,19],[4,17],[16,5],[17,3],[17,1],[-1,-1],[4,16],[16,4],[-1,-1],[3,19],[3,17],[4,15],[16,3],[17,1],[-1,-1],[8,12],[4,8],[3,6],[3,4],[4,2],[3,1],[-1,-1],[3,6],[5,2],[-1,-1],[4,8],[4,6],[5,4],[5,2],[3,1],[-1,-1],[11,9],[16,14],[-1,-1],[14,19],[14,16],[15,14],[17,14],[17,16],[15,17],[14,19],[-1,-1],[14,19],[15,16],[17,14]] },
+8592: { width: 26, points: [[7,12],[4,10],[7,8],[-1,-1],[10,15],[5,10],[10,5],[-1,-1],[5,10],[22,10]] },
+8593: { width: 16, points: [[6,16],[8,19],[10,16],[-1,-1],[3,13],[8,18],[13,13],[-1,-1],[8,18],[8,1]] },
+8594: { width: 26, points: [[19,12],[22,10],[19,8],[-1,-1],[16,15],[21,10],[16,5],[-1,-1],[4,10],[21,10]] },
+8595: { width: 16, points: [[6,4],[8,1],[10,4],[-1,-1],[3,7],[8,2],[13,7],[-1,-1],[8,19],[8,2]] },
+8706: { width: 19, points: [[15,10],[14,13],[13,14],[11,15],[9,15],[6,14],[4,11],[3,8],[3,5],[4,3],[5,2],[7,1],[9,1],[12,2],[14,4],[15,7],[16,12],[16,17],[15,20],[14,21],[12,22],[9,22],[7,21],[6,20],[6,19],[7,19],[7,20],[-1,-1],[9,15],[7,14],[5,11],[4,8],[4,4],[5,2],[-1,-1],[9,1],[11,2],[13,4],[14,7],[15,12],[15,17],[14,20],[12,22]] },
+8710: { width: 20, points: [[2,1],[10,22],[-1,-1],[17,1],[10,20],[-1,-1],[18,1],[10,22],[-1,-1],[2,1],[18,1],[-1,-1],[3,2],[17,2]] },
+8711: { width: 20, points: [[2,22],[10,1],[-1,-1],[3,22],[10,3],[-1,-1],[18,22],[10,1],[-1,-1],[2,22],[18,22],[-1,-1],[3,21],[17,21]] },
+8712: { width: 24, points: [[20,18],[13,18],[9,17],[7,16],[5,14],[4,11],[4,9],[5,6],[7,4],[9,3],[13,2],[20,2],[-1,-1],[4,10],[16,10]] },
+8713: { width: 24, points: [[20,18],[13,18],[9,17],[7,16],[5,14],[4,11],[4,9],[5,6],[7,4],[9,3],[13,2],[20,2],[-1,-1],[4,10],[16,10],[-1,-1],[18,19],[6,1]] },
+8719: { width: 34, points: [[7,26],[7,-6],[-1,-1],[8,26],[8,-6],[-1,-1],[26,26],[26,-6],[-1,-1],[27,26],[27,-6],[-1,-1],[3,26],[31,26],[-1,-1],[3,-6],[12,-6],[-1,-1],[22,-6],[31,-6]] },
+8721: { width: 31, points: [[5,26],[15,12],[4,-6],[-1,-1],[4,26],[14,12],[-1,-1],[3,26],[14,11],[-1,-1],[3,26],[26,26],[28,19],[25,26],[-1,-1],[5,-5],[26,-5],[-1,-1],[4,-6],[26,-6],[28,1],[25,-6]] },
+8728: { width:  16, points: [[7,13],[5,11],[5,9],[7,7],[9,7],[11,9],[11,11],[9,13],[7,13]] },
+8729: { width:  16, points: [[7,13],[5,11],[5,9],[7,7],[9,7],[11,9],[11,11],[9,13],[7,13],[-1,-1],[7,12],[6,11],[6,9],[7,8],[9,8],[10,9],[10,11],[9,12],[7,12],[-1,-1],[8,11],[7,10],[8,9],[9,10],[8,11]] },
+8730: { width: 22, points: [[3,15],[7,15],[13,3],[-1,-1],[6,15],[13,1],[-1,-1],[22,26],[13,1]] },
+8733: { width: 25, points: [[21,5],[19,5],[17,6],[15,8],[12,12],[11,13],[9,14],[7,14],[5,13],[4,11],[4,9],[5,7],[7,6],[9,6],[11,7],[12,8],[15,12],[17,14],[19,15],[21,15]] },
+8734: { width: 25, points: [[22,9],[21,7],[19,6],[17,6],[15,7],[14,8],[11,12],[10,13],[8,14],[6,14],[4,13],[3,11],[3,9],[4,7],[6,6],[8,6],[10,7],[11,8],[14,12],[15,13],[17,14],[19,14],[21,13],[22,11],[22,9]] },
+8745: { width: 24, points: [[4,2],[4,9],[5,13],[6,15],[8,17],[11,18],[13,18],[16,17],[18,15],[19,13],[20,9],[20,2]] },
+8746: { width: 24, points: [[4,18],[4,11],[5,7],[6,5],[8,3],[11,2],[13,2],[16,3],[18,5],[19,7],[20,11],[20,18]] },
+8747: { width: 24, points: [[21,25],[20,24],[21,23],[22,24],[22,25],[21,26],[19,26],[17,25],[15,23],[14,21],[13,18],[12,14],[10,2],[9,-2],[8,-4],[-1,-1],[16,24],[15,22],[14,18],[12,6],[11,2],[10,-1],[9,-3],[7,-5],[5,-6],[3,-6],[2,-5],[2,-4],[3,-3],[4,-4],[3,-5]] },
+8800: { width: 24, points: [[18,19],[6,1],[-1,-1],[3,12],[20,12],[-1,-1],[3,6],[20,6]] },
+8834: { width: 24, points: [[20,18],[13,18],[9,17],[7,16],[5,14],[4,11],[4,9],[5,6],[7,4],[9,3],[13,2],[20,2]] },
+8835: { width: 24, points: [[4,18],[11,18],[15,17],[17,16],[19,14],[20,11],[20,9],[19,6],[17,4],[15,3],[11,2],[4,2]] },
+8853: { width: 20, points: [[9,17],[6,16],[4,14],[3,11],[3,9],[4,6],[6,4],[9,3],[11,3],[14,4],[16,6],[17,9],[17,11],[16,14],[14,16],[11,17],[9,17],[-1,-1],[5,10],[15,10],[-1,-1],[10,5],[10,15]] },
+8855: { width: 20, points: [[9,17],[6,16],[4,14],[3,11],[3,9],[4,6],[6,4],[9,3],[11,3],[14,4],[16,6],[17,9],[17,11],[16,14],[14,16],[11,17],[9,17],[-1,-1],[6,6],[14,14],[-1,-1],[14,6],[6,14]] },
+8857: { width: 20, points: [[9,17],[6,16],[4,14],[3,11],[3,9],[4,6],[6,4],[9,3],[11,3],[14,4],[16,6],[17,9],[17,11],[16,14],[14,16],[11,17],[9,17],[-1,-1],[10,11],[9,10],[10,9],[11,10],[10,11]] },
+9737: { width: 27, points: [[12,22],[9,21],[6,19],[4,16],[3,13],[3,10],[4,7],[6,4],[9,2],[12,1],[15,1],[18,2],[21,4],[23,7],[24,10],[24,13],[23,16],[21,19],[18,21],[15,22],[12,22],[-1,-1],[13,13],[12,12],[12,11],[13,10],[14,10],[15,11],[15,12],[14,13],[13,13],[-1,-1],[13,12],[13,11],[14,11],[14,12],[13,12]] },
+
+// Miscellaneous glyphs (EAM)
+
+176: { width: 14, points: [[6,22],[4,21],[3,19],[3,17],[4,15],[6,14],[8,14],[10,15],[11,17],[11,19],[10,21],[8,22],[6,22]] },
+177: { width: 20, points: [[10,15],[10,5],[-1,-1],[4,10],[16,10],[-1,-1],[4,2],[16,2]] },
+181: { width: 0, points: [[-99,956]] },
+183: { width: 10, points: [[5,11],[4,10],[5,9],[6,10],[5,11]] },
+215: { width: 20, points: [[4,16],[16,4],[-1,-1],[4,4],[16,16]] },
+402: { width: 15, points: [[15,21],[14,20],[15,19],[16,20],[16,21],[15,22],[13,22],[11,21],[10,20],[9,18],[8,15],[5,1],[4,-3],[3,-5],[-1,-1],[13,22],[11,20],[10,18],[9,14],[7,5],[6,1],[5,-2],[4,-4],[3,-5],[1,-6],[-1,-6],[-2,-5],[-2,-4],[-1,-3],[0,-4],[-1,-5],[-1,-1],[4,15],[14,15]] },
+8242: { width: 8, points: [[5,24],[3,16],[-1,-1],[3,16],[6,24]] },
+8243: { width: 11, points: [[4,24],[2,16],[-1,-1],[2,16],[5,24],[-1,-1],[9,24],[7,16],[-1,-1],[7,16],[10,24]] },
+8463: { width: 21, points: [[9,22],[3,1],[-1,-1],[5,7],[7,11],[9,13],[11,14],[13,14],[15,14],[16,12],[16,10],[14,5],[14,2],[15,1],[19,3],[-1,-1],[7,21],[9,22],[-1,-1],[4,15],[14,20]] },
+8491: { width: 0, points: [[-99,197]] },
+8495: { width: 18, points: [[4,6],[8,7],[11,8],[14,10],[15,12],[14,14],[12,15],[9,15],[6,14],[4,11],[3,8],[3,5],[4,3],[5,2],[7,1],[9,1],[12,2],[14,4],[-1,-1],[9,15],[7,14],[5,11],[4,8],[4,4],[5,2]] },
+
+// Used to indicate missing glyph
+129: { width: 18, points: [[2,-2],[2,21],[16,21],[16,-2],[2,-2]] }
+};
+
+
+CanvasTextFunctions.letter = function (ch)
+{
+    glyph = CanvasTextFunctions.letters[ch];
+
+    // EAM - Draw an empty box for undefined glyphs
+    if (glyph == undefined)
+	glyph = CanvasTextFunctions.letters[129];
+
+    return glyph;
+}
+
+CanvasTextFunctions.ascent = function( font, size)
+{
+    return size;
+}
+
+CanvasTextFunctions.descent = function( font, size)
+{
+    return 7.0*size/25.0;
+}
+
+CanvasTextFunctions.measure = function( font, size, str)
+{
+    var total = 0;
+    var len = str.length;
+
+    for ( i = 0; i < len; i++) {
+	var index = str.charAt(i);
+	// EAM deal with non-ascii characaters
+	if (index > '~')
+	    index = str.charCodeAt(i);
+
+	var c = CanvasTextFunctions.letter(index);
+	if (c) total += c.width * size / 25.0;
+    }
+    return total;
+}
+
+CanvasTextFunctions.draw = function(ctx,font,size,x,y,str)
+{
+    var total = 0;
+    var len = str.length;
+    var mag = size / 25.0;
+    var composite = 0;
+
+    ctx.save();
+    ctx.lineCap = "round";
+    ctx.lineWidth = 2.0 * mag;
+
+    for ( i = 0; i < len; i++) {
+	var index = str.charAt(i);
+
+	// EAM deal with non-ascii characaters
+	if (index > '~')
+	    index = str.charCodeAt(i);
+
+	// EAM allow composing characters
+	if (composite != 0) {
+	    index = composite;
+	    composite = 0;
+	}
+
+	var c = CanvasTextFunctions.letter(index);
+	if ( !c) continue;
+
+	ctx.beginPath();
+
+	var penUp = 1;
+	var needStroke = 0;
+	for ( j = 0; j < c.points.length; j++) {
+	    var a = c.points[j];
+	    if ( a[0] == -1 && a[1] == -1) {
+		penUp = 1;
+		continue;
+	    }
+	    if ( a[0] == -99 ) {
+		composite = a[1];
+		i--;
+		break;
+	    }
+	    if ( penUp) {
+		ctx.moveTo( x + a[0]*mag, y - a[1]*mag);
+		penUp = false;
+	    } else {
+		ctx.lineTo( x + a[0]*mag, y - a[1]*mag);
+	    }
+	}
+	ctx.stroke();
+	x += c.width*mag;
+    }
+    ctx.restore();
+    return total;
+}
+
+CanvasTextFunctions.enable = function( ctx)
+{
+    ctx.drawText = function(font,size,x,y,text) { return CanvasTextFunctions.draw( ctx, font,size,x,y,text); };
+    ctx.measureText = function(font,size,text) { return CanvasTextFunctions.measure( font,size,text); };
+    ctx.fontAscent = function(font,size) { return CanvasTextFunctions.ascent(font,size); }
+    ctx.fontDescent = function(font,size) { return CanvasTextFunctions.descent(font,size); }
+
+    ctx.drawTextRight = function(font,size,x,y,text) { 
+	var w = CanvasTextFunctions.measure(font,size,text);
+	return CanvasTextFunctions.draw( ctx, font,size,x-w,y,text); 
+    };
+    ctx.drawTextCenter = function(font,size,x,y,text) { 
+	var w = CanvasTextFunctions.measure(font,size,text);
+	return CanvasTextFunctions.draw( ctx, font,size,x-w/2,y,text); 
+    };
+}
+
diff -rupN C:\gnuplot-4.4.0\term/js/.svn/text-base/canvastext.js.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/js/.svn/text-base/canvastext.js.svn-base
--- C:\gnuplot-4.4.0\term/js/.svn/text-base/canvastext.js.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/js/.svn/text-base/canvastext.js.svn-base	2012-01-03 17:07:33.670294700 -0800
@@ -0,0 +1,211 @@
+/*
+ * $Id: canvastext.js,v 1.3 2009/02/22 19:14:05 sfeam Exp $
+ */
+// The canvastext.js code was released to the public domain by Jim Studt, 2007.
+// He may keep some sort of up to date copy at http://www.federated.com/~jim/canvastext/
+// Feb 2009 Ethan A Merritt (EAM) Modify code to work in non-ascii environments.
+//
+var CanvasTextFunctions = { };
+
+CanvasTextFunctions.letters = {
+    ' ': { width: 16, points: [] },
+    '!': { width: 10, points: [[5,21],[5,7],[-1,-1],[5,2],[4,1],[5,0],[6,1],[5,2]] },
+    '"': { width: 16, points: [[4,21],[4,14],[-1,-1],[12,21],[12,14]] },
+    '#': { width: 21, points: [[11,25],[4,-7],[-1,-1],[17,25],[10,-7],[-1,-1],[4,12],[18,12],[-1,-1],[3,6],[17,6]] },
+    '$': { width: 20, points: [[8,25],[8,-4],[-1,-1],[12,25],[12,-4],[-1,-1],[17,18],[15,20],[12,21],[8,21],[5,20],[3,18],[3,16],[4,14],[5,13],[7,12],[13,10],[15,9],[16,8],[17,6],[17,3],[15,1],[12,0],[8,0],[5,1],[3,3]] },
+    '%': { width: 24, points: [[21,21],[3,0],[-1,-1],[8,21],[10,19],[10,17],[9,15],[7,14],[5,14],[3,16],[3,18],[4,20],[6,21],[8,21],[10,20],[13,19],[16,19],[19,20],[21,21],[-1,-1],[17,7],[15,6],[14,4],[14,2],[16,0],[18,0],[20,1],[21,3],[21,5],[19,7],[17,7]] },
+    '&': { width: 26, points: [[23,12],[23,13],[22,14],[21,14],[20,13],[19,11],[17,6],[15,3],[13,1],[11,0],[7,0],[5,1],[4,2],[3,4],[3,6],[4,8],[5,9],[12,13],[13,14],[14,16],[14,18],[13,20],[11,21],[9,20],[8,18],[8,16],[9,13],[11,10],[16,3],[18,1],[20,0],[22,0],[23,1],[23,2]] },
+    '\'': { width: 10, points: [[5,19],[4,20],[5,21],[6,20],[6,18],[5,16],[4,15]] },
+    '(': { width: 14, points: [[11,25],[9,23],[7,20],[5,16],[4,11],[4,7],[5,2],[7,-2],[9,-5],[11,-7]] },
+    ')': { width: 14, points: [[3,25],[5,23],[7,20],[9,16],[10,11],[10,7],[9,2],[7,-2],[5,-5],[3,-7]] },
+    '*': { width: 16, points: [[8,21],[8,9],[-1,-1],[3,18],[13,12],[-1,-1],[13,18],[3,12]] },
+    '+': { width: 26, points: [[13,18],[13,0],[-1,-1],[4,9],[22,9]] },
+    ',': { width: 10, points: [[6,1],[5,0],[4,1],[5,2],[6,1],[6,-1],[5,-3],[4,-4]] },
+    '-': { width: 26, points: [[4,9],[22,9]] },
+    '.': { width: 10, points: [[5,2],[4,1],[5,0],[6,1],[5,2]] },
+    '/': { width: 22, points: [[20,25],[2,-7]] },
+    '0': { width: 20, points: [[9,21],[6,20],[4,17],[3,12],[3,9],[4,4],[6,1],[9,0],[11,0],[14,1],[16,4],[17,9],[17,12],[16,17],[14,20],[11,21],[9,21]] },
+    '1': { width: 20, points: [[6,17],[8,18],[11,21],[11,0]] },
+    '2': { width: 20, points: [[4,16],[4,17],[5,19],[6,20],[8,21],[12,21],[14,20],[15,19],[16,17],[16,15],[15,13],[13,10],[3,0],[17,0]] },
+    '3': { width: 20, points: [[5,21],[16,21],[10,13],[13,13],[15,12],[16,11],[17,8],[17,6],[16,3],[14,1],[11,0],[8,0],[5,1],[4,2],[3,4]] },
+    '4': { width: 20, points: [[13,21],[3,7],[18,7],[-1,-1],[13,21],[13,0]] },
+    '5': { width: 20, points: [[15,21],[5,21],[4,12],[5,13],[8,14],[11,14],[14,13],[16,11],[17,8],[17,6],[16,3],[14,1],[11,0],[8,0],[5,1],[4,2],[3,4]] },
+    '6': { width: 20, points: [[16,18],[15,20],[12,21],[10,21],[7,20],[5,17],[4,12],[4,7],[5,3],[7,1],[10,0],[11,0],[14,1],[16,3],[17,6],[17,7],[16,10],[14,12],[11,13],[10,13],[7,12],[5,10],[4,7]] },
+    '7': { width: 20, points: [[17,21],[7,0],[-1,-1],[3,21],[17,21]] },
+    '8': { width: 20, points: [[8,21],[5,20],[4,18],[4,16],[5,14],[7,13],[11,12],[14,11],[16,9],[17,7],[17,4],[16,2],[15,1],[12,0],[8,0],[5,1],[4,2],[3,4],[3,7],[4,9],[6,11],[9,12],[13,13],[15,14],[16,16],[16,18],[15,20],[12,21],[8,21]] },
+    '9': { width: 20, points: [[16,14],[15,11],[13,9],[10,8],[9,8],[6,9],[4,11],[3,14],[3,15],[4,18],[6,20],[9,21],[10,21],[13,20],[15,18],[16,14],[16,9],[15,4],[13,1],[10,0],[8,0],[5,1],[4,3]] },
+    ':': { width: 10, points: [[5,14],[4,13],[5,12],[6,13],[5,14],[-1,-1],[5,2],[4,1],[5,0],[6,1],[5,2]] },
+    ';': { width: 10, points: [[5,14],[4,13],[5,12],[6,13],[5,14],[-1,-1],[6,1],[5,0],[4,1],[5,2],[6,1],[6,-1],[5,-3],[4,-4]] },
+    '<': { width: 24, points: [[20,18],[4,9],[20,0]] },
+    '=': { width: 26, points: [[4,12],[22,12],[-1,-1],[4,6],[22,6]] },
+    '>': { width: 24, points: [[4,18],[20,9],[4,0]] },
+    '?': { width: 18, points: [[3,16],[3,17],[4,19],[5,20],[7,21],[11,21],[13,20],[14,19],[15,17],[15,15],[14,13],[13,12],[9,10],[9,7],[-1,-1],[9,2],[8,1],[9,0],[10,1],[9,2]] },
+    '@': { width: 27, points: [[18,13],[17,15],[15,16],[12,16],[10,15],[9,14],[8,11],[8,8],[9,6],[11,5],[14,5],[16,6],[17,8],[-1,-1],[12,16],[10,14],[9,11],[9,8],[10,6],[11,5],[-1,-1],[18,16],[17,8],[17,6],[19,5],[21,5],[23,7],[24,10],[24,12],[23,15],[22,17],[20,19],[18,20],[15,21],[12,21],[9,20],[7,19],[5,17],[4,15],[3,12],[3,9],[4,6],[5,4],[7,2],[9,1],[12,0],[15,0],[18,1],[20,2],[21,3],[-1,-1],[19,16],[18,8],[18,6],[19,5]] },
+    'A': { width: 18, points: [[9,21],[1,0],[-1,-1],[9,21],[17,0],[-1,-1],[4,7],[14,7]] },
+    'B': { width: 21, points: [[4,21],[4,0],[-1,-1],[4,21],[13,21],[16,20],[17,19],[18,17],[18,15],[17,13],[16,12],[13,11],[-1,-1],[4,11],[13,11],[16,10],[17,9],[18,7],[18,4],[17,2],[16,1],[13,0],[4,0]] },
+    'C': { width: 21, points: [[18,16],[17,18],[15,20],[13,21],[9,21],[7,20],[5,18],[4,16],[3,13],[3,8],[4,5],[5,3],[7,1],[9,0],[13,0],[15,1],[17,3],[18,5]] },
+    'D': { width: 21, points: [[4,21],[4,0],[-1,-1],[4,21],[11,21],[14,20],[16,18],[17,16],[18,13],[18,8],[17,5],[16,3],[14,1],[11,0],[4,0]] },
+    'E': { width: 19, points: [[4,21],[4,0],[-1,-1],[4,21],[17,21],[-1,-1],[4,11],[12,11],[-1,-1],[4,0],[17,0]] },
+    'F': { width: 18, points: [[4,21],[4,0],[-1,-1],[4,21],[17,21],[-1,-1],[4,11],[12,11]] },
+    'G': { width: 21, points: [[18,16],[17,18],[15,20],[13,21],[9,21],[7,20],[5,18],[4,16],[3,13],[3,8],[4,5],[5,3],[7,1],[9,0],[13,0],[15,1],[17,3],[18,5],[18,8],[-1,-1],[13,8],[18,8]] },
+    'H': { width: 22, points: [[4,21],[4,0],[-1,-1],[18,21],[18,0],[-1,-1],[4,11],[18,11]] },
+    'I': { width: 8, points: [[4,21],[4,0]] },
+    'J': { width: 16, points: [[12,21],[12,5],[11,2],[10,1],[8,0],[6,0],[4,1],[3,2],[2,5],[2,7]] },
+    'K': { width: 21, points: [[4,21],[4,0],[-1,-1],[18,21],[4,7],[-1,-1],[9,12],[18,0]] },
+    'L': { width: 17, points: [[4,21],[4,0],[-1,-1],[4,0],[16,0]] },
+    'M': { width: 24, points: [[4,21],[4,0],[-1,-1],[4,21],[12,0],[-1,-1],[20,21],[12,0],[-1,-1],[20,21],[20,0]] },
+    'N': { width: 22, points: [[4,21],[4,0],[-1,-1],[4,21],[18,0],[-1,-1],[18,21],[18,0]] },
+    'O': { width: 22, points: [[9,21],[7,20],[5,18],[4,16],[3,13],[3,8],[4,5],[5,3],[7,1],[9,0],[13,0],[15,1],[17,3],[18,5],[19,8],[19,13],[18,16],[17,18],[15,20],[13,21],[9,21]] },
+    'P': { width: 21, points: [[4,21],[4,0],[-1,-1],[4,21],[13,21],[16,20],[17,19],[18,17],[18,14],[17,12],[16,11],[13,10],[4,10]] },
+    'Q': { width: 22, points: [[9,21],[7,20],[5,18],[4,16],[3,13],[3,8],[4,5],[5,3],[7,1],[9,0],[13,0],[15,1],[17,3],[18,5],[19,8],[19,13],[18,16],[17,18],[15,20],[13,21],[9,21],[-1,-1],[12,4],[18,-2]] },
+    'R': { width: 21, points: [[4,21],[4,0],[-1,-1],[4,21],[13,21],[16,20],[17,19],[18,17],[18,15],[17,13],[16,12],[13,11],[4,11],[-1,-1],[11,11],[18,0]] },
+    'S': { width: 20, points: [[17,18],[15,20],[12,21],[8,21],[5,20],[3,18],[3,16],[4,14],[5,13],[7,12],[13,10],[15,9],[16,8],[17,6],[17,3],[15,1],[12,0],[8,0],[5,1],[3,3]] },
+    'T': { width: 16, points: [[8,21],[8,0],[-1,-1],[1,21],[15,21]] },
+    'U': { width: 22, points: [[4,21],[4,6],[5,3],[7,1],[10,0],[12,0],[15,1],[17,3],[18,6],[18,21]] },
+    'V': { width: 18, points: [[1,21],[9,0],[-1,-1],[17,21],[9,0]] },
+    'W': { width: 24, points: [[2,21],[7,0],[-1,-1],[12,21],[7,0],[-1,-1],[12,21],[17,0],[-1,-1],[22,21],[17,0]] },
+    'X': { width: 20, points: [[3,21],[17,0],[-1,-1],[17,21],[3,0]] },
+    'Y': { width: 18, points: [[1,21],[9,11],[9,0],[-1,-1],[17,21],[9,11]] },
+    'Z': { width: 20, points: [[17,21],[3,0],[-1,-1],[3,21],[17,21],[-1,-1],[3,0],[17,0]] },
+    '[': { width: 14, points: [[4,25],[4,-7],[-1,-1],[5,25],[5,-7],[-1,-1],[4,25],[11,25],[-1,-1],[4,-7],[11,-7]] },
+    '\\': { width: 14, points: [[0,21],[14,-3]] },
+    ']': { width: 14, points: [[9,25],[9,-7],[-1,-1],[10,25],[10,-7],[-1,-1],[3,25],[10,25],[-1,-1],[3,-7],[10,-7]] },
+    '^': { width: 16, points: [[5,15],[8,19],[11,15],[-1,-1],[2,12],[8,18],[14,12]] },
+    '_': { width: 16, points: [[0,-2],[16,-2]] },
+    '`': { width: 10, points: [[6,21],[5,20],[4,18],[4,16],[5,15],[6,16],[5,17]] },
+    'a': { width: 19, points: [[15,14],[15,0],[-1,-1],[15,11],[13,13],[11,14],[8,14],[6,13],[4,11],[3,8],[3,6],[4,3],[6,1],[8,0],[11,0],[13,1],[15,3]] },
+    'b': { width: 19, points: [[4,21],[4,0],[-1,-1],[4,11],[6,13],[8,14],[11,14],[13,13],[15,11],[16,8],[16,6],[15,3],[13,1],[11,0],[8,0],[6,1],[4,3]] },
+    'c': { width: 18, points: [[15,11],[13,13],[11,14],[8,14],[6,13],[4,11],[3,8],[3,6],[4,3],[6,1],[8,0],[11,0],[13,1],[15,3]] },
+    'd': { width: 19, points: [[15,21],[15,0],[-1,-1],[15,11],[13,13],[11,14],[8,14],[6,13],[4,11],[3,8],[3,6],[4,3],[6,1],[8,0],[11,0],[13,1],[15,3]] },
+    'e': { width: 18, points: [[3,8],[15,8],[15,10],[14,12],[13,13],[11,14],[8,14],[6,13],[4,11],[3,8],[3,6],[4,3],[6,1],[8,0],[11,0],[13,1],[15,3]] },
+    'f': { width: 12, points: [[10,21],[8,21],[6,20],[5,17],[5,0],[-1,-1],[2,14],[9,14]] },
+    'g': { width: 19, points: [[15,14],[15,-2],[14,-5],[13,-6],[11,-7],[8,-7],[6,-6],[-1,-1],[15,11],[13,13],[11,14],[8,14],[6,13],[4,11],[3,8],[3,6],[4,3],[6,1],[8,0],[11,0],[13,1],[15,3]] },
+    'h': { width: 19, points: [[4,21],[4,0],[-1,-1],[4,10],[7,13],[9,14],[12,14],[14,13],[15,10],[15,0]] },
+    'i': { width: 8, points: [[3,21],[4,20],[5,21],[4,22],[3,21],[-1,-1],[4,14],[4,0]] },
+    'j': { width: 10, points: [[5,21],[6,20],[7,21],[6,22],[5,21],[-1,-1],[6,14],[6,-3],[5,-6],[3,-7],[1,-7]] },
+    'k': { width: 17, points: [[4,21],[4,0],[-1,-1],[14,14],[4,4],[-1,-1],[8,8],[15,0]] },
+    'l': { width: 8, points: [[4,21],[4,0]] },
+    'm': { width: 30, points: [[4,14],[4,0],[-1,-1],[4,10],[7,13],[9,14],[12,14],[14,13],[15,10],[15,0],[-1,-1],[15,10],[18,13],[20,14],[23,14],[25,13],[26,10],[26,0]] },
+    'n': { width: 19, points: [[4,14],[4,0],[-1,-1],[4,10],[7,13],[9,14],[12,14],[14,13],[15,10],[15,0]] },
+    'o': { width: 19, points: [[8,14],[6,13],[4,11],[3,8],[3,6],[4,3],[6,1],[8,0],[11,0],[13,1],[15,3],[16,6],[16,8],[15,11],[13,13],[11,14],[8,14]] },
+    'p': { width: 19, points: [[4,14],[4,-7],[-1,-1],[4,11],[6,13],[8,14],[11,14],[13,13],[15,11],[16,8],[16,6],[15,3],[13,1],[11,0],[8,0],[6,1],[4,3]] },
+    'q': { width: 19, points: [[15,14],[15,-7],[-1,-1],[15,11],[13,13],[11,14],[8,14],[6,13],[4,11],[3,8],[3,6],[4,3],[6,1],[8,0],[11,0],[13,1],[15,3]] },
+    'r': { width: 13, points: [[4,14],[4,0],[-1,-1],[4,8],[5,11],[7,13],[9,14],[12,14]] },
+    's': { width: 17, points: [[14,11],[13,13],[10,14],[7,14],[4,13],[3,11],[4,9],[6,8],[11,7],[13,6],[14,4],[14,3],[13,1],[10,0],[7,0],[4,1],[3,3]] },
+    't': { width: 12, points: [[5,21],[5,4],[6,1],[8,0],[10,0],[-1,-1],[2,14],[9,14]] },
+    'u': { width: 19, points: [[4,14],[4,4],[5,1],[7,0],[10,0],[12,1],[15,4],[-1,-1],[15,14],[15,0]] },
+    'v': { width: 16, points: [[2,14],[8,0],[-1,-1],[14,14],[8,0]] },
+    'w': { width: 22, points: [[3,14],[7,0],[-1,-1],[11,14],[7,0],[-1,-1],[11,14],[15,0],[-1,-1],[19,14],[15,0]] },
+    'x': { width: 17, points: [[3,14],[14,0],[-1,-1],[14,14],[3,0]] },
+    'y': { width: 16, points: [[2,14],[8,0],[-1,-1],[14,14],[8,0],[6,-4],[4,-6],[2,-7],[1,-7]] },
+    'z': { width: 17, points: [[14,14],[3,0],[-1,-1],[3,14],[14,14],[-1,-1],[3,0],[14,0]] },
+    '{': { width: 14, points: [[9,25],[7,24],[6,23],[5,21],[5,19],[6,17],[7,16],[8,14],[8,12],[6,10],[-1,-1],[7,24],[6,22],[6,20],[7,18],[8,17],[9,15],[9,13],[8,11],[4,9],[8,7],[9,5],[9,3],[8,1],[7,0],[6,-2],[6,-4],[7,-6],[-1,-1],[6,8],[8,6],[8,4],[7,2],[6,1],[5,-1],[5,-3],[6,-5],[7,-6],[9,-7]] },
+    '|': { width: 8, points: [[4,25],[4,-7]] },
+    '}': { width: 14, points: [[5,25],[7,24],[8,23],[9,21],[9,19],[8,17],[7,16],[6,14],[6,12],[8,10],[-1,-1],[7,24],[8,22],[8,20],[7,18],[6,17],[5,15],[5,13],[6,11],[10,9],[6,7],[5,5],[5,3],[6,1],[7,0],[8,-2],[8,-4],[7,-6],[-1,-1],[8,8],[6,6],[6,4],[7,2],[8,1],[9,-1],[9,-3],[8,-5],[7,-6],[5,-7]] },
+    '~': { width: 24, points: [[3,6],[3,8],[4,11],[6,12],[8,12],[10,11],[14,8],[16,7],[18,7],[20,8],[21,10],[-1,-1],[3,8],[4,10],[6,11],[8,11],[10,10],[14,7],[16,6],[18,6],[20,7],[21,10],[21,12]] },
+
+// Miscellaneous glyphs (EAM)
+129: { width: 18, points: [[2,-2],[2,21],[16,21],[16,-2],[2,-2]] },
+176: { width: 8, points: [[3,22],[1,20],[1,18],[3,16],[5,16],[7,18],[7,20],[5,22],[3,22]]},
+197: { width: 18, points: [[9,18],[1,0],[-1,-1],[9,18],[17,0],[-1,-1],[4,7],[14,7],[-1,-1], [8,22],[6,20],[6,18],[8,16],[10,16],[12,18],[12,20],[10,22],[8,22]]},
+215: { width: 26, points: [[6,17],[20,3],[-1,-1],[6,3],[20,17]] }
+};
+
+CanvasTextFunctions.letter = function (ch)
+{
+    glyph = CanvasTextFunctions.letters[ch];
+
+    // EAM - Draw an empty box for undefined glyphs
+    if (glyph == undefined)
+	glyph = CanvasTextFunctions.letters[129];
+
+    return glyph;
+}
+
+CanvasTextFunctions.ascent = function( font, size)
+{
+    return size;
+}
+
+CanvasTextFunctions.descent = function( font, size)
+{
+    return 7.0*size/25.0;
+}
+
+CanvasTextFunctions.measure = function( font, size, str)
+{
+    var total = 0;
+    var len = str.length;
+
+    for ( i = 0; i < len; i++) {
+        var index = str.charAt(i);
+	// EAM deal with non-ascii characaters
+	if (index > '~')
+	    index = str.charCodeAt(i);
+
+	var c = CanvasTextFunctions.letter(index);
+	if (c) total += c.width * size / 25.0;
+    }
+    return total;
+}
+
+CanvasTextFunctions.draw = function(ctx,font,size,x,y,str)
+{
+    var total = 0;
+    var len = str.length;
+    var mag = size / 25.0;
+
+    ctx.save();
+    ctx.lineCap = "round";
+    ctx.lineWidth = 2.0 * mag;
+
+    for ( i = 0; i < len; i++) {
+        var index = str.charAt(i);
+	// EAM deal with non-ascii characaters
+	if (index > '~')
+	    index = str.charCodeAt(i);
+
+	var c = CanvasTextFunctions.letter(index);
+	if ( !c) continue;
+
+	ctx.beginPath();
+
+	var penUp = 1;
+	var needStroke = 0;
+	for ( j = 0; j < c.points.length; j++) {
+	    var a = c.points[j];
+	    if ( a[0] == -1 && a[1] == -1) {
+		penUp = 1;
+		continue;
+	    }
+	    if ( penUp) {
+		ctx.moveTo( x + a[0]*mag, y - a[1]*mag);
+		penUp = false;
+	    } else {
+		ctx.lineTo( x + a[0]*mag, y - a[1]*mag);
+	    }
+	}
+	ctx.stroke();
+	x += c.width*mag;
+    }
+    ctx.restore();
+    return total;
+}
+
+CanvasTextFunctions.enable = function( ctx)
+{
+    ctx.drawText = function(font,size,x,y,text) { return CanvasTextFunctions.draw( ctx, font,size,x,y,text); };
+    ctx.measureText = function(font,size,text) { return CanvasTextFunctions.measure( font,size,text); };
+    ctx.fontAscent = function(font,size) { return CanvasTextFunctions.ascent(font,size); }
+    ctx.fontDescent = function(font,size) { return CanvasTextFunctions.descent(font,size); }
+
+    ctx.drawTextRight = function(font,size,x,y,text) { 
+	var w = CanvasTextFunctions.measure(font,size,text);
+	return CanvasTextFunctions.draw( ctx, font,size,x-w,y,text); 
+    };
+    ctx.drawTextCenter = function(font,size,x,y,text) { 
+	var w = CanvasTextFunctions.measure(font,size,text);
+	return CanvasTextFunctions.draw( ctx, font,size,x-w/2,y,text); 
+    };
+}
+
diff -rupN C:\gnuplot-4.4.0\term/js/.svn/text-base/gnuplot_common.js.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/js/.svn/text-base/gnuplot_common.js.svn-base
--- C:\gnuplot-4.4.0\term/js/.svn/text-base/gnuplot_common.js.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/js/.svn/text-base/gnuplot_common.js.svn-base	2012-01-03 17:07:33.884851100 -0800
@@ -0,0 +1,112 @@
+/*
+ * $Id: gnuplot_common.js,v 1.2 2009/05/29 03:14:48 sfeam Exp $
+ */
+// Shared helper routines for gnuplot's canvas terminal driver.
+// Link to this file by reference rather than including the function definitions
+// in every *.js file produced by the canvas terminal.
+//
+function L(x,y) {
+  if (zoomed) {
+    zoom = zoomXY(x/10.0,y/10.0);
+    ctx.lineTo(zoom.x,zoom.y);
+  } else
+    ctx.lineTo(x/10.0,y/10.0);
+}
+function M(x,y) {
+  if (zoomed) {
+    zoom = zoomXY(x/10.0,y/10.0);
+    ctx.moveTo(zoom.x,zoom.y);
+  } else
+    ctx.moveTo(x/10.0,y/10.0);
+}
+function R(x,y,w,h) {
+  if (zoomed) {
+    zoom = zoomXY(x/10.0,y/10.0);
+    ctx.fillRect(zoom.x, zoom.y, zoomW(w/10.0), zoomH(h/10.0));
+  } else
+    ctx.fillRect(x/10.0, y/10.0, w/10.0, h/10.0);
+}
+function T(x,y,fontsize,justify,string) {
+  xx = x/10.0; yy = y/10.0;
+  if (zoomed) {
+    zoom = zoomXY(xx,yy);
+    if (zoom.clip) return;
+    xx = zoom.x; yy = zoom.y;
+    if (plot_xmin < xx && xx < plot_xmax && plot_ybot > yy && yy > plot_ytop)
+      if ((typeof(zoom_text) != "undefined") && (zoom_text == true))
+	fontsize = Math.sqrt(zoomW(fontsize)*zoomH(fontsize));
+  }
+  if (justify=="") ctx.drawText("sans", fontsize, xx, yy, string);
+  else if (justify=="Right") ctx.drawTextRight("sans", fontsize, xx, yy, string);
+  else if (justify=="Center") ctx.drawTextCenter("sans", fontsize, xx, yy, string);
+}
+function TR(x,y,angle,fontsize,justify,string) {
+  ctx.save(); xx = x/10.0; yy = y/10.0;
+  if (zoomed) {zoom = zoomXY(xx,yy); ctx.translate(zoom.x,zoom.y);}
+  else ctx.translate(xx,yy);
+  ctx.rotate(angle * Math.PI / 180);
+  if (justify=="") ctx.drawText("sans", fontsize, 0, 0, string);
+  else if (justify=="Right") ctx.drawTextRight("sans", fontsize, 0, 0, string);
+  else if (justify=="Center") ctx.drawTextCenter("sans", fontsize, 0, 0, string);
+  ctx.restore();
+}
+function bp(x,y) // begin polygon
+    { ctx.beginPath(); M(x,y); }
+function cfp() // close and fill polygon
+    { ctx.closePath(); ctx.fill(); }
+function cfsp() // close and fill polygon with stroke color
+    { ctx.closePath(); ctx.fillStyle = ctx.strokeStyle; ctx.fill(); }
+function Dot(x,y) {
+    xx = x; yy = y;
+    if (zoomed) {zoom = zoomXY(xx,yy); xx = zoom.x; yy = zoom.y; if (zoom.clip) return;}
+    ctx.strokeRect(xx,yy,0.5,0.5);
+}
+function Pt(N,x,y,w) {
+    xx = x; yy = y;
+    if (zoomed) {zoom = zoomXY(xx,yy); xx = zoom.x; yy = zoom.y; if (zoom.clip) return;}
+    switch (N)
+    {
+    case 0:
+	ctx.beginPath();
+	ctx.moveTo(xx-w,yy); ctx.lineTo(xx+w,yy);
+	ctx.moveTo(xx,yy-w); ctx.lineTo(xx,yy+w);
+	ctx.stroke();
+	break;
+    case 1:
+	ww = w * 3/4;
+	ctx.beginPath();
+	ctx.moveTo(xx-ww,yy-ww); ctx.lineTo(xx+ww,yy+ww);
+	ctx.moveTo(xx+ww,yy-ww); ctx.lineTo(xx-ww,yy+ww);
+	ctx.stroke();
+	break;
+    case 2:
+	Pt(0,x,y,w); Pt(1,x,y,w);
+	break;
+    case 3:
+	ctx.strokeRect(xx-w/2,yy-w/2,w,w);
+	break;
+    case 4:
+	ctx.save(); ctx.strokeRect(xx-w/2,yy-w/2,w,w); ctx.restore();
+	ctx.fillRect(xx-w/2,yy-w/2,w,w);
+	break;
+    case 5:
+	ctx.beginPath(); ctx.arc(xx,yy,w/2,0,Math.PI*2,true); ctx.stroke();
+	break;
+    default:
+    case 6:
+	ctx.beginPath(); ctx.arc(xx,yy,w/2,0,Math.PI*2,true); ctx.fill();
+	break;
+    case 7:
+	ctx.beginPath();
+	ctx.moveTo(xx,yy-w); ctx.lineTo(xx-w,yy+w/2); ctx.lineTo(xx+w,yy+w/2);
+	ctx.closePath();
+	ctx.stroke();
+	break;
+    case 8:
+	ctx.beginPath();
+	ctx.moveTo(xx,yy-w); ctx.lineTo(xx-w,yy+w/2); ctx.lineTo(xx+w,yy+w/2);
+	ctx.closePath();
+	ctx.fill();
+	break;
+    }
+}
diff -rupN C:\gnuplot-4.4.0\term/js/.svn/text-base/gnuplot_mouse.css.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/js/.svn/text-base/gnuplot_mouse.css.svn-base
--- C:\gnuplot-4.4.0\term/js/.svn/text-base/gnuplot_mouse.css.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/js/.svn/text-base/gnuplot_mouse.css.svn-base	2012-01-03 17:07:34.067324300 -0800
@@ -0,0 +1,15 @@
+canvas		{ border:0; background-color: white; }
+td.mousebox	{ vertical-align: top; }
+td.mbh		{ height: 16pt; }
+td.mb0		{ text-align: left; font-size: smaller; width: 20; padding-left: 15;
+		  color:#000; background-color: #EEE}
+td.mb1		{ text-align: left; font-size: smaller; width: 80; padding-left: 15;
+		  color:#070; background-color: #EEE}
+td.icon		{ width:  16; height: 16;
+		  background-color: #EEE}
+table.mbleft	{ border-collapse: collapse; border: 0; margin-left: auto; margin-right: auto; }
+table.mbright	{ border-collapse: collapse; border: 0; margin-left: 0; margin-right: auto; }
+table.mbunder	{ border-collapse: collapse; border: 0; margin-left: auto; margin-right: auto; }
+table.plot	{ border-collapse: collapse; border: 0; margin-left: auto; margin-right: auto; }
+table.mousebox	{ border-collapse: collapse; margin-left: 0; margin-right: 10; }
+div.gnuplot	{ background-color: white; }
diff -rupN C:\gnuplot-4.4.0\term/js/.svn/text-base/gnuplot_mouse.js.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/js/.svn/text-base/gnuplot_mouse.js.svn-base
--- C:\gnuplot-4.4.0\term/js/.svn/text-base/gnuplot_mouse.js.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/js/.svn/text-base/gnuplot_mouse.js.svn-base	2012-01-03 17:07:34.254810500 -0800
@@ -0,0 +1,389 @@
+/*
+ * $Id: gnuplot_mouse.js,v 1.7 2009/05/30 17:55:42 sfeam Exp $
+ */
+// Mousing code for use with gnuplot's 'canvas' terminal driver.
+// The functions defined here assume that the javascript plot produced by
+// gnuplot initializes the plot boundary and scaling parameters.
+
+var mousex = 0;
+var mousey = 0;
+var plotx = 0;
+var ploty = 0;
+var scaled_x = 0;
+var scaled_y = 0;
+
+// These will be initialized by the gnuplot canvas-drawing function
+var plot_xmin = 0;
+var plot_xmax = 0;
+var plot_ybot = 0;
+var plot_ytop = 0;
+var plot_width  = 0
+var plot_height = 0
+var plot_term_ymax = 0;
+var plot_axis_xmin = 0;
+var plot_axis_xmax = 0;
+var plot_axis_width  = 0;
+var plot_axis_height = 0;
+var plot_axis_ymin = 0;
+var plot_axis_ymax = 0;
+var plot_axis_x2min = "none";
+var plot_axis_y2min = "none";
+var plot_logaxis_x = 0;
+var plot_logaxis_y = 0;
+var grid_lines = true;
+var zoom_text = false;
+
+// These are the equivalent parameters while zooming
+var zoom_axis_xmin = 0;
+var zoom_axis_xmax = 0;
+var zoom_axis_ymin = 0;
+var zoom_axis_ymax = 0;
+var zoom_axis_x2min = 0;
+var zoom_axis_x2max = 0;
+var zoom_axis_y2min = 0;
+var zoom_axis_y2max = 0;
+var zoom_axis_width = 0;
+var zoom_axis_height = 0;
+var zoom_temp_xmin = 0;
+var zoom_temp_ymin = 0;
+var zoom_temp_x2min = 0;
+var zoom_temp_y2min = 0;
+var zoom_in_progress = false;
+
+function gnuplot_init()
+{
+  if (document.getElementById("gnuplot_canvas"))
+      document.getElementById("gnuplot_canvas").onmousemove = mouse_update;
+  if (document.getElementById("gnuplot_canvas"))
+      document.getElementById("gnuplot_canvas").onmouseup = zoom_in;
+  if (document.getElementById("gnuplot_canvas"))
+      document.getElementById("gnuplot_canvas").onmousedown = saveclick;
+  if (document.getElementById("gnuplot_canvas"))
+      document.getElementById("gnuplot_canvas").onkeypress = do_hotkey;
+  if (document.getElementById("gnuplot_grid_icon"))
+      document.getElementById("gnuplot_grid_icon").onmouseup = toggle_grid;
+  if (document.getElementById("gnuplot_textzoom_icon"))
+      document.getElementById("gnuplot_textzoom_icon").onmouseup = toggle_zoom_text;
+  if (document.getElementById("gnuplot_rezoom_icon"))
+      document.getElementById("gnuplot_rezoom_icon").onmouseup = rezoom;
+  if (document.getElementById("gnuplot_unzoom_icon"))
+      document.getElementById("gnuplot_unzoom_icon").onmouseup = unzoom;
+  mouse_update();
+}
+
+function getMouseCoordsWithinTarget(event)
+{
+	var coords = { x: 0, y: 0};
+
+	if(!event) // then we're in a non-DOM (probably IE) browser
+	{
+		event = window.event;
+		if (event) {
+			coords.x = event.offsetX;
+			coords.y = event.offsetY;
+		}
+	}
+	else		// we assume DOM modeled javascript
+	{
+		var Element = event.target ;
+		var CalculatedTotalOffsetLeft = 0;
+		var CalculatedTotalOffsetTop = 0 ;
+
+		while (Element.offsetParent)
+ 		{
+ 			CalculatedTotalOffsetLeft += Element.offsetLeft ;     
+			CalculatedTotalOffsetTop += Element.offsetTop ;
+ 			Element = Element.offsetParent ;
+ 		}
+
+		coords.x = event.pageX - CalculatedTotalOffsetLeft ;
+		coords.y = event.pageY - CalculatedTotalOffsetTop ;
+	}
+
+	mousex = coords.x;
+	mousey = coords.y;
+}
+
+
+function mouse_update(e)
+{
+  getMouseCoordsWithinTarget(e);
+
+  plotx = mousex - plot_xmin;
+  ploty = -(mousey - plot_ybot);
+
+  // Limit tracking to the interior of the plot
+  if (plotx < 0 || ploty < 0) return;
+  if (mousex > plot_xmax || mousey < plot_ytop) return;
+
+  var axis_xmin = (zoomed) ? zoom_axis_xmin : plot_axis_xmin;
+  var axis_xmax = (zoomed) ? zoom_axis_xmax : plot_axis_xmax;
+  var axis_ymin = (zoomed) ? zoom_axis_ymin : plot_axis_ymin;
+  var axis_ymax = (zoomed) ? zoom_axis_ymax : plot_axis_ymax;
+
+    if (plot_logaxis_x != 0) {
+	x = Math.log(axis_xmax) - Math.log(axis_xmin);
+	x = x * (plotx / (plot_xmax-plot_xmin)) + Math.log(axis_xmin);
+	x = Math.exp(x);
+    } else {
+	x =  axis_xmin + (plotx / (plot_xmax-plot_xmin)) * (axis_xmax - axis_xmin);
+    }
+
+    if (plot_logaxis_y != 0) {
+	y = Math.log(axis_ymax) - Math.log(axis_ymin);
+	y = y * (-ploty / (plot_ytop-plot_ybot)) + Math.log(axis_ymin);
+	y = Math.exp(y);
+    } else {
+	y =  axis_ymin - (ploty / (plot_ytop-plot_ybot)) * (axis_ymax - axis_ymin);
+    }
+
+    if (plot_axis_x2min != "none") {
+	axis_x2min = (zoomed) ? zoom_axis_x2min : plot_axis_x2min;
+	axis_x2max = (zoomed) ? zoom_axis_x2max : plot_axis_x2max;
+	x2 =  axis_x2min + (plotx / (plot_xmax-plot_xmin)) * (axis_x2max - axis_x2min);
+	if (document.getElementById(active_plot_name + "_x2"))
+	    document.getElementById(active_plot_name + "_x2").innerHTML = x2.toPrecision(4);
+    }
+    if (plot_axis_y2min != "none") {
+	axis_y2min = (zoomed) ? zoom_axis_y2min : plot_axis_y2min;
+	axis_y2max = (zoomed) ? zoom_axis_y2max : plot_axis_y2max;
+	y2 = axis_y2min - (ploty / (plot_ytop-plot_ybot)) * (axis_y2max - axis_y2min);
+	if (document.getElementById(active_plot_name + "_y2"))
+	    document.getElementById(active_plot_name + "_y2").innerHTML = y2.toPrecision(4);
+    }
+
+  if (document.getElementById(active_plot_name + "_x"))
+      document.getElementById(active_plot_name + "_x").innerHTML = x.toPrecision(4);
+  if (document.getElementById(active_plot_name + "_y"))
+      document.getElementById(active_plot_name + "_y").innerHTML = y.toPrecision(4);
+
+  // Echo the zoom box interactively
+  if (zoom_in_progress) {
+    ctx.strokeStyle="rgba(128,128,128,0.20)";
+    ctx.strokeRect(
+	plot_xmin + zoom_temp_plotx,  plot_ybot - zoom_temp_ploty,
+	plotx - zoom_temp_plotx, -(ploty - zoom_temp_ploty));
+  }
+}
+
+function saveclick(event)
+{
+  mouse_update(event);
+  
+  // Limit tracking to the interior of the plot
+  if (plotx < 0 || ploty < 0) return;
+  if (mousex > plot_xmax || mousey < plot_ytop) return;
+
+  if (event.which == null) 	/* IE case */
+    button= (event.button < 2) ? "LEFT" : ((event.button == 4) ? "MIDDLE" : "RIGHT");
+  else				/* All others */
+    button= (event.which < 2) ? "LEFT" : ((event.which == 2) ? "MIDDLE" : "RIGHT");
+
+  if (button == "LEFT") {
+    ctx.strokeStyle="black";
+    ctx.strokeRect(mousex, mousey, 1, 1);
+    click = " " + x.toPrecision(4) + ", " + y.toPrecision(4);
+    ctx.drawText("sans", 9, mousex, mousey, click);
+  }
+
+  // Save starting corner of zoom box
+  else {
+    zoom_temp_xmin = x;
+    zoom_temp_ymin = y;
+    if (plot_axis_x2min != "none") zoom_temp_x2min = x2;
+    if (plot_axis_y2min != "none") zoom_temp_y2min = y2;
+    // Only used to echo the zoom box interactively
+    zoom_temp_plotx = plotx;
+    zoom_temp_ploty = ploty;
+    zoom_in_progress = true;
+  }
+  return false; // Nobody else should respond to this event
+}
+
+function zoom_in(event)
+{
+  if (!zoom_in_progress)
+    return false;
+
+  mouse_update(event);
+  
+  if (event.which == null) 	/* IE case */
+    button= (event.button < 2) ? "LEFT" : ((event.button == 4) ? "MIDDLE" : "RIGHT");
+  else				/* All others */
+    button= (event.which < 2) ? "LEFT" : ((event.which == 2) ? "MIDDLE" : "RIGHT");
+
+  // Save ending corner of zoom box
+  if (button != "LEFT") {
+    if (x > zoom_temp_xmin) {
+        zoom_axis_xmin = zoom_temp_xmin;
+	zoom_axis_xmax = x;
+	if (plot_axis_x2min != "none") {
+            zoom_axis_x2min = zoom_temp_x2min;
+	    zoom_axis_x2max = x2;
+	}
+    } else {
+        zoom_axis_xmin = x;
+	zoom_axis_xmax = zoom_temp_xmin;
+	if (plot_axis_x2min != "none") {
+            zoom_axis_x2min = x2;
+	    zoom_axis_x2max = zoom_temp_x2min;
+	}
+    }
+    if (y > zoom_temp_ymin) {
+        zoom_axis_ymin = zoom_temp_ymin;
+	zoom_axis_ymax = y;
+	if (plot_axis_y2min != "none") {
+            zoom_axis_y2min = zoom_temp_y2min;
+	    zoom_axis_y2max = y2;
+	}
+    } else {
+        zoom_axis_ymin = y;
+	zoom_axis_ymax = zoom_temp_ymin;
+	if (plot_axis_y2min != "none") {
+            zoom_axis_y2min = y2;
+	    zoom_axis_y2max = zoom_temp_y2min;
+	}
+    }
+    zoom_axis_width = zoom_axis_xmax - zoom_axis_xmin;
+    zoom_axis_height = zoom_axis_ymax - zoom_axis_ymin;
+    zoom_in_progress = false;
+    rezoom(event);
+  }
+  return false; // Nobody else should respond to this event
+}
+
+function toggle_grid(e)
+{
+  if (!grid_lines) grid_lines = true;
+  else grid_lines = false;
+  ctx.clearRect(0,0,plot_term_xmax,plot_term_ymax);
+  gnuplot_canvas();
+}
+
+function toggle_zoom_text(e)
+{
+  if (!zoom_text) zoom_text = true;
+  else zoom_text = false;
+  ctx.clearRect(0,0,plot_term_xmax,plot_term_ymax);
+  gnuplot_canvas();
+}
+
+function rezoom(e)
+{
+  if (zoom_axis_width > 0)
+    zoomed = true;
+  ctx.clearRect(0,0,plot_term_xmax,plot_term_ymax);
+  gnuplot_canvas();
+}
+
+function unzoom(e)
+{
+  zoomed = false;
+  ctx.clearRect(0,0,plot_term_xmax,plot_term_ymax);
+  gnuplot_canvas();
+}
+
+function zoomXY(x,y)
+{
+  zoom = new Object;
+  var xreal, yreal;
+
+  zoom.x = x; zoom.y = y; zoom.clip = false;
+
+  if (plot_logaxis_x != 0) {
+	xreal = Math.log(plot_axis_xmax) - Math.log(plot_axis_xmin);
+	xreal = Math.log(plot_axis_xmin) + (x - plot_xmin) * xreal/plot_width;
+	zoom.x = Math.log(zoom_axis_xmax) - Math.log(zoom_axis_xmin);
+	zoom.x = plot_xmin + (xreal - Math.log(zoom_axis_xmin)) * plot_width/zoom.x;
+  } else {
+	xreal = plot_axis_xmin + (x - plot_xmin) * (plot_axis_width/plot_width);
+	zoom.x = plot_xmin + (xreal - zoom_axis_xmin) * (plot_width/zoom_axis_width);
+  }
+  if (plot_logaxis_y != 0) {
+	yreal = Math.log(plot_axis_ymax) - Math.log(plot_axis_ymin);
+	yreal = Math.log(plot_axis_ymin) + (plot_ybot - y) * yreal/plot_height;
+	zoom.y = Math.log(zoom_axis_ymax) - Math.log(zoom_axis_ymin);
+	zoom.y = plot_ybot - (yreal - Math.log(zoom_axis_ymin)) * plot_height/zoom.y;
+  } else {
+	yreal = plot_axis_ymin + (plot_ybot - y) * (plot_axis_height/plot_height);
+	zoom.y = plot_ybot - (yreal - zoom_axis_ymin) * (plot_height/zoom_axis_height);
+  }
+
+  // Limit the zoomed plot to the original plot area
+  if (x > plot_xmax) {
+    zoom.x = x;
+    if (plot_axis_y2min == "none") {
+      zoom.y = y;
+      return zoom;
+    }
+    if (plot_ybot <= y && y <= plot_ybot + 15)
+      zoom.clip = true;
+  }
+
+  else if (x < plot_xmin)
+    zoom.x = x;
+  else if (zoom.x < plot_xmin)
+    { zoom.x = plot_xmin; zoom.clip = true; }
+  else if (zoom.x > plot_xmax)
+    { zoom.x = plot_xmax; zoom.clip = true; }
+
+  if (y < plot_ytop) {
+    zoom.y = y;
+    if (plot_axis_x2min == "none") {
+      zoom.x = x; zoom.clip = false;
+      return zoom;
+    }
+  }
+
+  else if (y > plot_ybot)
+    zoom.y = y;
+  else if (zoom.y > plot_ybot)
+    { zoom.y = plot_ybot; zoom.clip = true; }
+  else if (zoom.y < plot_ytop)
+    { zoom.y = plot_ytop; zoom.clip = true; }
+
+  return zoom;
+}
+
+function zoomW(w) { return (w*plot_axis_width/zoom_axis_width); }
+function zoomH(h) { return (h*plot_axis_height/zoom_axis_height); }
+
+function do_hotkey(event) {
+    keychar = String.fromCharCode(event.charCode ? event.charCode : event.keyCode);
+    switch (keychar) {
+    case 'e':	ctx.clearRect(0,0,plot_term_xmax,plot_term_ymax);
+		gnuplot_canvas();
+		break;
+    case 'g':	toggle_grid();
+		break;
+    case 'n':	rezoom();
+		break;
+    case 'r':
+		ctx.lineWidth = 0.5;
+		ctx.strokeStyle="rgba(128,128,128,0.50)";
+		ctx.moveTo(plot_xmin, mousey); ctx.lineTo(plot_xmax, mousey);
+		ctx.moveTo(mousex, plot_ybot); ctx.lineTo(mousex, plot_ytop);
+		ctx.stroke();
+		break;
+    case 'p':
+    case 'u':	unzoom();
+		break;
+    case '':	zoom_in_progress = false;
+		break;
+
+// Arrow keys
+    case '%':	// ctx.drawText("sans", 10, mousex, mousey, "<");
+		break;
+    case '\'':	// ctx.drawText("sans", 10, mousex, mousey, ">");
+		break;
+    case '&':	// ctx.drawText("sans", 10, mousex, mousey, "^");
+		break;
+    case '(':	// ctx.drawText("sans", 10, mousex, mousey, "v");
+		break;
+
+    default:	// ctx.drawText("sans", 10, mousex, mousey, keychar);
+		return true; // Let someone else handle it
+		break;
+    }
+    return false; // Nobody else should respond to this keypress
+}
Files C:\gnuplot-4.4.0\term/js/.svn/text-base/grid.png.svn-base and C:\Users\champioc\workspace\AddiPlot\jni\term/js/.svn/text-base/grid.png.svn-base differ
Files C:\gnuplot-4.4.0\term/js/.svn/text-base/help.png.svn-base and C:\Users\champioc\workspace\AddiPlot\jni\term/js/.svn/text-base/help.png.svn-base differ
Files C:\gnuplot-4.4.0\term/js/.svn/text-base/nextzoom.png.svn-base and C:\Users\champioc\workspace\AddiPlot\jni\term/js/.svn/text-base/nextzoom.png.svn-base differ
Files C:\gnuplot-4.4.0\term/js/.svn/text-base/previouszoom.png.svn-base and C:\Users\champioc\workspace\AddiPlot\jni\term/js/.svn/text-base/previouszoom.png.svn-base differ
Files C:\gnuplot-4.4.0\term/js/.svn/text-base/textzoom.png.svn-base and C:\Users\champioc\workspace\AddiPlot\jni\term/js/.svn/text-base/textzoom.png.svn-base differ
diff -rupN C:\gnuplot-4.4.0\term/lua/.svn/all-wcprops C:\Users\champioc\workspace\AddiPlot\jni\term/lua/.svn/all-wcprops
--- C:\gnuplot-4.4.0\term/lua/.svn/all-wcprops	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/lua/.svn/all-wcprops	2012-01-03 17:08:15.630107300 -0800
@@ -0,0 +1,47 @@
+K 25
+svn:wc:ra_dav:version-url
+V 35
+/svn/!svn/ver/39/trunk/jni/term/lua
+END
+NEWS
+K 25
+svn:wc:ra_dav:version-url
+V 40
+/svn/!svn/ver/39/trunk/jni/term/lua/NEWS
+END
+ChangeLog
+K 25
+svn:wc:ra_dav:version-url
+V 45
+/svn/!svn/ver/39/trunk/jni/term/lua/ChangeLog
+END
+TODO
+K 25
+svn:wc:ra_dav:version-url
+V 40
+/svn/!svn/ver/39/trunk/jni/term/lua/TODO
+END
+INSTALL
+K 25
+svn:wc:ra_dav:version-url
+V 43
+/svn/!svn/ver/39/trunk/jni/term/lua/INSTALL
+END
+gnuplot-tikz.lua
+K 25
+svn:wc:ra_dav:version-url
+V 52
+/svn/!svn/ver/39/trunk/jni/term/lua/gnuplot-tikz.lua
+END
+gnuplot-tikz.help
+K 25
+svn:wc:ra_dav:version-url
+V 53
+/svn/!svn/ver/39/trunk/jni/term/lua/gnuplot-tikz.help
+END
+README
+K 25
+svn:wc:ra_dav:version-url
+V 42
+/svn/!svn/ver/39/trunk/jni/term/lua/README
+END
diff -rupN C:\gnuplot-4.4.0\term/lua/.svn/entries C:\Users\champioc\workspace\AddiPlot\jni\term/lua/.svn/entries
--- C:\gnuplot-4.4.0\term/lua/.svn/entries	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/lua/.svn/entries	2012-01-03 17:08:15.639130700 -0800
@@ -0,0 +1,273 @@
+10
+
+dir
+39
+https://addiplot.googlecode.com/svn/trunk/jni/term/lua
+https://addiplot.googlecode.com/svn
+
+
+
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+svn:special svn:externals svn:needs-lock
+
+
+
+
+
+
+
+
+
+
+
+776c9c97-d481-0677-478a-dd5044256a82
+
+
+
+
+
+
+0
+
+ChangeLog
+file
+
+
+
+
+2012-01-03T23:32:38.743000Z
+bdac12b4069357d5808937a7b2940116
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+8961
+
+INSTALL
+file
+
+
+
+
+2012-01-03T23:32:38.758000Z
+8af6b3a39d350f9f5c83642699640848
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+4354
+
+NEWS
+file
+
+
+
+
+2012-01-03T23:32:38.790000Z
+87ad04bcb6c5a275abc09bea99a68927
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+4497
+
+README
+file
+
+
+
+
+2012-01-03T23:32:38.751000Z
+e7f9dbee5e1b5f99d399e9fc2ac716e9
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+3123
+
+TODO
+file
+
+
+
+
+2012-01-03T23:32:38.765000Z
+c3873ef627ac4080fa97f103e344892a
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+898
+
+gnuplot-tikz.help
+file
+
+
+
+
+2012-01-03T23:32:38.798000Z
+de0c33502f4663c0d9452a9ad07c7eae
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+5256
+
+gnuplot-tikz.lua
+file
+
+
+
+
+2012-01-03T23:32:38.783000Z
+71adedda463105c2b7dcba165ec8011b
+2012-01-04T01:06:11.139921Z
+39
+corbinlc@gmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+57990
+
diff -rupN C:\gnuplot-4.4.0\term/lua/.svn/text-base/ChangeLog.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/lua/.svn/text-base/ChangeLog.svn-base
--- C:\gnuplot-4.4.0\term/lua/.svn/text-base/ChangeLog.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/lua/.svn/text-base/ChangeLog.svn-base	2012-01-03 17:07:38.223101300 -0800
@@ -0,0 +1,322 @@
+2009-03-29  peter
+
+	* [r96] /gnuplot-tikz.lua, /lua.trm: removed duplicate line in docs
+	  minor changes to keep pace with recent the cvs version
+
+2009-03-11  peter
+
+	* [r95] /gnuplot-tikz.lua: fixed revision date parsing again to
+	  work with CVS and SVN
+	* [r94] /gnuplot-tikz.lua: * make plot nodes globally available to
+	  work with gnuplottex
+	  * dummy node for character size calculation was changing the
+	  bounding box
+
+2009-03-02  peter
+
+	* [r93] /INSTALL, /README, /gnuplot-tikz.lua, /lua.trm:
+	  Documentation update.
+	  The TikZ driver help is now included as a subsection of the Lua
+	  terminal.
+	  The help file is generated via 'lua gnuplot-tikz.lua termhelp >
+	  gnuplot-tikz.help'.
+
+2009-02-22  peter
+
+	* [r92] /gnuplot-tikz.lua, /gnuplot.lua, /lua.trm: improved error
+	  handling
+	  gnuplot.lua renamed to gnuplot-tikz.lua
+	  removed option "script" from gnuplot-tikz.lua
+
+2009-02-20  peter
+
+	* [r91] /lua.trm: * Providing a script name is now mandatory, like
+	  set term lua tikz {<term options>}
+	  * Support for script names via the environmental variable
+	  GNUPLOT_LUA_SCRIPT is dropped
+	  * The environmental variable GNUPLOT_DRIVER_DIR can now be
+	  used to change the default search dir
+
+2008-12-20  peter
+
+	* [r90] /Copyright, /gnuplot.lua, /lua.trm: style and color name
+	  changes and small fixes
+	  plot box coordinates are now accessible via a special node
+	  new interface function gp.term_options()
+
+2008-12-09  peter
+
+	* [r89] /COPYING, /Copyright, /INSTALL, /README, /TODO,
+	  /gnuplot.lua, /lua.trm: Changed the license from GPL to gnuplot
+	  license
+
+2008-11-23  peter
+
+	* [r88] /gnuplot.lua: fixed a typo in charsize example code
+	* [r87] /gnuplot.lua: added some example code for charsize
+	  small bugfix on charsize/canvas calculation
+
+2008-11-22  peter
+
+	* [r86] /gnuplot.lua: Straightened the canvas calculation to make
+	  it more easy to change the default sizes.
+	  Changed the default canvas size to 12.5cm x 8.75cm (suggested by
+	  Juergen Wieferink).
+	  In "fulldoc" mode the preview package is now used to clip the
+	  plot (suggested by Juergen Wieferink).
+	  Added north, south, west and east coordinates of the plot area.
+
+2008-02-24  peter
+
+	* [r85] /gnuplot.lua: new option `charsize'
+
+2008-02-02  peter
+
+	* [r84] /test.2.gnu, /test.tex: only minor changes in the demo
+	  files
+
+2008-01-29  peter
+
+	* [r83] /gnuplot.lua: minor "pretty printing" changes
+
+2008-01-27  peter
+
+	* [r82] /gnuplot.lua: some internal renaming
+	* [r81] /INSTALL, /gnuplot.lua, /lua.trm: keeping pace with gnuplot
+	  4.3 development
+
+2008-01-24  peter
+
+	* [r80] /INSTALL, /README, /gnuplot.lua: documentation update
+	* [r79] /gnuplot.lua, /lua.trm: added pager functionality for help
+	  output
+
+2008-01-17  peter
+
+	* [r78] /gnuplot.lua: added options for CMYK support and for
+	  disabling bitmap rendering
+	* [r77] /gnuplot.lua: fixed "zero length path" bug
+
+2008-01-12  peter
+
+	* [r76] /INSTALL, /lua.trm: added the environment variable
+	  GNUPLOT_LUA_SCRIPT
+
+2008-01-03  peter
+
+	* [r75] /lua.trm: fixing the latest changes
+	* [r74] /lua.trm: Initialize term->tscale for gnuplot 4.3
+
+2007-12-22  peter
+
+	* [r73] /INSTALL, /gnuplot.lua, /lua.trm: small adaptions to the
+	  most recent CVS version
+
+2007-11-03  peter
+
+	* [r72] /gnuplot.lua: gnuplottex support
+	  some minor changes
+
+2007-10-11  peter
+
+	* [r71] /gnuplot.lua: fixed the option parser fix and improved
+	  error reporting
+
+2007-10-10  peter
+
+	* [r70] /README, /TODO, /gnuplot.lua: gnuplot arrow styles to TikZ
+	  mapping
+	  cmyk support for image data
+	  some minor bugfixes (parser, "path redundencies", color value
+	  rounding)
+
+2007-09-29  peter
+
+	* [r69] /TODO, /gnuplot.lua, /lua.trm, /test.tex: new option
+	  'providevars'
+	  new color scheme and dash styles
+	  small option parser fixes
+	  bounding box coordinates name change
+
+2007-09-22  peter
+
+	* [r68] /TODO, /test.2.gnu, /test.gnu, /test.tex: examples update
+	* [r67] /gnuplot.lua: the 'smooth' option is now named 'tikzplot'
+
+2007-09-10  peter
+
+	* [r66] /gnuplot.lua: image code now works with tex (dvi/ps),
+	  pdftex and xetex
+
+2007-09-06  peter
+
+	* [r65] /gnuplot.lua: even more work on images
+
+2007-09-04  peter
+
+	* [r64] /gnuplot.lua, /lua.trm: more work on images
+	* [r63] /TODO, /gnuplot.lua, /lua.trm: First support for plotting
+	  images.
+	  API change: Color and fill styles are now passed as strings
+	  instead of integers to the script.
+
+2007-08-31  peter
+
+	* [r62] /TODO:
+
+2007-08-28  peter
+
+	* [r61] /gnuplot.lua: added \gpscalepointstrue \gpscalepointsfalse
+	  cleanups
+	* [r60] /test.2.gnu, /test.tex: only small changes
+	* [r59] /gnuplot.lua: lengths now accept units
+	  more individual gnuplot TikZ-styles
+	  experimental option 'smooth'
+
+2007-08-26  peter
+
+	* [r58] /lua.trm: little clean up
+	  added gp.is_multiplot()
+
+2007-08-25  peter
+
+	* [r57] /TODO, /gnuplot.lua: fixed a compatibility issue with pgf
+	  1.10
+	* [r56] /gnuplot.lua: option parser is more robust
+	* [r55] /gnuplot.lua: debug code removed
+	* [r54] /gnuplot.lua: Fixed rectangle scaling with option
+	  'plotsize'
+
+2007-08-24  peter
+
+	* [r53] /gnuplot.lua: New option 'size'.
+	  Removed 'xscale' and 'yscale'.
+	  Fixed scaling and resizing behavior.
+	  Made styles a little more flexible.
+	* [r52] /INSTALL, /test.2.gnu, /test.tex: more updates
+	* [r51] /README, /TODO: docs update
+	* [r50] /lua.trm: new ouput function for console messages
+
+2007-08-20  peter
+
+	* [r49] /gnuplot.lua, /lua.trm, /test.tex: new option 'createstyle'
+	  fixed a node placement bug in the lua script and tikz style
+
+2007-08-13  peter
+
+	* [r48] /gnuplot.lua, /test.tex: fixed scaling and aspect ratio of
+	  tic marks
+
+2007-08-12  peter
+
+	* [r47] /test.tex:
+	* [r46] /test.tex:
+	* [r45] /demo.gnu, /demo.tex, /test.gnu, /test.tex: new test file
+	* [r44] /demo.gnu, /demo.tex, /gnuplot.lua, /test.2.gnu, /test.gnu:
+	  new options 'originreset' and 'plotsize x,y'
+
+2007-08-08  peter
+
+	* [r43] /INSTALL, /README, /TODO, /gnuplot.lua: new terminal option
+	  'nopicenvironment'
+	  fixed gfx.format_color() call in term.filled_polygon()
+
+2007-07-09  peter
+
+	* [r42] /gnuplot.lua, /lua.trm: lots of internal api changes
+	  new options gparrows and gppoints
+	  debugging code removed
+
+2007-07-03  peter
+
+	* [r41] /README.terminal, /TODO, /gnuplot.lua, /lua.trm: linetype
+	  now set via \gpsetlinetype;
+	  changed bounding box determination;
+	  mapping for function 'layer'
+
+2007-07-01  peter
+
+	* [r40] /INSTALL, /gnuplot.lua: direkte Erzeugung des Style-Files,
+	  Hilfe auf der Kommandozeile
+	* [r39] /gnuplot.lua: Bugfix aus vorangegangener Revision
+	* [r38] /gnuplot.lua: mehr Infos im Style-File
+	* [r37] /README, /gnuplot.lua: neue Hilfsmakros \gpsetlinewidth,
+	  \gpsetpointsize und \gppoint
+
+2007-06-28  peter
+
+	* [r36] /INSTALL, /README, /TODO, /gnuplot.lua: Tippfehler und
+	  Doku, plotmarks haben nun eine eigene Basisgre
+
+2007-06-27  peter
+
+	* [r35] /INSTALL, /gnuplot.lua: filldraw zurckgenommen
+
+2007-06-26  peter
+
+	* [r34] /TODO, /gnuplot.lua, /lua.trm, /test.gnu: bugfixes,
+	  kompaktere Ausgabe
+
+2007-06-25  peter
+
+	* [r33] /README, /TODO, /gnuplot.lua, /test.gnu: erzeugter Code ist
+	  etwas kompakter
+
+2007-06-24  peter
+
+	* [r32] /gnuplot.lua, /lua.trm: + ein paar Tippfehler gefixed
+	  + Initialisierung der Terminalvariablen berarbeitet
+	* [r31] /gnuplot.lua, /lua.trm, /test.gnu: neue Optionen 'xscale'
+	  und 'yscale'
+	  single und double quote strings in Optionen
+	  Koordinaten der Bounding-Box des Plots zugnglich gemacht
+	  Hilfe erweitert
+
+2007-06-23  peter
+
+	* [r30] /gnuplot.lua, /lua.trm: Koordinaten der bounding box des
+	  Plots sind nun verfgbar
+	* [r29] /gnuplot.lua, /lua.trm: Aufrumarbeiten
+
+2007-06-21  peter
+
+	* [r28] /gnuplot.lua, /lua.trm: filled_polygon API gendert
+
+2007-06-20  peter
+
+	* [r27] /gnuplot.lua, /lua.trm: Umbenennungen
+	  ein kleiner bugfix
+	  "Auflsung" reduziert
+	* [r26] /INSTALL, /TODO, /gnuplot.lua, /lua.trm, /test.gnu: einige
+	  Konstanten nach lua.trm verschoben
+	  Initialisierung des lua-Skriptes gendert
+
+2007-06-18  peter
+
+	* [r25] /gnuplot.lua, /test.gnu: typo gefixed
+	  option preamble mehrfach mglich
+	* [r24] /gnuplot.lua, /lua.trm, /test.gnu: hilfe erweitert
+	* [r23] /README, /gnuplot.lua, /test.gnu: neue optionen font (fr
+	  default font), scale
+	  set_font untersttzung
+	* [r22] /gnuplot.lua, /lua.trm: lua terminal revision zugnglich
+	  gemacht
+	* [r21] /gnuplot.lua, /lua.trm, /test.gnu: gnuplot version nun
+	  direkt via variablen zugnglich
+	* [r20] /gnuplot.lua, /lua.trm: besseres skript handling
+	  neue funktion gp.version()
+	  bugfixes
+
+2007-06-17  peter
+
+	* [r19] /gnuplot.lua, /lua.trm, /test.gnu: lua optionen parser
+	  kennt nun auch abkrzungen wie in gnuplot
+	* [r18] /gnuplot.lua, /lua.trm, /test.gnu: verbesserte
+	  Fehlerbehandlung
+	  bugfixes
+	* [r17] /TODO, /gnuplot.lua, /lua.trm, /test.gnu: Optionen Parser
+	  im Skript
+	  bugfixes
+	* [r16] /lua.trm: verbesserte fehlerbehandlung
+	  terminal wertet die option "script" aus :-)
+
diff -rupN C:\gnuplot-4.4.0\term/lua/.svn/text-base/INSTALL.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/lua/.svn/text-base/INSTALL.svn-base
--- C:\gnuplot-4.4.0\term/lua/.svn/text-base/INSTALL.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/lua/.svn/text-base/INSTALL.svn-base	2012-01-03 17:07:38.470743500 -0800
@@ -0,0 +1,187 @@
+
+
+This document consists of brief installation instructions of the GNUPLOT Lua
+terminal for
+
+  * Unix like systems
+  * MS Windows
+  * Mac OS X Leopard 
+
+
+
+
+Requirements
+============
+
+Since this software comes as a patch to the gnuplot sources and
+also uses Lua you need to get the following software before
+installation:
+
+  1. gnuplot 4.2 or 4.3cvs sources from http://gnuplot.sourceforge.net
+  
+  2. a working Lua 5.1 installation e.g. from http://www.lua.org
+     or http://lua-users.org/wiki/LuaBinaries
+
+  3. since the only supported backend is PGF/TikZ you may also
+     want to install the PGF/TikZ packages from
+     http://www.ctan.org/tex-archive/help/Catalogue/entries/pgf.html
+     or http://sourceforge.net/projects/pgf/
+
+
+
+Installation on Unix-like systems
+=================================
+
+  1. compile gnuplot 
+
+  2. copy lua.trm to "<gnuplot_src_path>/term/"
+
+  3. add the line 
+      
+       #include "lua.trm"
+    
+     at the bottom of <gnuplot_src_path>/src/term.h
+
+  4. modify <gnuplot_src_path>/src/Makefile, so that gnuplot
+     links against lua by adding e.g. `-llua' to LIBS:
+    
+       LIBS = -lm -llua
+
+     You may also have to adapt the include path in regard
+     to your Lua installation.
+
+  5. run "make" and "make install" again
+
+  6. call gnuplot.lua with the parameter 'style' to
+     generate the LaTeX style file:
+    
+       # lua gnuplot.lua style
+
+     Or from the gnuplot console:
+     
+       > set term lua createstyle
+     
+     The basename of the LaTeX style file is defined in the
+     'pgf.LATEX_STYLE_FILE' variable (currently set to
+     'gnuplot-lua-tikz').
+
+  7. try e.g. the example file:
+     
+       # gnuplot test.gnu
+       # pdflatex test.tex
+
+
+
+Installation on Windows systems
+===============================
+
+  1. see above
+
+  2. see above
+
+  3. see above
+
+  4. edit the makefile, used for the initial build process, similar to
+     the above, so that the Lua library and headers will be found
+
+  4b. in 'lua.trm' the line
+     
+       #define GNUPLOT_LUA_DIR X11_DRIVER_DIR
+   
+     has to be changed, so that GNUPLOT_LUA_DIR points to a directory
+     for the 'gnuplot.lua' script, e.g.:
+     
+       #define GNUPLOT_LUA_DIR "share\luaterm"
+
+
+  5. see above
+
+  6. see above
+
+  7. see above
+
+
+
+Installation on Mac OS X Leopard (Intel)
+(thanks to Federico Maggi)
+========================================
+
+  0. Update the port base (if needed) and get Gnuplot TikZ terminal:
+
+       $ sudo port sync
+       $ cd
+       $ wget http://peter.affenbande.org/gnuplot/gnuplot_lua_terminal.tgz
+       $ tar zxf gnuplot_lua_terminal.tgz
+ 
+
+  1. Install lua 5.1
+
+       $ sudo port install lua
+ 
+  2. Fetch GNUPLOT source (if GNUPLOT is alread installed, uninstall
+     it using $ sudo port uninstall gnuplot)
+
+       $ sudo port -d fetch gnuplot
+
+
+  3. Extract GNUPLOT and configure it
+
+       $ sudo port -d extract gnuplot
+       $ sudo port -d configure gnuplot
+
+
+  4. Patch the source code
+
+       $ cd {ports_prefix}/var/macports/build/${portbuildpath}/gnuplot-4.2.3/ 
+         (e.g. /opt/local/var/macports/build/_opt_local_var_macports_sources_rsync.macports.org_release_ports_math_gnuplot/work/gnuplot-4.2.3/ )
+       $ cp ~/gnuplot_lua_terminal/lua.trm term/
+       $ $EDITOR src/term.h
+
+     and add #include "lua.trm" to the bottom of the file.
+     Open the Makefile
+
+       $ $EDITOR src/Makefile 
+     
+     and locate the LIBS variable, append -llua to the other values of LIBS
+     (aquaterm should be there).
+
+
+  5. Build the port
+
+       $ sudo port build gnuplot
+
+
+  6. Install it
+
+       $ sudo port install gnuplot
+
+
+  7. Copy gnuplot.lua
+
+       $ sudo cp ~/gnuplot_lua_terminal/gnuplot.lua ${ports_prefix}/libexec/gnuplot/4.2/
+
+     or define the env variable GNUPLOT_LUA_SCRIPT to place it wherever you want.
+
+
+
+Additional notes
+================
+
+  Please take care, that the gnuplot.lua script is in the search path
+  of gnuplot. This is usually the working directory or the directory
+  defined in X11_DRIVER_DIR/GNUPLOT_LUA_DIR. It is also possible to refer
+  to a script by using the 'script' terminal option or the environment
+  variable GNUPLOT_LUA_SCRIPT.
+
+  For more informations about the Lua terminal options just type
+    > help term lua
+  and
+    > set term lua help
+  from the gnuplot console.
+
+
+  Now use the source :-)
+
+
+-Peter Hedwig <peter(at)affenbande.org>
+
diff -rupN C:\gnuplot-4.4.0\term/lua/.svn/text-base/NEWS.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/lua/.svn/text-base/NEWS.svn-base
--- C:\gnuplot-4.4.0\term/lua/.svn/text-base/NEWS.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/lua/.svn/text-base/NEWS.svn-base	2012-01-03 17:07:38.713372700 -0800
@@ -0,0 +1,115 @@
+2009-03-29
+
+  * Providing a script or target name is now mandatory. The new syntax:
+       set terminal lua <target name> | "<file name>"
+                        {<script_args> ...}
+    This will look for a script named `gnuplot-<target name>.lua' or
+    a script named "<file name>" (in quotes!).
+  * Support for script names via the environmental variable
+    GNUPLOT_LUA_SCRIPT is dropped.
+  * The option "script" is obsolete and also removed.
+  * Via the environmental variable GNUPLOT_DRIVER_DIR the default search
+    directory for driver scripts can be changed.
+  * The TikZ driver help is now included as a subsection of the Lua
+    terminal.
+  * minor bugfixes (see ChangeLog)
+
+  This version drops backward compatibility again!
+
+2008-12-20
+
+  * Removed all underscrores in style and color names.
+  * The plot box coordinates are now accessible via a special node. (e.g.
+    "gp plot 1.north east".
+  * Added aliases 'standalone' ('fulldoc') and 'header' ('preamble')
+  * Preparations to echo back the options string to the user.
+
+  This version drops backward compatibility!
+
+2008-11-22
+
+  * Changed default canvas size to 12.5cm x 8.75cm and use the preview
+    package to clip the plot in 'fulldoc' mode (suggested by Juergen Wieferink).
+  * New option 'charsize'. In conjunction with the gnuplottex.sty the
+    font size can now be determined automatically. (look at the style file for
+    example code).
+  * Removed the default font setting (previously set to "\small").
+
+  No binary updates needed.
+
+2008-02-02
+
+  * Implemented a mapping of gnuplot arrow styles to TikZ arrow styles by
+    "misusing" the angle of the gnuplot arrow definition.
+  * CMYK support for image data (all other colors are handled through the
+    xcolor package).
+  * terminal works with gnuplottex (\begin{gnuplot}[terminal=lua]...)
+    (http://www.ctan.org/tex-archive/help/Catalogue/entries/gnuplottex.html)
+  * compatibility updates for gnuplot 4.3cvs version
+  * optional environment variable GNUPLOT_LUA_SCRIPT
+  * fixed zero length paths artifacts and some more minor bugs
+  * added simple pager functionality for help output
+
+  The Lua script should work with the previous binary version, but the new
+  GNUPLOT_LUA_SCRIPT feature and pager functionality will not be available.
+  Maybe a minor issue for most users ;-)
+
+2007-10-03
+
+  * New option 'providevars' to make gnuplot's internal and user variables
+    available within the TeX-script.
+  * Adopted the color scheme and dash patterns to (largely) resemble the
+    look of the postscript terminal.
+  * Changed the names of the bounding box coordinates from 'lowerleft' to
+    'south west' etc. to be closer to the TikZ naming scheme.
+
+  Binary update needed on upgrade.
+
+2007-09-22
+
+  * Lengths in the 'size' options now accept the units cm, mm, in or inch, pt,
+    pc, bp, dd and cc.
+  * Switched from generic TikZ styles like 'every plot' to gnuplot specific
+    TikZ-styles.
+  * Support for plotting images of pixel and binary 2D-data. For PDF and
+    Postscript generation the image will be included in a native PDF or PS
+    format what reduces space and compile time and improves rendering quality.
+    For the SVG output of PGF/TikZ the 'native image' feature has to be
+    disabled manually. The image will then be rendered of filled rectangles.
+  * Added 'tikzplot' option which allows using the TikZ '\path plot'
+    command instead of the simple '\path' for plots with given linetypes.
+  * Added 'is_multiplot()' to the Lua terminal (currently unused in the
+    TikZ backend).
+  * Changed the Lua-API: Color and fill styles are now passed as strings
+    instead of integers to the script.
+
+  Binary update needed on upgrade.
+
+2007-08-25 ii
+  
+  * Improved robustness of the option parser.
+  * Fixed a PGF/TikZ compatibility issue reported by Scott Murman.
+    
+  No binary update from previous version needed.
+
+
+2007-08-25
+
+  * Fixed rectangle scaling in conjunction with the 'plotsize' option
+    (thanks to Scott Murman for reporting).
+  
+  This update only affects the gnuplot.lua script.
+
+
+2007-08-24
+
+  * A 'size' option for the canvas was added.
+  * The 'scale' option now expects an x and y parameter, so the
+    'xscale' and 'yscale' options where removed. Scaling and resizing
+    now work similar to the other terminals.
+  * The 'monochrome' and 'solid' options do not change the actual
+    TikZ plot commands anymore, but only change the according TikZ
+    style settings.
+
+
+See the 'ChangeLog' file for previous changes.
diff -rupN C:\gnuplot-4.4.0\term/lua/.svn/text-base/README.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/lua/.svn/text-base/README.svn-base
--- C:\gnuplot-4.4.0\term/lua/.svn/text-base/README.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/lua/.svn/text-base/README.svn-base	2012-01-03 17:07:38.990090300 -0800
@@ -0,0 +1,98 @@
+
+Gnuplot PGF/TikZ terminal
+=========================
+
+The PGF/TikZ terminal mainly consists of a generic Lua terminal to
+wrap the gnuplot terminal C functions. This allows writing gnuplot
+terminals in Lua instead of C. The first (and currently only) implemented
+`backend' is the PGF/TikZ terminal for the use with TeX/LaTeX.
+
+The actual terminal functionality is a provided by a separate Lua script
+`gnuplot.lua'. The LaTeX style file is usually derived from PGF/TikZ terminal
+script to keep things consistent.
+
+
+
+Disclaimer
+==========
+
+This terminal is tested with Lua 5.1 and gnuplot 4.2 and 4.3csv,
+and since I am exclusively using Linux it is also mainly tested on
+this platform.
+
+
+
+Why all that hassle?
+====================
+
+There are are couple of terminals allready usable for LaTeX so why
+writing another one?
+
+Here is a brief list of reasons:
+
+ 1. I like PGF/TikZ and there is no such terminal so far.
+ 2. I also like lerning Lua and the use of Lua makes this terminal
+    very versatile, e.g. there is no recompilation necessary if
+    you want to change/add any terminal features and you also gain
+    all the benefits of using a scripting language in this
+    place -- whatever that means to you ;-)
+ 3. Most advantages are directly related to PGF/TikZ:
+    a. rescaling the plot does not automatically change the linewidths
+       nor the size of points (aka plot marks), fonts, arrow tips or
+       fill patterns. The aspect ratio of these elements will also
+       remain unchanged on unproportional scalings.
+    b. you can directly produce documents of any output format
+       that is supported by PGF/TikZ.
+    c. changing the appearance of the plots is an easy task even
+       after the generation of the PGF/TikZ code. This can be done
+       locally or globally by changing certain TikZ-styles or
+       dimensions.
+    d. it is also easy to put the keys (aka legend) into the normal text
+       area (e.g. the plot caption), because the line and plotmark styles
+       are available.
+    e. overlaying of the plot with e.g. additional nodes, arrows etc. is 
+       possible through the use the of tikz coordinates of the actual
+       plotting area (at least on 2D plots).
+
+For more reasons please have a look at the PGF/TikZ manual ;-)
+
+
+Usage
+=====
+
+The usage is quite similar to the other terminals with the difference that
+most terminal options are processed by the external Lua script. To see the
+list of additional script options just type
+  gnuplot> set term lua help
+or
+  # lua gnuplot.lua
+on the command line.
+
+
+A minimalist gnuplot session (or script) may look like this:
+  
+> set term lua          # activate the Lua terminal and load "gnuplot.lua"
+> set out 'test.tex'    # write output to file 'test.tex'
+> plot x*x              # plot a nice parabola
+
+The generated file `test.tex' can be used by simply adding the line
+
+ \input{test.tex}
+
+to your LaTeX document and by adding
+
+ \usepackage{gnuplot-lua-tikz}
+
+to the preamble.
+
+
+
+
+
+Any comments, suggestions and bug reports are most welcome and should go
+to <peter(at)affenbande.org>.
+
+Have fun!
+
+-Peter Hedwig <peter@affenbande.org>
+
diff -rupN C:\gnuplot-4.4.0\term/lua/.svn/text-base/TODO.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/lua/.svn/text-base/TODO.svn-base
--- C:\gnuplot-4.4.0\term/lua/.svn/text-base/TODO.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/lua/.svn/text-base/TODO.svn-base	2012-01-03 17:07:39.198631100 -0800
@@ -0,0 +1,25 @@
+TODO
+====
+
+Autoconf
+
+ * liblua is not always named liblua;  can we autodetect its name?
+   EAM: Yes, via the AC_SEARCH_LIBS macro in configure.in
+ * where to install gnuplot-lua-tikz.sty?  Versioning?
+   EAM: I moved this file to .../share/LaTeX, where there is already an 
+   installation script for latex support files
+
+Lua generic terminal
+
+ * support color palettes (low priority, not really needed for TikZ?)
+ * support enhanced text mode (low priority, not really needed for TikZ)
+ * alpha channel support for image data (need to have a look)?
+   EAM: Seems to work already.  Did you have an example that fails?
+
+TikZ backend
+
+ * alpha channel support for image data (need to have a look)?
+   EAM: The demos for transparency seem to work already
+ * automatic detection of font sizes (via LaTeX test call?! very low priority)
+ * ConTeXt and plain TeX support
+ * switch to pgf 2.0 style system
diff -rupN C:\gnuplot-4.4.0\term/lua/.svn/text-base/gnuplot-tikz.help.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/lua/.svn/text-base/gnuplot-tikz.help.svn-base
--- C:\gnuplot-4.4.0\term/lua/.svn/text-base/gnuplot-tikz.help.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/lua/.svn/text-base/gnuplot-tikz.help.svn-base	2012-01-03 17:07:39.413187500 -0800
@@ -0,0 +1,117 @@
+"",
+" The TikZ driver provides the following additional terminal options:",
+"",
+"      {help}",
+"      {monochrome}",
+"      {solid}",
+"      {originreset}",
+"      {gparrows}",
+"      {gppoints}",
+"      {nopicenvironment}",
+"      {size <x>{unit},<y>{unit}}",
+"      {scale <x>,<y>}",
+"      {plotsize <x>{unit},<y>{unit}}",
+"      {charsize <x>{unit},<y>{unit}}",
+"      {font \"<fontdesc>\"}",
+"      {createstyle}",
+"      {fulldoc|standalone}",
+"      {{preamble|header} \"<preamble_string>\"}",
+"      {tikzplot <ltn>,...}",
+"      {tikzarrows}",
+"      {cmykimages}",
+"      {nobitmap}",
+"      {providevars <var name>,...}",
+"",
+" For all options that expect lengths as their arguments they",
+" will default to 'cm' if no unit is specified. For all lengths",
+" the following units may be used: 'cm', 'mm', 'in' or 'inch',",
+" 'pt', 'pc', 'bp', 'dd', 'cc'. Blanks between numbers and units",
+" are not allowed.",
+"",
+" 'monochrome' disables line coloring and switches to grayscaled",
+" fills.",
+"",
+" 'solid' use only solid lines.",
+"",
+" 'originreset' moves the origin of the TikZ picture to the lower",
+" left corner of the plot. It may be used to align several plots",
+" within one tikzpicture environment. This is not tested with",
+" multiplots and pm3d plots!",
+"",
+" 'gparrows' use gnuplot's internal arrow drawing function",
+" instead of the ones provided by TikZ.",
+"",
+" 'gppoints' use gnuplot's internal plotmark drawing function",
+" instead of the ones provided by TikZ.",
+"",
+" 'nopicenvironment' omits the declaration of the 'tikzpicture'",
+" environment in order to set it manually. This permits putting",
+" some PGF/TikZ code directly before or after the plot.",
+"",
+" The 'size' option expects two lenghts <x> and <y> as the canvas size.",
+" The default size of the canvas is 12.5cm x 8.75cm.",
+"",
+" The 'scale' option works similar to the 'size' option but expects",
+" scaling factors <x> and <y> instead of lengths.",
+"",
+" The 'plotsize' option permits setting the size of the plot area",
+" instead of the canvas size, which is the usual gnuplot behaviour.",
+" Using this option may lead to slightly asymmetric tic lengths.",
+" Like 'originreset' this option may not lead to convenient results",
+" if used with multiplots or pm3d plots.",
+"",
+" The 'charsize' option expects the average horizontal and vertical",
+" size of the used font. Look at the generated style file for an",
+" example of how to use it from within your TeX document.",
+"",
+" 'createstyle' derives the LaTeX style file from the script and",
+" writes it to the file 'gnuplot-lua-tikz.sty'.",
+"",
+" 'fulldoc' or 'standalone' produces a full LaTeX document for direct",
+" compilation.",
+"",
+" 'preamble' or 'header' may be used to put any additional LaTeX code",
+" into the document preamble in standalone mode.",
+"",
+" With the 'tikzplot' option the '\\path plot' command will be used",
+" instead of only '\\path'. The following list of numbers of linetypes",
+" (<ltn>,...) defines the affected plotlines. There exists a plotstyle",
+" for every linetype. The default plotstyle is 'smooth' for every",
+" linetype >= 1.",
+"",
+" By using the 'tikzarrows' option the gnuplot arrow styles defined by",
+" the user will be mapped to TikZ arrow styles. This is done by 'misusing'",
+" the angle value of the arrow definition. E.g. an arrow style with the",
+" angle '7' will be mapped to the TikZ style 'gp arrow 7' ignoring all the",
+" other given values. By default the TikZ terminal uses the stealth' arrow",
+" tips for all arrows. To obtain the default gnuplot behaviour please use",
+" the 'gparrows' option.",
+"",
+" With 'cmykimages' the CMYK color model will be used for image data",
+" instead of the RGB model. All other colors (like line colors etc.) are",
+" not affected by this option, since they are handled by the xcolors",
+" package. So take care to change the color model also there if needed.",
+"",
+" The 'nobitmap' option let images be rendered as filled rectangles",
+" instead of the nativ PS or PDF image format. This option has to be",
+" enabled if you intend to use other output formats.",
+"",
+" The 'providevars' options makes gnuplot's internal and user variables",
+" available by using the '\\gpgetvar{<var name>}' commmand within the TeX",
+" script. Use gnuplot's 'show variables all' command to see the list",
+" of valid variables.",
+"",
+" The <fontdesc> string may contain any valid LaTeX font commands like",
+" e.g. '\\small'. It is passed directly as a node parameter in form of",
+" \"font=<fontdesc>\". This can be 'misused' to add further code to a node,",
+" e.g. '\\small,yshift=1ex' or ',yshift=1ex' are also valid while the",
+" latter does not change the current font settings. One exception is",
+" the second argument of the list. If it is a number of the form",
+" <number>{unit} it will be interpreted as a fontsize like in other",
+" terminals and will be appended to the first argument. If the unit is",
+" omitted the value is interpreted as 'pt'. As an example the string",
+" '\\sffamily,12,fill=red' sets the font to LaTeX's sans serif font at",
+" a size of 12pt and red background color.",
+"",
+" Strings have to be put in single or double quotes. Double quoted",
+" strings may contain special characters like newlines '\\n' etc.",
diff -rupN C:\gnuplot-4.4.0\term/lua/.svn/text-base/gnuplot-tikz.lua.svn-base C:\Users\champioc\workspace\AddiPlot\jni\term/lua/.svn/text-base/gnuplot-tikz.lua.svn-base
--- C:\gnuplot-4.4.0\term/lua/.svn/text-base/gnuplot-tikz.lua.svn-base	1969-12-31 16:00:00.000000000 -0800
+++ C:\Users\champioc\workspace\AddiPlot\jni\term/lua/.svn/text-base/gnuplot-tikz.lua.svn-base	2012-01-03 17:07:39.611702300 -0800
@@ -0,0 +1,1944 @@
+--[[
+
+  This is the execution script for the `Lua generic terminal' driver.
+
+  This script provides an interface to the PGF/TikZ package for LaTeX.
+
+
+  Copyright 2008    Peter Hedwig <peter@affenbande.org>
+
+
+
+  Permission to use, copy, and distribute this software and its
+  documentation for any purpose with or without fee is hereby granted,
+  provided that the above copyright notice appear in all copies and
+  that both that copyright notice and this permission notice appear
+  in supporting documentation.
+
+  Permission to modify the software is granted, but not the right to
+  distribute the complete modified source code.  Modifications are to
+  be distributed as patches to the released version.  Permission to
+  distribute binaries produced by compiling modified sources is granted,
+  provided you
+    1. distribute the corresponding source modifications from the
+     released version in the form of a patch file along with the binaries,
+    2. add special version identification to distinguish your version
+     in addition to the base release version number,
+    3. provide your name and address as the primary contact for the
+     support of your modified version, and
+    4. retain our contact information in regard to use of the base
+     software.
+  Permission to distribute the released version of the source code along
+  with corresponding source modifications in the form of a patch file is
+  granted with same provisions 2 through 4 for binary distributions.
+
+  This software is provided "as is" without express or implied warranty
+  to the extent permitted by applicable law.
+
+
+
+  $Date: 2009/06/05 05:37:04 $
+  $Author: sfeam $
+  $Rev: 96 $
+
+]]--
+
+
+
+--[[
+ 
+ `term'   gnuplot term_api -> local interface
+ `gp'     local -> gnuplot interface
+
+  are both initialized by the terminal
+
+]]--
+
+
+--
+-- internal variables
+--
+
+local pgf = {}
+local gfx = {}
+
+-- the terminal default size in cm
+pgf.DEFAULT_CANVAS_SIZE_X = 12.5
+pgf.DEFAULT_CANVAS_SIZE_Y = 8.75
+-- tic default size in cm
+pgf.DEFAULT_TIC_SIZE = 0.18
+-- the terminal resolution in "dots" per cm.
+pgf.DEFAULT_RESOLUTION = 1000
+-- default font size in TeX pt
+pgf.DEFAULT_FONT_SIZE = 10
+
+pgf.LATEX_STYLE_FILE = "gnuplot-lua-tikz"  -- \usepackage{gnuplot-lua-tikz}
+
+pgf.REVISION = string.sub("$Rev: 96a $",7,-3)
+pgf.REVISION_DATE = string.gsub("$Date: 2009/06/05 05:37:04 $",
+                                "$Date: ([0-9]+).([0-9]+).([0-9]+) .*","%1/%2/%3")
+
+pgf.styles = {}
+
+-- the styles are used in conjunction with the 'tikzarrows'
+-- and the style number directly corresponds to the used
+-- angle in the gnuplot style definition
+pgf.styles.arrows = {
+   [1] = {"gp arrow 1", ">=latex"},
+   [2] = {"gp arrow 2", ">=angle 90"},
+   [3] = {"gp arrow 3", ">=angle 60"},
+   [4] = {"gp arrow 4", ">=angle 45"},
+   [5] = {"gp arrow 5", ">=o"},
+   [6] = {"gp arrow 6", ">=*"},
+   [7] = {"gp arrow 7", ">=diamond"},
+   [8] = {"gp arrow 8", ">=open diamond"},
+   [9] = {"gp arrow 9", ">={]}"},
+  [10] = {"gp arrow 10", ">={[}"},
+  [11] = {"gp arrow 11", ">=)"},
+  [12] = {"gp arrow 12", ">=("}
+}
+
+-- plot styles are corresponding with linetypes and must have the same number of entries
+-- see option 'tikzplot' for usage
+pgf.styles.plotstyles_axes = {
+  [1] = {"gp plot axes", ""},
+  [2] = {"gp plot border", ""},
+}
+
+pgf.styles.plotstyles = {
+  [1] = {"gp plot 0", "smooth"},
+  [2] = {"gp plot 1", "smooth"},
+  [3] = {"gp plot 2", "smooth"},
+  [4] = {"gp plot 3", "smooth"},
+  [5] = {"gp plot 4", "smooth"},
+  [6] = {"gp plot 5", "smooth"},
+  [7] = {"gp plot 6", "smooth"},
+  [8] = {"gp plot 7", "smooth"}
+}
+
+pgf.styles.linetypes_axes = {
+  [1] = {"gp lt axes", "dashed"},  -- An lt of -1 is used for the X and Y axes.  
+  [2] = {"gp lt border", "solid"}, -- An lt of -2 is used for the border of the plot.
+}
+
+pgf.styles.linetypes = {
+  [1] = {"gp lt plot 0", "solid"},  -- first graph
+  [2] = {"gp lt plot 1", "dashed"}, -- second ...
+  [3] = {"gp lt plot 2", "dash pattern=on 1.5pt off 2.25pt"},
+  [4] = {"gp lt plot 3", "dash pattern=on \\pgflinewidth off 1.125"},
+  [5] = {"gp lt plot 4", "dash pattern=on 4.5pt off 1.5pt on \\pgflinewidth off 1.5pt"},
+  [6] = {"gp lt plot 5", "dash pattern=on 2.25pt off 2.25pt on \\pgflinewidth off 2.25pt"},
+  [7] = {"gp lt plot 6", "dash pattern=on 1.5pt off 1.5pt on 1.5pt off 4.5pt"},
+  [8] = {"gp lt plot 7", "dash pattern=on \\pgflinewidth off 1.5pt on 4.5pt off 1.5pt on \\pgflinewidth off 1.5pt"}
+}
+
+-- corresponds to pgf.styles.linetypes
+pgf.styles.lt_colors_axes = {
+  [1] = {"gp lt color axes", "black"},
+  [2] = {"gp lt color border", "black"},
+}
+
+pgf.styles.lt_colors = {
+  [1] = {"gp lt color 0", "red"},
+  [2] = {"gp lt color 1", "green!60!black"},
+  [3] = {"gp lt color 2", "blue"},
+  [4] = {"gp lt color 3", "magenta"},
+  [5] = {"gp lt color 4", "cyan"},
+  [6] = {"gp lt color 5", "orange"},
+  [7] = {"gp lt color 6", "yellow!80!red"},
+  [8] = {"gp lt color 7", "blue!80!black"}
+}
+
+pgf.styles.patterns = {
+  [1] = {"gp pattern 0", "white"},
+  [2] = {"gp pattern 1", "pattern=north east lines"},
+  [3] = {"gp pattern 2", "pattern=north west lines"},
+  [4] = {"gp pattern 3", "pattern=crosshatch"},
+  [5] = {"gp pattern 4", "pattern=grid"},
+  [6] = {"gp pattern 5", "pattern=vertical lines"},
+  [7] = {"gp pattern 6", "pattern=horizontal lines"},
+  [8] = {"gp pattern 7", "pattern=dots"},
+  [9] = {"gp pattern 8", "pattern=crosshatch dots"},
+ [10] = {"gp pattern 9", "pattern=fivepointed stars"},
+ [11] = {"gp pattern 10", "pattern=sixpointed stars"},
+ [12] = {"gp pattern 11", "pattern=bricks"}
+}
+
+
+pgf.styles.plotmarks = {
+  [1] = {"gp mark 0", "mark size=.5\\pgflinewidth,mark=*"}, -- point (-1)
+  [2] = {"gp mark 1", "mark=+"},
+  [3] = {"gp mark 2", "mark=x"},
+  [4] = {"gp mark 3", "mark=star"},
+  [5] = {"gp mark 4", "mark=square"},
+  [6] = {"gp mark 5", "mark=square*"},
+  [7] = {"gp mark 6", "mark=o"},
+  [8] = {"gp mark 7", "mark=*"},
+  [9] = {"gp mark 8", "mark=triangle"},
+ [10] = {"gp mark 9", "mark=triangle*"},
+ [11] = {"gp mark 10", "mark=triangle,mark options={rotate=180}"},
+ [12] = {"gp mark 11", "mark=triangle*,mark options={rotate=180}"},
+ [13] = {"gp mark 12", "mark=diamond"},
+ [14] = {"gp mark 13", "mark=diamond*"},
+ [15] = {"gp mark 14", "mark=otimes"},
+ [16] = {"gp mark 15", "mark=oplus"}
+}  
+
+--[[===============================================================================================
+
+    helper functions
+
+]]--===============================================================================================
+
+-- from the Lua wiki
+explode = function(div,str)
+  if (div=='') then return false end
+  local pos,arr = 0,{}
+  local trim = function(s) return (string.gsub(s,"^%s*(.-)%s*$", "%1")) end
+  -- for each divider found
+  for st,sp in function() return string.find(str,div,pos,true) end do
+    table.insert(arr, trim(string.sub(str,pos,st-1))) -- Attach chars left of current divider
+    pos = sp + 1 -- Jump past current divider
+  end
+  table.insert(arr, trim(string.sub(str,pos))) -- Attach chars right of last divider
+  return arr
+end
+
+
+
+--[[===============================================================================================
+
+  The PGF/TikZ output routines
+
+]]--===============================================================================================
+
+
+pgf.transform_xcoord = function(coord)
+  return (coord+gfx.origin_xoffset)*gfx.scalex
+end
+
+pgf.transform_ycoord = function(coord)
+  return (coord+gfx.origin_yoffset)*gfx.scaley
+end
+
+pgf.format_coord = function(xc, yc)
+  return string.format("%.3f,%.3f", pgf.transform_xcoord(xc), pgf.transform_ycoord(yc))
+end
+
+pgf.write_doc_begin = function(preamble)
+  gp.write("\\documentclass["..pgf.DEFAULT_FONT_SIZE.."pt]{article}\n"
+        .."\\usepackage[T1]{fontenc}\n"
+        .."\\usepackage{textcomp}\n\n"
+        .."\\usepackage[utf8x]{inputenc}\n\n"
+        .."\\usepackage{"..pgf.LATEX_STYLE_FILE.."}\n"
+        .."\\pagestyle{empty}\n"
+        .."\\usepackage[active,tightpage]{preview}\n"
+        .."\\PreviewEnvironment{tikzpicture}\n"
+        .."\\setlength\\PreviewBorder{2mm}\n"
+        ..preamble.."\n\n"
+        .."\\begin{document}\n")
+end
+
+pgf.write_doc_end = function()
+  gp.write("\\end{document}\n")
+end
+
+pgf.write_graph_begin = function (font, noenv)
+  local global_opt = "" -- unused
+  if noenv then
+    gp.write("%% ") -- comment out
+  end
+  gp.write(string.format("\\begin{tikzpicture}[gnuplot%s]\n",global_opt))
+  gp.write(string.format("%%%% generated with GNUPLOT %sp%s (%s; terminal rev. %s, script rev. %s)\n%%%% %s\n",
+      term.gp_version, term.gp_patchlevel,
+      string.match(term.lua_ident, "Lua [0-9\.]+"),
+      string.sub(term.lua_term_revision,7,-3),
+      pgf.REVISION,os.date()))
+  if font ~= "" then
+    gp.write(string.format("\\tikzstyle{every node}+=[font=%s]\n", font))
+  end
+  if not gfx.opt.lines_dashed then
+    gp.write("\\gpsolidlines\n")
+  end
+  if not gfx.opt.lines_colored then
+    gp.write("\\gpmonochromelines\n")
+  end
+end
+
+pgf.write_graph_end = function(noenv)
+  if noenv then
+    gp.write("%% ") -- comment out
+  end
+  gp.write("\\end{tikzpicture}\n")
+end
+
+pgf.draw_path = function(t)
+
+  local use_plot = false
+  local c_str = '--'
+
+  -- is the current linetype in the list of plots?
+  if #gfx.opt.plot_list > 0 then
+    for k, v in pairs(gfx.opt.plot_list) do
+      if gfx.linetype_idx_set == v  then
+        use_plot = true
+        c_str = ' '
+        break
+      end
+    end
+  end
+
+  gp.write("\\draw[gp path] ")
+  if use_plot then
+    gp.write("plot["..pgf.styles.plotstyles[((gfx.linetype_idx_set) % #pgf.styles.plotstyles)+1][1].."] coordinates {")
+  end
+  gp.write("("..pgf.format_coord(t[1][1], t[1][2])..")")
+  for i = 2,#t-1 do
+    -- pretty printing
+    if (i % 6) == 0 then
+      gp.write("%\n  ")
+    end
+    gp.write(c_str.."("..pgf.format_coord(t[i][1], t[i][2])..")")
+  end
+  if (#t % 6) == 0 then
+    gp.write("%\n  ")
+  end
+  -- check for a cyclic path
+  if (t[1][1] == t[#t][1]) and (t[1][2] == t[#t][2]) and (not use_plot) then
+    gp.write("--cycle")
+  else
+    gp.write(c_str.."("..pgf.format_coord(t[#t][1], t[#t][2])..")")
+  end
+  if use_plot then
+    gp.write("}")
+  end
+  gp.write(";\n")
+end
+
+
+pgf.draw_arrow = function(t, direction, headstyle)
+  gp.write("\\draw[gp path")
+  if direction ~= '' then
+    gp.write(","..direction)
+  end
+  if headstyle > 0 then
+    gp.write(",gp arrow "..headstyle)
+  end
+  gp.write("]")
+  gp.write("("..pgf.format_coord(t[1][1], t[1][2])..")")
+  for i = 2,#t do
+    if (i % 6) == 0 then
+      gp.write("%\n  ")
+    end
+    gp.write("--("..pgf.format_coord(t[i][1], t[i][2])..")")
+  end
+  gp.write(";\n")
+end
+
+
+pgf.draw_points = function(t, pm)
+  gp.write("\\gppoint{"..pm.."}{")
+  for i,v in ipairs(t) do
+      gp.write("("..pgf.format_coord(v[1], v[2])..")")
+  end
+  gp.write("}\n")
+end
+
+
+pgf.set_linetype = function(linetype)
+  gp.write("\\gpsetlinetype{"..linetype.."}\n")
+end
+
+
+pgf.set_color = function(color)
+  gp.write("\\gpcolor{"..color.."}\n")
+end
+
+
+pgf.set_linewidth = function(width)
+  gp.write(string.format("\\gpsetlinewidth{%.2f}\n", width))
+end
+
+
+pgf.set_pointsize = function(size)
+  gp.write(string.format("\\gpsetpointsize{%.2f}\n", 4*size))
+end
+
+
+pgf.write_text_node = function(t, text, angle, justification, font)
+  local node_options = justification
+  if angle ~= 0 then
+    node_options = node_options .. ",rotate=" .. angle
+  end
+  if font ~= '' then
+    node_options = node_options .. ",font=" .. font
+  end  
+  gp.write(string.format("\\node[%s] at (%s) {%s};\n", 
+          node_options, pgf.format_coord(t[1], t[2]), text))
+end
+
+
+pgf.draw_fill = function(t, pattern, color, saturation, opacity)
+  local fill_path = ''
+  local fill_style = ''
+  
+  if saturation < 100 then
+    gp.write("\\begin{colormixin}{"..saturation.."!white}\n")
+  end
+
+  fill_path = fill_path .. '('..pgf.format_coord(t[1][1], t[1][2])..')'
+  -- draw 2nd to n-1 corners
+  for i = 2,#t-1 do
+    if (i % 5) == 0 then
+      -- pretty printing
+      fill_path = fill_path .. "%\n    "
+    end
+    fill_path = fill_path .. '--('..pgf.format_coord(t[i][1], t[i][2])..')'
+  end
+  if (#t % 5) == 0 then
+    gp.write("%\n  ")
+  end
+  -- draw last corner
+  -- 'cycle' is just for the case that we want to draw a
+  -- line around the filled area
+  if (t[1][1] == t[#t][1]) and (t[1][2] == t[#t][2]) then -- cyclic
+    fill_path = fill_path .. '--cycle'
+  else
+    fill_path = fill_path
+          .. '--('..pgf.format_coord(t[#t][1], t[#t][2])..')--cycle'
+  end
+  
+  if pattern == '' then
+    -- solid fills
+    fill_style = 'color='..color
+    if opacity < 100 then
+      fill_style = fill_style..string.format(",opacity=%.2f", opacity/100)
+    else
+      -- fill_style = "" -- color ?
+    end
+  else
+    -- pattern fills
+    fill_style = pattern..',pattern color='..color
+  end
+  local out = ''
+  if (pattern ~= '') and (opacity == 100) then
+    -- have to fill bg for opaque patterns
+    gp.write("\\def\\gpfillpath{"..fill_path.."}\n"
+          .. "\\gpfill{color=gpbgfillcolor} \\gpfillpath;\n"
+          .. "\\gpfill{"..fill_style.."} \\gpfillpath;\n")
+  else
+    gp.write("\\gpfill{"..fill_style.."} "..fill_path..";\n")
+  end
+  
+  if saturation < 100 then
+    gp.write("\\end{colormixin}\n")
+  end
+end
+
+pgf.draw_raw_rgb_image = function(t, m, n, ll, ur)
+  local gw = gp.write
+  local sf = string.format
+  local xs = sf("%.3f", pgf.transform_xcoord(ur[1]) - pgf.transform_xcoord(ll[1]))
+  local ys = sf("%.3f", pgf.transform_ycoord(ur[2]) - pgf.transform_ycoord(ll[2]))
+  gw("\\def\\gprawrgbimagedata{%\n  ")
+  for cnt = 1,#t do
+    gw(sf("%02x%02x%02x", 255*t[cnt][1]+0.5, 255*t[cnt][2]+0.5, 255*t[cnt][3]+0.5))
+    if (cnt % 16) == 0 then
+      gw("%\n  ")
+    end
+  end
+  gw("}%\n")
+  gw("\\gprawimage{rgb}{"..sf("%.3f", pgf.transform_xcoord(ll[1])).."}"
+      .."{"..sf("%.3f", pgf.transform_ycoord(ll[2])).."}"
+      .."{"..m.."}{"..n.."}{"..xs.."}{"..ys.."}{\\gprawrgbimagedata}\n")
+end
+
+pgf.draw_raw_cmyk_image = function(t, m, n, ll, ur)
+  local gw = gp.write
+  local sf = string.format
+  local min = math.min
+  local max = math.max
+  local mf = math.floor
+  local UCRBG = {1,1,1,1} -- default corrections
+  local rgb2cmyk255 = function(r,g,b)
+    local c = 1-r
+    local m = 1-g
+    local y = 1-b
+    local k = min(c,m,y)
+    c = mf(255*min(1, max(0, c - UCRBG[1]*k))+0.5)
+    m = mf(255*min(1, max(0, m - UCRBG[2]*k))+0.5)
+    y = mf(255*min(1, max(0, y - UCRBG[3]*k))+0.5)
+    k = mf(255*min(1, max(0,     UCRBG[4]*k))+0.5)
+    return c,m,y,k
+  end
+  local xs = sf("%.3f", pgf.transform_xcoord(ur[1]) - pgf.transform_xcoord(ll[1]))
+  local ys = sf("%.3f", pgf.transform_ycoord(ur[2]) - pgf.transform_ycoord(ll[2]))
+  gw("\\def\\gprawcmykimagedata{%\n  ")
+  for cnt = 1,#t do
+    gw(sf("%02x%02x%02x%02x", rgb2cmyk255(t[cnt][1],t[cnt][2],t[cnt][3])))
+    if (cnt % 12) == 0 then
+      gw("%\n  ")
+    end
+  end
+  gw("}%\n")
+  gw("\\gprawimage{cmyk}{"..sf("%.3f", pgf.transform_xcoord(ll[1])).."}"
+      .."{"..sf("%.3f", pgf.transform_ycoord(ll[2])).."}"
+      .."{"..m.."}{"..n.."}{"..xs.."}{"..ys.."}{\\gprawcmykimagedata}\n")
+end
+
+pgf.write_clipbox_begin = function (ll, ur)
+  gp.write("\\begin{scope}\n")
+  gp.write(string.format("\\clip (%s) rectangle (%s);\n",
+      pgf.format_coord(ll[1],ll[2]),pgf.format_coord(ur[1],ur[2])))
+end
+
+pgf.write_clipbox_end = function()
+  gp.write("\\end{scope}\n")
+end
+
+pgf.write_boundingbox = function(t, num)
+  gp.write("%% coordinates of the plot area\n")
+  gp.write("\\\gpdefrectangularnode{gp plot "..num.."}{"
+    ..string.format("\\pgfpoint{%.3fcm}{%.3fcm}", pgf.transform_xcoord(t.xleft), pgf.transform_ycoord(t.ybot)).."}{"
+    ..string.format("\\pgfpoint{%.3fcm}{%.3fcm}", pgf.transform_xcoord(t.xright), pgf.transform_ycoord(t.ytop)).."}\n")
+end
+
+pgf.write_variables = function(t)
+  gp.write("%% gnuplot variables\n")
+  for k, v in pairs(t) do
+    gp.write(string.format("\\gpsetvar{%s}{%s}\n",k,v))
+  end
+end
+
+-- write style to seperate file, or whatever...
+pgf.create_style = function(f)
+f:write([[
+%%
+%%  This is the style file for the gnuplot PGF/TikZ terminal
+%%  
+%%  It is associated with the 'gnuplot.lua' script, and usually generated
+%%  automatically. So take care whenever you make any changes!
+%%
+\NeedsTeXFormat{LaTeX2e}
+]])
+f:write("\\ProvidesPackage{"..pgf.LATEX_STYLE_FILE.."}%\n")
+f:write("          ["..pgf.REVISION_DATE.." (rev. "..pgf.REVISION..") GNUPLOT Lua terminal style]\n\n")
+f:write([[
+\RequirePackage{tikz,xxcolor,ifpdf,ifxetex}
+
+\usetikzlibrary{arrows,patterns,plotmarks}
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%%
+%%  
+%%
+
+%
+% image related stuff
+%
+\def\gp@rawimage@pdf#1#2#3#4#5#6{%
+  \def\gp@tempa{cmyk}%
+  \def\gp@tempb{#1}%
+  \ifx\gp@tempa\gp@tempb%
+    \def\gp@temp{/CMYK}%
+  \else%
+    \def\gp@temp{/RGB}%
+  \fi%
+  \pgf@sys@bp{#4}\pgfsysprotocol@literalbuffered{0 0}\pgf@sys@bp{#5}%
+  \pgfsysprotocol@literalbuffered{0 0 cm}%
+  \pgfsysprotocol@literalbuffered{BI /W #2 /H #3 /CS \gp@temp}%
+  \pgfsysprotocol@literalbuffered{/BPC 8 /F /AHx ID}%
+  \pgfsysprotocol@literal{#6 > EI}%
+}
+\def\gp@rawimage@ps#1#2#3#4#5#6{%
+  \def\gp@tempa{cmyk}%
+  \def\gp@tempb{#1}%
+  \ifx\gp@tempa\gp@tempb%
+    \def\gp@temp{4}%
+  \else%
+    \def\gp@temp{3}%
+  \fi%
+  \pgfsysprotocol@literalbuffered{0 0 translate}%
+  \pgf@sys@bp{#4}\pgf@sys@bp{#5}\pgfsysprotocol@literalbuffered{scale}%
+  \pgfsysprotocol@literalbuffered{#2 #3 8 [#2 0 0 -#3 0 #3]}%
+  \pgfsysprotocol@literalbuffered{currentfile /ASCIIHexDecode filter}%
+  \pgfsysprotocol@literalbuffered{false \gp@temp\space colorimage}%
+  \pgfsysprotocol@literal{#6 >}%
+}
+
+
+\ifpdf
+  \def\gp@rawimage{\gp@rawimage@pdf}
+\else
+  \ifxetex
+    \def\gp@rawimage{\gp@rawimage@pdf}
+  \else
+    \def\gp@rawimage{\gp@rawimage@ps}
+  \fi
+\fi
+
+\def\gp@set@size#1{%
+  \def\gp@image@size{#1}%
+}
+%% \gprawimage{color model}{xcoord}{ycoord}{# of xpixel}{# of ypixel}{xsize}{ysize}{rgb/cmyk hex data RRGGBB/CCMMYYKK ...}
+%% color model is 'cmyk' or 'rgb' (default)
+\def\gprawimage#1#2#3#4#5#6#7#8{%
+  \tikz@scan@one@point\gp@set@size(#6,#7)\relax%
+  \tikz@scan@one@point\pgftransformshift(#2,#3)\relax%
+  \pgftext {%
+    \pgfsys@beginpurepicture%
+    \gp@image@size% fill \pgf@x and \pgf@y
+    \gp@rawimage{#1}{#4}{#5}{\pgf@x}{\pgf@y}{#8}%
+    \pgfsys@endpurepicture%
+  }%
+}
+
+%
+% gnuplottex comapatibility
+% (see http://www.ctan.org/tex-archive/help/Catalogue/entries/gnuplottex.html)
+%
+
+\def\gnuplottexextension@lua{\string tex}
+
+%
+% gnuplot variables getter and setter
+%
+
+\def\gpsetvar#1#2{%
+  \expandafter\xdef\csname gp@var@#1\endcsname{#2}
+}
+
+\def\gpgetvar#1{%
+  \csname gp@var@#1\endcsname %
+}
+
+%
+% some wrapper code
+%
+
+% short for the lengthy xcolor rgb definition
+\def\gprgb#1#2#3{rgb,1000:red,#1;green,#2;blue,#3}
+
+% short for a filled path
+\def\gpfill#1{\path[fill,#1]}
+
+% short for changing the linewidth
+\def\gpsetlinewidth#1{\pgfsetlinewidth{#1\gpbaselw}}
+
+\def\gpsetlinetype#1{\tikzstyle{gp path}=[#1,#1 add]}
+
+% short for changing the pointsize
+\def\gpsetpointsize#1{\tikzstyle{gp point}=[mark size=#1\gpbasems]}
+
+% wrapper for color settings
+\def\gpcolor#1{\pgfsetcolor{#1}}
+
+% prevent plot mark distortions due to changes in the PGF transformation matrix
+% use `\gpscalepointstrue' and `\gpscalepointsfalse' for enabling and disabling
+% point scaling
+%
+\newif\ifgpscalepoints
+\tikzoption{gp shift only}[]{%
+  \ifgpscalepoints%
+  \else%
+    % this is actually the same definition as used by "shift only" (seen
+    % in pgf-1.18 and later)
+    \tikz@addtransform{\pgftransformresetnontranslations}%
+  \fi%
+}
+\def\gppoint#1#2{%
+  \path[solid] plot[only marks,gp point,#1,mark options={gp shift only}] coordinates {#2};%
+}
+
+\def\gpfontsize#1#2{\fontsize{#1}{#2}\selectfont}
+
+%
+% char size calculation, that might be used with gnuplottex
+%
+% Example code (needs gnuplottex.sty):
+%
+%    % calculate the char size when the "gnuplot" style is used
+%    \tikzset{gnuplot/.append style={execute at begin picture=\gpcalccharsize}}
+%
+%    \tikzset{gnuplot/.append style={font=\ttfamily\footnotesize}}
+%
+%    \begin{tikzpicture}[gnuplot]
+%      \begin{gnuplot}[terminal=lua,%
+%          terminaloptions={tikz solid nopic charsize \the\gphcharsize,\the\gpvcharsize}]
+%        test
+%      \end{gnuplot}
+%    \end{tikzpicture}
+%
+%%%
+% The `\gpcalccharsize' command fills the lengths \gpvcharsize and \gphcharsize with
+% the values of the current default font used within nodes and is meant to be called
+% within a tikzpicture environment.
+% 
+\newdimen\gpvcharsize
+\newdimen\gphcharsize
+\def\gpcalccharsize{%
+  \pgfinterruptboundingbox%
+  \pgfsys@begininvisible%
+  \node at (0,0) {%
+    \global\gphcharsize=1.05\fontcharwd\font`0%
+    \global\gpvcharsize=1.05\fontcharht\font`0%
+    \global\advance\gpvcharsize by 1.05\fontchardp\font`g%
+  };%
+  \pgfsys@endinvisible%
+  \endpgfinterruptboundingbox%
+}
+
+%
+%  define a rectangular node in tikz e.g. for the plot area
+%  FIXME: this is done globally to work with gnuplottex.sty
+%
+%  #1 node name
+%  #2 coordinate of "south west"
+%  #3 coordinate of "north east"
+%
+\def\gpdefrectangularnode#1#2#3{%
+  \expandafter\gdef\csname pgf@sh@ns@#1\endcsname{rectangle}
+  \expandafter\gdef\csname pgf@sh@np@#1\endcsname{%
+    \def\southwest{#2}%
+    \def\northeast{#3}%
+  }
+  \pgfgettransform\pgf@temp%
+  % once it is defined, no more transformations will be applied, I hope
+  \expandafter\xdef\csname pgf@sh@nt@#1\endcsname{\pgf@temp}%
+  \expandafter\xdef\csname pgf@sh@pi@#1\endcsname{\pgfpictureid}%
+}
+
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%%
+%%  You may want to adapt the following to fit your needs (in your 
+%%  individual style file and/or within your document).
+%%
+
+%
+% style for every plot
+%
+\tikzstyle{gnuplot}=[%
+  >=stealth',%
+  cap=round,%
+  join=round,%
+]
+
+\tikzstyle{gp node left}=[anchor=mid west,yshift=-.12ex]
+\tikzstyle{gp node center}=[anchor=mid,yshift=-.12ex]
+\tikzstyle{gp node right}=[anchor=mid east,yshift=-.12ex]
+
+% basic plot mark size (points)
+\newdimen\gpbasems
+\gpbasems=.4pt
+
+% basic linewidth
+\newdimen\gpbaselw
+\gpbaselw=.4pt
+
+% this is the default color for pattern backgrounds
+\colorlet{gpbgfillcolor}{white}
+
+
+% this should reverse the normal text node presets, for the
+% later referencing as described below
+\tikzstyle{gp refnode}=[coordinate,yshift=.12ex]
+
+% to add an empty label with the referenceable name "my node"
+% to the plot, just add the following line to your gnuplot
+% file:
+%
+% set label "" at 1,1 font ",gp refnode,name=my node"
+%
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%%
+%%  The following TikZ-styles are derived from the 'pgf.styles.*' tables
+%%  in the Lua script.
+%%  To change the number of used styles you should change them there and
+%%  regenerate this style file.
+%%
+
+]])
+  f:write("% arrow styles settings\n")
+  for i = 1, #pgf.styles.arrows do
+    f:write("\\tikzstyle{"..pgf.styles.arrows[i][1].."} = ["..pgf.styles.arrows[i][2].."]\n")
+  end
+  f:write("\n% plotmark settings\n")
+  for i = 1, #pgf.styles.plotmarks do
+    f:write("\\tikzstyle{"..pgf.styles.plotmarks[i][1].."} = ["..pgf.styles.plotmarks[i][2].."]\n")
+  end
+  f:write("\n% pattern settings\n")
+  for i = 1, #pgf.styles.patterns do
+    f:write("\\tikzstyle{"..pgf.styles.patterns[i][1].."} = ["..pgf.styles.patterns[i][2].."]\n")
+  end
+  f:write("\n% if the 'tikzplot' option is used the corresponding lines will be smoothed by default\n")
+  for i = 1, #pgf.styles.plotstyles_axes do
+    f:write("\\tikzstyle{"..pgf.styles.plotstyles_axes[i][1].."} = ["..pgf.styles.plotstyles_axes[i][2].."]%\n")
+  end
+  for i = 1, #pgf.styles.plotstyles do
+    f:write("\\tikzstyle{"..pgf.styles.plotstyles[i][1].."} = ["..pgf.styles.plotstyles[i][2].."]%\n")
+  end
+  -- line styles for borders etc ...
+  f:write("\n% linestyle settings\n")
+  for i = 1, #pgf.styles.linetypes_axes do
+    f:write("\\tikzstyle{"..pgf.styles.linetypes_axes[i][1].."} = ["..pgf.styles.linetypes_axes[i][2].."]\n")
+  end
+  f:write("\n% linestyle \"addon\" settings for overwriting a default linestyle within the\n")
+  f:write("% TeX document via eg. \\tikzstyle{gp lt plot 1 add}=[fill=black,draw=none] etc.\n")
+  for i = 1, #pgf.styles.linetypes_axes do
+    f:write("\\tikzstyle{"..pgf.styles.linetypes_axes[i][1].." add} = []\n")
+  end
+  for i = 1, #pgf.styles.linetypes do
+    f:write("\\tikzstyle{"..pgf.styles.linetypes[i][1].." add} = []\n")
+  end
+  f:write("\n% linestyle color settings\n")
+  for i = 1, #pgf.styles.lt_colors_axes do
+    f:write("\\colorlet{"..pgf.styles.lt_colors_axes[i][1].."}{"..pgf.styles.lt_colors_axes[i][2].."}\n")
+  end
+  -- line styles for the plots
+  f:write("\n% command for switching to dashed lines\n")
+  f:write("\\def\\gpdashedlines{%\n")
+  for i = 1, #pgf.styles.linetypes do
+    f:write("  \\tikzstyle{"..pgf.styles.linetypes[i][1].."} = ["..pgf.styles.linetypes[i][2].."]%\n")
+  end
+  f:write("}\n")
+  f:write("\n% command for switching to colored lines\n")
+  f:write("\\def\\gpcoloredlines{%\n")
+  for i = 1, #pgf.styles.lt_colors do
+    f:write("  \\colorlet{"..pgf.styles.lt_colors[i][1].."}{"..pgf.styles.lt_colors[i][2].."}%\n")
+  end
+  f:write("}\n")
+  f:write("\n% command for switching to solid lines\n")
+  f:write("\\def\\gpsolidlines{%\n")
+  for i = 1, #pgf.styles.linetypes do
+    f:write("  \\tikzstyle{"..pgf.styles.linetypes[i][1].."} = [solid]%\n")
+  end
+  f:write("}\n")
+  f:write("\n% command for switching to monochrome (black) lines\n")
+  f:write("\\def\\gpmonochromelines{%\n")
+  for i = 1, #pgf.styles.lt_colors do
+    f:write("  \\colorlet{"..pgf.styles.lt_colors[i][1].."}{black}%\n")
+  end
+  f:write("}\n\n")
+  f:write([[
+%
+% some initialisations
+%
+% by default all lines will be colored and dashed
+\gpcoloredlines
+\gpdashedlines
+\gpsetpointsize{4}
+\gpsetlinetype{gp lt solid}
+\gpscalepointsfalse
+\endinput
+]])
+  f:close()
+end
+
+
+pgf.print_help = function(fwrite)
+
+  fwrite([[
+      {help}
+      {monochrome}
+      {solid}
+      {originreset}
+      {gparrows}
+      {gppoints}
+      {nopicenvironment}
+      {size <x>{unit},<y>{unit}}
+      {scale <x>,<y>}
+      {plotsize <x>{unit},<y>{unit}}
+      {charsize <x>{unit},<y>{unit}}
+      {font "<fontdesc>"}
+      {createstyle}
+      {fulldoc|standalone}
+      {{preamble|header} "<preamble_string>"}
+      {tikzplot <ltn>,...}
+      {tikzarrows}
+      {cmykimages}
+      {nobitmap}
+      {providevars <var name>,...}
+
+ For all options that expect lengths as their arguments they
+ will default to 'cm' if no unit is specified. For all lengths
+ the following units may be used: 'cm', 'mm', 'in' or 'inch',
+ 'pt', 'pc', 'bp', 'dd', 'cc'. Blanks between numbers and units
+ are not allowed.
+
+ 'monochrome' disables line coloring and switches to grayscaled
+ fills.
+
+ 'solid' use only solid lines.
+
+ 'originreset' moves the origin of the TikZ picture to the lower
+ left corner of the plot. It may be used to align several plots
+ within one tikzpicture environment. This is not tested with
+ multiplots and pm3d plots!
+
+ 'gparrows' use gnuplot's internal arrow drawing function
+ instead of the ones provided by TikZ.
+
+ 'gppoints' use gnuplot's internal plotmark drawing function
+ instead of the ones provided by TikZ.
+
+ 'nopicenvironment' omits the declaration of the 'tikzpicture'
+ environment in order to set it manually. This permits putting
+ some PGF/TikZ code directly before or after the plot.
+
+ The 'size' option expects two lenghts <x> and <y> as the canvas size.
+ The default size of the canvas is ]]..pgf.DEFAULT_CANVAS_SIZE_X..[[cm x ]]..pgf.DEFAULT_CANVAS_SIZE_Y..[[cm.
+
+ The 'scale' option works similar to the 'size' option but expects
+ scaling factors <x> and <y> instead of lengths.
+
+ The 'plotsize' option permits setting the size of the plot area
+ instead of the canvas size, which is the usual gnuplot behaviour.
+ Using this option may lead to slightly asymmetric tic lengths.
+ Like 'originreset' this option may not lead to convenient results
+ if used with multiplots or pm3d plots.
+
+ The 'charsize' option expects the average horizontal and vertical
+ size of the used font. Look at the generated style file for an
+ example of how to use it from within your TeX document.
+
+ 'createstyle' derives the LaTeX style file from the script and
+ writes it to the file ']]..pgf.LATEX_STYLE_FILE..'.sty'..[['.
+
+ 'fulldoc' or 'standalone' produces a full LaTeX document for direct
+ compilation.
+
+ 'preamble' or 'header' may be used to put any additional LaTeX code
+ into the document preamble in standalone mode.
+
+ With the 'tikzplot' option the '\path plot' command will be used
+ instead of only '\path'. The following list of numbers of linetypes
+ (<ltn>,...) defines the affected plotlines. There exists a plotstyle
+ for every linetype. The default plotstyle is 'smooth' for every
+ linetype >= 1.
+
+ By using the 'tikzarrows' option the gnuplot arrow styles defined by
+ the user will be mapped to TikZ arrow styles. This is done by 'misusing'
+ the angle value of the arrow definition. E.g. an arrow style with the
+ angle '7' will be mapped to the TikZ style 'gp arrow 7' ignoring all the
+ other given values. By default the TikZ terminal uses the stealth' arrow
+ tips for all arrows. To obtain the default gnuplot behaviour please use
+ the 'gparrows' option.
+
+ With 'cmykimages' the CMYK color model will be used for image data
+ instead of the RGB model. All other colors (like line colors etc.) are
+ not affected by this option, since they are handled by the xcolors
+ package. So take care to change the color model also there if needed.
+
+ The 'nobitmap' option let images be rendered as filled rectangles
+ instead of the nativ PS or PDF image format. This option has to be
+ enabled if you intend to use other output formats.
+
+ The 'providevars' options makes gnuplot's internal and user variables
+ available by using the '\gpgetvar{<var name>}' commmand within the TeX
+ script. Use gnuplot's 'show variables all' command to see the list
+ of valid variables.
+
+ The <fontdesc> string may contain any valid LaTeX font commands like
+ e.g. '\small'. It is passed directly as a node parameter in form of
+ "font=<fontdesc>". This can be 'misused' to add further code to a node,
+ e.g. '\small,yshift=1ex' or ',yshift=1ex' are also valid while the
+ latter does not change the current font settings. One exception is
+ the second argument of the list. If it is a number of the form
+ <number>{unit} it will be interpreted as a fontsize like in other
+ terminals and will be appended to the first argument. If the unit is
+ omitted the value is interpreted as 'pt'. As an example the string
+ '\sffamily,12,fill=red' sets the font to LaTeX's sans serif font at
+ a size of 12pt and red background color.
+
+ Strings have to be put in single or double quotes. Double quoted
+ strings may contain special characters like newlines '\n' etc.
+]])
+end
+
+
+--[[===============================================================================================
+
+  gfx.* helper functions
+  
+  Main intention is to prevent redundancies in the drawing
+  operations and keep the pgf.* API as consistent as possible.
+  
+]]--===============================================================================================
+
+
+gfx.in_path = false
+
+gfx.path = {}
+gfx.posx = nil
+gfx.posy = nil
+
+
+-- gfx.DEFAULT_LINE_TYPE = -2
+-- gfx.linetype_idx = gfx.DEFAULT_LINE_TYPE -- current linetype intended for the plot
+gfx.linetype_idx = nil       -- current linetype intended for the plot
+gfx.linetype_idx_set = nil   -- current linetype set in the plot
+gfx.linewidth = nil
+gfx.linewidth_set = nil
+
+-- internal calculated scaling factors
+gfx.scalex = 1
+gfx.scaley = 1
+
+-- recalculate the origin of the plot
+-- used for moving the origin to the lower left
+-- corner...
+gfx.origin_xoffset = 0
+gfx.origin_yoffset = 0
+
+
+
+-- color set in the document
+gfx.color = ''
+gfx.color_set = ''
+
+gfx.pointsize = nil
+gfx.pointsize_set = nil
+
+gfx.text_font = ''
+gfx.text_justify = "center"
+gfx.text_angle = 0
+
+-- option vars
+gfx.opt = {
+  latex_preamble = '',
+  default_font = '',
+  lines_dashed = true,
+  lines_colored = true,
+  -- use gnuplot arrows or points instead of TikZ?
+  gp_arrows = false,
+  gp_points = false,
+  -- don't put graphic commands into a tikzpicture environment
+  nopicenv = false,
+  -- produce full LaTeX document?
+  full_doc = false,
+  -- in gnuplot all sizes refer to the size of the canvas
+  -- and not the size of plot itself
+  plotsize_x = nil,
+  plotsize_y = nil,
+  set_plotsize = false,
+  -- recalculate the origin of the plot
+  -- used for moving the origin to the lower left
+  -- corner...
+  set_origin = false,
+  -- list of _linetypes_ of plots that should be drawn as with the \plot
+  -- command instead of \path
+  plot_list = {},
+  -- uses some pdf/ps specials with image function that will only work
+  -- with pdf/ps generation!
+  direct_image = true,
+  -- list of gnuplot variables that should be made available via
+  -- \gpsetvar{name}{val}
+  gnuplot_vars = {},
+  -- if true, the gnuplot arrow will be mapped to TikZ arrow styles by the
+  -- given angle. E.g. an arrow with the angle `7' will be mapped to `gp arrow 7'
+  -- style.
+  tikzarrows = false,
+  -- if true, cmyk image model will be used for bitmap images
+  cmykimage = false
+}
+
+-- within tikzpicture environment or not
+gfx.in_picture = false
+
+-- have not determined the plotbox, see the 'plotsize' option
+gfx.have_plotbox = false
+
+gfx.current_boundingbox = {
+  xleft = nil, xright = nil, ytop = nil, ybot = nil
+}
+-- plot bounding boxes counter
+gfx.boundingbox_cnt = 0
+
+gfx.TEXT_ANCHOR = {
+  ["left"]   = "gp node left",
+  ["center"] = "gp node center",
+  ["right"]  = "gp node right"
+}
+
+gfx.HEAD_STR = {"", "->", "<-", "<->"}
+
+
+-- conversion factors in `cm'
+gfx.units = {
+  ['']    = 1,        -- default
+  ['cm']  = 1,
+  ['mm']  = 0.1,
+  ['in']  = 2.54,
+  ['inch']= 2.54,
+  ['pt']  = 0.035146, -- Pica Point   (72.27pt = 1in)
+  ['pc']  = 0.42176,  -- Pica         (1 Pica = 1/6 inch)
+  ['bp']  = 0.035278, -- Big Point    (72bp = 1in)
+  ['dd']  = 0.0376,   -- Didot Point  (1cm = 26.6dd)
+  ['cc']  = 0.45113   -- Cicero       (1cc = 12 dd)
+}
+
+
+gfx.parse_number_unit = function (str, from, to)
+  to = to or 'cm'
+  from = from or 'cm'
+  local num, unit = string.match(str, '([%d%.]+)([a-z]*)')
+  if unit and (string.len(unit) > 0) then
+    from = unit
+  else
+    unit = false
+  end
+  local factor_from = gfx.units[from]
+  local factor_to   = gfx.units[to]
+  num = tonumber(num)
+  if num and factor_from then
+    -- to cm and then to our target unit
+    return num*(factor_from/factor_to), unit
+  else
+    return false, false
+  end
+end
+
+
+gfx.parse_font_string = function (str)
+  local size,rets,toks = nil, str, explode(',', str)
+  -- if at least two tokens
+  if #toks > 1 then
+    -- add first element to font string
+    rets = table.remove(toks,1)
+    -- no unit means 'pt'
+    size, _ = gfx.parse_number_unit(toks[1],'pt','pt')
+    if (size) then
+      table.remove(toks,1)
+      rets = rets .. string.format('\\gpfontsize{%.2fpt}{%.2fpt}',size,size*1.2)
+    end
+    -- add remaining parts
+    for k,v in ipairs(toks) do
+      rets = rets .. ',' .. v
+    end
+  end
+  return rets, size
+end
+
+
+gfx.write_boundingbox = function()
+  local t = gp.get_boundingbox()
+  for k, v in pairs (t) do
+    if v ~= gfx.current_boundingbox[k] then
+      gfx.boundingbox_cnt = gfx.boundingbox_cnt + 1
+      gfx.current_boundingbox = t
+      pgf.write_boundingbox(t, gfx.boundingbox_cnt)
+      break
+    end  
+  end
+end
+
+gfx.adjust_plotbox = function()
+  local t = gp.get_boundingbox()
+  if gfx.opt.set_origin then
+    -- move origin to the lower left corner of the plot
+    gfx.origin_xoffset = - t.xleft
+    gfx.origin_yoffset = - t.ybot
+  end
+  if gfx.opt.set_plotsize then
+    if (t.xright - t.xleft) > 0 then
+      gfx.scalex = gfx.scalex*gfx.opt.plotsize_x * pgf.DEFAULT_RESOLUTION/(t.xright - t.xleft)
+      gfx.scaley = gfx.scaley*gfx.opt.plotsize_y * pgf.DEFAULT_RESOLUTION/(t.ytop - t.ybot)
+    else
+      -- could not determin a valid bounding box, so keep using the
+      -- plotsize as the canvas size
+      gp.term_out("WARNING: PGF/TikZ Terminal: `plotsize' option used, but I could not determin the plot area!\n")
+    end
+  end
+end
+
+
+gfx.check_variables = function()
+  local vl = gfx.opt.gnuplot_vars
+  local t = gp.get_all_variables()
+  local sl = {}
+  for i=1,#vl do
+    if t[vl[i]] then
+      sl[vl[i]] = t[vl[i]][3]
+      if t[vl[i]][4] then
+        sl[vl[i].." Im"] = t[vl[i]][4]
+      end
+    end
+  end
+  pgf.write_variables(sl)
+end
+
+
+-- do we have to start a new path?
+gfx.check_in_path = function()
+  -- boundingbox data is available with the first
+  -- drawing command
+  if (not gfx.have_plotbox) and gfx.in_picture then
+    gfx.adjust_plotbox()
+    gfx.have_plotbox = true
+  end
+  
+  if gfx.in_path == true then
+    if #gfx.path > 1 then
+      -- don't draw zero length paths
+      pgf.draw_path(gfx.path)
+    end
+    gfx.in_path = false
+    gfx.path = {}
+    gfx.posx = nil
+    gfx.posy = nil
+  end
+end
+
+-- did the linetype change?
+gfx.check_linetype = function()
+  if gfx.linetype_idx ~= gfx.linetype_idx_set then
+    local lt
+    if gfx.linetype_idx < 0 then
+      lt = pgf.styles.linetypes_axes[math.abs(gfx.linetype_idx)][1]
+    else
+      lt = pgf.styles.linetypes[(gfx.linetype_idx % #pgf.styles.linetypes)+1][1]
+    end
+    pgf.set_linetype(lt)
+    gfx.linetype_idx_set = gfx.linetype_idx
+  end
+end
+
+-- did the color change?
+gfx.check_color = function()
+  if gfx.color_set ~= gfx.color then
+    pgf.set_color(gfx.color)
+    gfx.color_set = gfx.color
+  end
+end
+
+-- sanity check if we already are at this position in our path
+-- and save this position
+gfx.check_coord = function(x, y)
+  if (x == gfx.posx) and (y == gfx.posy) then
+    return true
+  end
+  gfx.posx = x
+  gfx.posy = y
+  return false
+end
+
+-- did the linewidth change?
+gfx.check_linewidth = function()
+  if gfx.linewidth ~= gfx.linewidth_set then
+    pgf.set_linewidth(gfx.linewidth)
+    gfx.linewidth_set = gfx.linewidth
+  end
+end
+
+-- did the pointsize change?
+gfx.check_pointsize = function()
+  if gfx.pointsize ~= gfx.pointsize_set then
+    pgf.set_pointsize(gfx.pointsize)
+    gfx.pointsize_set = gfx.pointsize
+  end
+end
+
+
+gfx.start_path = function(x, y)
+  gfx.check_color()
+  gfx.check_linetype()
+  gfx.check_linewidth()
+
+  --  init path with first coords
+  gfx.path = {{x,y}}  
+  gfx.in_path = true
+  gfx.posx = x
+  gfx.posy = y
+end
+
+-- ctype  string  LT|RGB|GRAY
+-- val   table   {name}|{r,g,b}
+gfx.format_color = function(ctype, val)
+  local c
+  if ctype == 'LT' then
+    if val[1] < 0 then
+      if val[1] < -2 then --  LT_NODRAW, LT_BACKGROUND, LT_UNDEFINED
+        c = 'gpbgfillcolor'
+      else
+        c = pgf.styles.lt_colors_axes[math.abs(val[1])][1]
+      end
+    else
+      c = pgf.styles.lt_colors[(val[1] % #pgf.styles.lt_colors)+1][1]
+    end
+    -- c = pgf.styles.lt_colors[((val[1]+3) % #pgf.styles.lt_colors) + 1][1]
+  elseif ctype == 'RGB' then
+    c = string.format("\\gprgb{%i}{%i}{%i}",
+                  1000*val[1]+0.5, 1000*val[2]+0.5, 1000*val[3]+0.5)
+  elseif ctype == 'GRAY' then
+    c = string.format("black!%i", 100*val[1]+0.5)
+  end
+  return c
+end
+
+gfx.set_color = function(ctype, val)
+  gfx.color = gfx.format_color(ctype, val)
+end
+
+
+--[[===============================================================================================
+
+  The terminal layer
+  
+  The term.* functions are usually called from the gnuplot Lua terminal
+
+]]--===============================================================================================
+
+
+if arg then
+  -- when called from the command line we have
+  -- to initialize the table `term' manually
+  -- to avoid errors
+  term = {}
+else
+  --
+  -- gnuplot terminal default parameters and flags
+  --
+  term.xmax = pgf.DEFAULT_RESOLUTION * pgf.DEFAULT_CANVAS_SIZE_X
+  term.ymax = pgf.DEFAULT_RESOLUTION * pgf.DEFAULT_CANVAS_SIZE_Y
+  term.h_tic =  pgf.DEFAULT_RESOLUTION * pgf.DEFAULT_TIC_SIZE
+  term.v_tic =  pgf.DEFAULT_RESOLUTION * pgf.DEFAULT_TIC_SIZE
+  -- default size for CM@10pt
+  term.h_char = 184 * math.floor((pgf.DEFAULT_FONT_SIZE/10) * (pgf.DEFAULT_RESOLUTION/1000) + .5)
+  term.v_char = 308 * math.floor((pgf.DEFAULT_FONT_SIZE/10) * (pgf.DEFAULT_RESOLUTION/1000) + .5)
+  term.description = "Lua PGF/TikZ terminal for LaTeX2e"
+  term.flags = term.TERM_BINARY + term.TERM_CAN_CLIP
+                + term.TERM_IS_POSTSCRIPT + term.TERM_CAN_MULTIPLOT
+  if term.IS_GNUPLOT_43 then  -- gnuplot 4.3
+    term.flags = term.flags + term.TERM_CAN_DASH
+  end
+end
+
+
+--
+-- initial = 1  for the initial "set term" call
+--           0  for subsequent option changes -- currently unused, since the changeable options
+--              are hardcoded within gnuplot :-(
+--
+-- t_count   see e.g. int_error()
+--
+term.options = function(opt_str, initial, t_count)
+
+  local o_next = ""
+  local o_type = nil
+  local s_start, s_end = 1, 1
+
+  -- trim spaces
+  opt_str = opt_str:gsub("^%s*(.-)%s*$", "%1")
+  local opt_len = string.len(opt_str)
+
+  t_count = t_count - 1
+
+  local set_t_count = function(num) 
+    -- gnuplot handles commas as regular tokens
+    t_count = t_count + 2*num - 2
+  end
+
+  local almost_equals = function(param, opt)
+    local op1, op2
+
+    local st, _ = string.find(opt, "$", 2, true)
+    if st then
+      op1 = string.sub(opt, 1, st-1)
+      op2 = string.sub(opt, st+1)
+      if (string.sub(param, 1, st-1) == op1)
+          and (string.find(op1..op2, param, 1, true) == 1) then
+        return true
+      end
+    elseif opt == param then
+      return true
+    end
+    return false
+  end
+
+  --
+  -- simple parser for options and strings
+  --
+  local get_next_token = function()
+
+    -- beyond the limit?
+    if s_start > opt_len then
+      o_next = ""
+      o_type = nil
+      return
+    end
+
+    t_count = t_count + 1
+
+    -- search the start of the next token
+    s_start, _ = string.find (opt_str, '[^%s]', s_start)
+    if not s_start then
+      o_next = ""
+      o_type = nil
+      return
+    end
+
+    -- a new string argument?
+    local next_char = string.sub(opt_str, s_start, s_start)
+    if next_char == '"' or next_char == "'" then
+      -- find the end of the string by searching for
+      -- the next not escaped quote
+      _ , s_end = string.find (opt_str, '[^\\]'..next_char, s_start+1)
+      if s_end then
+        o_next = string.sub(opt_str, s_start+1, s_end-1)
+        if next_char == '"' then
+          -- Wow! this is to resolve all string escapes, kind of "unescape string"
+          o_next = assert(loadstring("return(\""..o_next.."\")"))()
+        end
+        o_type = "string"
+      else
+        -- FIXME: error: string does not end...
+        -- seems that gnuplot adds missing quotes
+        -- so this will never happen...
+      end
+    else
+      -- ok, it's not a string...
+      -- then find the next white space or end of line
+      -- comma separated strings are regarded as one token
+      s_end, _ = string.find (opt_str, '[^,][%s]+[^,]', s_start)
+      if not s_end then -- reached the end of the string
+        s_end = opt_len + 1
+      else
+        s_end = s_end + 1
+      end
+      o_next = string.sub(opt_str, s_start, s_end-1)
+      o_type = "op"
+    end
+    s_start = s_end + 1
+    return
+  end    
+
+  local get_two_sizes = function(str)
+    local args = explode(',', str)
+    set_t_count(#args)
+
+    local num1, num2, unit
+    if #args ~= 2 then
+      return false, nil
+    else
+      num1, unit = gfx.parse_number_unit(args[1])
+      if unit then
+        t_count = t_count + 1
+      end
+      num2, unit = gfx.parse_number_unit(args[2])
+      if unit then
+        t_count = t_count + 1
+      end
+      if not (num1 and num2) then
+        return false, nil
+      end
+    end
+    return num1, num2
+  end
+  
+  local print_help = false
+
+  while true do
+    get_next_token()
+    if not o_type then break end
+    if almost_equals(o_next, "he$lp") then
+      print_help = true
+    elseif almost_equals(o_next, "mono$chrome") then
+      -- no colored lines
+      gfx.opt.lines_colored = false
+    elseif almost_equals(o_next, "c$olor") or almost_equals(o_next, "c$olour") then
+      -- colored lines
+      gfx.opt.lines_colored = true
+    elseif almost_equals(o_next, "so$lid") then
+      -- no dashed and dotted etc. lines
+      gfx.opt.lines_dashed = false
+    elseif almost_equals(o_next, "da$shed") then
+      -- dashed and dotted etc. lines
+      gfx.opt.lines_dashed = true
+    elseif almost_equals(o_next, "gparr$ows") then
+      -- use gnuplot arrows instead of TikZ
+      gfx.opt.gp_arrows = true
+    elseif almost_equals(o_next, "gppoint$s") then
+      -- use gnuplot points instead of TikZ
+      gfx.opt.gp_points = true
+    elseif almost_equals(o_next, "nopic$environment") then
+      -- omit the 'tikzpicture' environment
+      gfx.opt.nopicenv = true
+    elseif almost_equals(o_next, "origin$reset") then
+      -- moves the origin of the TikZ picture to the lower left corner of the plot
+      gfx.opt.set_origin = true
+    elseif almost_equals(o_next, "plot$size") then
+      get_next_token()
+      gfx.opt.plotsize_x, gfx.opt.plotsize_y = get_two_sizes(o_next)
+      if not gfx.opt.plotsize_x then
+        gp.int_error(t_count, string.format("error: two comma seperated lengths expected, got `%s'.", o_next))
+      end
+      gfx.opt.set_plotsize = true
+      -- we set the canvas size to the plotsize to keep the aspect ratio as good as possible
+      -- and rescale later once we know the actual plotsize...
+      term.xmax = gfx.opt.plotsize_x*pgf.DEFAULT_RESOLUTION
+      term.ymax = gfx.opt.plotsize_y*pgf.DEFAULT_RESOLUTION
+    elseif almost_equals(o_next, "si$ze") then
+      get_next_token()
+      local plotsize_x, plotsize_y = get_two_sizes(o_next)
+      if not plotsize_x then
+        gp.int_error(t_count, string.format("error: two comma seperated lengths expected, got `%s'.", o_next))
+      end
+      term.xmax = plotsize_x*pgf.DEFAULT_RESOLUTION
+      term.ymax = plotsize_y*pgf.DEFAULT_RESOLUTION
+    elseif almost_equals(o_next, "char$size") then
+      get_next_token()
+      local charsize_h, charsize_v = get_two_sizes(o_next)
+      if not charsize_h then
+        gp.int_error(t_count, string.format("error: two comma seperated lengths expected, got `%s'.", o_next))
+      end
+      term.h_char = math.floor(charsize_h*pgf.DEFAULT_RESOLUTION + .5)
+      term.v_char = math.floor(charsize_v*pgf.DEFAULT_RESOLUTION + .5)
+    elseif almost_equals(o_next, "sc$ale") then
+      get_next_token()
+      local xscale, yscale = get_two_sizes(o_next)
+      if not xscale then
+        gp.int_error(t_count, string.format("error: two comma seperated numbers expected, got `%s'.", o_next))
+      end
+      term.xmax = term.xmax * xscale
+      term.ymax = term.ymax * yscale
+    elseif almost_equals(o_next, "tikzpl$ot") then
+      get_next_token()
+      local args = explode(',', o_next)
+      set_t_count(#args)
+      for i = 1,#args do
+        args[i] = tonumber(args[i])
+        if args[i] == nil then
+          gp.int_error(t_count, string.format("error: list of comma seperated numbers expected, got `%s'.", o_next))
+        end
+        args[i] = args[i] - 1
+      end
+      gfx.opt.plot_list = args
+    elseif almost_equals(o_next, "provide$vars") then
+      get_next_token()
+      local args = explode(',', o_next)
+      set_t_count(#args)
+      gfx.opt.gnuplot_vars = args
+    elseif almost_equals(o_next, "tikzar$rows") then
+      -- map the arrow angles to TikZ arrow styles
+      gfx.opt.tikzarrows = true
+    elseif almost_equals(o_next, "nobit$map") then
+      -- render images as filled rectangles instead of the nativ
+      -- PS or PDF image format
+      gfx.opt.direct_image = false
+    elseif almost_equals(o_next, "cmyk$image") then
+      -- use cmyk color model for images
+      gfx.opt.cmykimage = true
+    elseif almost_equals(o_next, "full$doc") or almost_equals(o_next, "stand$alone") then
+      -- produce full tex document
+      gfx.opt.full_doc = true
+    elseif almost_equals(o_next, "create$style") then
+      -- creates the coresponding LaTeX style from the script
+      local f = io.open(pgf.LATEX_STYLE_FILE..".sty" , "w+")
+      pgf.create_style(f)
+    elseif almost_equals(o_next, "fo$nt") then
+      local fsize
+      get_next_token()
+      if o_type == 'string' then
+        gfx.opt.default_font, fsize = gfx.parse_font_string(o_next)
+      else
+        gp.int_error(t_count, string.format("error: string expected, got `%s'.", o_next))
+      end
+      if fsize then
+        term.h_char = math.floor(term.h_char * (fsize/pgf.DEFAULT_FONT_SIZE) + .5)
+        term.v_char = math.floor(term.v_char * (fsize/pgf.DEFAULT_FONT_SIZE) + .5)
+      end
+    elseif almost_equals(o_next, "pre$amble") or almost_equals(o_next, "header") then
+      get_next_token()
+      if o_type == 'string' then
+        gfx.opt.latex_preamble = gfx.opt.latex_preamble .. o_next .. "\n"
+      else
+        gp.int_error(t_count, string.format("error: string expected, got `%s'.", o_next))
+      end
+    else
+      gp.int_warn(t_count, string.format("unknown option `%s'.", o_next))
+    end
+  end
+
+  if print_help then
+    pgf.print_help(gp.term_out)
+  end
+
+  local tf = function(b,y,n)
+    if b then 
+      return(y)
+    else
+      return(n)
+    end
+  end
+
+  local opt_str = string.format("%s %s",
+    tf(gfx.opt.lines_colored, 'color', 'monochrome'),
+    tf(gfx.opt.lines_dashed, 'dashed', 'solid'))
+
+  gp.term_options(opt_str)
+
+  return 1
+end
+
+-- Called once, when the device is first selected.
+term.init = function()
+  if gfx.opt.full_doc then
+    pgf.write_doc_begin(gfx.opt.latex_preamble)
+  end
+  return 1
+end
+
+-- Called just before a plot is going to be displayed.
+term.graphics = function()
+  -- reset some state variables
+  gfx.linetype_idx_set = nil
+  gfx.linewidth_set = nil
+  gfx.pointsize_set = nil
+  gfx.color_set = nil
+  gfx.in_picture = true
+  gfx.have_plotbox = false
+  gfx.boundingbox_cnt = 0
+  gfx.scalex = 1/pgf.DEFAULT_RESOLUTION
+  gfx.scaley = 1/pgf.DEFAULT_RESOLUTION
+  gfx.current_boundingbox = {
+    xleft = nil, xright = nil, ytop = nil, ybot = nil
+  }
+
+    -- put a newline between subsequent plots in fulldoc mode...
+  if gfx.opt.full_doc then
+    gp.write("\n")
+  end
+  pgf.write_graph_begin(gfx.opt.default_font, gfx.opt.nopicenv)
+  return 1
+end
+
+
+term.vector = function(x, y)
+  if not gfx.in_path then
+    gfx.start_path(gfx.posx, gfx.posy)
+  elseif not gfx.check_coord(x, y) then
+    -- checked for zero path length and add the path coords to gfx.path
+    gfx.path[#gfx.path+1] = {x,y}
+  end
+  return 1
+end
+
+term.move = function(x, y)
+  -- if we move to our last position we will just continue the path there
+  if not gfx.check_coord(x, y) then
+    gfx.check_in_path()
+    gfx.start_path(x, y)
+  end
+  return 1
+end
+
+term.linetype = function(ltype)
+  gfx.check_in_path()
+
+  gfx.set_color('LT', {ltype})
+  gfx.linetype_idx = ltype
+
+  return 1
+end
+
+term.point = function(x, y, num)
+  if gfx.opt.gp_points then
+    return 0
+  else
+    gfx.check_in_path()
+    gfx.check_color()
+    gfx.check_linewidth()
+    gfx.check_pointsize()
+  
+    local pm
+    if num == -1 then
+      pm = pgf.styles.plotmarks[1][1]
+    else
+      pm = pgf.styles.plotmarks[(num % (#pgf.styles.plotmarks-1)) + 2][1]
+    end
+    pgf.draw_points({{x,y}}, pm)
+    
+    return 1
+  end
+end
+
+
+--[[
+  this differs from the original API
+  one may use the additional parameters to define own styles
+  e.g. "misuse" angle for numbering predefined styles...
+
+  int length        /* head length */
+  double angle      /* head angle in degrees */
+  double backangle  /* head back angle in degrees */
+  int filled        /* arrow head filled or not */
+]]
+term.arrow = function(sx, sy, ex, ey, head, length, angle, backangle, filled)
+  if gfx.opt.gp_arrows then
+    return 0
+  else
+    local headstyle = 0
+    if gfx.opt.tikzarrows then
+      headstyle = angle
+    end
+    gfx.check_in_path()
+    gfx.check_color()
+    gfx.check_linetype()
+    gfx.check_linewidth()
+    pgf.draw_arrow({{sx,sy},{ex,ey}}, gfx.HEAD_STR[head+1], headstyle)
+    return 1
+  end
+end
+
+-- Called immediately after a plot is displayed.
+term.text = function()
+  gfx.check_in_path()
+  pgf.write_graph_end(gfx.opt.nopicenv)
+  gfx.in_picture = false
+  return 1
+end
+
+term.put_text = function(x, y, txt)
+  gfx.check_in_path()
+  gfx.check_color()
+  
+  if (txt ~= '') or (gfx.text_font ~= '')  then -- omit empty nodes
+    pgf.write_text_node({x, y}, txt, gfx.text_angle, gfx.TEXT_ANCHOR[gfx.text_justify], gfx.text_font)
+  end
+  return 1
+end
+
+term.justify_text = function(justify)
+  gfx.text_justify = justify
+  return 1
+end
+
+term.text_angle = function(ang)
+  gfx.text_angle = ang
+  return 1
+end
+
+term.linewidth = function(width)
+  if gfx.linewidth ~= width then
+    gfx.linewidth = width
+    gfx.check_in_path()
+  end
+  return 1
+end
+
+term.pointsize = function(size)
+  if gfx.pointsize ~= size then
+    gfx.pointsize = size
+    gfx.check_in_path()
+  end
+  return 1
+end
+
+term.set_font = function(font)
+  gfx.text_font = gfx.parse_font_string(font)
+  return 1
+end
+
+-- at the moment this is only used to check
+-- the plot's bounding box as seldom as possible
+term.layer = function(l)
+  if l == 'end_text' then
+    -- called after a plot is finished (also after each "mutiplot")
+    gfx.write_boundingbox()
+  end
+  return 1
+end
+
+-- we don't use this, because we are implicitly testing
+-- for closed paths
+term.path = function(p)
+  return 1
+end
+
+
+term.filled_polygon = function(style, fillpar, t)
+  local pattern = nil
+  local color = nil
+  local opacity = 100
+  local saturation = 100
+  
+  gfx.check_in_path()
+
+  if style == 'EMPTY' then
+      -- FIXME: should be the "background color" and not gpbgfillcolor
+      pattern = ''
+      color = 'gpbgfillcolor'
+      saturation = 100
+      opacity = 100
+  elseif style == 'DEFAULT' or style == 'OPAQUE' then -- FIXME: not shure about the opaque style
+      pattern = ''
+      color = gfx.color
+      saturation = 100
+      opacity = 100
+  elseif style == 'SOLID' then
+      pattern = ''
+      color = gfx.color
+      if fillpar < 100 then
+        saturation = fillpar
+      else
+        saturation = 100
+      end
+      opacity = 100
+  elseif style == 'PATTERN' then
+      pattern = pgf.styles.patterns[(fillpar % #pgf.styles.patterns) + 1][1]
+      color = gfx.color
+      saturation = 100
+      opacity = 100
+  elseif style == 'TRANSPARENT_SOLID' then
+      pattern = ''
+      color = gfx.color
+      saturation = 100
+      opacity = fillpar
+  elseif style == 'TRANSPARENT_PATTERN' then
+      pattern = pgf.styles.patterns[(fillpar % #pgf.styles.patterns) + 1][1]
+      color = gfx.color
+      saturation = 100
+      opacity = 0
+  end
+  
+  pgf.draw_fill(t, pattern, color, saturation, opacity)  
+  
+  return 1
+end
+
+
+term.boxfill = function(style, fillpar, x1, y1, width, height)
+  local t = {{x1, y1}, {x1+width, y1}, {x1+width, y1+height}, {x1, y1+height}}
+  return term.filled_polygon(style, fillpar, t)
+end
+
+-- points[row][column]
+-- m: #cols, n: #rows
+-- corners: clip box and draw box coordinates
+-- ctype: "RGB" or "GRAY" (unused since we allways use RGB to keep things simple)
+term.image = function(m, n, points, corners, ctype)
+  gfx.check_in_path()
+  
+  pgf.write_clipbox_begin({corners[3][1],corners[3][2]},{corners[4][1],corners[4][2]})
+  
+  if gfx.opt.direct_image then
+    local ll = {corners[1][1],corners[2][2]}
+    local ur = {corners[2][1],corners[1][2]}
+    if gfx.opt.cmykimage then
+      pgf.draw_raw_cmyk_image(points, m, n, ll, ur)
+    else
+      pgf.draw_raw_rgb_image(points, m, n, ll, ur)
+    end
+  else
+    local w = (corners[2][1] - corners[1][1])/m
+    local h = (corners[1][2] - corners[2][2])/n
+
+    local yy,yyy,xx,xxx
+    for cnt = 1,#points do
+      xx = corners[1][1]+(cnt%m-1)*w
+      yy = corners[1][2]-math.floor(cnt/m)*h
+      yyy = yy-h
+      xxx = xx+w
+      pgf.draw_fill({{xx, yy}, {xxx, yy}, {xxx, yyy}, {xx, yyy}}, '', gfx.format_color('RGB', points[cnt]) , 100, 100)
+    end
+  end
+  pgf.write_clipbox_end()
+end
+
+term.make_palette = function()
+  -- continuous number of colours
+  return 0
+end
+
+term.previous_palette = function()
+  return 1
+end
+
+term.set_color = function(ctype, lt, value, r, g, b)
+  gfx.check_in_path()
+  -- FIXME gryscale on monochrome?? ... or use xcolor?
+
+  if ctype == 'LT' then
+    gfx.set_color('LT', {lt})
+  elseif ctype == 'FRAC' then
+    if gfx.opt.lines_colored then
+      gfx.set_color('RGB', {r, g , b})
+    else
+      gfx.set_color('GRAY', {value})
+    end
+  elseif ctype == 'RGB' then
+    gfx.set_color('RGB', {r, g , b})
+  else
+    gp.int_error(string.format("set color: unknown type (%s), lt (%i), value (%.3f)\n", ctype, lt, value))
+  end
+  
+  return 1
+end
+
+-- Called when gnuplot is exited.
+term.reset = function(p)
+  gfx.check_in_path()
+  gfx.check_variables()
+  if gfx.opt.full_doc then
+    pgf.write_doc_end()
+  end
+  return 1
+end
+
+--[[===============================================================================================
+
+  command line code
+
+]]--===============================================================================================
+
+term_help = function(helptext)
+  local w
+  for w in string.gmatch(helptext, "([^\n]*)\n") do
+    w = string.gsub(w, "\\", "\\\\")
+    w = string.gsub(w, "\"", "\\\"")
+    io.write('"'..w.."\",\n")
+  end
+--[[  
+  local out = string.gsub(helptext, "\n", "\",\n\"")
+  local out = string.gsub(helptext, "\n", "\",\n\"")
+  io.write(out)]]
+end
+
+if arg then -- called from the command line!
+  if #arg > 0 and arg[1] == 'style' then
+    -- write style file
+    local f = io.open(pgf.LATEX_STYLE_FILE..".sty" , "w+")
+    pgf.create_style(f)
+  elseif arg[1] == 'termhelp' then
+    io.write([["2 tikz",
+"?set terminal lua tikz",
+"?set term lua tikz",
+"?term lua tikz",
+"?tikz",
+" The TikZ driver is an output driver for the generic Lua terminal.",
+" Please read the Lua terminal section for additional information.",
+"",
+" Syntax:",
+"     set terminal lua tikz",
+"",
+]])
+    pgf.print_help(term_help)
+    io.write("\"\"\n")
+  else
+    io.write([[
+ This script is intended to be called from GNUPLOT.
+
+ For generating the associated LaTeX style file
+  (']] .. pgf.LATEX_STYLE_FILE..".sty')" .. [[ just call this script
+ with the additional option 'style':
+
+   # lua gnuplot.lua style
+
+ The TikZ driver provides the following additional terminal options:
+
+]])
+    pgf.print_help(io.write)
+  end
+end
